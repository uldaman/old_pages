Title: 函数式领域建模(四)
Author: HanXiao
Date: 2019-12-09 10:00
Tags: 函数式, 领域驱动, DDD

[TOC]

# Value Objects

我们已经了解了对领域数据和工作流建模的基本方法. 现在, 让我们继续研究一种对数据类型进行分类的重要方式 -- 基于数据类型是否具有**持久标识**.

在 DDD 术语中, 具有持久身份的对象称为 **Entities**(实体), 而没有持久身份的对象称为 **Value Objects**(值对象). 让我们首先讨论值对象.

在许多情况下, 我们正在处理的数据对象没有身份 -- 它们是可互换的. 例如, 出现在所有地方值为 W1234 的 WidgetCode 都彼此相等, 我们不需要区分它们.

```f#
let widgetCode1 = WidgetCode "W1234"
let widgetCode2 = WidgetCode "W1234"
printfn "%b" (widgetCode1 = widgetCode2) // prints "true"
```

"values without identity" 的概念在领域模型中经常出现, 无论是复杂类型还是简单类型. 例如, 一个 `PersonalName` 的 AND 类型可能具有 `FirstName` 和 `LastName` 两个字段, 因此它比简单的字符串复杂, 但它也是一个值对象, 因为具有相同字段的两个个人名称是可以互换的.

```f#
let name1 = {FirstName="Alex"; LastName="Adams"}
let name2 = {FirstName="Alex"; LastName="Adams"}
printfn "%b" (name1 = name2) // prints "true
```

例如 `“address”` 类型也是值对象, 如果两个值具有相同的街道地址以及城市和邮政编码, 则它们是相同的地址.

## Implementing Equality for Value Objects

当我们使用 `F＃` 代数类型系统对领域建模时, 默认情况下, 我们创建的类型基于字段的相等性判断 -- 我们不需要自己编写任何判断相等性的代码.

准确地说, 在 `F＃` 中, 如果两个 AND 类型值的所有字段都相等, 则两个值(相同类型)相等; 如果两个 OR 类型的选择情况相同, 则两个选择值相等; 这称为结构平等.

而在其它语言中, 我们可能需要重写 `Equals` 之类的方法.

# Entities

但是, 我们也经常需要对在现实世界中具有独特标识的事物进行建模, 即使它们的组成发生变化, 但它们依然是同一个事物. 例如, 即使我更改了姓名或地址, 我仍然是同一个人.

DDD 术语中, 这些事物被称为 `Entities`(实体).

在我们实例的上下文中, 实体通常是某种类型的文档: 订单, 报价, 发票, 客户资料, 产品单等. 它们具有**生命周期**, 并通过各种业务流程从一种状态转换为另一种状态.

值对象与实体之间的区别取决于其所在的上下文. 例如, 考虑手机的生命周期.

- 在制造过程中, 每部手机都会获得一个唯一的序列号, 因此在这种情况下, 它们将被建模为实体.
- 在出售时, 序列号无关紧要-所有规格相同的手机都是可以互换的-可以将它们建模为值对象.
- 一旦将特定手机出售给特定客户, 身份就会再次变得相关, 应该将其建模为一个实体：即使更换屏幕或电池, 客户也将其视为同一部手机.

## Identifiers for Entities

在对实体进行建模时, 我们需要为它们提供唯一的标识符或键, 例如 `Order Id`, or `Customer Id`.

例如下面的 `Contact` 类型, 不管 `PhoneNumber` 或 `EmailAddress` 属性怎么更改, 它的 `ContactId` 属性保持不变.

```f#
type ContactId = ContactId of int

type Contact = {
    ContactId : ContactId
    PhoneNumber : ...
    EmailAddress: ...
}
```

这些标识符从何而来?

有时, 标识符是由真实世界本身提供的, 例如纸质订单和发票上总是写有某种单号; 但有时, 我们需要使用 UUID, 自动递增数据库表, ID 生成服务等技术自己创建一个人工标识符. 在我们的实例中, 仅假设客户已向我们提供了标识符.

## Adding Identifiers to Data Definitions

向 AND 类型添加标识符很简单, 只需添加一个字段, 但是如何向 OR 类型添加标识符? 我们应该将标识符放在内部(与每个 case 关联)还是在外部(与任何 case 都不关联)?

例如, 假设我们有两个发票选项: `Unpaid` 和 `Paid`.

如果我们使用外部方式对其进行建模, 我们将有一个包含 `InvoiceId` 的 AND 类型, 然后在该类型内有一个选择类型 `InvoiceInfo`, 其中包含每种发票类型的信息. 该代码将如下所示:

```f#
// Info for the unpaid case (without id)
type UnpaidInvoiceInfo = ...

// Info for the paid case (without id)
type PaidInvoiceInfo = ...

// Combined information (without id)
type InvoiceInfo =
    | Unpaid of UnpaidInvoiceInfo
    | Paid of PaidInvoiceInfo

// Id for invoice
type InvoiceId = ...

// Top level invoice type
type Invoice = {
    InvoiceId : InvoiceId // "outside" the two child cases
    InvoiceInfo : InvoiceInfo
}
```

如果使用内部方式, 我们将创建两个单独的类型(`UnpaidInvoice` 和 `PaidInvoice`), 这两个类型都有自己的 `InvoiceId`, 然后是一个在它们之间进行选择的顶级 OR 类型 `Invoice`. 该代码将如下所示:

```f#
type UnpaidInvoice = {
    InvoiceId : InvoiceId // id stored "inside"
    // and other info for the unpaid case
}

type PaidInvoice = {
    InvoiceId : InvoiceId // id stored "inside"
    // and other info for the paid case
}

// top level invoice type
type Invoice =
    | Unpaid of UnpaidInvoice
    | Paid of PaidInvoice
```

相对于外部方式, 内部方式都易于使用模式匹配, 它将所有的数据都放在一起, 包括 `id`:

```f#
let invoice = Paid {InvoiceId = ...}

match invoice with
    | Unpaid unpaidInvoice ->
      printfn "The unpaid invoiceId is %A" unpaidInvoice.InvoiceId
    | Paid paidInvoice ->
      printfn "The paid invoiceId is %A" paidInvoice.InvoiceId
```

**在实践中, 更常见的是使用内部方法.**

## Implementing Equality for Entities

前面我们看到, 默认情况下, `F＃` 中的相等性判断使用类型的所有字段. 但是, 当我们比较实体时, 我们只想使用标识符字段. 这意味着, 为了在 `F＃` 中正确建模实体, 我们必须更改默认行为.

一种方法是重写相等性判断, 以便仅使用标识符. 要更改默认判断逻辑, 我们必须:

1. 重写 `Equals` 方法.
2. 重写 `GetHashCode` 方法.
3. 将 `CustomEquality` 和 `NoComparison` 属性添加到类型中, 以告知编译器我们要更改默认行为.

```f#
[<CustomEquality; NoComparison>]
type Contact = {
    ContactId : ContactId
    PhoneNumber : PhoneNumber
    EmailAddress: EmailAddress
}
with
override this.Equals(obj) =
    match obj with
        | :? Contact as c -> this.ContactId = c.ContactId
        | _ -> false
override this.GetHashCode() =
    hash this.ContactId
```
