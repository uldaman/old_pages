Title: 函数式领域建模(三)
Author: HanXiao
Date: 2019-12-03 15:00
Tags: 函数式, 领域驱动, DDD

# Reviewing the Domain Model

现在让我们看下已有领域模型的伪代码 (在与领域专家讨论需求时记录下来的):

```
context: Order-Taking
// ----------------------
// Simple types
// ----------------------
// Product codes
data ProductCode = WidgetCode OR GizmoCode
data WidgetCode = string starting with "W" then 4 digits
data GizmoCode = ...

// Order Quantity
data OrderQuantity = UnitQuantity OR KilogramQuantity
data UnitQuantity = ...
data KilogramQuantity = ...

// ----------------------
// Order lifecycle
// ----------------------
// ----- unvalidated state -----
data UnvalidatedOrder =
    UnvalidatedCustomerInfo
    AND UnvalidatedShippingAddress
    AND UnvalidatedBillingAddress
    AND list of UnvalidatedOrderLine

data UnvalidatedOrderLine =
    UnvalidatedProductCode
    AND UnvalidatedOrderQuantity

// ----- validated state -----
data ValidatedOrder = ...
data ValidatedOrderLine = ...

// ----- priced state -----
data PricedOrder = ...
data PricedOrderLine = ...

// ----- output events -----
data OrderAcknowledgmentSent = ...
data OrderPlaced = ...
data BillableOrderPlaced = ...

// ----------------------
// Processes
// ----------------------
process "Place Order" =
    input: UnvalidatedOrder
    output (on success):
        OrderAcknowledgmentSent
        AND OrderPlaced (to send to shipping)
        AND BillableOrderPlaced (to send to billing)
    output (on error):
        InvalidOrder

// etc
```

我们的目标是将此转换为真实的代码.

# Building a Domain Model by Composing Types

可组合的类型系统是实践领域驱动设计的绝佳帮助, 因为只需将类型混合在一起, 即可快速创建复杂的模型. 接下来以跟踪电子商务网站的付款为例, 让我们看看如何在设计期间通过代码勾勒出这一点.

首先, 我们从包装一些基础类型, 例如 `CardNumber`. 这样做是为它们提供有意义的名称, 我们称之为 "简单类型".

```f#
type CardNumber = CardNumber of string
```

接下来, 我们建立一些 "低级类型", 它们看上去仅仅是其它语言中的 "枚举" 类型. `CardType` 是 OR 类型 –- `Visa` 或 `Mastercard`, 而 `CreditCardInfo` 是 AND 类型, 包含 `CardType` 和 `CardNumber`：

```f#
type CardType =
    Visa | Mastercard // 'OR' type

type CreditCardInfo = { // 'AND' type (record)
    CardType : CardType
    CardNumber : CardNumber
}
```

然后, 我们将另一种 OR 类型 `PaymentMethod` 定义为 `Cash` 或 `Check` 或 `Card` 之间的选择. 这不再是一个简单的 "枚举", 因为某些选项具有与其关联的数据: `Check` 具有 `CheckNumber`, 而 `Card` 具有 `CreditCardInfo`:

```f#
type CheckNumber = CheckNumber of int

type PaymentMethod =
    | Cash
    | Check of CheckNumber
    | Card of CreditCardInfo
```

我们继续定义一些基本的类型, 如 `PaymentAmount` 和 `Currency`:

```f#
type PaymentAmount = PaymentAmount of decimal
type Currency = EUR | USD
```

最后定义 "顶级类型" -- `Payment`:

```f#
type Payment = {
    Amount : PaymentAmount
    Currency: Currency
    Method: PaymentMethod
}
```

所以, 在大约 25 行代码中, 我们已经定义了一组非常有用的类型.

当然, 还没有与这些类型直接相关的行为, 因为这是函数式模型, 而不是面向对象的模型. 为了建模可以执行的操作, 我们要开始定义一些表示函数的类型.

如果想要建模一个使用 `Payment` 支付 `UnpaidInvoice` 并返回 `PaidInvoice` 的行为, 可以定义如下所示的函数类型:

```f#
type PayInvoice =
    UnpaidInvoice -> Payment -> PaidInvoice
```
