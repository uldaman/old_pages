Title: 代数数据类型 (Algebraic Data Type)
Author: Martin
Date: 2018-11-23 19:00

# Haskell ADT

代数数据类型是一种复合类型, 即通过组合其他类型形成的类型. 以下摘自 Haskell Wiki:

"Algebraic" refers to the property that an Algebraic Data Type is created by "algebraic" operations. The "algebra" here is "sums" and "products":

- "sum" is alternation (A | B, meaning A or B but not both)
- "product" is combination (A B, meaning A and B together)

建立代数数据类型只是开始, 我们要做的是对它们使用 **模式匹配**. Examples (以下摘自 Haskell Wiki):

`data Pair = I Int | D Double` is just one number, either an Int or else a Double. In this case, the tags I and D are used (in constructors and pattern matching) to distinguish between the two alternatives.

`data Pair = P Int Double` is a pair of numbers, an Int and a Double together. The tag P is used (in constructors and pattern matching) to combine the contained values into a single structure that can be assigned to a variable.

当然 "sum" 和 "product" 也可以结合在一起, 例如: `data Pair = I Int Double | S String Float`.

# Scala ADT

Scala 用 case class 模拟 ADT (case class 的参数默认不可变, 固不同参数构造出来的 case class 实例可以匹配成不同的模式), 比如一个账户抽象:

```scala
sealed trait Account {
  def number: String  // phone
  def name: String  // name
}

case class CheckingAccount(number: String, name: String, dateOfOpening: Data) extends Account

case class SavingsAccount(number: String, name: String, rateOfInterest: BigDecimal) extends Account
```

对应的 ADT: `Account = CheckingAccount String String Data | SavingsAccount String String BigDecimal`. 现在就可以对其应用模式匹配了, 例如:

```scala
account match {
  case CheckingAccount("159 xxxx xxxx", "zhang san", "2018-11-22") => ...
  case CheckingAccount("130 xxxx xxxx", "li si", "2018-11-22") => ...
  case SavingsAccount("135 xxxx xxxx", "wang er", BigDecimal(1.1)) => ...
}
```
