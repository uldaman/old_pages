author: Martin
date: 2015-02-15 14:21
title: 6、[C++]六大设计原则

[TOC]

# 单一职责原则
单一职责原则: 就一个类而言, 应该仅有一个引起它变化的原因.

日常编程, 我们习惯性的很自然给一个类加这样那样的功能, 比如之前讲过的计算器, 很可能我们会设计出一个类, 把计算 显示等功能都写那个类中, 这样的代码维护很麻烦, 复用不可能, 也缺乏灵活性, 因此我们对那个类进行了重构才引出了**简单工厂模式**和**策略模式**.

如果一个类承担的职业过多, 就等于把这些职责耦合在一起, 一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力. 这种耦合会导致脆弱的设计, 当变化发生时, 设计会遭受到意想不到的破坏.

**软件设计真正要做的许多内容, 就是发现职责并把那此职责相互分离.**

怎么判断是否应该分离?

那就是如果你能够想到多于一个的动机去改变一个类, 那么这个类就具有多于一个职责, 就应该考虑类的职责分离.

* * *

# 开放-封闭原则
开放-封闭原则: 软件实体(类 模块 函数等等), 应该是可以扩展但不可修改的.

也就是说对于扩展是开放的, 对于更改是封闭的, 再换句话说就是**设计软件要容易维护又不容易出问题的最好办法是多扩展少修改.**
要达到这样的效果就是我们在设计类的时候, 时刻要考虑尽量让这个类是足够好, 写好了就不要去修改了, 如果新需求来, 我们增加一些类就完事了, 原来的代码能不动则不动.

但是, 无论是多么的”封闭”, 都会存在一些无法对之封闭的变化, 既然不可能完全封闭, 设计人员就必须对于它设计的模块应该对哪种变化封闭做出选择, 他必须先猜测出最有可能发生的变化种类, 然后构造抽象来隔离那些变化.

再回想一下我们之前的计算器例子, 一开始的时候, 我们把计算的算法都封装在一个类当中:

```java
class Operation {
public:
    static double GetResult(double dNum_A, double dNum_B, char cOp) {
        double dResult = 0.0;
        switch (cOp) {
        case '+':
            dResult = dNum_A + dNum_B;
            break;
        case '-':
            dResult = dNum_A - dNum_B;
            break;
        case '*':
            dResult = dNum_A * dNum_B;
            break;
        case '/':
            dResult = dNum_A / dNum_B;
            break;
        }

        return dResult;
    }
}
```
<br>
而在设计时已经猜测出以后可能会添加其他的运算, 所以我们把运算的算法抽象了出来.

在一开始设计时, 我们有可能很难预先猜测, 但我们却可以在发生小变化时, 就及早去想办法应对发生大变化的可能. 换句话说:**在我们最初编程时, 假设变化不会发生, 而当变化真实发生时, 我们就创建抽象一隔离以后发生的同种类变化.**

> 面对需求, 对程序的发动是通过增加新代码进行的, 而不是更改现有的代码.

当然开发人员应该仅对程序中呈现出频繁变化的那部分做出抽象, 然而, 对于应用程序中的每个部分都刻意地进行抽象同样也不是一个好注意, 拒绝不成熟的抽象和抽象本身一样重要.

> 其实, 只要我们对另外 5 项原则遵守的好了, 设计出的软件自然是符合开闭原则的.

* * *

# 里氏代换原则
**里氏代换原则**: 子类型必须能够替换掉它们的父类型, 即所有引用基类的地方必须能透明地使用其子类的对象 (因为子类继承了父类的方法).

问题由来:<br>
有一功能 P1, 由类 A 完成. 现需要将功能 P1 进行扩展, 扩展后的功能为 P, 由原功能 P1 与新功能 P2 组成. 扩展后的 P 由类 A 的子类 B 来完成, 则子类 B 在完成新功能 P2 的同时, 有可能会导致原有功能 P1 发生故障.

解决方案:<br>
当使用继承时, 遵循里氏替换原则. 类 B 继承类 A 时, 除添加新的方法完成新增功能 P2 外, 尽量不要重写父类 A 的方法.

继承隐式的包含这样一层含义:<br>
父类中凡是已经实现好的方法 (相对于抽象方法而言), 实际上是在设定一系列的规范和契约, 虽然它不强制要求所有的子类必须遵从这些契约, 但是如果子类对这些非抽象方法任意修改, 就会对整个继承体系造成破坏. 而里氏替换原则就是表达了这一层含义.

继承作为面向对象三大特性之一, 在给程序设计带来巨大便利的同时, 也带来了弊端. 比如使用继承会给程序带来侵入性, 程序的可移植性降低, 增加了对象间的耦合性, 如果一个类被其他的类所继承, 则当这个类需要修改时, 必须考虑到所有的子类, 并且父类修改后, 所有涉及到子类的功能都有可能会产生故障.

里氏替换原则通俗的来讲就是: **子类可以扩展父类的功能, 但不能改变父类原有的功能**. 它包含以下4层含义:

- 子类可以实现父类的抽象方法, 但不能覆盖父类的非抽象方法
- 子类中可以增加自己特有的方法
- 当子类的方法重载父类的方法时, 方法的前置条件 (即方法的形参) 要比父类方法的输入参数更宽松
- 当子类的方法实现父类的抽象方法时, 方法的后置条件 (即方法的返回值) 要比父类更严格

其实, 里氏替换原则的**重点**在**不影响原功能**, 而不是不覆盖原方法, 另外, **子类不要添加基类没有的约束**, 所以正常遵从该原则的处理办法是**在需要覆盖父类方法时应该首先考虑使用 `super` 调用父类的同名方法以保证父类同名方法会被调用** (如果确实不需要调用父类方法, 则不需如此).

* * *

# 接口隔离原则
定义:<br>
客户端不应该依赖它不需要的接口; 一个类对另一个类的依赖应该建立在最小的接口上.

问题由来:<br>
类 A 通过接口 I 依赖类 B, 类 C 通过接口 I 依赖类 D, 如果接口 I 对于类 A 和类 B 来说不是最小接口, 则类 B 和类 D 必须去实现他们不需要的方法.

![](http://i63.tinypic.com/ifpm55.jpg)

解决方案:<br>
将臃肿的接口 I 拆分为独立的几个接口, 类 A 和类 C 分别与他们需要的接口建立依赖关系. 也就是采用接口隔离原则.
举例来说明接口隔离原则:

![](http://i68.tinypic.com/2r7bkw8.jpg)

接口隔离原则的含义是:<br>
建立单一接口, 不要建立庞大臃肿的接口, 尽量细化接口, 接口中的方法尽量少. 也就是说, 我们要为各个类建立专用的接口, 而不要试图去建立一个很庞大的接口供所有依赖它的类去调用. 在程序设计中, 依赖几个专用的接口要比依赖一个综合的接口更灵活.

说到这里, 很多人会觉的接口隔离原则跟之前的**单一职责**原则很相似, 其实不然.

**其一**, 单一职责原则原注重的是职责; 而接口隔离原则注重对接口依赖的隔离.

**其二**, 单一职责原则主要是约束类, 其次才是接口和方法, 它针对的是程序中的实现和细节; 而接口隔离原则主要约束接口接口, 主要针对抽象, 针对程序整体框架的构建.

采用接口隔离原则对接口进行约束时, 要**注意**以下几点:

- 接口尽量小, 但是要有限度. 对接口进行细化可以提高程序设计灵活性是不挣的事实, 但是如果过小, 则会造成接口数量过多, 使设计复杂化. 所以一定要适度
- 为依赖接口的类定制服务, 只暴露给调用的类它需要的方法, 它不需要的方法则隐藏起来. 只有专注地为一个模块提供定制服务, 才能建立最小的依赖关系
- 提高内聚, 减少对外交互. 使接口用最少的方法去完成最多的事情

运用接口隔离原则, 一定要适度, 接口设计的过大或过小都不好. 设计接口的时候, 只有多花些时间去思考和筹划, 才能准确地实践这一原则.

* * *

# 依赖倒置原则
依赖倒置原则: 抽象不应该依赖细节, 细节应该依赖于抽象, 高层模块不应该依赖低层模块, 都应该依赖抽象.
说白了, 就是应该**针对接口编程**而不要对实现编程.

在我们的计算器(策略模式)程序中, `Context` 类依赖于 `Operation` 抽象类而不依赖具体的算法类, 具体的算法类也依赖于 `Operation` 抽象类, 根据里氏代换原则, 只要接口 `Operation` 抽象类是稳定的, 那么任何一个更改都不用担心其他受到影响(我们可以通过实例化新的子类来处理), 这使得无论高层模块还是低层模块都可以很容易地被复用.

> 为什么叫倒置? 这是针对面向过程来说的, 在面向过程的开发中, 为了使用常用的代码可以复用, 一般都会把这些常用的代码写成许许多多函数的程序库, 这样我们做新项目的时候, 就去调用这些函数就可以了.<br>
> 例如: 我们做的项目大多要访问数据库, 所以我们就把数据库的代码写成了函数, 每次做新项目时就去调用这些函数, 这也就是高层依赖于低层模块了.

依赖倒置原则其实可以说是面向对象设计的标志, 编程时考虑的都是如何针对抽象编程而不是针对细节编程, 即程序中所有的依赖关系都是终止于抽象类或者接口.

* * *

# 迪米特法则
迪米特法则也叫最小知识原则, 迪米特法则还有一个更简单的定义: **只与直接的朋友通信.**

对于一个对象, 其朋友包括以下几类:

- 以参数形式传入到当前对象方法中的对象
- 当前对象的成员对象
- 如果当前对象的成员对象是一个集合, 那么集合中的元素也都是朋友
- 当前对象方法的返回值

而出现在局部变量中的类(出现在当前类方法内部)则不是直接的朋友. 也就是说, 陌生的类最好不要作为局部变量的形式出现在类的内部.

要注意的是: 朋友间也是有距离的.

一个类公开的 `public` 属性或方法越多, 修改时涉及的面也就越大, 变更引起的风险扩散也就越大.

因此, 为了保持朋友类间的距离, 在设计时需要反复衡量: 是否还可以再减少 `public` 方法和属性, 是否可以修改为 `private`、`protected` 等访问权限等.

迪米特法则首先强调的前提就是在类的结构设计上, 每一个类都应当尽量降低成员的访问权限.

其根本思想是强调了类之间的松耦合, 类之间的耦合越弱, 越有利于复用, 一个处在弱耦合的类被修改, 不会对其他有关系的类造成波及.

迪米特法则还要求我们在设计时, 应该尽量减少对象之间的交互, 如果两个对象之间不必彼此直接通信, 那么这两个对象就不应当发生任何直接的相互作用, 如果其中的一个对象需要调用另一个对象的某一个方法的话, 可以通过第三者转发这个调用. 简言之, **就是通过引入一个合理的第三者来降低现有对象之间的耦合度**.

要理解这些可能有些难, 我们来看一下例子.

体育老老师让体委清点全班女生个数, 先上一段有问题的代码:


```java
#include <list>
#include <iostream>
using namespace std;

class Girl {
};

class GroupLeader {
    //有清查女生的工作
public:
    void countGirls(list<Girl> listGirls){
        cout << "女生数量是: " << listGirls.size() << endl;
    }
};

class Teacher {
    //老师对学生发布命令,清一下女生
public:
    void commond(GroupLeader groupLeader) {
        list<Girl> listGirls;
        //初始化女生
        for (int i = 0; i < 20; i++){
            listGirls.push_back(Girl());
        }
        //告诉体育委员开始执行清查任务
        groupLeader.countGirls(listGirls);
    }
};

int _tmain(int argc, _TCHAR* argv[]) {
    Teacher teacher;
    //老师发布命令
    teacher.commond(GroupLeader());

    system("PAUSE");
    return 0;
}
```
<br>
问题出在 Teacher 这个类中, 首先, Girl 类做为 commond 方法的局部变量出现..

其次, 和体育老师有直接联系的是体委, 而不是全班女生, 体育老师和女生不应该相互作用, 而应该通过体委来跳转(如果两个对象之间不必彼此直接通信, 那么这两个对象就不应当发生任何直接的相互作用, 如果其中的一个对象需要调用另一个对象的某一个方法的话, 可以通过第三者转发这个调用).

改进后代码如下:

```java
#include "stdafx.h"
#include <list>
#include <iostream>
using namespace std;

class Girl {
};

class GroupLeader {
    //有清查女生的工作
private:
    list<Girl> m_listGirls;
    //传递全班的女生

public:
    GroupLeader(list<Girl> _listGirls) {
        m_listGirls = _listGirls;
    }

    //有清查女生的工作
    void countGirls(){
        cout << "女生数量是: " << m_listGirls.size() << endl;
    }
};

class Teacher {
    //老师对学生发布命令,清一下女生
public:
    void commond(GroupLeader groupLeader) {
        groupLeader.countGirls();
    }
};

int _tmain(int argc, _TCHAR* argv[]) {
    list<Girl> listGirls;
    //初始化女生
    for (int i = 0; i < 20; i++){
        listGirls.push_back(Girl());
    }

    Teacher teacher;
    //老师发布命令
    teacher.commond(GroupLeader(listGirls));

    system("PAUSE");
    return 0;
}
```
<br>
这样的设计符合迪米特法则.

在上面的例子中, 我们也可以看出虽然迪米特法则可以避免与非直接的类通信, 但是要通信, 必然会通过一个“中介”来发生联系, 例如本例中, 体育老师就是通过体委这个“中介”来与学生发生联系的. 过分的使用迪米特原则, 会产生大量这样的中介和传递类, 导致系统复杂度变大. 所以在采用迪米特法则时要反复权衡, 既做到结构清晰, 又要高内聚低耦合.

狭义的迪米特法则的缺点:

在系统里面造出大量的小方法, 这些方法仅仅是传递间接的调用, 与程序的逻辑无关.

遵循类之间的迪米特法则会使一个系统的局部设计简化, 因为每一个局部都不会和远距离的对象有之间的关联, 但是, 这也会造成系统的不同模块之间的通信效率降低, 也会使系统的不同模块之间不容易协调.

广义的迪米特法则在类的设计上的体现:

优先考虑将一个类设置成不变类; 尽量降低一个类的访问权限; 尽量降低成员的访问权限.
