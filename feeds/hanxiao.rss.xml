<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Small Cpp - HanXiao</title><link>http://www.smallcpp.cn/</link><description>勿在浮沙筑高台, 练从难处练, 用从易处用.</description><lastBuildDate>Tue, 10 Mar 2020 13:00:00 +0800</lastBuildDate><item><title>七. Implementation: Working with Errors</title><link>http://www.smallcpp.cn/qi-implementation-working-with-errors.html</link><description>
&lt;p&gt;如果产品代码格式错误，客户名称过长或地址验证服务超时，该怎么办？任何系统都会有错误，我们如何处理它们很重要。一致且透明的错误处理对于任何类型的生产系统都是至关重要的。&lt;/p&gt;
&lt;p&gt;在上一章中，我们故意从 &lt;em&gt;pipeline&lt;/em&gt; 的步骤中删除了错误副作用(&lt;em&gt;Result&lt;/em&gt; 类型)，以便我们可以专注于组合和依赖等问题。
但是副作用很重要! 在本章中，我们将 &lt;em&gt;Result&lt;/em&gt; 恢复为类型签名，并学习如何和它们一起工作。&lt;/p&gt;
&lt;p&gt;更通俗地说，我们将探索错误处理的函数式方法，使用一种技术，可以优雅地捕获错误，而不会因丑陋的条件判断或 &lt;em&gt;try/catch&lt;/em&gt; 语句而污染代码。我们还将看到为什么我们应该将某些类型的错误视为领域错误，并应与其它领域驱动设计一样重视。&lt;/p&gt;
&lt;h1 id="using-the-result-type-to-make-errors-explicit"&gt;Using …&lt;/h1&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Tue, 10 Mar 2020 13:00:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2020-03-10:/qi-implementation-working-with-errors.html</guid><category>函数式</category><category>函数式领域建模</category><category>函数式</category><category>领域驱动</category><category>DDD</category></item><item><title>六. Implementation: Composing a Pipeline</title><link>http://www.smallcpp.cn/liu-implementation-composing-a-pipeline.html</link><description>
&lt;h1 id="understanding-functions"&gt;Understanding Functions&lt;/h1&gt;
&lt;p&gt;在很多现代语言中, 函数也是一等对象, 但只是使用函数并不意味着在进行函数式编程.&lt;/p&gt;
&lt;p&gt;函数式编程范例的关键在于, 函数无处不在, 应有尽有, 程序中的任何问题都有函数式的解决方案.&lt;/p&gt;
&lt;p&gt;例如, 假设我们有一个大型程序, 它是由较小的块组成的.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在面向对象的方法中, 这些部分将是类和对象.&lt;/li&gt;
&lt;li&gt;在功能式的方法中, 这些部分将是函数.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再比如我们需要参数化程序的某些方面, 或者想减少组件之间的耦合.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在面向对象的方法中, 我们将使用接口和依赖注入.&lt;/li&gt;
&lt;li&gt;在函数式的方法中, 我们将使用函数进行参数化.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;又比如我们要遵循 “不要重复自己” 的原则, 并在许多组件之间重用代码.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在面向对象的方法中, 我们可能会使用继承或类似装饰者模式的技术.&lt;/li&gt;
&lt;li&gt;在函数式的方法中, 我们将所有可重复使用的代码放入函数中 …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Thu, 06 Feb 2020 13:00:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2020-02-06:/liu-implementation-composing-a-pipeline.html</guid><category>函数式</category><category>函数式领域建模</category><category>函数式</category><category>领域驱动</category><category>DDD</category></item><item><title>五. Modeling Workflows as Pipelines</title><link>http://www.smallcpp.cn/wu-modeling-workflows-as-pipelines.html</link><description>
&lt;p&gt;现在开始对 &lt;em&gt;Place Order&lt;/em&gt; 工作流建模, 下面是我们需要建模的摘要:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;workflow "Place Order" =
    input: UnvalidatedOrder
    output (on success):
        OrderAcknowledgmentSent
        AND OrderPlaced (to send to shipping)
        AND BillableOrderPlaced (to send to billing)
    output (on error):
        ValidationError …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Mon, 16 Dec 2019 23:00:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2019-12-16:/wu-modeling-workflows-as-pipelines.html</guid><category>函数式</category><category>函数式领域建模</category><category>函数式</category><category>领域驱动</category><category>DDD</category></item><item><title>四. Integrity and Consistency in the Domain</title><link>http://www.smallcpp.cn/si-integrity-and-consistency-in-the-domain.html</link><description>
&lt;p&gt;现在, 我们构建了一组丰富的领域模型. 接下来要做的是 “&lt;a href="http://www.smallcpp.cn/er-a-functional-architecture.html#trust-boundaries-and-validation"&gt;保护好&lt;/a&gt;” 它, 因此应该采取一些预防措施, 以确保此域中的任何数据都是有效和一致的. 我们的目标是创建一个界限上下文, 该上下文始终包含我们可以信任的数据, 与不受信任的外部世界不同. 如果我们能够确保所有数据始终有效, 则实现可以保持干净, 并且我们可以避免执行防御性编程以及减少单元测试.&lt;/p&gt;
&lt;p&gt;先来看下两个很重要的概念, &lt;a href="http://www.smallcpp.cn/san-domain-modeling-with-types.html#aggregates-enforce-consistency-and-invariants"&gt;上一节&lt;/a&gt;中也有提到.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Integrity&lt;/strong&gt; (or validity) 意味着一段数据遵循正确的业务规则(Guard).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Consistency&lt;/strong&gt; 意味着领域模型的不同部分要与事实一致(有点类似事务).&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Invariants&lt;/strong&gt; are generally business rules/enforcements …&lt;/p&gt;&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Tue, 10 Dec 2019 15:00:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2019-12-10:/si-integrity-and-consistency-in-the-domain.html</guid><category>函数式</category><category>函数式</category><category>领域驱动</category><category>DDD</category></item><item><title>三. Domain Modeling with Types</title><link>http://www.smallcpp.cn/san-domain-modeling-with-types.html</link><description>
&lt;h1 id="reviewing-the-domain-model"&gt;Reviewing the Domain Model&lt;/h1&gt;
&lt;p&gt;TODO: 补充需求.&lt;/p&gt;
&lt;p&gt;现在让我们看下已有领域模型的伪代码 (在与领域专家讨论需求时记录下来的):&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;context: Order-Taking
// ----------------------
// Simple types
// ----------------------
// Product codes
data ProductCode = WidgetCode OR GizmoCode
data WidgetCode = string starting with "W" then 4 digits
data …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Tue, 03 Dec 2019 15:00:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2019-12-03:/san-domain-modeling-with-types.html</guid><category>函数式</category><category>函数式</category><category>领域驱动</category><category>DDD</category></item><item><title>二. A Functional Architecture</title><link>http://www.smallcpp.cn/er-a-functional-architecture.html</link><description>
&lt;p&gt;在本章中, 我们将简要介绍面向函数式的领域模型的典型软件架构以及将 DDD 概念(如 “界限上下文” 和 “领域事件”)转换为软件的方法.&lt;/p&gt;
&lt;p&gt;当然, 软件架构本身就是一个领域, 因此, 让我们遵循我们自己的建议, 在谈论它时使用 “无处不在的语言”. 我们将使用 Simon Brown 的 “C4” 方法中的术语, 其中软件架构由四个级别组成:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The “&lt;strong&gt;system context&lt;/strong&gt;” is the top level representing …&lt;/li&gt;&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Fri, 29 Nov 2019 13:00:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2019-11-29:/er-a-functional-architecture.html</guid><category>函数式</category><category>函数式</category><category>领域驱动</category><category>DDD</category></item><item><title>一. Introducing Domain-Driven Design</title><link>http://www.smallcpp.cn/yi-introducing-domain-driven-design.html</link><description>
&lt;p&gt;DDD 社区指导我们如何创建通用的模型:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关注业务事件和工作流程, 而不是数据结构 (ps: 职责驱动)&lt;/li&gt;
&lt;li&gt;将问题域划分为较小的子域&lt;/li&gt;
&lt;li&gt;为每个子域创建解决方案模型 (Bounded Contexts – Domain Model)&lt;/li&gt;
&lt;li&gt;开发一种公共语言在项目涉及的每个人之间共享, 并在代码中随处使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="understanding-the-domain-through-business-events"&gt;Understanding the Domain Through Business Events&lt;/h1&gt;
&lt;p&gt;DDD 收集需求的方法强调在开发人员和领域专家之间建立共识, 但是我们该从哪开始?&lt;/p&gt;
&lt;p&gt;第一条准则是 “&lt;strong&gt;专注于业务事件&lt;/strong&gt;”, 因此让我们开始事件风暴会议. 这是开始的方式.&lt;/p&gt;
&lt;p&gt;业务不光有数据, 而且还以某种方式对其进行了转换. 也就是说 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Thu, 28 Nov 2019 10:00:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2019-11-28:/yi-introducing-domain-driven-design.html</guid><category>函数式</category><category>函数式</category><category>领域驱动</category><category>DDD</category></item><item><title>函数式领域建模 - 用DDD和F＃解决软件复杂性</title><link>http://www.smallcpp.cn/han-shu-shi-ling-yu-jian-mo-yong-dddhe-fjie-jue-ruan-jian-fu-za-xing.html</link><description>&lt;p&gt;本书大纲&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一部分 — 了解领域&lt;ul&gt;
&lt;li&gt;什么是 DDD&lt;/li&gt;
&lt;li&gt;通用模型的重要性&lt;/li&gt;
&lt;li&gt;理解领域事件&lt;/li&gt;
&lt;li&gt;拆分领域为子域&lt;/li&gt;
&lt;li&gt;界限上下文&lt;/li&gt;
&lt;li&gt;通用的语言&lt;/li&gt;
&lt;li&gt;总结 DDD 的概念&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Thu, 28 Nov 2019 09:00:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2019-11-28:/han-shu-shi-ling-yu-jian-mo-yong-dddhe-fjie-jue-ruan-jian-fu-za-xing.html</guid><category>函数式</category><category>函数式</category><category>领域驱动</category><category>DDD</category></item><item><title>修改 Safari 代码字体</title><link>http://www.smallcpp.cn/xiu-gai-safari-dai-ma-zi-ti.html</link><description>&lt;p&gt;工具: &lt;a href="https://tampermonkey.net/?browser=safari"&gt;油猴插件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;添加以下脚本:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;// ==UserScript==&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// @name         使用等宽字体&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// @namespace    https://github.com/uldaman/&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// @version      1.0.0&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// @description  强制修改网页中代码部分为等宽字体!&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// @author       HanXiao&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// @include      *&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// @exclude      *.seedr.cc*&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// @exclude      *console.cloud.google.com/cloudshell*&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// @run-at …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Thu, 17 Jan 2019 12:56:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2019-01-17:/xiu-gai-safari-dai-ma-zi-ti.html</guid><category>工具折腾</category></item><item><title>Js 函数式库</title><link>http://www.smallcpp.cn/js-han-shu-shi-ku.html</link><description>
&lt;h1 id="fantasy-land"&gt;Fantasy land&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://github.com/fantasyland/fantasy-land"&gt;Fantasy Land&lt;/a&gt; 是一套 &lt;a href="http://www.smallcpp.cn/han-shu-shi-guan-jian-gai-nian-haskell-miao-shu.html#_7"&gt;TypeClass&lt;/a&gt; 的 JS 描述, 包括但不限于 Functor, Applicative, Monad.&lt;/p&gt;
&lt;p&gt;以下是几个常用的 TypeClass.&lt;/p&gt;
&lt;h2 id="functor"&gt;Functor&lt;/h2&gt;
&lt;p&gt;Haskell 描述: &lt;a href="http://www.smallcpp.cn/han-shu-shi-guan-jian-gai-nian-Haskell-miao-shu.html#functor"&gt;Functor&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Js 描述差不多, 用 map 代替了 fmap.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;F.map(f)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id="applicative"&gt;Applicative&lt;/h2&gt;
&lt;p&gt;Haskell …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Wed, 16 Jan 2019 15:00:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2019-01-16:/js-han-shu-shi-ku.html</guid><category>函数式</category></item><item><title>Ramda 算子一览表</title><link>http://www.smallcpp.cn/ramda-suan-zi-yi-lan-biao.html</link><description>&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;list&lt;/th&gt;
&lt;th&gt;function&lt;/th&gt;
&lt;th&gt;object&lt;/th&gt;
&lt;th&gt;relation&lt;/th&gt;
&lt;th&gt;logic&lt;/th&gt;
&lt;th&gt;math&lt;/th&gt;
&lt;th&gt;string&lt;/th&gt;
&lt;th&gt;type&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;adjust&lt;/td&gt;
&lt;td&gt;__&lt;/td&gt;
&lt;td&gt;assoc&lt;/td&gt;
&lt;td&gt;clamp&lt;/td&gt;
&lt;td&gt;allPass&lt;/td&gt;
&lt;td&gt;add&lt;/td&gt;
&lt;td&gt;match&lt;/td&gt;
&lt;td&gt;is&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;all&lt;/td&gt;
&lt;td&gt;addIndex&lt;/td&gt;
&lt;td&gt;assocPath&lt;/td&gt;
&lt;td&gt;countBy&lt;/td&gt;
&lt;td&gt;and&lt;/td&gt;
&lt;td&gt;dec&lt;/td&gt;
&lt;td&gt;replace&lt;/td&gt;
&lt;td&gt;isNil&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;any&lt;/td&gt;
&lt;td&gt;always&lt;/td&gt;
&lt;td&gt;clone&lt;/td&gt;
&lt;td&gt;difference&lt;/td&gt;
&lt;td&gt;anyPass&lt;/td&gt;
&lt;td&gt;divide …&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Sun, 16 Dec 2018 19:00:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2018-12-16:/ramda-suan-zi-yi-lan-biao.html</guid><category>函数式</category></item><item><title>函数式关键概念 Haskell 描述</title><link>http://www.smallcpp.cn/han-shu-shi-guan-jian-gai-nian-haskell-miao-shu.html</link><description>&lt;p&gt;学习 Haskell 过程中接触到的 FP (functional programming) 的一些概念, 并不是 FP 的全部 (PS: 为了容易理解, 尽可能的忽略了数学描述, 而改用开发容易理解的字眼, 所以某些概念可能会描述的并不准确).&lt;/p&gt;

&lt;h1 id="_1"&gt;函数式&lt;/h1&gt;
&lt;h2 id="_2"&gt;纯函数&lt;/h2&gt;
&lt;p&gt;函数式编程中的函数式指的是&lt;strong&gt;数学函数&lt;/strong&gt;, 即我们要编写具有数学函数性质的函数.&lt;/p&gt;
&lt;p&gt;数学中的函数, 为两集合间的一种对应关系:&lt;br/&gt;
输入值集合中的每项元素 x, 对其施加某个法则 f, 皆能对应&lt;strong&gt;唯一&lt;/strong&gt;一项输出值集合中的元素 y …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Mon, 03 Dec 2018 18:00:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2018-12-03:/han-shu-shi-guan-jian-gai-nian-haskell-miao-shu.html</guid><category>函数式</category></item><item><title>用费曼技巧读书</title><link>http://www.smallcpp.cn/yong-fei-man-ji-qiao-du-shu.html</link><description>
&lt;p&gt;Reference:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.jianshu.com/p/682872cc0fc8"&gt;读书与皇帝的金扁担&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.studygs.net/chinese/texred2.htm"&gt;SQ3R 阅读方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="_1"&gt;解构目录&lt;/h1&gt;
&lt;p&gt;读书不是从第一页开始, 而是从目录开始. 了解这本书的目录章节, 然后开始思考: 作者为何这样编排结构? 设想你是作者, 在这样的结构下, 结合你的经验和阅历, 你会怎么样来写作各个章节的内容? 解构完目录, 你已预先建立了这本书的属于你自己的框架.&lt;/p&gt;
&lt;p&gt;如果对某些章节有疑问, 那最好不过, 把这部分内容当作你的&lt;em&gt;锚点&lt;/em&gt;, 先别急着去解开疑惑, 或许等你读到那里的时候, 自然会豁然开朗. 这样的体验是美妙的.&lt;/p&gt;
&lt;h1 id="_2"&gt;以章节作为阅读单位&lt;/h1&gt;
&lt;p&gt;每读完一章节, 停下来, 从整体的角度来看, 思考这一章的内容是怎样来支持作者的观点的?&lt;/p&gt;
&lt;p&gt;罗列各个要点 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Mon, 26 Nov 2018 11:46:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2018-11-26:/yong-fei-man-ji-qiao-du-shu.html</guid><category>杂项</category></item><item><title>柯里化与偏函数</title><link>http://www.smallcpp.cn/ke-li-hua-yu-pian-han-shu.html</link><description>&lt;p&gt;&lt;strong&gt;Currying&lt;/strong&gt;: 因为是美国数理逻辑学家哈斯凯尔·柯里(Haskell Curry)发明了这种函数使用技巧, 所以这样用法就以他的名字命名为 Currying, 中文翻译为 “柯里化”.&lt;/p&gt;
&lt;p&gt;我感觉很多人都对函数柯里化(Currying)和偏函数应用(Partial Application)之间的区别搞不清楚, 尤其是在相似的上下文环境中它们同时出现的时候.&lt;/p&gt;

&lt;h1 id="_1"&gt;偏函数应用&lt;/h1&gt;
&lt;p&gt;偏函数应用解决这样的问题: 如果我们有函数是多个参数的, 我们希望能固定其中某几个参数的值.&lt;/p&gt;
&lt;p&gt;几乎所有编程语言中都有非常明显的偏函数应用. 在 C 语言中:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #00688B; font-weight: bold"&gt;int&lt;/span&gt; &lt;span style="color: #008b45"&gt;foo&lt;/span&gt;(&lt;span style="color: #00688B; font-weight: bold"&gt;int&lt;/span&gt; a, &lt;span style="color: #00688B; font-weight: bold"&gt;int …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Thu, 06 Sep 2018 19:00:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2018-09-06:/ke-li-hua-yu-pian-han-shu.html</guid><category>函数式</category></item><item><title>计算机程序的构造与解释</title><link>http://www.smallcpp.cn/ji-suan-ji-cheng-xu-de-gou-zao-yu-jie-shi.html</link><description>
&lt;h1 id="_1"&gt;函数式编程&lt;/h1&gt;
&lt;p&gt;函数式编程是一种编程典范, 比起指令式(过程式)编程的复杂执行过程, 函数式编程更加强调程序执行的结果, 倡导利用若干简单的执行单元让计算结果不断渐进, 仔细定义每个运算的输入, 以及每个运算返回的内容, 逐层推导复杂的运算, 并且避免使用程序状态以及易变对象.&lt;/p&gt;
&lt;p&gt;以一个多项式求值 &lt;code&gt;a * (b + c)&lt;/code&gt; 举例 (假设存在 &lt;code&gt;add&lt;/code&gt; 和 &lt;code&gt;mul&lt;/code&gt; 方法):&lt;/p&gt;
&lt;p&gt;指令式(过程式)编程:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;x = add(b, c)
y = mul …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Wed, 01 Aug 2018 12:36:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2018-08-01:/ji-suan-ji-cheng-xu-de-gou-zao-yu-jie-shi.html</guid><category>函数式</category></item><item><title>UML和模式应用</title><link>http://www.smallcpp.cn/umlhe-mo-shi-ying-yong.html</link><description>
&lt;h1 id="aup-agile-unified-process"&gt;AUP: Agile Unified Process&lt;/h1&gt;
&lt;p&gt;敏捷统一过程, 轻量级的 RUP.&lt;/p&gt;
&lt;p&gt;本书通过两个案例 &amp;lt;NextGen POS&amp;gt; 和 &amp;lt;MonopolyGame&amp;gt; 将 AUP 贯穿起来. 从 OOA/D 的概念到系统架构中模式的应用, 一层一层的展开, 介绍了如何从最初的软件需求, 结合 UML 帮助软件开发、设计人员更好地进行领域模型的表达和建立, 以及随着迭代的进行, 逐步细化设计, 最终完成一个有弹性、易维护、可扩展 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Sat, 05 May 2018 18:09:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2018-05-05:/umlhe-mo-shi-ying-yong.html</guid><category>软件工程</category></item><item><title>连接字符串的几种方式</title><link>http://www.smallcpp.cn/lian-jie-zi-fu-chuan-de-ji-chong-fang-shi.html</link><description>&lt;blockquote&gt;
&lt;p&gt;转自 hatlonely Golang 语言社区&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最近在做性能优化, 有个函数里面的耗时特别长, 看里面的操作大多是一些字符串拼接的操作, 而字符串拼接在 golang 里面其实有很多种实现.&lt;/p&gt;
&lt;h1 id="_1"&gt;直接使用运算符&lt;/h1&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;func BenchmarkAddStringWithOperator(b *testing.B) {
    hello := "hello"
    world := "world"
    for i := 0; i &amp;lt; b.N; i++ {
        _ = hello + "," + world …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Fri, 09 Feb 2018 11:21:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2018-02-09:/lian-jie-zi-fu-chuan-de-ji-chong-fang-shi.html</guid><category>Golang</category></item><item><title>渗透法学英语</title><link>http://www.smallcpp.cn/shen-tou-fa-xue-ying-yu.html</link><description>&lt;blockquote&gt;
&lt;p&gt;需先提升英语水平致赖世雄高级水平.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下内容转自公众号「恶魔奶爸Sam」&lt;/p&gt;
&lt;p&gt;1, 选书, 选择&lt;strong&gt;单页&lt;/strong&gt;生词率低于 10 个以下的 (相关书籍推荐原书都有), 最简单的原文书应该是 Goose bump 跟 Magic Tree House, 每个系列都有 60 本以上, 网上 mobi epub 一大堆, 属于 2000 到 3000 词汇量以内可以看懂的 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Thu, 01 Feb 2018 23:50:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2018-02-01:/shen-tou-fa-xue-ying-yu.html</guid><category>杂项</category></item><item><title>mock fake stub</title><link>http://www.smallcpp.cn/mock-fake-stub.html</link><description>&lt;blockquote&gt;
&lt;p&gt;只有当&lt;strong&gt;感知&lt;/strong&gt;和&lt;strong&gt;分离&lt;/strong&gt;困难时, 才需要使用这三个特殊 Object. Reference:《修改代码的艺术》.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id="fake-object"&gt;Fake Object&lt;/h5&gt;
&lt;p&gt;仿对象, 实现了依赖的接口, 包含一些简单的数据处理逻辑, 可对外部调用进行&lt;strong&gt;感知&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;如果依赖的类很难构造, 或无法进行感知时, 可使用 Fake Object.&lt;/p&gt;
&lt;h4 id="mock-object"&gt;Mock Object&lt;/h4&gt;
&lt;p&gt;伪对象, Facke 的高级版, 在内部进行了&lt;strong&gt;断言&lt;/strong&gt;处理.&lt;/p&gt;
&lt;h4 id="stub-object"&gt;Stub …&lt;/h4&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Tue, 23 Jan 2018 15:17:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2018-01-23:/mock-fake-stub.html</guid><category>软件工程</category></item><item><title>递归转尾递归</title><link>http://www.smallcpp.cn/di-gui-zhuan-wei-di-gui.html</link><description>&lt;blockquote&gt;
&lt;p&gt;尾递归 == 伪递归, 只有递, 没有归&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不是所有的递归都可以转成尾递归, 例如回溯的递归实现就不行, 因为回溯是每一次执行都有 n (n &amp;gt; 1) 种状态, 即在递归的每一层都会有多个递归调用.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;递归 (回溯除外) 是一种特殊的隐式图 DFS, 其每一次状态转换都只有一条路径.&lt;/p&gt;
&lt;p&gt;通常, 如果规模为 n 的问题, 可由 n 的子集 (n-1, n/2 等) 的解推导出时, 考虑使用递归 …&lt;/p&gt;&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Mon, 22 Jan 2018 19:36:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2018-01-22:/di-gui-zhuan-wei-di-gui.html</guid><category>软件工程</category></item><item><title>去除 golint 对 self this 的警告</title><link>http://www.smallcpp.cn/qu-chu-golint-dui-self-this-de-jing-gao.html</link><description>&lt;p&gt;去除 golint 对方法接收者命名为 self、this 的警告.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Fri, 01 Dec 2017 14:00:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2017-12-01:/qu-chu-golint-dui-self-this-de-jing-gao.html</guid><category>Golang</category></item><item><title>PlantUML in VSCode</title><link>http://www.smallcpp.cn/plantuml-in-vscode.html</link><description>&lt;p&gt;&lt;a href="https://marketplace.visualstudio.com/items?itemName=jebbs.plantuml"&gt;PlantUML for VSCode&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 VSCode 的插件中安装 plantuml&lt;/li&gt;
&lt;li&gt;&lt;code&gt;brew install graphviz&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;brew cask install java&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;plantuml 文件后缀是 &lt;code&gt;.wsd&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Use References:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.jianshu.com/p/e92a52770832"&gt;使用 Sublime + PlantUML 高效地画图&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://archive.3zso.com/archives/plantuml-quickstart.html#orgec32f74"&gt;PlantUML 快速指南&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Fri, 01 Dec 2017 13:00:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2017-12-01:/plantuml-in-vscode.html</guid><category>工具折腾</category></item><item><title>Go test log in VSCode</title><link>http://www.smallcpp.cn/go-test-log-in-vscode.html</link><description>&lt;p&gt;VSCode 中写 go test 时支持直接运行测试, 但是却输不出 log 信息, 这是因为 VSCode 默认执行 &lt;code&gt;go test&lt;/code&gt; 时没有 &lt;code&gt;-v&lt;/code&gt; 参数 (详细输出).&lt;/p&gt;
&lt;p&gt;打开用户设置 (首选项 -&amp;gt; 设置):&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;{
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;quot;go.testFlags&amp;quot;&lt;/span&gt;: [&lt;span style="color: #CD5555"&gt;&amp;quot;-v&amp;quot;&lt;/span&gt;]
}
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Thu, 30 Nov 2017 15:58:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2017-11-30:/go-test-log-in-vscode.html</guid><category>工具折腾</category></item><item><title>mac tools</title><link>http://www.smallcpp.cn/mac-tools.html</link><description>&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/robbyrussell/oh-my-zsh"&gt;oh-my-zsh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://itunes.apple.com/cn/app/go2shell/id445770608?mt=12"&gt;go2shell&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://supportdownloads.adobe.com/thankyou.jsp?ftpID=5137&amp;amp;fileID=4770"&gt;Adobe Reader&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Wed, 29 Nov 2017 19:00:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2017-11-29:/mac-tools.html</guid><category>工具折腾</category></item><item><title>Open file in new tab in VSCode</title><link>http://www.smallcpp.cn/open-file-in-new-tab-in-vscode.html</link><description>&lt;p&gt;在 VSCode 的资源管理器中打开文件会&amp;rdquo;冲&amp;rdquo;掉当前打开的文件, 很不方便.&lt;/p&gt;
&lt;p&gt;这是由于默认在 VSCode 的资源管理器中单击文件是预览模式, 双击才是真正的打开文件, 通过用户设置可以改变这种行为.&lt;/p&gt;
&lt;p&gt;打开用户设置 (首选项 -&amp;gt; 设置):&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;{
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;quot;workbench.editor.enablePreview&amp;quot;&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;false&lt;/span&gt;,
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;quot;workbench.editor.enablePreviewFromQuickOpen&amp;quot;&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;false&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Wed, 29 Nov 2017 16:58:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2017-11-29:/open-file-in-new-tab-in-vscode.html</guid><category>工具折腾</category></item><item><title>GOPATH in VSCode</title><link>http://www.smallcpp.cn/gopath-in-vscode.html</link><description>&lt;p&gt;打开用户设置 (首选项 -&amp;gt; 设置):&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;{
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;quot;go.inferGopath&amp;quot;&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;,
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;quot;go.toolsGopath&amp;quot;&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;&amp;quot;/Users/hanxiao/Desktop/commonGoPath&amp;quot;&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;inferGopath&lt;/strong&gt; 让编辑器自动推断 Gopath, 规则是沿着当前文件向上找到 src 目录, 并将其设为 Gopath (该结果会覆盖 go.gopath 的设置). 所以我们的项目必须满足 Go 推荐的结构, 即源码要位于 &lt;code&gt;gopath/src …&lt;/code&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Wed, 22 Nov 2017 16:58:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2017-11-22:/gopath-in-vscode.html</guid><category>工具折腾</category></item><item><title>为 bash 设置 Shadowsocks</title><link>http://www.smallcpp.cn/wei-bash-she-zhi-shadowsocks.html</link><description>
&lt;blockquote&gt;
&lt;p&gt;socks5 设置方式:&lt;br/&gt;
&lt;code&gt;export ALL_PROXY=socks5://127.0.0.1:1086&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Shadowsocks 是常用的代理工具, 它使用 socks5 协议, 而终端很多工具目前只支持 http 和 https 等协议, 对 socks5 协议支持不够好, 所以为终端设置 shadowsocks 的思路就是将 socks 协议转换成 http 协议 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Wed, 22 Nov 2017 16:56:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2017-11-22:/wei-bash-she-zhi-shadowsocks.html</guid><category>工具折腾</category></item><item><title>类型嵌入实践</title><link>http://www.smallcpp.cn/lei-xing-qian-ru-shi-jian.html</link><description>&lt;p&gt;Go 中没有提供继承的语义, 可以使用组合设计模式, 只需简单的将一个类型嵌入另一个类型就能实现复用.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Fri, 10 Nov 2017 14:00:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2017-11-10:/lei-xing-qian-ru-shi-jian.html</guid><category>Golang</category></item><item><title>Tox P2P 加密聊天工具</title><link>http://www.smallcpp.cn/tox-p2p-jia-mi-liao-tian-gong-ju.html</link><description>&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;Tox 是一个与众不同的即时通讯软件, 最大的特点是 P2P 通讯, 没有服务商的服务器储存各种信息, 所有的一切, 都储存在自己的电脑中, 并且完美兼容 Windows、Linux、MAC、IOS 以及 Android 平台.&lt;/p&gt;
&lt;p&gt;这一点带来了利弊两个方面, 好处是这种方式保护了我们的隐私, 避免对话受到外泄和审查, 坏处是一切都储存在你自己的设备上 (电脑、手机), 于是迁移或者多客户端使用就不太方便 (不过可以通过 &lt;a href="http://www.mintos.org/skill/qtox-switch-devices.html"&gt;Tox聊天(4): qTox 异地同一账号登录&lt;/a&gt; 曲线救国&amp;hellip;).&lt;/p&gt;
&lt;p&gt;Tox …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Thu, 14 Sep 2017 16:37:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2017-09-14:/tox-p2p-jia-mi-liao-tian-gong-ju.html</guid><category>工具折腾</category></item><item><title>从程序员到软件架构师</title><link>http://www.smallcpp.cn/cong-cheng-xu-yuan-dao-ruan-jian-jia-gou-shi.html</link><description>&lt;p&gt;从程序员到软件架构师, 那些年走过的路.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Sun, 27 Aug 2017 13:27:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2017-08-27:/cong-cheng-xu-yuan-dao-ruan-jian-jia-gou-shi.html</guid><category>软件工程</category></item><item><title>Github 常用功能</title><link>http://www.smallcpp.cn/github-chang-yong-gong-neng.html</link><description>
&lt;h1 id="watchstarfork"&gt;Watch、star、fork&lt;/h1&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/github/watch.png"/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示, 每个 github 项目的右上角, 都有三个按钮: &lt;code&gt;Watch&lt;/code&gt;、&lt;code&gt;star&lt;/code&gt;、&lt;code&gt;fork&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="watch"&gt;Watch&lt;/h2&gt;
&lt;p&gt;这个单词在调试程序时经常遇到, 意为监视, 当把某个变量添加到监视后, 就可以实时看到变量的值的变化.&lt;/p&gt;
&lt;p&gt;Github 中的 &lt;code&gt;Watch&lt;/code&gt; 也是类似的功能, 当你监视某个项目后, 如果项目发生变动, 如有人提交了 pull request、发起了 issue 等等情况, 都会在自己的个人通知中心收到一条通知消息, 如果设置了个人邮箱 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Sat, 26 Aug 2017 21:28:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2017-08-26:/github-chang-yong-gong-neng.html</guid><category>工具折腾</category></item><item><title>位掩码 (权限模型、组合标志)</title><link>http://www.smallcpp.cn/wei-yan-ma-quan-xian-mo-xing-zu-he-biao-zhi.html</link><description>&lt;p&gt;位运算在程序设计中的使用 &amp;ndash; 位掩码&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Tue, 22 Aug 2017 13:27:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2017-08-22:/wei-yan-ma-quan-xian-mo-xing-zu-he-biao-zhi.html</guid><category>软件工程</category></item><item><title>书单</title><link>http://www.smallcpp.cn/shu-dan.html</link><description>&lt;p&gt;一部分书是早几年就读过 PDF 的 (还是挑着章节读的 ~ ~), 很多内容其实没搞懂, 当时技术能力跟不上也就得过且过了; 随着这几年不断的提升自我, 对技术也越来越有比较深的领悟, 感觉应该把那些年当糟粕丢弃的精华重新捡起来再读次.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Sat, 19 Aug 2017 13:32:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2017-08-19:/shu-dan.html</guid><category>杂项</category></item><item><title>Chrome F12 Network</title><link>http://www.smallcpp.cn/chrome-f12-network.html</link><description>&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/chromef12/network.png"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;序号 &lt;strong&gt;0&lt;/strong&gt;: 保存 Log, 页面跳转后, 控制台和网络控制台的内容暂时不清空, 保留下来&lt;/li&gt;
&lt;li&gt;序号 &lt;strong&gt;1&lt;/strong&gt;: 禁用缓存, 打钩后, 刷新页面, 所有请求都是 200, 不打勾当你打开重复页面会出现 304&lt;/li&gt;
&lt;li&gt;序号 &lt;strong&gt;2&lt;/strong&gt;: 可以设置模拟网络, 打开当前页&lt;/li&gt;
&lt;li&gt;序号 &lt;strong&gt;3&lt;/strong&gt;: 本页面共发了多少请求, 本页面大小
    * finish: 每次加载完一个资源 (js, css, img) 时间都会累加 …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Tue, 15 Aug 2017 11:00:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2017-08-15:/chrome-f12-network.html</guid><category>工具折腾</category></item><item><title>关于框架</title><link>http://www.smallcpp.cn/guan-yu-kuang-jia.html</link><description>&lt;p&gt;成也框架, 败也框架.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Sun, 13 Aug 2017 13:27:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2017-08-13:/guan-yu-kuang-jia.html</guid><category>软件工程</category></item><item><title>Git Rebase</title><link>http://www.smallcpp.cn/git-rebase.html</link><description>
&lt;p&gt;rebase 比较复杂, 应该是 git 中的高级应用了, 所以单独拿出来做篇 wiki, 转自: &lt;a href="https://ihower.tw/blog"&gt;ihower blog&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id="git-rebase-merge"&gt;使用 git rebase 避免無謂的 merge&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;git pull&lt;/code&gt; 預設的行為是將遠端的 repo. 與本地的 repo. 合併, 這也是 DVCS 的初衷, 將兩個 branch 合併. 但是, 很多時候會發生以下這種情形 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Mon, 07 Aug 2017 13:00:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2017-08-07:/git-rebase.html</guid><category>工具折腾</category></item><item><title>需求分析 (定义用例)</title><link>http://www.smallcpp.cn/xu-qiu-fen-xi-ding-yi-yong-li.html</link><description>
&lt;p&gt;在 AUP 中, 需求也不是一次性分析完的, 会是一个不断迭代精化的过程.&lt;/p&gt;
&lt;p&gt;先来个&lt;strong&gt;总结&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;摘要/非正式/用例图&lt;/strong&gt;, 用来快速收集需求, 表达用户可以利用系统作什么, 是粗粒度级别的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;详述用例&lt;/strong&gt;, 用来详细的描述完成用例的所有步骤及各种变化, 不仅仅是用户的操作, 还包括系统处理的事件流和业务流, 注意是黑盒, 不涉及代码.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="_1"&gt;迭代过程&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;先进行高阶需求分析, 仅仅确定用例的名称, 以及关键的非功能性需求&lt;/li&gt;
&lt;li&gt;从高阶需求列表中选取 10% 的列表项进行详细的分析
    1. 核心架构
    2. 高业务价值 …&lt;/li&gt;&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Sat, 05 Aug 2017 01:30:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2017-08-05:/xu-qiu-fen-xi-ding-yi-yong-li.html</guid><category>软件工程</category></item><item><title>DDD 领域驱动设计与六边形架构</title><link>http://www.smallcpp.cn/ddd-ling-yu-qu-dong-she-ji-yu-liu-bian-xing-jia-gou.html</link><description>&lt;p&gt;软件世界是对现实世界的抽象, 而传统的三层架构或 MVC 架构 (参考: &lt;a href="http://www.smallcpp.cn/san-ceng-jia-gou-yu-mvc.html"&gt;三层架构与 MVC&lt;/a&gt;), 却是结构化的生搬硬套, 在这些架构中的设计出来的对象是贫血的, 是“业务逻辑”类, 跟现实世界甚至毫无关系, 那么根据根据现实世界的真实领域, 映射到软件世界的&lt;code&gt;领域驱动设计&lt;/code&gt;和&lt;code&gt;六边形架构&lt;/code&gt;, 才是更好的架构方式, 应用场景更广, 扩展更简单.&lt;/p&gt;
&lt;p&gt;PS, 领域驱动设计继承了职责驱动设计, 或者可以说是职责驱动设计的进化.&lt;/p&gt;
&lt;p&gt;领域驱动设计不是一种设计风格, 也不是一种架构模型, 而是一种思考方式, 指导如何进行职责的划分, 而六边开架构就是一种架构了, &amp;ldquo;六 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Fri, 04 Aug 2017 11:24:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2017-08-04:/ddd-ling-yu-qu-dong-she-ji-yu-liu-bian-xing-jia-gou.html</guid><category>软件工程</category></item><item><title>Git pull/clone 时报 early EOF 错</title><link>http://www.smallcpp.cn/git-pullclone-shi-bao-early-eof-cuo.html</link><description>&lt;p&gt;错误信息如下:
fatal: The remote end hung up unexpectedly
fatal: early EOF
fatal: unpack-objects failed&lt;/p&gt;
&lt;p&gt;解决方案一:
1. 先启动 git bash
2. 打开一个 cmd, 启动 git 守护进程 &lt;code&gt;sh.exe --login -i -c …&lt;/code&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Mon, 24 Jul 2017 21:28:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2017-07-24:/git-pullclone-shi-bao-early-eof-cuo.html</guid><category>工具折腾</category></item><item><title>文档编辑器鄙视链</title><link>http://www.smallcpp.cn/wen-dang-bian-ji-qi-bi-shi-lian.html</link><description>&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/文档编辑器鄙视链/bslian.png"&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Sat, 22 Jul 2017 16:37:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2017-07-22:/wen-dang-bian-ji-qi-bi-shi-lian.html</guid><category>工具折腾</category></item><item><title>迁移 OneNote 说明</title><link>http://www.smallcpp.cn/qian-yi-onenote-shuo-ming.html</link><description>&lt;p&gt;微软已经彻底免费了 OneNote, 试用一段时间后感觉超级棒, 以后都将 OneNote 作为主要&lt;strong&gt;笔记&lt;/strong&gt;工具.&lt;/p&gt;
&lt;p&gt;笔记 (读书、学习等)、日志类 -&gt; OneNote&lt;/p&gt;
&lt;p&gt;拾遗、碎片知识、操作指南类 -&gt; &lt;a href="http://wiki.smallcpp.cn"&gt;wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;总结、感想、分析类 -&gt; &lt;a href="http://www.smallcpp.cn"&gt;blog&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Mon, 23 Jan 2017 03:40:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2017-01-23:/qian-yi-onenote-shuo-ming.html</guid><category>杂项</category></item><item><title>11. 回收站的使用</title><link>http://www.smallcpp.cn/11-hui-shou-zhan-de-shi-yong.html</link><description>&lt;p&gt;回收站的使用&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Thu, 24 Nov 2016 10:37:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-11-24:/11-hui-shou-zhan-de-shi-yong.html</guid><category>大数据</category></item><item><title>10. 2.X HA (高可靠) 及 Federation (联盟)</title><link>http://www.smallcpp.cn/10-2x-ha-gao-ke-kao-ji-federation-lian-meng.html</link><description>&lt;p&gt;2.x 用 HA 实现 NameNode 高可靠 及 Federation (联盟)&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Wed, 23 Nov 2016 19:00:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-11-23:/10-2x-ha-gao-ke-kao-ji-federation-lian-meng.html</guid><category>大数据</category></item><item><title>09. 小文件解决方案</title><link>http://www.smallcpp.cn/09-xiao-wen-jian-jie-jue-fang-an.html</link><description>&lt;p&gt;小文件解决方案&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Wed, 23 Nov 2016 18:27:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-11-23:/09-xiao-wen-jian-jie-jue-fang-an.html</guid><category>大数据</category></item><item><title>RUP 核心工作流及模板</title><link>http://www.smallcpp.cn/rup-he-xin-gong-zuo-liu-ji-mo-ban.html</link><description>&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a href="http://pan.baidu.com/s/1jI4VeHw"&gt;RUP 项目模板&lt;/a&gt; 密码: &lt;code&gt;ownc&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;RUP 中有 9 个核心工作流, 分为 6 个核心过程工作流 (Core Process Workflows) 和 3 个核心支持工作流 (Core Supporting Workflows). 尽管 6 个核心过程工作流可能使人想起传统瀑布模型中的几个阶段, 但应注意迭代过程中的阶段是完全不同的, 这些工作流在整个生命周期中一次又一次被访问. 9 个核心工作流在项目中轮流被使用, 在每一次迭代中以不同的重点和强度重复.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;商业建模&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;商业建模 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Mon, 14 Nov 2016 19:02:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-11-14:/rup-he-xin-gong-zuo-liu-ji-mo-ban.html</guid><category>软件工程</category></item><item><title>JMS AMQP 对比表</title><link>http://www.smallcpp.cn/jms-amqp-dui-bi-biao.html</link><description>&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/JMSAMQP对比表/jmsamqp.png"&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Sun, 13 Nov 2016 18:38:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-11-13:/jms-amqp-dui-bi-biao.html</guid><category>软件工程</category></item><item><title>Hadoop Storm 概念对照表</title><link>http://www.smallcpp.cn/hadoop-storm-gai-nian-dui-zhao-biao.html</link><description>&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/搭建Hadoop分布式实验环境/HadoopStorm.png"&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Sun, 13 Nov 2016 18:34:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-11-13:/hadoop-storm-gai-nian-dui-zhao-biao.html</guid><category>大数据</category></item><item><title>SecureCRT 的安装和使用</title><link>http://www.smallcpp.cn/securecrt-de-an-zhuang-he-shi-yong.html</link><description>&lt;p&gt;&lt;strong&gt;SecureCRT&lt;/strong&gt; 是一款支持 SSH（SSH1 和 SSH2）的终端仿真程序, 同时支持 Telnet 和 rlogin 协议; 它可用于连接运行包括 Windows、Unis 和 linux 在内的远程系统.&lt;/p&gt;
&lt;p&gt;首先下载 SecureCRT 并安装(网上有中文版本下载, 注意找大网站下载, 别下载了被装后门的版本).&lt;/p&gt;
&lt;p&gt;去 Ubuntu 中开启 SSH 功能. (SSH …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Fri, 11 Nov 2016 21:09:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-11-11:/securecrt-de-an-zhuang-he-shi-yong.html</guid><category>工具折腾</category></item><item><title>浅聊架构师</title><link>http://www.smallcpp.cn/qian-liao-jia-gou-shi.html</link><description>&lt;p&gt;简单聊聊架构师及其职责.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Thu, 10 Nov 2016 13:27:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-11-10:/qian-liao-jia-gou-shi.html</guid><category>软件工程</category></item><item><title>Maven</title><link>http://www.smallcpp.cn/maven.html</link><description>
&lt;h1 id="_1"&gt;介绍&lt;/h1&gt;
&lt;p&gt;maven 是一个基于 POM (项目对象模型) 的项目管理和构建自动化工具, 通过它便捷的管理项目生命周期. 即项目的 jar 包依赖、开发、测试、打包和发布.&lt;/p&gt;
&lt;p&gt;可以下载最新版本, 也可以下载经典版本: &lt;a href="http://archive.apache.org/dist/maven/maven-3/3.0.5/binaries/"&gt;maven 3.0.5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于我个人来说, 使用了 maven 最大的好处就是不再需要上网单独下载 jar 包, 只需要在配置文件 &lt;code&gt;pom.xml&lt;/code&gt; 中配置 jar …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Wed, 09 Nov 2016 21:28:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-11-09:/maven.html</guid><category>工具折腾</category></item><item><title>08. 云计算</title><link>http://www.smallcpp.cn/08-yun-ji-suan.html</link><description>&lt;p&gt;云计算&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Sat, 05 Nov 2016 16:03:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-11-05:/08-yun-ji-suan.html</guid><category>大数据</category></item><item><title>SSH 远程执行脚本的环境变量问题</title><link>http://www.smallcpp.cn/ssh-yuan-cheng-zhi-xing-jiao-ben-de-huan-jing-bian-liang-wen-ti.html</link><description>&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;export 导出变量的作用域只即在当前进程及其子进程.&lt;/p&gt;
&lt;p&gt;SSH 远程会话是没有远程主机的环境变量, 解决方法: &lt;code&gt;ssh 远程主机 ". ~/etc/profile &amp;amp;&amp;amp; 命令"&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;有兴趣深纠可参考: &lt;a href="http://feihu.me/blog/2014/env-problem-when-ssh-executing-command-on-remote/#section-10"&gt;ssh 连接远程主机执行脚本的环境变量问题&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Thu, 03 Nov 2016 23:59:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-11-03:/ssh-yuan-cheng-zhi-xing-jiao-ben-de-huan-jing-bian-liang-wen-ti.html</guid><category>工具折腾</category></item><item><title>07. zookeeper 简介</title><link>http://www.smallcpp.cn/07-zookeeper-jian-jie.html</link><description>&lt;p&gt;zookeeper 简介&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Thu, 03 Nov 2016 23:07:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-11-03:/07-zookeeper-jian-jie.html</guid><category>大数据</category></item><item><title>解决复制出来的虚拟机不能启动 DataNode</title><link>http://www.smallcpp.cn/jie-jue-fu-zhi-chu-lai-de-xu-ni-ji-bu-neng-qi-dong-datanode.html</link><description>&lt;p&gt;今天因测试需要, 需要第二台 hadoop 虚拟机, 于是就从 smallcpp01 克隆了一份, 命名为 smallcpp02.&lt;/p&gt;
&lt;p&gt;对第二台主机设置了 主机名、静态IP、 HOSTS、hadoop 配置(就是把一些配置文件里的 ip 和 主机名修改下), 重启虚拟机, 然后重新格式化 hdfs, 启动 Hadoop 服务…&lt;/p&gt;
&lt;p&gt;JPS 后发现, DataNode 并没有被启动…查资料发现问题原因 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Thu, 03 Nov 2016 22:58:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-11-03:/jie-jue-fu-zhi-chu-lai-de-xu-ni-ji-bu-neng-qi-dong-datanode.html</guid><category>大数据</category></item><item><title>Ubuntu 安装 ShadowSocks</title><link>http://www.smallcpp.cn/ubuntu-an-zhuang-shadowsocks.html</link><description>&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装图形界面客户端:
&lt;code&gt;sudo add-apt-repository ppa:hzwhuang/ss-qt5&lt;/code&gt;
&lt;code&gt;sudo apt-get update&lt;/code&gt;
&lt;code&gt;sudo apt-get install shadowsocks-qt5&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="" src="http://i62.tinypic.com/2wcnwy1.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i62.tinypic.com/jjlamt.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i58.tinypic.com/10psqyp.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;将下来, 打开 firefox.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i59.tinypic.com/4ift35.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i57.tinypic.com/2s6udkp.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i60.tinypic.com/33cyi5k.jpg"&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Thu, 03 Nov 2016 22:32:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-11-03:/ubuntu-an-zhuang-shadowsocks.html</guid><category>工具折腾</category></item><item><title>配置 SSH 免密码登录</title><link>http://www.smallcpp.cn/pei-zhi-ssh-mian-mi-ma-deng-lu.html</link><description>&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/SSH/免密码登录原理.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cd ~&lt;/code&gt; 进入根目录&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ls -la&lt;/code&gt; 查看下当前目录文件, 可以看到有个隐藏的 &lt;code&gt;.ssh&lt;/code&gt; 文件夹 (点开头就是隐藏的)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cd .ssh/&lt;/code&gt; 进入 &lt;code&gt;.ssh&lt;/code&gt; 目录, &lt;code&gt;ls&lt;/code&gt; 一下, 看看该目录下有没有 &lt;code&gt;id_rsa&lt;/code&gt;、&lt;code&gt;id_rsa.pub&lt;/code&gt; 两个文件, 如果没有, 就生成一对:
&lt;code&gt;ssh-keygen -t(加密类型) rsa&lt;/code&gt;
&amp;ndash;四个回车&amp;ndash;
然后就会在 &lt;code&gt;.ssh …&lt;/code&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Thu, 03 Nov 2016 22:30:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-11-03:/pei-zhi-ssh-mian-mi-ma-deng-lu.html</guid><category>工具折腾</category></item><item><title>06. 使用 Rest 操作 HDFS</title><link>http://www.smallcpp.cn/06-shi-yong-rest-cao-zuo-hdfs.html</link><description>&lt;p&gt;使用 rest 操作 HDFS&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Thu, 03 Nov 2016 22:07:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-11-03:/06-shi-yong-rest-cao-zuo-hdfs.html</guid><category>大数据</category></item><item><title>前端 Js 插件汇总</title><link>http://www.smallcpp.cn/qian-duan-js-cha-jian-hui-zong.html</link><description>&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.htmleaf.com/jQuery/Menu-Navigation/201502141379.html"&gt;基于 bootstrap 的 jQuery 多级列表树插件 (支持 checkbox)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/wangfupeng1988/wangEditor"&gt;基于javascript和css开发的 Web 富文本编辑器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Wed, 02 Nov 2016 20:29:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-11-02:/qian-duan-js-cha-jian-hui-zong.html</guid><category>软件工程</category></item><item><title>常见的驱动设计</title><link>http://www.smallcpp.cn/chang-jian-de-qu-dong-she-ji.html</link><description>&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;DDD: 领域驱动设计, 《领域驱动设计》&lt;/li&gt;
&lt;li&gt;TDD: 测试驱动开发, 《敏捷软件开发》&lt;/li&gt;
&lt;li&gt;BDD: 行为驱动开发, 《C# 测试驱动开发》&lt;/li&gt;
&lt;li&gt;FDD: 特性驱动开发, 《彩色 UML 建模》&lt;/li&gt;
&lt;li&gt;MDD: 元数据驱动开发, 《程序员修炼之道》、《Ruby 元编程》&lt;/li&gt;
&lt;li&gt;EDD: 事件驱动开发, 《发布订阅模式》&lt;/li&gt;
&lt;li&gt;MDD: 消息驱动开发, 参考各种 ESB 实现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比较常见的是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BDD …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Mon, 31 Oct 2016 13:57:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-10-31:/chang-jian-de-qu-dong-she-ji.html</guid><category>软件工程</category></item><item><title>vim 入门</title><link>http://www.smallcpp.cn/vim-ru-men.html</link><description>
&lt;h1 id="_1"&gt;配置文件&lt;/h1&gt;
&lt;p&gt;整体 vim 的设置值一般是放置在  &lt;code&gt;/etc/vimrc&lt;/code&gt;  这个文件, 不过, 不建议你修改它, 可以修改 &lt;code&gt;~/.vimrc&lt;/code&gt; 这个文件（默认不存在, 请你自行手动创建! ）, 这是 vim 的用户配置文件.&lt;/p&gt;
&lt;h1 id="vim"&gt;VIM 新特性&lt;/h1&gt;
&lt;h2 id="_2"&gt;区块选择&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;v 字符选择&lt;/li&gt;
&lt;li&gt;V 行选择&lt;/li&gt;
&lt;li&gt;ctrl + v 区块选择&lt;/li&gt;
&lt;li&gt;y 复制选择&lt;/li&gt;
&lt;li&gt;d …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Fri, 28 Oct 2016 16:37:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-10-28:/vim-ru-men.html</guid><category>工具折腾</category></item><item><title>高可用高并发网站架构演化 (nginx + keepalived)</title><link>http://www.smallcpp.cn/gao-ke-yong-gao-bing-fa-wang-zhan-jia-gou-yan-hua-nginx-keepalived.html</link><description>&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;nginx + keepalived 的组合通常被用来实现前端高可用.&lt;/p&gt;
&lt;p&gt;在这个组合中, 利用 &lt;strong&gt;nginx&lt;/strong&gt; 的反向代理实现前端的&lt;em&gt;动静分离&lt;/em&gt;和&lt;em&gt;负载均衡&lt;/em&gt;, 如下图.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/高可用高并发架构/nginx.jpg"&gt;&lt;/p&gt;
&lt;p&gt;在以上的体系中, 我们接着将一些通用的服务从动态 Server 上抽离出来单独封装, 动态 Server 通过 &lt;strong&gt;RPC&lt;/strong&gt; 远程调用通用服务, 这样就避免升级通用服务时会更改对所有动态 Server 的问题.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/高可用高并发架构/rpc.jpg"&gt;&lt;/p&gt;
&lt;p&gt;如上图, 如果 RPC 服务器挂掉了, 那所有的 RPC 请求都会出问题 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Thu, 27 Oct 2016 22:27:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-10-27:/gao-ke-yong-gao-bing-fa-wang-zhan-jia-gou-yan-hua-nginx-keepalived.html</guid><category>软件工程</category></item><item><title>HDFS Shell 命令</title><link>http://www.smallcpp.cn/hdfs-shell-ming-ling.html</link><description>
&lt;p&gt;如何使用 Shell 操作 HDFS 参考 Blog: &lt;a href="http://blog.smallcpp.cn/04-shi-yong-shell-cao-zuo-hdfs.html"&gt;使用 Shell 操作 HDFS&lt;/a&gt;&lt;/p&gt;
&lt;h1 id="_1"&gt;常用命令&lt;/h1&gt;
&lt;p&gt;get == copyToLocal&lt;/p&gt;
&lt;p&gt;put == copyFromHdfs&lt;/p&gt;
&lt;h2 id="cp"&gt;cp&lt;/h2&gt;
&lt;p&gt;源和目标都是 hdfs&lt;/p&gt;
&lt;p&gt;-f 覆盖&lt;/p&gt;
&lt;p&gt;-p 保留文件属性 (cp 文件时, 更新时间会变, 所属组也会变成操作者)&lt;/p&gt;
&lt;h2 id="mv"&gt;mv&lt;/h2&gt;
&lt;p&gt;源和目标都是 hdfs&lt;/p&gt;
&lt;h2 id="count"&gt;count …&lt;/h2&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Wed, 26 Oct 2016 15:03:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-10-26:/hdfs-shell-ming-ling.html</guid><category>大数据</category></item><item><title>Shell 命令</title><link>http://www.smallcpp.cn/shell-ming-ling.html</link><description>
&lt;h1 id="_1"&gt;基础使用&lt;/h1&gt;
&lt;h2 id="_2"&gt;执行方式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;方式一:
    + 需在脚本开头指定解释器: #!/bin/bash
    + 给脚本 +x 权限,
    + 输入脚本绝对路径或相对路径:
        * &lt;code&gt;/root/test.sh&lt;/code&gt;
        * &lt;code&gt;./test.sh&lt;/code&gt;
    + 或者在路径前再加个点
        * &lt;code&gt;. ./test.sh&lt;/code&gt;
    + 区别在于前面的会新开一个 bash (不可见), 也就是在当前 bash 变量不共享, 加个 &lt;code&gt;.&lt;/code&gt; 表示在当前脚本执行脚本&lt;/li&gt;
&lt;li&gt;方式二:
    用指定解释器执行 sh test …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Wed, 26 Oct 2016 11:19:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-10-26:/shell-ming-ling.html</guid><category>软件工程</category></item><item><title>NodeJs 调试技巧</title><link>http://www.smallcpp.cn/nodejs-diao-shi-ji-qiao.html</link><description>
&lt;h1 id="supervisor"&gt;supervisor&lt;/h1&gt;
&lt;p&gt;node.js 的 supervisor 插件可以帮我们监控文件的改动, 自动重启服务器, 这个 supervisor 是 node.js 的一个包 (而不是 python 的那个 supervisor, 别弄混了), 安装起来很简单, 使用 npm 的安装命令就可以, 因为我们需要在控制台运行, 所以需要安装在全局环境中.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;npm install -g supervisor
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就可以使用 supervisor …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Mon, 24 Oct 2016 18:37:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-10-24:/nodejs-diao-shi-ji-qiao.html</guid><category>工具折腾</category></item><item><title>JSHint 速查</title><link>http://www.smallcpp.cn/jshint-su-cha.html</link><description>&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Missing semicolon&lt;/code&gt;:
    + 缺少分号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Use the function form of "use strict"&lt;/code&gt;:
    + 使用标准化定义 function&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Unexpected space after ‘-’&lt;/code&gt;:
    + 在’-&amp;lsquo;后面不应出现空格&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Expected a JSON value&lt;/code&gt;:
    + 请传入一个json的值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Mixed spaces and tabs&lt;/code&gt;:
    + 空格和TAB重复&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Unsafe character&lt;/code&gt;:
    + 不安全的字符 …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Mon, 24 Oct 2016 13:40:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-10-24:/jshint-su-cha.html</guid><category>工具折腾</category></item><item><title>05. 使用 Java Api 操作 HDFS</title><link>http://www.smallcpp.cn/05-shi-yong-java-api-cao-zuo-hdfs.html</link><description>&lt;p&gt;使用 Java Api 操作 HDFS&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Sun, 23 Oct 2016 20:26:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-10-23:/05-shi-yong-java-api-cao-zuo-hdfs.html</guid><category>大数据</category></item><item><title>04. 使用 Shell 操作 HDFS</title><link>http://www.smallcpp.cn/04-shi-yong-shell-cao-zuo-hdfs.html</link><description>&lt;p&gt;使用 Shell 操作 HDFS&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Sun, 23 Oct 2016 20:25:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-10-23:/04-shi-yong-shell-cao-zuo-hdfs.html</guid><category>大数据</category></item><item><title>03. Hadoop 2.x 新特性</title><link>http://www.smallcpp.cn/03-hadoop-2x-xin-te-xing.html</link><description>&lt;p&gt;Hadoop 2.x 新特性&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Sun, 23 Oct 2016 19:21:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-10-23:/03-hadoop-2x-xin-te-xing.html</guid><category>大数据</category></item><item><title>使用 Eclipse 开发 HDFS</title><link>http://www.smallcpp.cn/shi-yong-eclipse-kai-fa-hdfs.html</link><description>&lt;p&gt;先在 windows 7 下搭建好 eclipse 项目环境, 参考 &lt;a href="http://www.smallcpp.cn/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/Eclipse%20%E9%85%8D%E7%BD%AE%20Java%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html"&gt;Eclipse 配置 Java 开发环境&lt;/a&gt;&lt;/p&gt;

&lt;h1 id="_1"&gt;导入依赖包&lt;/h1&gt;
&lt;p&gt;创建一个 Java 工程后, 在工程下新建个 lib 文件夹, 导入 hdfs 的相关 jar 包:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;/usr/smallcpp/hadoop-2.7.1/share/hadoop …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Sat, 22 Oct 2016 22:08:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-10-22:/shi-yong-eclipse-kai-fa-hdfs.html</guid><category>大数据</category></item><item><title>转.分布式文件系统命名空间解析</title><link>http://www.smallcpp.cn/zhuan-fen-bu-shi-wen-jian-xi-tong-ming-ming-kong-jian-jie-xi.html</link><description>&lt;p&gt;近些年, 微软对其分布式文件系统 (Distributed File System, DFS) 做了很多改良, 其中的一项技术对文件系统资源提供了统一视图. DFS 重新定向了来自 UNC 途径的请求, 其中一个网络驱动映射到请求资源所在的网络共享. 这样的结果是你可以添加文件服务器到网络或者不用影响用户访问文件的方式就能强化现有的文件服务器.&lt;/p&gt;
&lt;p&gt;重定向请求到文件实际位置的 UNC 途径就是 DFS 命名空间. 本质上, DFS 命名空间是为用户呈现文件服务器资源集中化视图的统一命名空间. 一个 DFS 命名空间由很多部分组成.&lt;/p&gt;
&lt;h1 id="dfs"&gt;DFS 根&lt;/h1&gt;
&lt;p&gt;DFS 命名空间本质上是分等级的, 最顶端的是DFS根 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Sat, 22 Oct 2016 22:08:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-10-22:/zhuan-fen-bu-shi-wen-jian-xi-tong-ming-ming-kong-jian-jie-xi.html</guid><category>大数据</category></item><item><title>Eclipse 配置 Java 开发环境</title><link>http://www.smallcpp.cn/eclipse-pei-zhi-java-kai-fa-huan-jing.html</link><description>
&lt;h1 id="java"&gt;Java 安装&lt;/h1&gt;
&lt;p&gt;访问 oracle 官网 : &lt;a href="http://www.oracle.com/index.html"&gt;http://www.oracle.com/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i65.tinypic.com/11ryjc5.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i64.tinypic.com/504f34.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i64.tinypic.com/2vcth8j.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;下载下来直接安装即可, 安装的时候, 不要勾选 &lt;strong&gt;公共 JRE&lt;/strong&gt;, 因为 JDK 中已包含一个专用的 JRE.
&lt;strong&gt;注意&lt;/strong&gt;: 路径中不要有中文或特殊符号、空格等.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i65.tinypic.com/14v1xxi.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;安装好 JDK 后, 在指定的安装目录里有很多的文件和文件夹, 其中 &lt;strong&gt;bin&lt;/strong&gt; 目录和 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Sat, 22 Oct 2016 20:09:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-10-22:/eclipse-pei-zhi-java-kai-fa-huan-jing.html</guid><category>工具折腾</category></item><item><title>Hadoop 集群添加新节点</title><link>http://www.smallcpp.cn/hadoop-ji-qun-tian-jia-xin-jie-dian.html</link><description>&lt;p&gt;仅为&lt;strong&gt;实验&lt;/strong&gt;集群或者&lt;strong&gt;小型&lt;/strong&gt;集群的添加节点方法, 一般&lt;strong&gt;大型&lt;/strong&gt;的集群都有专门的运维.&lt;/p&gt;

&lt;h1 id="_1"&gt;安装系统&lt;/h1&gt;
&lt;p&gt;首先安装好系统, 配置好 IP、JDK 及 Hadoop, 参考 &lt;a href="http://www.smallcpp.cn/Hadoop/%E6%90%AD%E5%BB%BA%20Hadoop%20%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83.html"&gt;搭建 Hadoop 分布式实验环境&lt;/a&gt; 前三步.&lt;/p&gt;
&lt;h1 id="_2"&gt;设置域名解析&lt;/h1&gt;
&lt;p&gt;到 &lt;strong&gt;NameNode&lt;/strong&gt; 节点下, &lt;code&gt;cd /usr/smallcpp/hadoop-2.7.3 …&lt;/code&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Sat, 22 Oct 2016 14:05:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-10-22:/hadoop-ji-qun-tian-jia-xin-jie-dian.html</guid><category>大数据</category></item><item><title>Hadoop Logs 文件</title><link>http://www.smallcpp.cn/hadoop-logs-wen-jian.html</link><description>&lt;p&gt;Hadoop 存在多种日志文件, 其中 &lt;strong&gt;Master&lt;/strong&gt; 上的日志文件记录全面信息, 包括 &lt;strong&gt;Slave&lt;/strong&gt; 上的 &lt;strong&gt;JobTracker&lt;/strong&gt; 与 &lt;strong&gt;DataNode&lt;/strong&gt; 也会将错误信息写到 &lt;strong&gt;Master&lt;/strong&gt; 中, 而 &lt;strong&gt;Slave&lt;/strong&gt; 中的日志主要记录完成的 &lt;strong&gt;Task&lt;/strong&gt; 任务信息.&lt;/p&gt;
&lt;p&gt;Hadoop Log 文件保存在 Hadoop 根目录下的 logs 目录里.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;hanxiao@smallcpp01:/usr/smallcpp …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Thu, 20 Oct 2016 21:10:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-10-20:/hadoop-logs-wen-jian.html</guid><category>大数据</category></item><item><title>02. HDFS 简介</title><link>http://www.smallcpp.cn/02-hdfs-jian-jie.html</link><description>&lt;p&gt;HDFS 简介&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Thu, 20 Oct 2016 20:52:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-10-20:/02-hdfs-jian-jie.html</guid><category>大数据</category></item><item><title>Sublime 常用插件与快捷键</title><link>http://www.smallcpp.cn/sublime-chang-yong-cha-jian-yu-kuai-jie-jian.html</link><description>
&lt;h1 id="_1"&gt;常用插件&lt;/h1&gt;
&lt;p&gt;有个老外推荐了他使用的一些包, 我觉得都很好, 这里也推荐一下 &lt;a href="https://johnblackbourn.com/my-st3-packages"&gt;传送门&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;我常用的大部分插件在之前的几篇 Wiki 都介绍配置过了.&lt;/p&gt;
&lt;p&gt;如果出现快捷键失灵, 那么可能是热键冲突引起的, 此时可以 &lt;code&gt;Ctrl + 反引号&lt;/code&gt; 打开日志控制台, 然后再按快捷键看看日志信息, 如果什么信息都没有, 说明快捷键失效了, 换一个快捷键再试试.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.smallcpp.cn/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/Sublime%20%E9%85%8D%E7%BD%AE%20Markdown%20%E5%86%99%E4%BD%9C%E7%8E%AF%E5%A2%83.html"&gt;Sublime 配置 Markdown 写作环境&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.smallcpp.cn/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/Sublime%20%E9%85%8D%E7%BD%AE%20Python%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html"&gt;Sublime 配置 Python 开发环境&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.smallcpp.cn/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/Sublime%20%E9%85%8D%E7%BD%AE%20Nodejs%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html"&gt;Sublime 配置 Nodejs 开发环境 …&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Wed, 19 Oct 2016 13:27:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-10-19:/sublime-chang-yong-cha-jian-yu-kuai-jie-jian.html</guid><category>工具折腾</category></item><item><title>Sublime 配置 Nodejs 开发环境</title><link>http://www.smallcpp.cn/sublime-pei-zhi-nodejs-kai-fa-huan-jing.html</link><description>
&lt;h1 id="_1"&gt;语法提示&lt;/h1&gt;
&lt;p&gt;使用插件: &lt;strong&gt;SublimeText-Nodejs&lt;/strong&gt; 插件（&lt;a href="https://github.com/tanepiper/SublimeText-Nodejs"&gt;Github&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;, 这个插件不要用 Sublime 的 Package Control 来安装, Package Control 安装的会没有配置文件导致设置不了插件 . . .&lt;/p&gt;
&lt;p&gt;直接在 Github 上下载包下来, 解压重命名为 &lt;strong&gt;Nodejs&lt;/strong&gt;, 然后放到 Sublime 的 &lt;strong&gt;Packages&lt;/strong&gt; 目录下 (首选项 -&amp;gt; 浏览插件);&lt;/p&gt;
&lt;p&gt;打开 Nodejs 下面的 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Tue, 18 Oct 2016 22:19:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-10-18:/sublime-pei-zhi-nodejs-kai-fa-huan-jing.html</guid><category>工具折腾</category></item><item><title>01. Hadoop 初识</title><link>http://www.smallcpp.cn/01-hadoop-chu-shi.html</link><description>&lt;p&gt;Hadoop 初识&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Sun, 16 Oct 2016 23:32:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-10-16:/01-hadoop-chu-shi.html</guid><category>大数据</category></item><item><title>搭建 Hadoop 分布式实验环境</title><link>http://www.smallcpp.cn/da-jian-hadoop-fen-bu-shi-shi-yan-huan-jing.html</link><description>&lt;p&gt;&lt;strong&gt;实验最终成品&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;宿主机: win7 64位, 16G&lt;/li&gt;
&lt;li&gt;虚拟化工具: VMware Workstation&lt;/li&gt;
&lt;li&gt;虚拟机系统: Ubuntu 32位, 1.5G, 20G, NAT&lt;/li&gt;
&lt;li&gt;主机名: smallcpp01 (NameNode), smallcpp02 (Datanode), smallcpp03 (Datanode)&lt;/li&gt;
&lt;li&gt;Java 版本: jdk-8u101-linux-i586&lt;/li&gt;
&lt;li&gt;Hadoop 版本: hadoop-2.7.3 …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Sun, 16 Oct 2016 11:42:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-10-16:/da-jian-hadoop-fen-bu-shi-shi-yan-huan-jing.html</guid><category>大数据</category></item><item><title>VMware 安装 Ubuntu</title><link>http://www.smallcpp.cn/vmware-an-zhuang-ubuntu.html</link><description>
&lt;h1 id="_1"&gt;安装系统&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;宿主机: win7 64位, 16G&lt;/li&gt;
&lt;li&gt;虚拟机系统: Ubuntu 32位&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;1. 创建新的虚拟机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i59.tinypic.com/2jff68n.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 使用自定义模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i60.tinypic.com/315ohh1.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 下一步直到选择安装源&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i58.tinypic.com/33vp5af.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 选择操作系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i62.tinypic.com/2lw6dz9.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 设置虚拟机名称及安装路径&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i61.tinypic.com/t6e0c2.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6. 设置处理器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i60.tinypic.com/16gg5co.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7. 设置内存, 对于测试环境的 Linux (32 位) 来说, &lt;code&gt;1G&lt;/code&gt; 足够 (条件允许可以设置大一点 …&lt;/strong&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Sun, 16 Oct 2016 03:04:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-10-16:/vmware-an-zhuang-ubuntu.html</guid><category>工具折腾</category></item><item><title>vector、deque、list 三者的区别</title><link>http://www.smallcpp.cn/vector-deque-list-san-zhe-de-qu-bie.html</link><description>
&lt;p&gt;stl 提供了三个最基本的容器: vector, list, deque.&lt;/p&gt;
&lt;h1 id="vector"&gt;vector&lt;/h1&gt;
&lt;p&gt;vector 为存储的对象分配一块连续的地址空间, 因此对 vector 中的元素随机访问效率很高.&lt;/p&gt;
&lt;p&gt;在 vecotor 中插入或者删除某个元素, 需要将现有元素进行复制, 移动. 如果 vector 中存储的对象很大, 或者构造函数复杂, 则在对现有元素进行拷贝时开销较大, 因为拷贝对象要调用拷贝构造函数. 对于简单的小对象, vector 的效率优于 list.&lt;/p&gt;
&lt;p&gt;vector 在每次扩张容量的时候, 将容量扩展 2 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Mon, 10 Oct 2016 14:37:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-10-10:/vector-deque-list-san-zhe-de-qu-bie.html</guid><category>软件工程</category></item><item><title>程序员的碎片知识管理</title><link>http://www.smallcpp.cn/cheng-xu-yuan-de-sui-pian-zhi-shi-guan-li.html</link><description>&lt;p&gt;面对信息量爆炸的时代, 做为一名程序员, 如何才能在诸多知识碎片中逆水行舟?&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Wed, 24 Aug 2016 19:22:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-08-24:/cheng-xu-yuan-de-sui-pian-zhi-shi-guan-li.html</guid><category>杂项</category></item><item><title>玩转奇妙清单</title><link>http://www.smallcpp.cn/wan-zhuan-qi-miao-qing-dan.html</link><description>&lt;p&gt;转自&lt;a href="http://sspai.com/tag/%E5%A5%87%E5%A6%99%E6%B8%85%E5%8D%95"&gt;少数派&lt;/a&gt;&lt;/p&gt;

&lt;h1 id="_1"&gt;添加待办事项&lt;/h1&gt;
&lt;p&gt;除了进入奇妙清单应用添加添加待办事项外, 这里列举了一些其他方法.&lt;/p&gt;
&lt;h2 id="_2"&gt;邮件添加&lt;/h2&gt;
&lt;p&gt;只需要用登录奇妙清单的邮箱账号作为&lt;strong&gt;发信人&lt;/strong&gt;, 向 &lt;code&gt;me@wunderlist.com&lt;/code&gt; 发送邮件, 就可以生成一条待办事项, 具体规则:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;邮件的标题会成为待办事项的名称&lt;/li&gt;
&lt;li&gt;邮件的正文内容会成为待办事项的备注&lt;/li&gt;
&lt;li&gt;所有生成的待办事项都被存放在&lt;code&gt;收件箱&lt;/code&gt;中&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_3"&gt;收件箱&lt;/h2&gt;
&lt;p&gt;奇妙清单上有一项默认的清单&lt;code&gt;收件箱&lt;/code&gt;, 这是一个随时储存灵感、临时想到的待办的地方, 一定要随时 check.&lt;/p&gt;
&lt;p&gt;通过邮件添加的待办事项也会放在&lt;code&gt;收件箱&lt;/code&gt;中 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Fri, 19 Aug 2016 13:56:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-08-19:/wan-zhuan-qi-miao-qing-dan.html</guid><category>工具折腾</category></item><item><title>GenShi Templates</title><link>http://www.smallcpp.cn/genshi-templates.html</link><description>
&lt;h1 id="genshi-xml-template-language"&gt;Genshi XML Template Language&lt;/h1&gt;
&lt;p&gt;Genshi provides a XML-based template language that is heavily inspired by Kid, which in turn was inspired by a number of existing template languages, namely XSLT …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Fri, 19 Aug 2016 12:56:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-08-19:/genshi-templates.html</guid><category>软件工程</category></item><item><title>使用 Chrome 调试 XPath</title><link>http://www.smallcpp.cn/shi-yong-chrome-diao-shi-xpath.html</link><description>
&lt;blockquote&gt;
&lt;p&gt;需要注意, 有时获取出来并测试成功的 XPath 用 xlml 来实现的话有可能获取不到, 那时就要手动分析了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id="xpath"&gt;获取 XPath&lt;/h1&gt;
&lt;p&gt;&lt;img alt="" src="http://i67.tinypic.com/fbffnn.jpg"/&gt;&lt;/p&gt;
&lt;h1 id="xpath_1"&gt;测试 XPath&lt;/h1&gt;
&lt;p&gt;在 console 中用 &lt;code&gt;$x(' . . . ')&lt;/code&gt; 来测试 XPath&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i66.tinypic.com/29wswaa.jpg"/&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Tue, 16 Aug 2016 16:00:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-08-16:/shi-yong-chrome-diao-shi-xpath.html</guid><category>工具折腾</category></item><item><title>JVisualVM JConsole</title><link>http://www.smallcpp.cn/jvisualvm-jconsole.html</link><description>&lt;h1 id="jvisualvm"&gt;JVisualVM&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;JConsole: Java 性能分析器, 用于连接正在运行的 JVM, 不过此 JVM 需要使用可管理的模式启动 (在启动时设置 &lt;code&gt;com.sun.management.jmxremote&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;JVisualVM: 升级版的 JConsole, 可以监控线程, 内存情况, 查看方法的 CPU 时间和内存中的对象, 已被 GC 的对象, 反向查看分配的堆栈&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Visual GC&lt;/strong&gt; 插件: 监控垃圾回收器 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Thu, 11 Aug 2016 10:19:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-08-11:/jvisualvm-jconsole.html</guid><category>工具折腾</category></item><item><title>JDBC 为什么用 Class.forName 加载驱动</title><link>http://www.smallcpp.cn/jdbc-wei-shi-yao-yong-classforname-jia-zai-qu-dong.html</link><description>
&lt;p&gt;JDBC 中注册驱动为什么使用 &lt;code&gt;Class.forName("com.mysql.jdbc.Driver")&lt;/code&gt; 而不使用 &lt;code&gt;new com.mysql.jdbc.Driver()&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;其原因有二.&lt;/p&gt;
&lt;h3 id="_1"&gt;原因一&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;new&lt;/code&gt; 一个类需要 &lt;code&gt;import&lt;/code&gt; 它的包, 而各大数据库提供的驱动不一样, 使用 &lt;code&gt;new&lt;/code&gt; 的方式就十分依赖 &lt;code&gt;import&lt;/code&gt; 驱动的 jar 包, 这样一旦换了数据库驱动, 还要修改 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Tue, 02 Aug 2016 16:55:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-08-02:/jdbc-wei-shi-yao-yong-classforname-jia-zai-qu-dong.html</guid><category>软件工程</category></item><item><title>事务隔离级别</title><link>http://www.smallcpp.cn/shi-wu-ge-chi-ji-bie.html</link><description>
&lt;h1 id="_1"&gt;事务并发引起的问题&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;脏读&lt;/strong&gt; (Drity Read): 某个事务已更新一份数据, 另一个事务在此时读取了同一份数据, 由于某些原因, 前一个 RollBack 了操作, 则后一个事务所读取的数据就会是不正确的.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不可重复读&lt;/strong&gt; (Non-repeatable read): 在一个事务的两次查询之中数据不一致, 这可能是两次查询过程中间被另一个事务&lt;strong&gt;更新&lt;/strong&gt;了原有的数据.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;幻读&lt;/strong&gt; (Phantom Read): 和不可重复读很像, 在一个事务的两次查询中数据笔数不一致, 这可能是两次查询过程中间被一个事务&lt;strong&gt;插入&lt;/strong&gt;了新的数据.&lt;/p&gt;
&lt;h1 id="_2"&gt;隔离级别&lt;/h1&gt;
&lt;p&gt;为了解决上面事务并发引起的问题, 数据库的事务系统一般提供了隔离级别的设定:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读未提交 …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Mon, 01 Aug 2016 17:22:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-08-01:/shi-wu-ge-chi-ji-bie.html</guid><category>数据库</category></item><item><title>mysql transaction 与 autocommit</title><link>http://www.smallcpp.cn/mysql-transaction-yu-autocommit.html</link><description>&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;在默认的情况下, MySQL 从自动提交 (autocommit) 模式运行, 这种模式会在每条语句执行完毕后把它作出的修改立刻提交给数据库并使之永久化. 事实上, 这相当于把每一条语句都&lt;strong&gt;隐含&lt;/strong&gt;地当做一个&lt;strong&gt;事务&lt;/strong&gt;来执行.&lt;/p&gt;
&lt;p&gt;如果你想明确地执行事务, 需要&lt;strong&gt;禁用&lt;/strong&gt;自动提交模式并告诉 MySQL 你想让它在何时提交或回滚有关的修改.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;禁用&lt;/strong&gt;自动提交模式有两种方式:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一种&lt;/strong&gt;是直接设置 &lt;code&gt;autocommit&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt;, 此时, 在提交或回滚前的所有 sql 语句都会当成同一个事务来处理;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另一种 …&lt;/strong&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Mon, 01 Aug 2016 15:42:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-08-01:/mysql-transaction-yu-autocommit.html</guid><category>数据库</category></item><item><title>三层架构与 MVC</title><link>http://www.smallcpp.cn/san-ceng-jia-gou-yu-mvc.html</link><description>
&lt;p&gt;近来对架构这块又有了新认识, MVC 也好, 三层也罢, 都是结构性模式, 由于结构化, 而可能忽视了行为事件, 这类的架构大多是一种 “失血”、”贫血” 模式 (这段话不理解先看完下面的分析, 再看下最后的&lt;a href="http://www.smallcpp.cn/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E4%B8%8E%20MVC.html#_3"&gt;小结&lt;/a&gt;, 然后回过头来理解这段话).&lt;/p&gt;
&lt;p&gt;现在, 我更推荐&lt;a href="http://www.smallcpp.cn/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/DDD%20%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%85%AD%E8%BE%B9%E5%BD%A2%E6%9E%B6%E6%9E%84.html"&gt;领域驱动设计配合六边形架构&lt;/a&gt; (领域驱动设计继承了职责驱动设计, 或者可以说是职责驱动设计的进化).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;推荐本书: &lt;a href="https://share.weiyun.com/ffebfff0ea72831e6d0a96905f359d06"&gt;UML 和模式应用&lt;/a&gt;, 这本书介绍了对象职责的分配原则&lt;/p&gt;
&lt;p&gt;参考资料:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.jdon.com/38045"&gt;对象的责任与职责&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.jdon.com/37976"&gt;DCI 架构是什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.jdon.com/38071"&gt;如何从职责和协作中发现丰富对象？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.jdon.com/38448"&gt;MVC …&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Fri, 29 Jul 2016 11:24:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-07-29:/san-ceng-jia-gou-yu-mvc.html</guid><category>软件工程</category></item><item><title>WRUP 实践</title><link>http://www.smallcpp.cn/wrup-shi-jian.html</link><description>
&lt;h1 id="rup"&gt;RUP 软件工程管理概述&lt;/h1&gt;
&lt;h2 id="_1"&gt;软件工程模型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;瀑布式开发&lt;/li&gt;
&lt;li&gt;迭代式开发&lt;/li&gt;
&lt;li&gt;敏捷开发模型&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_2"&gt;瀑布式开发&lt;/h3&gt;
&lt;p&gt;传统的瀑布式开发, 也就是从需求到设计, 从设计到编码, 从编码到测试, 从测试到提交, 大概这样的流程;&lt;/p&gt;
&lt;p&gt;它要求每一个开发阶段都要做到最好, 特别是前期阶段, 设计的越完美, 提交后的成本损失就越少. 以前很多从事的外包项目就是这样的流程.&lt;/p&gt;
&lt;p&gt;但是这里面有个问题, 就是开发途中发现之前的需求不合格、需要重新设计等问题, 都要留到下一个版本的开发中了.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i63.tinypic.com/29f9e87.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;所以, 瀑布式开发的过程中是比较机械化的, 按流程走下来, 要求每一个流程都要按规范走完.&lt;/p&gt;
&lt;p&gt;当然它也有好处的, 从开发者的角度上说, 当你进入开发阶段时, 项目的文档是非常详细的 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Fri, 29 Jul 2016 11:18:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-07-29:/wrup-shi-jian.html</guid><category>软件工程</category></item><item><title>使用 StarUML 绘制 UML</title><link>http://www.smallcpp.cn/shi-yong-staruml-hui-zhi-uml.html</link><description>
&lt;h1 id="uml-staruml"&gt;UML 架构及 StarUML&lt;/h1&gt;
&lt;h2 id="uml"&gt;UML 架构&lt;/h2&gt;
&lt;p&gt;UML 图形分类:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象图
    + 类图
    + 组件图
    + 部署图&lt;/li&gt;
&lt;li&gt;交互图
    + 用例图
    + 时序图
    + 协作图
    + 活动图&lt;/li&gt;
&lt;li&gt;状态图
    + 状态图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="http://www.ibm.com/developerworks/cn/rational/r-uml/"&gt;参考文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里重点学习 &lt;strong&gt;用例图、时序图 和 类图&lt;/strong&gt; 三张图.&lt;/p&gt;
&lt;h2 id="staruml"&gt;StarUML&lt;/h2&gt;
&lt;p&gt;StarUML 5.0 貌似是最后一个免费版本 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Fri, 29 Jul 2016 11:07:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-07-29:/shi-yong-staruml-hui-zhi-uml.html</guid><category>软件工程</category></item><item><title>事务与锁</title><link>http://www.smallcpp.cn/shi-wu-yu-suo.html</link><description>&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;事务与锁是不同的, &lt;strong&gt;事务&lt;/strong&gt;具有 &lt;code&gt;ACID&lt;/code&gt; (原子性、一致性、&lt;strong&gt;隔离性&lt;/strong&gt;和持久性), 而&lt;strong&gt;锁&lt;/strong&gt;是用于解决其中&lt;strong&gt;隔离性&lt;/strong&gt;的一种机制.&lt;/p&gt;
&lt;p&gt;事务的隔离级别通过锁的机制来实现.&lt;/p&gt;
&lt;p&gt;隔离级别, 一般有四种:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读未提交 Read uncommitted&lt;/li&gt;
&lt;li&gt;读已提交 Read committed&lt;/li&gt;
&lt;li&gt;可重复读 Repeatable read&lt;/li&gt;
&lt;li&gt;可串行化 Serializable&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;关于隔离级别的说明参考另一篇 wiki: &lt;a href="http://www.smallcpp.cn/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.html"&gt;事务的隔离级别 …&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Thu, 28 Jul 2016 17:48:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-07-28:/shi-wu-yu-suo.html</guid><category>数据库</category></item><item><title>悲观锁与乐观锁</title><link>http://www.smallcpp.cn/bei-guan-suo-yu-le-guan-suo.html</link><description>&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;悲观锁&lt;/strong&gt; (Pessimistic Lock), 顾名思义, 就是很悲观, 每次去拿数据的时候都认为别人会修改, 所以每次在拿数据的时候都会上锁, 这样别人想拿这个数据就会 block 直到它拿到锁.&lt;/p&gt;
&lt;p&gt;传统的关系型数据库里边就用到了很多这种锁机制, 比如行锁, 表锁等, 都是在做操作之前先上锁.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;乐观锁&lt;/strong&gt; (Optimistic Lock), 顾名思义, 就是很乐观, 每次去拿数据的时候都认为别人不会修改, 所以不会上锁, 但是在更新的时候会判断一下在此期间别人有没有去更新这个数据, 可以使用版本号等机制.&lt;/p&gt;
&lt;p&gt;乐观锁适用于多读的应用类型, 这样可以提高吞吐量, 像数据库如果提供类似于 write_condition 机制的其实都是提供的乐观锁.&lt;/p&gt;
&lt;p&gt;两种锁各有优缺点, 不可认为一种好于另一种 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Thu, 28 Jul 2016 17:46:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-07-28:/bei-guan-suo-yu-le-guan-suo.html</guid><category>数据库</category></item><item><title>读锁与写锁</title><link>http://www.smallcpp.cn/du-suo-yu-xie-suo.html</link><description>
&lt;h1 id="_1"&gt;读锁&lt;/h1&gt;
&lt;p&gt;读锁的意义在于,  当前线程告诉别人: “我要读东西啦, 你们先不要改数据, 免得我读到错的数据.”&lt;/p&gt;
&lt;p&gt;由于可见, 对数据加读锁后, 其他线程还能读 (因为大家都是读的话, 就不会产生正在读的过程中数据被修改的问题), 但是不允许对加锁的数据进行写入…&lt;/p&gt;
&lt;h1 id="_2"&gt;写锁&lt;/h1&gt;
&lt;p&gt;写锁呢, 就是告诉别人: “我要修改数据了, 修改后才是正常的数据, 你们要等我修改完再读.”&lt;/p&gt;
&lt;p&gt;所以, 加数据加写锁后, 其他线程即不能读也不能写…&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Thu, 28 Jul 2016 17:37:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-07-28:/du-suo-yu-xie-suo.html</guid><category>软件工程</category></item><item><title>字符编码</title><link>http://www.smallcpp.cn/zi-fu-bian-ma.html</link><description>
&lt;h1 id="_1"&gt;编码/解码&lt;/h1&gt;
&lt;p&gt;任何数据在内存中都是以二进制的形式保存, 也就是说一个文本文件, 不管你看到的是中文还是英文或者是法文, 它在内存也都是一串二进制数据 (或者说是一串字节数组), 那么当用一个文本浏览器打开一个文本文件时, 该文本浏览器就会拿它读出来的字节数组去 “查字典”, 然后将查到的结果展现出来.&lt;/p&gt;
&lt;p&gt;这个 “查字典” 的动作就被称之为&lt;strong&gt;解码&lt;/strong&gt;, 当然我们不叫它 “查字典”, 而叫它查码表, 常见的码表有 ASCII、ISO-8859-1、GB2312、GBK、UTF-8、UTF-16 等.&lt;/p&gt;
&lt;p&gt;(解码, 解码, 可以理解成&lt;strong&gt;破解密码 …&lt;/strong&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Thu, 28 Jul 2016 17:19:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-07-28:/zi-fu-bian-ma.html</guid><category>软件工程</category></item><item><title>打磨 gem</title><link>http://www.smallcpp.cn/da-mo-gem.html</link><description>
&lt;h1 id="_1"&gt;打磨&lt;/h1&gt;
&lt;p&gt;由于 GFW 的原因, 直接使用 gem 会报错: &lt;code&gt;Errno::ECONNRESET: Connection reset by peer - SSL_connect (https://api.rubygems.org&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;更改 gem 的源为国内的映像就好了:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;gem sources --remove https://rubygems.org/

gem sources -a …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Sat, 28 May 2016 22:56:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-05-28:/da-mo-gem.html</guid><category>工具折腾</category></item><item><title>Ubuntu 升级 Ruby 版本</title><link>http://www.smallcpp.cn/ubuntu-sheng-ji-ruby-ban-ben.html</link><description>
&lt;h1 id="rvm-ruby"&gt;使用 rvm 管理 ruby 版本&lt;/h1&gt;
&lt;p&gt;这是推荐的方式, 但是由于 GFW 的原因, rvm 不一定安装成功, 如果不成功则参考下面的从源码安装.&lt;/p&gt;
&lt;p&gt;Reference: &lt;a href="http://blog.csdn.net/abbuggy/article/details/8170899"&gt;在ubuntu中安装及使用rvm管理ruby版本&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="_1"&gt;准备工作&lt;/h2&gt;
&lt;p&gt;后面需要使用 &lt;strong&gt;curl&lt;/strong&gt;, 用 &lt;strong&gt;dpkg -s curl&lt;/strong&gt; 命令检查一下系统中有没有安装&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;abbuggy@abbuggy-ubuntu:~$ dpkg -s curl
Package: curl
Status …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Sat, 28 May 2016 21:47:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-05-28:/ubuntu-sheng-ji-ruby-ban-ben.html</guid><category>工具折腾</category></item><item><title>折腾 Travis CI</title><link>http://www.smallcpp.cn/zhe-teng-travis-ci.html</link><description>
&lt;h1 id="_1"&gt;介绍&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://travis-ci.org/"&gt;Travis CI&lt;/a&gt; 是在软件开发领域中的一个&lt;strong&gt;在线的&lt;/strong&gt;、&lt;strong&gt;分布式&lt;/strong&gt;的持续集成服务, 用来构建及测试在 &lt;strong&gt;Github&lt;/strong&gt; 托管的代码, 简单的说, 就是它可以监控你 Github 仓库的某个分支, 当你提交修改到这个分支的时候, 它就会把你提交的分支 clone 到它的服务上进行构建, 你可以通过配置来决定构建完成后是否推送回 Github ~&lt;/p&gt;
&lt;p&gt;这里记录一些我在将 Simiki 项目和 Travis CI 结合过程中折腾过的坑, 以抛砖引玉…&lt;/p&gt;
&lt;h1 id="github"&gt;关联 Github 仓库 …&lt;/h1&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Sat, 28 May 2016 21:04:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-05-28:/zhe-teng-travis-ci.html</guid><category>工具折腾</category></item><item><title>折腾 Simiki</title><link>http://www.smallcpp.cn/zhe-teng-simiki.html</link><description>
&lt;h1 id="diy"&gt;DIY 主题&lt;/h1&gt;
&lt;p&gt;Simiki 自带的主题稍微有点 low, 可以使用官网推荐的另一款主题: &lt;a href="https://github.com/tankywoo/yasimple/tree/ce4af036ab95ef1d5235266d8231f97dc14dd871"&gt;yasimple&lt;/a&gt;, Clone 到本地后替换掉 &lt;code&gt;~/themes/simple&lt;/code&gt; 下的文件;&lt;/p&gt;
&lt;p&gt;这些主题都没有网站图标, 所以要再 DIY 一下, 先准备好网站图标, 如 &lt;code&gt;favicon.ico&lt;/code&gt;, 放到 &lt;code&gt;~/themes/simple/static/images&lt;/code&gt; 目录下 (没有 &lt;code&gt;images&lt;/code&gt; 目录就新建一个), 然后打开 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Sat, 28 May 2016 19:18:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-05-28:/zhe-teng-simiki.html</guid><category>工具折腾</category></item><item><title>使用 Simiki 进行碎片整理</title><link>http://www.smallcpp.cn/shi-yong-simiki-jin-xing-sui-pian-zheng-li.html</link><description>
&lt;h1 id="_1"&gt;开始&lt;/h1&gt;
&lt;p&gt;从 Hansong Xiao 的&lt;a href="http://blog.xiaohansong.com/2016/01/16/kownledge-Management/"&gt;程序员的知识管理&lt;/a&gt;中学到用 wiki 来进行知识碎片整理, 确实, 一些零散的知识, 如某个常用命令的语法、特定的软件配置等等, 记到博客上太零碎, 本地记录的也不够系统, 放到个人 Wiki 是最不过了, 使用的就是 Hansong Xiao 推荐的 &lt;a href="http://simiki.org/"&gt;Simiki&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Simiki 提供了&lt;a href="http://simiki.org/zh-docs/"&gt;中文文档&lt;/a&gt;, 十分简单, 参考&lt;a href="http://simiki.org/zh-docs/"&gt;中文文档&lt;/a&gt;分分钟就上手了 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Fri, 27 May 2016 19:46:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-05-27:/shi-yong-simiki-jin-xing-sui-pian-zheng-li.html</guid><category>杂项</category></item><item><title>迁移 Github Project Page</title><link>http://www.smallcpp.cn/qian-yi-github-project-page.html</link><description>&lt;p&gt;将我的博客从 User Pages site 迁移到 Project Pages site.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Wed, 25 May 2016 18:45:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-05-25:/qian-yi-github-project-page.html</guid><category>杂项</category></item><item><title>在 OpenShift 上部署 Django Todolist 应用</title><link>http://www.smallcpp.cn/zai-openshift-shang-bu-shu-django-todolist-ying-yong.html</link><description>
&lt;h1 id="openshift-django"&gt;一、初始化 Openshift Django 应用&lt;/h1&gt;
&lt;p&gt;首先去 Openshift 上创建一个 Django 应用, 关于怎么创建 Openshift 应用参考我&lt;a href="http://www.smallcpp.cn/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/%E5%8D%90%20%E8%A7%A3%E5%90%A7!%20%E5%8F%B9%E6%81%AF%E5%A2%99!%20%E2%80%94%20%E4%BC%98%E9%9B%85%E7%9A%84%E7%BF%BB%E5%A2%99.html"&gt;另一篇笔记&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我这里创建了一个 &lt;code&gt;todolist-smallcpp.rhcloud.com&lt;/code&gt;, 然后, 利用&lt;a href="http://www.smallcpp.cn/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/%E5%8D%90%20%E8%A7%A3%E5%90%A7!%20%E5%8F%B9%E6%81%AF%E5%A2%99!%20%E2%80%94%20%E4%BC%98%E9%9B%85%E7%9A%84%E7%BF%BB%E5%A2%99.html"&gt;另一篇笔记&lt;/a&gt;的知识用 SecureCRT 连上我们的服务器.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;补充一下用 putty.exe 连接的方法.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先, 和 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Wed, 11 May 2016 10:23:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-05-11:/zai-openshift-shang-bu-shu-django-todolist-ying-yong.html</guid><category>工具折腾</category></item><item><title>让 Putty 自动登陆 [转]</title><link>http://www.smallcpp.cn/rang-putty-zi-dong-deng-lu-zhuan.html</link><description>
&lt;h3 id="_1"&gt;序言&lt;/h3&gt;
&lt;p&gt;Putty 基本是用来登陆 Linux/Unix 终端的不二之先, 因其小, 开源, 界面也非常实用. 可是当你要在私有的机器上, 经常性的要登陆很多机器的时候就觉得烦琐了, 不光打开一堆的窗口, 还要一遍一遍的输入用户名和密码. 当然登陆用户名是可以保存的, 我也是最近才注意到这一点的. Putty 不愿去保存密码是出于安全考虑, 相信在多数时候确实是非常必要的.&lt;/p&gt;
&lt;p&gt;于是我选择了 SecureCRT, 它能保存密码, 而且是多 Tab 的, 把 Session 改成 VT100 Linux 模式 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Thu, 05 May 2016 14:04:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-05-05:/rang-putty-zi-dong-deng-lu-zhuan.html</guid><category>工具折腾</category></item><item><title>Sublime 配置 Python 开发环境</title><link>http://www.smallcpp.cn/sublime-pei-zhi-python-kai-fa-huan-jing.html</link><description>
&lt;h1 id="1"&gt;1. 中文文件名方框&lt;/h1&gt;
&lt;p&gt;这个是 sublime text 3 的 bug, 当 Windows 个性化显示中的设置自定义文本大小 (DPI) 大于默认的 100% 的时候, 就会出现这个bug.&lt;/p&gt;
&lt;p&gt;解决方法:&lt;/p&gt;
&lt;p&gt;在 sublime text 3 中, Preference, Settings - User, 最后加上一行 &lt;code&gt;"dpi_scale": 1.0&lt;/code&gt; 覆盖操作系统设置的 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Sun, 24 Apr 2016 15:08:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-04-24:/sublime-pei-zhi-python-kai-fa-huan-jing.html</guid><category>工具折腾</category></item><item><title>win7 与 VMware ubuntu 虚拟机实现文件共享</title><link>http://www.smallcpp.cn/win7-yu-vmware-ubuntu-xu-ni-ji-shi-xian-wen-jian-gong-xiang.html</link><description>
&lt;p&gt;貌似安装 VM Tools 后也无法直接拖拽, 只能让 win7 与 VMware ubuntu 虚拟机实现文件共享了~~&lt;/p&gt;
&lt;h2 id="_1"&gt;第一步&lt;/h2&gt;
&lt;p&gt;当然是安装 VM Tools 啦.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 VMware 虚拟机界面, 点 VM -&amp;gt; Install VMware Tools, 之后, 点击 Ubuntu 窗口中主文件按钮, 然后再左边会看见设备里有 VMware tools …&lt;/li&gt;&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Sat, 23 Apr 2016 14:55:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-04-23:/win7-yu-vmware-ubuntu-xu-ni-ji-shi-xian-wen-jian-gong-xiang.html</guid><category>工具折腾</category></item><item><title>RedMine 简明手册</title><link>http://www.smallcpp.cn/redmine-jian-ming-shou-ce.html</link><description>&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;Redmine 是一个开源的项目管理平台, 用于项目的需求管理和缺陷跟踪, Redmine 可以和多种版本库 (如 Git) 整合, 可以直接通过 Web 界面浏览 Git 提交, 还实现了提交和问题的关联.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Thu, 21 Apr 2016 22:41:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-04-21:/redmine-jian-ming-shou-ce.html</guid><category>工具折腾</category></item><item><title>卐 解吧! 叹息墙! — 优雅的翻墙</title><link>http://www.smallcpp.cn/wan-jie-ba-tan-xi-qiang-you-ya-de-fan-qiang.html</link><description>
&lt;h2 id="_1"&gt;一. 介绍&lt;/h2&gt;
&lt;h3 id="openshift"&gt;Openshift&lt;/h3&gt;
&lt;p&gt;OpenShift 是&lt;strong&gt;红帽&lt;/strong&gt;的云开发平台即服务(&lt;strong&gt;PaaS&lt;/strong&gt;).&lt;/p&gt;
&lt;p&gt;在 OpenShift 上, 开发人员能够创建、测试和运行他们的应用程序, 并且可以把它们部署到云中.&lt;/p&gt;
&lt;p&gt;Openshift 广泛支持多种编程语言和框架, 如 Java、Ruby 和 PHP 等, 另外它还提供了多种集成开发工具, 如 Eclipse integration、JBoss Developer Studio 和 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Sat, 09 Apr 2016 17:49:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-04-09:/wan-jie-ba-tan-xi-qiang-you-ya-de-fan-qiang.html</guid><category>工具折腾</category></item><item><title>Git 简明手册</title><link>http://www.smallcpp.cn/git-jian-ming-shou-ce.html</link><description>
&lt;h2 id="1-git"&gt;1. git 配置&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;git config --list&lt;/li&gt;
&lt;li&gt;git config --global user.name “your name”&lt;/li&gt;
&lt;li&gt;git config --global user.email “email@example.com”&lt;/li&gt;
&lt;li&gt;git config --global push.followTags true  // 这会在 push 时推送有注释的 …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Sun, 13 Mar 2016 13:00:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-03-13:/git-jian-ming-shou-ce.html</guid><category>工具折腾</category></item><item><title>Sublime 配置 Markdown 写作环境</title><link>http://www.smallcpp.cn/sublime-pei-zhi-markdown-xie-zuo-huan-jing.html</link><description>
&lt;h2 id="_1"&gt;语法高亮&lt;/h2&gt;
&lt;p&gt;Sublime Text 内置 Markdown 文档的语法高亮, 只是默认的太挫了…&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Monokai Extended&lt;/strong&gt; 和 &lt;strong&gt;Markdown Extended&lt;/strong&gt; 是一套解决方案.&lt;/p&gt;
&lt;p&gt;安装完两个插件后, 首先在 [首选项] -&amp;gt; [主题方案] 里设置 &lt;em&gt;Monokai Extended&lt;/em&gt;, 然后, 打开一个 *.md 文件, 在 Sublime 右下角显示文件语法那里点击选择 [打开具有当前扩展名的] -&amp;gt; [Markdown Extended …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Sat, 05 Mar 2016 13:00:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-03-05:/sublime-pei-zhi-markdown-xie-zuo-huan-jing.html</guid><category>工具折腾</category></item><item><title>从 wp 迁移到 pelican (github)</title><link>http://www.smallcpp.cn/cong-wp-qian-yi-dao-pelican-github.html</link><description>&lt;p&gt;考虑了很久, 终于下定决心把博客从 wordpress 迁移到 github 上了, 这里作个记录, 方便以后查询.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Sun, 03 Jan 2016 23:00:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2016-01-03:/cong-wp-qian-yi-dao-pelican-github.html</guid><category>杂项</category></item><item><title>正则表达式</title><link>http://www.smallcpp.cn/zheng-ze-biao-da-shi.html</link><description>
&lt;h1 id="_1"&gt;正则基础&lt;/h1&gt;
&lt;h2 id="_2"&gt;常用符号&lt;/h2&gt;
&lt;p&gt;比较常用的是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;?&lt;/code&gt;, 代表前面的字符能出现 0 次或 1 次, 比如 &lt;code&gt;colou?r&lt;/code&gt; 表示在目标串中找到 &lt;code&gt;color&lt;/code&gt; 或 &lt;code&gt;colour&lt;/code&gt; 并返回, 即 &lt;code&gt;u&lt;/code&gt; 可以出现 0 次或 1 次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt;, 代表前面的字符能出现 0 次或无限次, 比如 &lt;code&gt;colou*r&lt;/code&gt; 表示在目标串中找到 …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Fri, 21 Aug 2015 17:19:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2015-08-21:/zheng-ze-biao-da-shi.html</guid><category>工具折腾</category></item><item><title>短期充电计划</title><link>http://www.smallcpp.cn/duan-qi-chong-dian-ji-hua.html</link><description>&lt;p&gt;&lt;img alt="" src="http://i61.tinypic.com/x6lde9.jpg"&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Fri, 13 Mar 2015 13:25:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2015-03-13:/duan-qi-chong-dian-ji-hua.html</guid><category>杂项</category></item><item><title>VS 注释模板</title><link>http://www.smallcpp.cn/vs-zhu-shi-mo-ban.html</link><description>
&lt;h1 id="_1"&gt;函数注释&lt;/h1&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;/************************************************************************&lt;/span&gt;
&lt;span style="color: #228B22"&gt;◇  名称:      $SymbolName$&lt;/span&gt;
&lt;span style="color: #228B22"&gt;◇  参数:      $MethodArg$&lt;/span&gt;
&lt;span style="color: #228B22"&gt;◇  返回值:    $SymbolType$&lt;/span&gt;
&lt;span style="color: #228B22"&gt;◇  功能:      $end$&lt;/span&gt;
&lt;span style="color: #228B22"&gt;◇  说明:      $selected$&lt;/span&gt;
&lt;span style="color: #228B22"&gt;************************************************************************/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;简单版:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;// 参数: $MethodArg$&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// 说明: $end$&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置方法:&lt;/p&gt;
&lt;p&gt;“VAssistX” –&amp;gt; “Visual VAssistX Options” 然后选择 “Suggestions”, 再点击 “Edit VA Snippets”,&lt;/p&gt;
&lt;p&gt;在打开的窗口中选择  “Refactoring”  –&amp;gt; “Document …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Thu, 12 Mar 2015 14:20:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2015-03-12:/vs-zhu-shi-mo-ban.html</guid><category>软件工程</category></item><item><title>C++ 中的基类为什么要抽象析构函数</title><link>http://www.smallcpp.cn/c-zhong-de-ji-lei-wei-shi-yao-yao-chou-xiang-xi-gou-han-shu.html</link><description>&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;在 Google 编程规范 中提到过: 用来做基类的类, 其析构函数应该为虚函数.&lt;/p&gt;
&lt;p&gt;那么为什么呢? 看下面这个例子:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #1e889b"&gt;#include&lt;/span&gt; &lt;span style="color: #228B22"&gt;&amp;quot;stdafx.h&amp;quot;&lt;/span&gt;&lt;span style="color: #1e889b"&gt;&lt;/span&gt;
&lt;span style="color: #1e889b"&gt;#include&lt;/span&gt; &lt;span style="color: #228B22"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style="color: #1e889b"&gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;using&lt;/span&gt; &lt;span style="color: #8B008B; font-weight: bold"&gt;namespace&lt;/span&gt; std;

&lt;span style="color: #8B008B; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;ClxBase&lt;/span&gt; {
&lt;span style="color: #8B008B; font-weight: bold"&gt;public&lt;/span&gt;:
    ClxBase() {};
    &lt;span style="color: #8B008B; font-weight: bold"&gt;virtual&lt;/span&gt; ~ClxBase() {};

    &lt;span style="color: #8B008B; font-weight: bold"&gt;virtual&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;void&lt;/span&gt; DoSomething() {
        cout &lt;span style="color: #CD5555"&gt;&amp;quot;Do something in class …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Thu, 12 Mar 2015 11:40:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2015-03-12:/c-zhong-de-ji-lei-wei-shi-yao-yao-chou-xiang-xi-gou-han-shu.html</guid><category>软件工程</category></item><item><title>XMind (思维导图制作软件) 零基础教程</title><link>http://www.smallcpp.cn/xmind-si-wei-dao-tu-zhi-zuo-ruan-jian-ling-ji-chu-jiao-cheng.html</link><description>&lt;p&gt;工欲善其事, 必先利其器. 这里推荐一款很不错的思维导图编辑软件 – XMind, &lt;a href="http://www.dayanzai.me/xmind.html"&gt;下载传送门&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id="xmind"&gt;&lt;strong&gt;XMind界面简介&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;img alt="" src="http://i60.tinypic.com/e8anhz.jpg"&gt;&lt;/p&gt;
&lt;p&gt;XMind有五种不同类型的主题，如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i60.tinypic.com/2ms0m89.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中心主题：&lt;/strong&gt;每一张思维图有且仅有一个中心主题. 这个主题在新建图的时候会被自动创建并安排在图的中心的位置. 当保存这个新建图的时候, 中心主题的内容会默认设置为保存文件的名字.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分支主题：&lt;/strong&gt;中心主题周围发散的第一层主题即分支主题.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子主题：&lt;/strong&gt;分支主题和自由主题后面添加的主题都被称为子主题.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自由主题：&lt;/strong&gt;通常总还会有些关键的, 但是临时缺少合适位置的信息, 这些信息将以自由主题的形式存在. Xmind 中有种不同的自由主题, 用户可以按需选用.&lt;/p&gt;
&lt;h1 id="_1"&gt;&lt;strong&gt;添加主题&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;分支主题:&lt;/strong&gt; 点选 [中心主题] , 右键-插入-主题.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i58.tinypic.com/2agoh1x.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子主题 …&lt;/strong&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Tue, 10 Mar 2015 02:38:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2015-03-10:/xmind-si-wei-dao-tu-zhi-zuo-ruan-jian-ling-ji-chu-jiao-cheng.html</guid><category>杂项</category></item><item><title>瀑布式开发 VS 迭代式开发 [转]</title><link>http://www.smallcpp.cn/pu-bu-shi-kai-fa-vs-die-dai-shi-kai-fa-zhuan.html</link><description>&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;两者都是一种开发模式, 就像设计模式一样, 考虑的角度不一样, 个人感觉谈不到取代一说.&lt;/p&gt;
&lt;p&gt;传统的瀑布式开发, 也就是从需求到设计, 从设计到编码, 从编码到测试, 从测试到提交大概这样的流程, 要求每一个开发阶段都要做到最好. 特别是前期阶段, 设计的越完美, 提交后的成本损失就越少. 我现在从事的外包项目就是这样的流程.&lt;/p&gt;
&lt;p&gt;迭代式开发, 不要求每一个阶段的任务做的都是最完美的, 而是明明知道还有很多不足的地方, 却偏偏不去完善它, 而是把主要功能先搭建起来为目的, 以最短的时间, 最少的损失先完成一个&amp;rdquo;不完美的成果物&amp;rdquo;直至提交. 然后再通过客户或用户的反馈信息, 在这个&amp;rdquo;不完美的成果物&amp;rdquo;上逐步进行完善.&lt;/p&gt;
&lt;p&gt;这两种开发模式都各自具有自己的特点, 迭代式开发适合在一些需求信息不明确的项目中, 这样在开发过程中遇到需求的变化时 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Mon, 02 Mar 2015 05:48:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2015-03-02:/pu-bu-shi-kai-fa-vs-die-dai-shi-kai-fa-zhuan.html</guid><category>软件工程</category></item><item><title>UML 类图</title><link>http://www.smallcpp.cn/uml-lei-tu.html</link><description>&lt;p&gt;&lt;img alt="UML类图样例" src="http://img.blog.csdn.net/20150211193154259"&gt;&lt;/p&gt;
&lt;h4 id="_1"&gt;类图和接口图&lt;/h4&gt;
&lt;p&gt;首先&lt;strong&gt;动物&lt;/strong&gt;矩形框, 它就代表一个&lt;strong&gt;类图&lt;/strong&gt;, 分三层:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一层显示类的名称, 如果是&lt;strong&gt;抽象类&lt;/strong&gt;, 则用斜体表示&lt;/li&gt;
&lt;li&gt;第二层是类的属性&lt;/li&gt;
&lt;li&gt;第三层是类的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意前面的符号:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;‘+’ –&amp;gt; public&lt;/li&gt;
&lt;li&gt;‘-’ –&amp;gt; private&lt;/li&gt;
&lt;li&gt;‘#’ –&amp;gt; protected&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;左下角的”飞翔”矩形框, 它是一个&lt;strong&gt;接口图&lt;/strong&gt;, 它与类图的区别是顶端有&lt;strong&gt;interface&lt;/strong&gt;显示, 然后它只有二层, 第二层是接口方法.&lt;/p&gt;
&lt;p&gt;另外接口还有另一种表示法, 叫棒棒糖表示法, 看正下方的 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HanXiao</dc:creator><pubDate>Sun, 15 Feb 2015 14:17:00 +0800</pubDate><guid isPermaLink="false">tag:www.smallcpp.cn,2015-02-15:/uml-lei-tu.html</guid><category>软件工程</category></item></channel></rss>