<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Small Cpp - HanXiao</title><link href="http://www.smallcpp.cn/" rel="alternate"></link><link href="http://www.smallcpp.cn/feeds/hanxiao.atom.xml" rel="self"></link><id>http://www.smallcpp.cn/</id><updated>2020-03-10T13:00:00+08:00</updated><subtitle>勿在浮沙筑高台, 练从难处练, 用从易处用.</subtitle><entry><title>七. Implementation: Working with Errors</title><link href="http://www.smallcpp.cn/qi-implementation-working-with-errors.html" rel="alternate"></link><published>2020-03-10T13:00:00+08:00</published><updated>2020-03-10T13:00:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2020-03-10:/qi-implementation-working-with-errors.html</id><summary type="html">
&lt;p&gt;如果产品代码格式错误，客户名称过长或地址验证服务超时，该怎么办？任何系统都会有错误，我们如何处理它们很重要。一致且透明的错误处理对于任何类型的生产系统都是至关重要的。&lt;/p&gt;
&lt;p&gt;在上一章中，我们故意从 &lt;em&gt;pipeline&lt;/em&gt; 的步骤中删除了错误副作用(&lt;em&gt;Result&lt;/em&gt; 类型)，以便我们可以专注于组合和依赖等问题。
但是副作用很重要! 在本章中，我们将 &lt;em&gt;Result&lt;/em&gt; 恢复为类型签名，并学习如何和它们一起工作。&lt;/p&gt;
&lt;p&gt;更通俗地说，我们将探索错误处理的函数式方法，使用一种技术，可以优雅地捕获错误，而不会因丑陋的条件判断或 &lt;em&gt;try/catch&lt;/em&gt; 语句而污染代码。我们还将看到为什么我们应该将某些类型的错误视为领域错误，并应与其它领域驱动设计一样重视。&lt;/p&gt;
&lt;h1 id="using-the-result-type-to-make-errors-explicit"&gt;Using …&lt;/h1&gt;</summary><content type="html">
&lt;p&gt;如果产品代码格式错误，客户名称过长或地址验证服务超时，该怎么办？任何系统都会有错误，我们如何处理它们很重要。一致且透明的错误处理对于任何类型的生产系统都是至关重要的。&lt;/p&gt;
&lt;p&gt;在上一章中，我们故意从 &lt;em&gt;pipeline&lt;/em&gt; 的步骤中删除了错误副作用(&lt;em&gt;Result&lt;/em&gt; 类型)，以便我们可以专注于组合和依赖等问题。
但是副作用很重要! 在本章中，我们将 &lt;em&gt;Result&lt;/em&gt; 恢复为类型签名，并学习如何和它们一起工作。&lt;/p&gt;
&lt;p&gt;更通俗地说，我们将探索错误处理的函数式方法，使用一种技术，可以优雅地捕获错误，而不会因丑陋的条件判断或 &lt;em&gt;try/catch&lt;/em&gt; 语句而污染代码。我们还将看到为什么我们应该将某些类型的错误视为领域错误，并应与其它领域驱动设计一样重视。&lt;/p&gt;
&lt;h1 id="using-the-result-type-to-make-errors-explicit"&gt;Using the Result Type to Make Errors Explicit&lt;/h1&gt;
&lt;p&gt;函数式编程技术着重于使事情尽可能明确，这也适用于错误处理。我们想要创建明确是否成功的的函数，如果失败，则要说明错误情况是什么。&lt;/p&gt;
&lt;p&gt;在我们平时的代码中，错误经常被视为二等公民。但是，为了拥有一个健壮的，有价值的系统，我们应该将他们视为头等公民。而对于属于领域的错误，则更要加倍重视。&lt;/p&gt;
&lt;p&gt;在上一章中，我们使用异常来引发错误。这很方便，但是这意味着所有的函数签名都是误导性的。例如，检查地址的函数具有以下签名：&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CheckAddressExists&lt;/span&gt; =
    UnvalidatedAddress -&amp;gt; CheckedAddress
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种签名对我们没有帮助, 因为它对我们隐藏了可能会出现的问题。取而代之的是，我们想要的是一个全函数(total function)，其中所有可能的结果都由函数签名显式记录。正如之前的章节所说，我们可以使用 &lt;em&gt;Result&lt;/em&gt; 类型来明确函数可以成功还是失败，然后签名看起来像这样：&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CheckAddressExists&lt;/span&gt; =
    UnvalidatedAddress -&amp;gt; Result&amp;lt;CheckedAddress,AddressValidationError&amp;gt;
&lt;span style="color: #8B008B"&gt;and&lt;/span&gt; AddressValidationError =
    | InvalidFormat &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;string&lt;/span&gt;
    | AddressNotFound &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;string&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个签名告诉我们:&lt;/p&gt;
&lt;p&gt;This tells us:
• The input is an UnvalidatedAddress.
• If the validation was successful, the output is a (possibly different)
CheckedAddress.
• If the validation was not successful, the reason is because the format was
invalid or because the address was not found.&lt;/p&gt;</content><category term="函数式"></category><category term="函数式领域建模"></category><category term="函数式"></category><category term="领域驱动"></category><category term="DDD"></category></entry><entry><title>六. Implementation: Composing a Pipeline</title><link href="http://www.smallcpp.cn/liu-implementation-composing-a-pipeline.html" rel="alternate"></link><published>2020-02-06T13:00:00+08:00</published><updated>2020-02-06T13:00:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2020-02-06:/liu-implementation-composing-a-pipeline.html</id><summary type="html">
&lt;h1 id="understanding-functions"&gt;Understanding Functions&lt;/h1&gt;
&lt;p&gt;在很多现代语言中, 函数也是一等对象, 但只是使用函数并不意味着在进行函数式编程.&lt;/p&gt;
&lt;p&gt;函数式编程范例的关键在于, 函数无处不在, 应有尽有, 程序中的任何问题都有函数式的解决方案.&lt;/p&gt;
&lt;p&gt;例如, 假设我们有一个大型程序, 它是由较小的块组成的.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在面向对象的方法中, 这些部分将是类和对象.&lt;/li&gt;
&lt;li&gt;在功能式的方法中, 这些部分将是函数.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再比如我们需要参数化程序的某些方面, 或者想减少组件之间的耦合.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在面向对象的方法中, 我们将使用接口和依赖注入.&lt;/li&gt;
&lt;li&gt;在函数式的方法中, 我们将使用函数进行参数化.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;又比如我们要遵循 “不要重复自己” 的原则, 并在许多组件之间重用代码.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在面向对象的方法中, 我们可能会使用继承或类似装饰者模式的技术.&lt;/li&gt;
&lt;li&gt;在函数式的方法中, 我们将所有可重复使用的代码放入函数中 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">
&lt;h1 id="understanding-functions"&gt;Understanding Functions&lt;/h1&gt;
&lt;p&gt;在很多现代语言中, 函数也是一等对象, 但只是使用函数并不意味着在进行函数式编程.&lt;/p&gt;
&lt;p&gt;函数式编程范例的关键在于, 函数无处不在, 应有尽有, 程序中的任何问题都有函数式的解决方案.&lt;/p&gt;
&lt;p&gt;例如, 假设我们有一个大型程序, 它是由较小的块组成的.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在面向对象的方法中, 这些部分将是类和对象.&lt;/li&gt;
&lt;li&gt;在功能式的方法中, 这些部分将是函数.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再比如我们需要参数化程序的某些方面, 或者想减少组件之间的耦合.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在面向对象的方法中, 我们将使用接口和依赖注入.&lt;/li&gt;
&lt;li&gt;在函数式的方法中, 我们将使用函数进行参数化.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;又比如我们要遵循 “不要重复自己” 的原则, 并在许多组件之间重用代码.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在面向对象的方法中, 我们可能会使用继承或类似装饰者模式的技术.&lt;/li&gt;
&lt;li&gt;在函数式的方法中, 我们将所有可重复使用的代码放入函数中, 并使用组合将它们组合在一起.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实际上, 函数式编程是一种完全不同的&lt;strong&gt;编程思维方式&lt;/strong&gt;. 比如我们日常编程中经常会思考的「如何遍历集合」以及「如何实现策略模式」这两个问题, 现在换个角度, 我们原本真的是想要解决这些问题吗?&lt;/p&gt;
&lt;p&gt;不是! 这些问题仅仅是「如何对集合的每个元素执行操作」以及「如何对行为进行参数化」的编程解决方案. 换句话说, 我们实际上要解决的是「如何对集合的每个元素执行操作」以及「如何对行为进行参数化」这些 “潜在” 的问题.&lt;/p&gt;
&lt;p&gt;作为程序员, 我们面临的这些真正要解决的 “潜在” 问题是相同的, 但函数式编程中使用的解决方案与面向对象编程中使用的解决方案却有很大不同, 这是我们要学习并掌握的地方.&lt;/p&gt;
&lt;h2 id="building-an-entire-application-from-functions"&gt;Building an Entire Application from Functions&lt;/h2&gt;
&lt;p&gt;在函数式编程中, 我们使用 &lt;em&gt;composition&lt;/em&gt; 的方式来构建程序.&lt;/p&gt;
&lt;p&gt;我们先从程序的最底层几个函数开始:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/lowlevel.png"/&gt;&lt;/p&gt;
&lt;p&gt;然后将它们组合成一些服务函数:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/service.png"/&gt;&lt;/p&gt;
&lt;p&gt;接下来, 我们可以使用这些服务函数并将它们粘合在一起, 以创建一个处理完整工作流的函数:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/workflowf.png"/&gt;&lt;/p&gt;
&lt;p&gt;最后, 我们可以通过并行组合这些工作流来构建应用程序, 并创建一个 &lt;em&gt;controller/dispatcher&lt;/em&gt;, 该 &lt;em&gt;controller/dispatcher&lt;/em&gt; 根据输入来选择要调用的特定工作流.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/workflowc.png"/&gt;&lt;/p&gt;
&lt;h1 id="implementation-composing-a-pipeline"&gt;Implementation: Composing a Pipeline&lt;/h1&gt;
&lt;p&gt;在上一章中, 我们已经花费了很多时间仅使用类型领域进行建模, 现在是时候使用函数式来实现它了.&lt;/p&gt;
&lt;p&gt;回顾上一章中的设计, 可以将工作流视为一系列文档转换(管道):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从 &lt;em&gt;UnvalidatedOrder&lt;/em&gt; 开始, 并将其转换为 &lt;em&gt;ValidatedOrder&lt;/em&gt;, 如果验证失败, 则返回错误.&lt;/li&gt;
&lt;li&gt;获取验证步骤的输出(&lt;em&gt;ValidatedOrder&lt;/em&gt;), 并通过添加一些额外信息将其转换为 &lt;em&gt;PricedOrder&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;获取定价步骤的输出(&lt;em&gt;PriceOrder&lt;/em&gt;), 从中创建确认信并发送.&lt;/li&gt;
&lt;li&gt;创建一组表示发生了什么的事件并将其返回.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;首先, 我们将管道中的每个步骤作为独立函数实现, 确保它是无状态的, 并且没有副作用, 因此可以独立地测试和推理.&lt;/p&gt;
&lt;p&gt;接下来, 我们将这些较小的函数组合成一个较大的函数. 这听起来很简单, 但正如我们&lt;a href="http://www.smallcpp.cn/liu-modeling-workflows-as-pipelines.html#composing-the-workflow-from-the-steps"&gt;前面&lt;/a&gt;提到的, 当我们真正尝试它时, 我们会遇到一个问题. 设计的函数不能很好地组合在一起 – 一个的输出与下一个的输入不匹配. 为了克服这一点, 我们需要学习如何操作每个步骤的输入和输出, 以便可以组合它们.&lt;/p&gt;
&lt;p&gt;最终的那一部分代码看起来可能会是这样:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;placeOrder&lt;/span&gt; unvalidatedOrder =
    unvalidatedOrder
    |&amp;gt; validateOrder
    |&amp;gt; priceOrder
    |&amp;gt; acknowledgeOrder
    |&amp;gt; createEvents
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;阻碍我们组合函数的原因有两个:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一些函数有额外的参数, 这些参数不是数据管道的一部分, 而是实现所需的参数, 我们称这些为依赖.&lt;/li&gt;
&lt;li&gt;显式指示副作用, 例如通过使用函数签名中的 &lt;em&gt;Result&lt;/em&gt; 等包装类型进行错误处理. 这意味着在其输出中具有副作用的函数不能直接连接到仅将纯数据作为输入的函数.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本节我们来解决第一个问题.&lt;/p&gt;
&lt;h2 id="working-with-simple-types"&gt;Working With Simple Types&lt;/h2&gt;
&lt;p&gt;在实现函数之前, 首先需要实现 “简单类型”, 如 &lt;em&gt;OrderId&lt;/em&gt;、&lt;em&gt;ProductCode&lt;/em&gt; 等.&lt;/p&gt;
&lt;p&gt;由于待创建大多数类型都以某种方式受到限制, 所以我们将用&lt;strong&gt;智能构造器&lt;/strong&gt;的方式来实现.&lt;/p&gt;
&lt;p&gt;对于每个简单类型, 我们至少需要两个函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构造函数, 该函数从基元(如字符串或 &lt;em&gt;int&lt;/em&gt;)构造类型. 例如, &lt;em&gt;OrderId.create&lt;/em&gt; 将从字符串创建 &lt;em&gt;OrderId&lt;/em&gt;, 如果字符串的格式错误, 则引发错误.&lt;/li&gt;
&lt;li&gt;提取内部基元值的值函数.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们通常将这些帮助函数放在与简单类型相同的文件中, 并使用与它们类型名称相同的模块名. 例如, 下面是领域模块中 &lt;em&gt;OrderId&lt;/em&gt; 的定义及其帮助函数:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;module&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;Domain&lt;/span&gt; =
    &lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;OrderId&lt;/span&gt; = &lt;span style="color: #8B008B; font-weight: bold"&gt;private&lt;/span&gt; OrderId &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;string&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;module&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;OrderId&lt;/span&gt; =
    &lt;span style="color: #228B22"&gt;// Define a "Smart constructor" for OrderId&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// string -&amp;gt; OrderId&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;create&lt;/span&gt; str =
        &lt;span style="color: #8B008B; font-weight: bold"&gt;if&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;String&lt;/span&gt;.IsNullOrEmpty(str) &lt;span style="color: #8B008B; font-weight: bold"&gt;then&lt;/span&gt;
        &lt;span style="color: #228B22"&gt;// use exceptions rather than Result for now&lt;/span&gt;
            failwith &lt;span style="color: #CD5555"&gt;"OrderId must not be null or empty"&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;elif&lt;/span&gt; str.Length &amp;gt; &lt;span style="color: #B452CD"&gt;50&lt;/span&gt; &lt;span style="color: #8B008B; font-weight: bold"&gt;then&lt;/span&gt;
            failwith &lt;span style="color: #CD5555"&gt;"OrderId must not be more than 50 chars"&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;else&lt;/span&gt;
            OrderId str

    &lt;span style="color: #228B22"&gt;// Extract the inner value from an OrderId&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// OrderId -&amp;gt; string&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;value&lt;/span&gt; (OrderId str) = &lt;span style="color: #228B22"&gt;// unwrap in the parameter!&lt;/span&gt;
        str &lt;span style="color: #228B22"&gt;// return the inner value&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;Create&lt;/em&gt; 函数中, 由于我们现在正在避免副作用的问题, 因此暂时对错误使用异常, 而不是返回 &lt;em&gt;Result&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id="using-function-types-to-guide-the-implementation"&gt;Using Function Types to Guide the Implementation&lt;/h2&gt;
&lt;p&gt;在&lt;a href="http://www.smallcpp.cn/wu-modeling-workflows-as-pipelines.html#modeling-each-step-in-the-workflow-with-types"&gt;上一章节&lt;/a&gt;中, 我们定义了一些函数类型来表示工作流的每个步骤.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;ValidateOrder&lt;/span&gt; =
    CheckProductCodeExists &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
    -&amp;gt; CheckAddressExists &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
    -&amp;gt; UnvalidatedOrder &lt;span style="color: #228B22"&gt;// input&lt;/span&gt;
    -&amp;gt; Result&amp;lt;ValidatedOrder,ValidationError&amp;gt; &lt;span style="color: #228B22"&gt;// output&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;PriceOrder&lt;/span&gt; =
    GetProductPrice &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
    -&amp;gt; ValidatedOrder &lt;span style="color: #228B22"&gt;// input&lt;/span&gt;
    -&amp;gt; PricedOrder &lt;span style="color: #228B22"&gt;// output&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;AcknowledgeOrder&lt;/span&gt; =
    CreateOrderAcknowledgmentLetter &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
    -&amp;gt; SendOrderAcknowledgment &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
    -&amp;gt; PricedOrder &lt;span style="color: #228B22"&gt;// input&lt;/span&gt;
    -&amp;gt; OrderAcknowledgmentSent option &lt;span style="color: #228B22"&gt;// output&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CreateEvents&lt;/span&gt; =
    PricedOrder -&amp;gt; PlaceOrderEvent &lt;span style="color: #00688B; font-weight: bold"&gt;list&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在是时候实现它们了. 为了清楚地说明我们正在实现某个特定的函数类型, 我们将函数记为一​​个值, 用函数类型作为其类型, 并将函数主体写为 &lt;em&gt;lambda&lt;/em&gt;. 看起来像这样:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;validateOrder&lt;/span&gt; : ValidateOrder =
    &lt;span style="color: #8B008B; font-weight: bold"&gt;fun&lt;/span&gt; checkProductCodeExists  &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
        checkAddressExists  &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
        unvalidatedOrder -&amp;gt;  &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
            &lt;span style="color: #228B22"&gt;//...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="implementing-steps"&gt;Implementing Steps&lt;/h2&gt;
&lt;h3 id="validation-step"&gt;Validation Step&lt;/h3&gt;
&lt;p&gt;我们在上章节中将此步骤的函数类型建模为:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CheckProductCodeExists&lt;/span&gt; =
    ProductCode -&amp;gt; &lt;span style="color: #00688B; font-weight: bold"&gt;bool&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CheckAddressExists&lt;/span&gt; =
    UnvalidatedAddress -&amp;gt; AsyncResult&amp;lt;CheckedAddress,AddressValidationError&amp;gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;ValidateOrder&lt;/span&gt; =
    CheckProductCodeExists  &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
    -&amp;gt; CheckAddressExists  &lt;span style="color: #228B22"&gt;// AsyncResult dependency&lt;/span&gt;
    -&amp;gt; UnvalidatedOrder  &lt;span style="color: #228B22"&gt;// input&lt;/span&gt;
    -&amp;gt; AsyncResult&amp;lt;ValidatedOrder,ValidationError &lt;span style="color: #00688B; font-weight: bold"&gt;list&lt;/span&gt;&amp;gt; &lt;span style="color: #228B22"&gt;// output&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;正如刚才所说, 本章节只关注额外的参数, 因此我们可以删除 &lt;em&gt;AsyncResult&lt;/em&gt; 部分, 留给我们这样模型:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CheckProductCodeExists&lt;/span&gt; =
    ProductCode -&amp;gt; &lt;span style="color: #00688B; font-weight: bold"&gt;bool&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CheckAddressExists&lt;/span&gt; =
    UnvalidatedAddress -&amp;gt; CheckedAddress

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;ValidateOrder&lt;/span&gt; =
    CheckProductCodeExists  &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
    -&amp;gt; CheckAddressExists  &lt;span style="color: #228B22"&gt;// AsyncResult dependency&lt;/span&gt;
    -&amp;gt; UnvalidatedOrder  &lt;span style="color: #228B22"&gt;// input&lt;/span&gt;
    -&amp;gt; CheckedAddress &lt;span style="color: #228B22"&gt;// output&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在开始实现. 从 &lt;em&gt;UnvalidatedOrder&lt;/em&gt; 创建出 &lt;em&gt;ValidatedOrder&lt;/em&gt; 的步骤如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从未验证订单中相应的 &lt;em&gt;OrderId&lt;/em&gt; 字符串创建 &lt;em&gt;OrderId&lt;/em&gt; 领域类型.&lt;/li&gt;
&lt;li&gt;从未验证订单中相应的 &lt;em&gt;UnvalidatedCustomerInfo&lt;/em&gt; 字段中创建 &lt;em&gt;CustomerInfo&lt;/em&gt; 领域类型.&lt;/li&gt;
&lt;li&gt;从未验证顺序中相应的 &lt;em&gt;ShippingAddress&lt;/em&gt; 字段中创建 &lt;em&gt;UnvalidatedAddress&lt;/em&gt; 领域类型.&lt;/li&gt;
&lt;li&gt;对 &lt;em&gt;BillingAddress&lt;/em&gt; 和所有其它属性进行同样的操作.&lt;/li&gt;
&lt;li&gt;一旦我们 &lt;em&gt;ValidatedOrder&lt;/em&gt; 的所有组件可用, 就可以使用通常的方式创建 &lt;em&gt;ValidatedOrder&lt;/em&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;validateOrder&lt;/span&gt; : ValidateOrder =
    &lt;span style="color: #8B008B; font-weight: bold"&gt;fun&lt;/span&gt; checkProductCodeExists checkAddressExists unvalidatedOrder -&amp;gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;orderId&lt;/span&gt; =
            unvalidatedOrder.OrderId
            |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;OrderId&lt;/span&gt;.create
        &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;customerInfo&lt;/span&gt; =
            unvalidatedOrder.CustomerInfo
            |&amp;gt; toCustomerInfo &lt;span style="color: #228B22"&gt;// helper function&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;shippingAddress&lt;/span&gt; =
            unvalidatedOrder.ShippingAddress
            |&amp;gt; toAddress &lt;span style="color: #228B22"&gt;// helper function&lt;/span&gt;
        &lt;span style="color: #228B22"&gt;// and so on, for each property of the unvalidatedOrder&lt;/span&gt;

        &lt;span style="color: #228B22"&gt;// when all the fields are ready, use them to&lt;/span&gt;
        &lt;span style="color: #228B22"&gt;// create and return a new "ValidatedOrder" record&lt;/span&gt;
        {
            OrderId = orderId
            CustomerInfo = customerInfo
            ShippingAddress = shippingAddress
            BillingAddress = &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
            Lines = &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到, 我们使用了一些尚未定义帮助函数, 例如 &lt;em&gt;toCustomerInfo&lt;/em&gt; 和 &lt;em&gt;toAddress&lt;/em&gt;. 这些函数负责从未验证的类型构造出领域类型. 例如, &lt;em&gt;toAddress&lt;/em&gt; 将 &lt;em&gt;UnvalidatedAddress&lt;/em&gt; 转换为相应的 &lt;em&gt;Address&lt;/em&gt; 领域类型, 如果 &lt;em&gt;UnvalidatedAddress&lt;/em&gt; 中的某些元素不符合约束(例如非空且长度小于 50 个字符), 则会引发错误. 一旦具备所有这些帮助函数, 将未验证订单(或任何非领域类型)转换为领域类型的逻辑就很简单了.&lt;/p&gt;
&lt;h4 id="create-customer-info"&gt;Create Customer Info&lt;/h4&gt;
&lt;p&gt;下面是 &lt;em&gt;toCustomerInfo&lt;/em&gt; 的代码示例:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;toCustomerInfo&lt;/span&gt; (customer:UnvalidatedCustomerInfo) : CustomerInfo =
    &lt;span style="color: #228B22"&gt;// create the various CustomerInfo properties&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// and throw exceptions if invalid&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;firstName&lt;/span&gt; = customer.FirstName |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;String50&lt;/span&gt;.create
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;lastName&lt;/span&gt; = customer.LastName |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;String50&lt;/span&gt;.create
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;emailAddress&lt;/span&gt; = customer.EmailAddress |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;EmailAddress&lt;/span&gt;.create

    &lt;span style="color: #228B22"&gt;// create a PersonalName&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;name&lt;/span&gt; : PersonalName = {
        FirstName = firstName
        LastName = lastName
    }
    &lt;span style="color: #228B22"&gt;// create a CustomerInfo&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;customerInfo&lt;/span&gt; : CustomerInfo = {
        Name = name
        EmailAddress = emailAddress
    }

    &lt;span style="color: #228B22"&gt;// ... and return it&lt;/span&gt;
    customerInfo
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="creating-a-valid-checked-address"&gt;Creating a Valid, Checked, Address&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;toAddress&lt;/em&gt; 函数稍微复杂一些, 因为它不仅需要将原始数据转换为领域对象, 而且还必须检查地址是否存在(使用 &lt;em&gt;CheckAddressExists&lt;/em&gt; 服务). 下面是完整的实现:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;toAddress&lt;/span&gt; (checkAddressExists:CheckAddressExists) unvalidatedAddress =
    &lt;span style="color: #228B22"&gt;// call the remote service&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;checkedAddress&lt;/span&gt; = checkAddressExists unvalidatedAddress
    &lt;span style="color: #228B22"&gt;// extract the inner value using pattern matching&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; (CheckedAddress checkedAddress) = checkedAddress

    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;addressLine1&lt;/span&gt; =
        checkedAddress.AddressLine1 |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;String50&lt;/span&gt;.create
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;addressLine2&lt;/span&gt; =
        checkedAddress.AddressLine2 |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;String50&lt;/span&gt;.createOption
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;addressLine3&lt;/span&gt; =
        checkedAddress.AddressLine3 |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;String50&lt;/span&gt;.createOption
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;addressLine4&lt;/span&gt; =
        checkedAddress.AddressLine4 |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;String50&lt;/span&gt;.createOption
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;city&lt;/span&gt; =
        checkedAddress.City |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;String50&lt;/span&gt;.create
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;zipCode&lt;/span&gt; =
        checkedAddress.ZipCode |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;ZipCode&lt;/span&gt;.create
    &lt;span style="color: #228B22"&gt;// create the address&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;address&lt;/span&gt; : Address = {
        AddressLine1 = addressLine1
        AddressLine2 = addressLine2
        AddressLine3 = addressLine3
        AddressLine4 = addressLine4
        City = city
        ZipCode = zipCode
    }
    &lt;span style="color: #228B22"&gt;// return the address&lt;/span&gt;
    address
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;请注意, 我们引用了 &lt;em&gt;String50&lt;/em&gt; 模块中的另一个构造函数 &lt;em&gt;createOption&lt;/em&gt;, 它允许输入为 &lt;em&gt;null&lt;/em&gt; 或为空, 并为此情况返回 &lt;em&gt;None&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;toAddress&lt;/em&gt; 函数需要调用 &lt;em&gt;checkAddressExists&lt;/em&gt;, 因此我们将其添加为参数, 必须从父函数 &lt;em&gt;validateOrder&lt;/em&gt; 传递该函数给 &lt;em&gt;toAddress&lt;/em&gt;:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;validateOrder&lt;/span&gt; : ValidateOrder =
    &lt;span style="color: #8B008B; font-weight: bold"&gt;fun&lt;/span&gt; checkProductCodeExists checkAddressExists unvalidatedOrder -&amp;gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;orderId&lt;/span&gt; =  &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;customerInfo&lt;/span&gt; =  &lt;span style="color: #228B22"&gt;//...&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;shippingAddress&lt;/span&gt; =
            unvalidatedOrder.ShippingAddress
            |&amp;gt; toAddress checkAddressExists  &lt;span style="color: #228B22"&gt;// new parameter, partial application&lt;/span&gt;
        &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="creating-the-order-lines"&gt;Creating the Order Lines&lt;/h4&gt;
&lt;p&gt;创建订单行列表会更加复杂. 首先, 我们需要一种将单个未验证订单行转换为已验证订单行的方法 &lt;em&gt;toValidatedOrderLine&lt;/em&gt;:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;toValidatedOrderLine&lt;/span&gt; checkProductCodeExists (unvalidatedOrderLine:UnvalidatedOrderLine) =
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;orderLineId&lt;/span&gt; =
        unvalidatedOrderLine.OrderLineId
        |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;OrderLineId&lt;/span&gt;.create
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;productCode&lt;/span&gt; =
        unvalidatedOrderLine.ProductCode
        |&amp;gt; toProductCode checkProductCodeExists &lt;span style="color: #228B22"&gt;// helper function&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;quantity&lt;/span&gt; =
        unvalidatedOrderLine.Quantity
        |&amp;gt; toOrderQuantity productCode &lt;span style="color: #228B22"&gt;// helper function&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;validatedOrderLine&lt;/span&gt; = {
        OrderLineId = orderLineId
        ProductCode = productCode
        Quantity = quantity
        }
    validatedOrderLine
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这与上面的 &lt;em&gt;toAddress&lt;/em&gt; 函数类似. 有两个帮助函数, &lt;em&gt;toProductCode&lt;/em&gt; 和 &lt;em&gt;toOrderQuantity&lt;/em&gt;, 我们稍后将讨论.&lt;/p&gt;
&lt;p&gt;我们可以使用 &lt;em&gt;List.map&lt;/em&gt; 来一次性转换整个列表中的所有元素, 从而提供一个可以在 &lt;em&gt;ValidatedOrder&lt;/em&gt; 中使用的 &lt;em&gt;ValidatedOrderLines&lt;/em&gt;:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;validateOrder&lt;/span&gt; : ValidateOrder =
    &lt;span style="color: #8B008B; font-weight: bold"&gt;fun&lt;/span&gt; checkProductCodeExists checkAddressExists unvalidatedOrder -&amp;gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;orderId&lt;/span&gt; =  &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;customerInfo&lt;/span&gt; =  &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;shippingAddress&lt;/span&gt; =  &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;orderLines&lt;/span&gt; =
            unvalidatedOrder.Lines
            &lt;span style="color: #228B22"&gt;// convert each line using `toValidatedOrderLine`&lt;/span&gt;
            |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;List&lt;/span&gt;.map (toValidatedOrderLine checkProductCodeExists)
        &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来, 我们来看一下 &lt;em&gt;toOrderQuantity&lt;/em&gt; 帮助函数. 这是一个很好的示例: 输入是从 &lt;em&gt;UnvalidatedOrderLine&lt;/em&gt; 中获得的原始未验证小数, 但输出(&lt;em&gt;OrderQuantity&lt;/em&gt;)是一个 OR 类型, 每个 case 有不同的验证过程. 代码如下所示:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;toOrderQuantity&lt;/span&gt; productCode quantity =
    &lt;span style="color: #8B008B; font-weight: bold"&gt;match&lt;/span&gt; productCode &lt;span style="color: #8B008B; font-weight: bold"&gt;with&lt;/span&gt;
    | Widget _ -&amp;gt;
        quantity
        |&amp;gt; int &lt;span style="color: #228B22"&gt;// convert decimal to int&lt;/span&gt;
        |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;UnitQuantity&lt;/span&gt;.create &lt;span style="color: #228B22"&gt;// to UnitQuantity&lt;/span&gt;
        |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;OrderQuantity&lt;/span&gt;.Unit &lt;span style="color: #228B22"&gt;// lift to OrderQuantity type&lt;/span&gt;
    | Gizmo _ -&amp;gt;
        quantity
        |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;KilogramQuantity&lt;/span&gt;.create &lt;span style="color: #228B22"&gt;// to KilogramQuantity&lt;/span&gt;
        |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;OrderQuantity&lt;/span&gt;.Kilogram &lt;span style="color: #228B22"&gt;// lift to OrderQuantity type&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们使用 OR 类型 &lt;em&gt;ProductCode&lt;/em&gt; 来指导构造函数. 例如, 如果 &lt;em&gt;ProductCode&lt;/em&gt; 是一个小部件, 则我们将原始小数转换为 &lt;em&gt;int&lt;/em&gt;, 然后创建出 &lt;em&gt;UnitQuantity&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;但我们不能止步于此. 因为如果一个分支返回 &lt;em&gt;UnitQuantity&lt;/em&gt;, 另一个返回 &lt;em&gt;KilogramQuantity&lt;/em&gt;, 编译器就会报错, 因为它们是不同的类型. 但通过将两个分支都转换为 OR 类型 &lt;em&gt;OrderQuantity&lt;/em&gt;, 就可以确保两个分支返回相同的类型.&lt;/p&gt;
&lt;p&gt;另一个帮助函数 &lt;em&gt;toProductCode&lt;/em&gt; 的实现应该是很一目了然的. 我们希望尽可能使用&lt;strong&gt;管道&lt;/strong&gt;编写函数, 因此代码应如下所示:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;toProductCode&lt;/span&gt; (checkProductCodeExists:CheckProductCodeExists) productCode =
    productCode
    |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;ProductCode&lt;/span&gt;.create
    |&amp;gt; checkProductCodeExists
    &lt;span style="color: #228B22"&gt;// a problem, returns a bool :(&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但现在我们有一个问题. 我们希望 &lt;em&gt;toProductCode&lt;/em&gt; 函数返回 &lt;em&gt;ProductCode&lt;/em&gt;, 但 &lt;em&gt;checkProductCodeExists&lt;/em&gt; 函数返回一个 &lt;em&gt;bool&lt;/em&gt;, 这意味着整个管道返回一个 &lt;em&gt;bool&lt;/em&gt;. 让我们看看怎样在不改变 &lt;em&gt;checkProductCodeExists&lt;/em&gt; 实现的前提下让管道返回 &lt;em&gt;ProductCode&lt;/em&gt;.&lt;/p&gt;
&lt;h4 id="creating-function-adapters"&gt;Creating Function Adapters&lt;/h4&gt;
&lt;p&gt;我们有一个返回 &lt;em&gt;bool&lt;/em&gt; 的函数, 但我们真的想要一个返回 &lt;em&gt;ProductCode&lt;/em&gt; 的函数. 于其改变这个函数本身, 不如创建一个适配器函数, 这个函数以原始函数为输入, 并返回一个满足要求的新函数.&lt;/p&gt;
&lt;p&gt;下面是一个实现:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;convertToPassthru&lt;/span&gt; checkProductCodeExists productCode =
    &lt;span style="color: #8B008B; font-weight: bold"&gt;if&lt;/span&gt; checkProductCodeExists productCode &lt;span style="color: #8B008B; font-weight: bold"&gt;then&lt;/span&gt;
        productCode
    &lt;span style="color: #8B008B; font-weight: bold"&gt;else&lt;/span&gt;
        failwith &lt;span style="color: #CD5555"&gt;"Invalid Product Code"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有趣的是, 编译器已经确定这个函数是完全通用的 – 它不特定于我们的特定案例! 如果我们查看函数签名, 可以看到没有提及 &lt;em&gt;ProductCode&lt;/em&gt; 类型:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;val&lt;/span&gt; convertToPassthru :
    checkProductCodeExists:(&lt;span style="color: #8B008B; font-weight: bold"&gt;'&lt;/span&gt;a -&amp;gt; &lt;span style="color: #00688B; font-weight: bold"&gt;bool&lt;/span&gt;) -&amp;gt; productCode:&lt;span style="color: #8B008B; font-weight: bold"&gt;'&lt;/span&gt;a -&amp;gt; &lt;span style="color: #8B008B; font-weight: bold"&gt;'&lt;/span&gt;a
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;事实上, 我们意外地创建了一个通用适配器, 该适配器将任何的判断函数转换为适合管道的 “传递” 函数.&lt;/p&gt;
&lt;p&gt;将参数称为 &lt;em&gt;checkProductCodeExists&lt;/em&gt; 或 &lt;em&gt;productCode&lt;/em&gt; 现在并不适用了, 因为现在这两个函数并不代表特定的案例. 这就是为什么许多标准库函数具有如此短的参数名称的原因, 例如函数参数的 &lt;em&gt;f&lt;/em&gt; 和 &lt;em&gt;g&lt;/em&gt;, 以及其他值的 &lt;em&gt;x&lt;/em&gt; 和 &lt;em&gt;y&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;让我们重写函数以使用更抽象的名称, 然后, 如下所示:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;predicateToPassthru&lt;/span&gt; f x =
    &lt;span style="color: #8B008B; font-weight: bold"&gt;if&lt;/span&gt; f x &lt;span style="color: #8B008B; font-weight: bold"&gt;then&lt;/span&gt;
        x
    &lt;span style="color: #8B008B; font-weight: bold"&gt;else&lt;/span&gt;
        failwith &lt;span style="color: #CD5555"&gt;"Invalid Product Code"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在硬编码的错误消息仍然有类似的问题, 所以让我们参数化. 下面是最终版本:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;predicateToPassthru&lt;/span&gt; errorMsg f x =
    &lt;span style="color: #8B008B; font-weight: bold"&gt;if&lt;/span&gt; f x &lt;span style="color: #8B008B; font-weight: bold"&gt;then&lt;/span&gt;
        x
    &lt;span style="color: #8B008B; font-weight: bold"&gt;else&lt;/span&gt;
        failwith errorMsg
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;请注意, 我们先将错误消息放在参数的第一个位置, 以便我们可以使用部分应用固定它.&lt;/p&gt;
&lt;p&gt;现在, 该函数的签名是:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;val&lt;/span&gt; predicateToPassthru :
    errorMsg:&lt;span style="color: #00688B; font-weight: bold"&gt;string&lt;/span&gt; -&amp;gt; f:(&lt;span style="color: #8B008B; font-weight: bold"&gt;'&lt;/span&gt;a -&amp;gt; &lt;span style="color: #00688B; font-weight: bold"&gt;bool&lt;/span&gt;) -&amp;gt; x:&lt;span style="color: #8B008B; font-weight: bold"&gt;'&lt;/span&gt;a -&amp;gt; &lt;span style="color: #8B008B; font-weight: bold"&gt;'&lt;/span&gt;a
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种抽象技术在函数式编程中非常常见, 因此了解发生了什么并识别出模式是非常重要的. 即使是不起眼的 &lt;em&gt;List.map&lt;/em&gt; 函数也可以被视为函数转换器, 它将 “正常” 函数 &lt;em&gt;‘a -&amp;gt; ‘b&lt;/em&gt; 转换为在列表上工作的函数 &lt;em&gt;‘a list -&amp;gt; ‘b list&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;好了, 现在让我们看下新版本的 &lt;em&gt;toProductCode&lt;/em&gt; 函数:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;toProductCode&lt;/span&gt; (checkProductCodeExists:CheckProductCodeExists) productCode =
    &lt;span style="color: #228B22"&gt;// create a local ProductCode -&amp;gt; ProductCode function&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// suitable for using in a pipeline&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;checkProduct&lt;/span&gt; productCode =
        &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;errorMsg&lt;/span&gt; = sprintf &lt;span style="color: #CD5555"&gt;"Invalid: %A"&lt;/span&gt; productCode
        predicateToPassthru errorMsg checkProductCodeExists productCode
    &lt;span style="color: #228B22"&gt;// assemble the pipeline&lt;/span&gt;
    productCode
    |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;ProductCode&lt;/span&gt;.create
    |&amp;gt; checkProduct
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这就是它 - 现在我们有一个 &lt;em&gt;validateOrder&lt;/em&gt; 实现的基本草图, 我们可以在此基础上构建. 请注意, 低级验证逻辑(如 &lt;em&gt;a product must start with a W or G&lt;/em&gt;)并未在我们的验证函数中显式实现, 而是内置到受约束的简单类型的构造函数中, 类似 &lt;em&gt;OrderId&lt;/em&gt; 和 &lt;em&gt;ProductCode&lt;/em&gt;.&lt;/p&gt;
&lt;h3 id="priceorder-step"&gt;PriceOrder Step&lt;/h3&gt;
&lt;p&gt;以下是 &lt;em&gt;PriceOrder&lt;/em&gt; 的原始定义:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;PriceOrder&lt;/span&gt; =
    GetProductPrice &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
    -&amp;gt; ValidatedOrder &lt;span style="color: #228B22"&gt;// input&lt;/span&gt;
    -&amp;gt; Result&amp;lt;PricedOrder, PlaceOrderError&amp;gt; &lt;span style="color: #228B22"&gt;// output&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们先消除副作用:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;GetProductPrice&lt;/span&gt; = ProductCode -&amp;gt; Price

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;PriceOrder&lt;/span&gt; =
    GetProductPrice &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
    -&amp;gt; ValidatedOrder &lt;span style="color: #228B22"&gt;// input&lt;/span&gt;
    -&amp;gt; PricedOrder &lt;span style="color: #228B22"&gt;// output&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是大概的实现. 它只需将每个订单行转换为 &lt;em&gt;PricedOrderLine&lt;/em&gt;, 并使用它们构建新的 &lt;em&gt;PricedOrder&lt;/em&gt;:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;priceOrder&lt;/span&gt; : PriceOrder =
    &lt;span style="color: #8B008B; font-weight: bold"&gt;fun&lt;/span&gt; getProductPrice validatedOrder -&amp;gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;lines&lt;/span&gt; =
            validatedOrder.Lines
            |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;List&lt;/span&gt;.map (toPricedOrderLine getProductPrice)
        &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;amountToBill&lt;/span&gt; =
            lines
            &lt;span style="color: #228B22"&gt;// get each line price&lt;/span&gt;
            |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;List&lt;/span&gt;.map (&lt;span style="color: #8B008B; font-weight: bold"&gt;fun&lt;/span&gt; line -&amp;gt; line.LinePrice)
            &lt;span style="color: #228B22"&gt;// add them together as a BillingAmount&lt;/span&gt;
            |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;BillingAmount&lt;/span&gt;.sumPrices
        &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;pricedOrder&lt;/span&gt; : PricedOrder = {
            OrderId = validatedOrder.OrderId
            CustomerInfo = validatedOrder.CustomerInfo
            ShippingAddress = validatedOrder.ShippingAddress
            BillingAddress = validatedOrder.BillingAddress
            Lines = lines
            AmountToBill = amountToBill
            }
        pricedOrder
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;顺便一提, 如果你的管道中有许多步骤, 并且暂时还不想实现它们(或不知道如何实现), 则只需使用如下所示的 &lt;em&gt;not implemented&lt;/em&gt; 消息来表示失败, 在绘制实现草图时, 使用 &lt;em&gt;not implemented&lt;/em&gt; 异常会很方便. 它能确保我们的项目在任何时候都是完全可编译的.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;priceOrder&lt;/span&gt; : PriceOrder =
    &lt;span style="color: #8B008B; font-weight: bold"&gt;fun&lt;/span&gt; getProductPrice validatedOrder -&amp;gt;
        failwith &lt;span style="color: #CD5555"&gt;"not implemented"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 &lt;em&gt;priceOrder&lt;/em&gt; 的实现中, 我们引入了两个新的帮助函数: &lt;em&gt;toPricedOrderLine&lt;/em&gt; 和 &lt;em&gt;BillingAmount.sumPrices&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;我们将 &lt;em&gt;sumPrices&lt;/em&gt; 函数添加到了共享的 &lt;em&gt;BillingAmount&lt;/em&gt; 模块. 它只是将价格列表加起来并将其包装为 &lt;em&gt;BillingAmount&lt;/em&gt;. 为什么我们首先定义 &lt;em&gt;BillingAmount&lt;/em&gt; 类型？因为它与 &lt;em&gt;Price&lt;/em&gt; 不同, 所以验证规则可能有所不同.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;// Sum a list of prices to make a billing amount&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// Raise exception if total is out of bounds&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;sumPrices&lt;/span&gt; prices =
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;total&lt;/span&gt; = prices |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;List&lt;/span&gt;.map &lt;span style="color: #008b45; text-decoration: underline"&gt;Price&lt;/span&gt;.value |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;List&lt;/span&gt;.sum
    create total
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数 &lt;em&gt;toPricedOrderLine&lt;/em&gt; 与我们以前看到的函数类似. 它是仅转换一行的帮助函数:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;// Transform a ValidatedOrderLine to a PricedOrderLine&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;toPricedOrderLine&lt;/span&gt; getProductPrice (line:ValidatedOrderLine) : PricedOrderLine =
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;qty&lt;/span&gt; = line.Quantity |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;OrderQuantity&lt;/span&gt;.value
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;price&lt;/span&gt; = line.ProductCode |&amp;gt; getProductPrice
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;linePrice&lt;/span&gt; = price |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;Price&lt;/span&gt;.multiply qty
    {
        OrderLineId = line.OrderLineId
        ProductCode = line.ProductCode
        Quantity = line.Quantity LinePrice = linePrice
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在此函数中, 我们引入了另一个帮助函数 &lt;em&gt;Price.multiply&lt;/em&gt;, 将价格乘以数量.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;// Multiply a Price by a decimal qty.&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// Raise exception if new price is out of bounds.&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;multiply&lt;/span&gt; qty (Price p) =
    create (qty * p)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定价步骤现已完成!&lt;/p&gt;
&lt;h3 id="acknowledgement-step"&gt;Acknowledgement Step&lt;/h3&gt;
&lt;p&gt;这是移除了副作用后的 &lt;em&gt;Acknowledgement&lt;/em&gt; 定义:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;HtmlString&lt;/span&gt; = HtmlString &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;string&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CreateOrderAcknowledgmentLetter&lt;/span&gt; =
    PricedOrder -&amp;gt; HtmlString

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;OrderAcknowledgment&lt;/span&gt; = {
    EmailAddress : EmailAddress
    Letter : HtmlString
}
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;SendResult&lt;/span&gt; = Sent | NotSent
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;SendOrderAcknowledgment&lt;/span&gt; =
    OrderAcknowledgment -&amp;gt; SendResult

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;AcknowledgeOrder&lt;/span&gt; =
    CreateOrderAcknowledgmentLetter  &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
    -&amp;gt; SendOrderAcknowledgment  &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
    -&amp;gt; PricedOrder  &lt;span style="color: #228B22"&gt;// input&lt;/span&gt;
    -&amp;gt; OrderAcknowledgmentSent option &lt;span style="color: #228B22"&gt;// output&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是它的实现:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;acknowledgeOrder&lt;/span&gt; : AcknowledgeOrder =
    &lt;span style="color: #8B008B; font-weight: bold"&gt;fun&lt;/span&gt; createAcknowledgmentLetter sendAcknowledgment pricedOrder -&amp;gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;letter&lt;/span&gt; = createAcknowledgmentLetter pricedOrder
        &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;acknowledgment&lt;/span&gt; = {
            EmailAddress = pricedOrder.CustomerInfo.EmailAddress
            Letter = letter
        }

        &lt;span style="color: #228B22"&gt;// if the acknowledgement was successfully sent,&lt;/span&gt;
        &lt;span style="color: #228B22"&gt;// return the corresponding event, else return None&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;match&lt;/span&gt; sendAcknowledgment acknowledgment &lt;span style="color: #8B008B; font-weight: bold"&gt;with&lt;/span&gt;
        | Sent -&amp;gt;
            &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;event&lt;/span&gt; = {
                OrderId = pricedOrder.OrderId
                EmailAddress = pricedOrder.CustomerInfo.EmailAddress
            }
            Some &lt;span style="color: #8B008B; font-weight: bold"&gt;event&lt;/span&gt;
        | NotSent -&amp;gt;
            None
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实现非常简单, 不需要帮助器函数, 所以这很容易!&lt;/p&gt;
&lt;p&gt;但是, &lt;em&gt;sendAcknowledgment&lt;/em&gt; 依赖项呢? 在某个时候, 我们将必须决定它的实现. 然而, 现在我们可以不去管它. 这是使用函数对依赖项进行参数化的巨大好处之一 – you can avoid making decisions until the last responsible moment, yet you can still build and assemble most of the code.&lt;/p&gt;
&lt;h3 id="createevents-step"&gt;CreateEvents Step&lt;/h3&gt;
&lt;p&gt;最后的步骤是创建从工作流返回的事件. 假设只有在计费金额大于 0 时才应发送 &lt;em&gt;billing&lt;/em&gt; 事件. 设计是:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;// Event to send to shipping context&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;OrderPlaced&lt;/span&gt; = PricedOrder

&lt;span style="color: #228B22"&gt;// Event to send to billing context&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// Will only be created if the AmountToBill is not zero&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;BillableOrderPlaced&lt;/span&gt; = {
    OrderId : OrderId
    BillingAddress: Address
    AmountToBill : BillingAmount
    }

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;PlaceOrderEvent&lt;/span&gt; =
    | OrderPlaced &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; OrderPlaced
    | BillableOrderPlaced &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; BillableOrderPlaced
    | AcknowledgmentSent &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; OrderAcknowledgmentSent

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CreateEvents&lt;/span&gt; =
    PricedOrder  &lt;span style="color: #228B22"&gt;// input&lt;/span&gt;
    -&amp;gt; OrderAcknowledgmentSent option  &lt;span style="color: #228B22"&gt;// input (event from previous step)&lt;/span&gt;
    -&amp;gt; PlaceOrderEvent &lt;span style="color: #00688B; font-weight: bold"&gt;list&lt;/span&gt;  &lt;span style="color: #228B22"&gt;// output&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们不需要创建 &lt;em&gt;OrderPlaced&lt;/em&gt; 事件, 因为它和 &lt;em&gt;PricedOrder&lt;/em&gt; 一样, 而 &lt;em&gt;OrderAcknowledgmentSent&lt;/em&gt; 事件是在上一步中创建的, 因此我们也不需要创建它.&lt;/p&gt;
&lt;p&gt;但是 &lt;em&gt;BillableOrderPlaced&lt;/em&gt; 事件需要我们手动创建, 所以要构建一个 &lt;em&gt;createBillingEvent&lt;/em&gt; 函数. 而由于还需要区别非零计费金额, 所以这个函数必须返回 &lt;em&gt;optional&lt;/em&gt; 类型.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;// PricedOrder -&amp;gt; BillableOrderPlaced option&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;createBillingEvent&lt;/span&gt; (placedOrder:PricedOrder) : BillableOrderPlaced option =
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;billingAmount&lt;/span&gt; = placedOrder.AmountToBill |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;BillingAmount&lt;/span&gt;.value
    &lt;span style="color: #8B008B; font-weight: bold"&gt;if&lt;/span&gt; billingAmount &amp;gt; &lt;span style="color: #B452CD"&gt;0M&lt;/span&gt; &lt;span style="color: #8B008B; font-weight: bold"&gt;then&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;event&lt;/span&gt; = {
            OrderId = placedOrder.OrderId
            BillingAddress = placedOrder.BillingAddress
            AmountToBill = placedOrder.AmountToBill
            }
        Some &lt;span style="color: #8B008B; font-weight: bold"&gt;event&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;else&lt;/span&gt;
        None
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们所有的事件都已经有了, 那么应该如何返回它们呢?&lt;/p&gt;
&lt;p&gt;我们&lt;a href="http://www.smallcpp.cn/wu-modeling-workflows-as-pipelines.html#creating-the-events-to-return"&gt;之前&lt;/a&gt;决定为所有的事件类型创建一个 OR 类型, 然后返回这些类型的列表. 因此, 首先我们需要将每个事件转换为 OR 类型. 对于 &lt;em&gt;OrderPlaced&lt;/em&gt; 事件, 我们只需直接使用 &lt;em&gt;PlaceOrderEvent.OrdePlaced&lt;/em&gt; 构造函数, 但对于另外两个事件, 我们需要使用 &lt;em&gt;Option.map&lt;/em&gt; 函数, 如果是 &lt;em&gt;None&lt;/em&gt;, 就返回 &lt;em&gt;None&lt;/em&gt;; 如果是 &lt;em&gt;Some(x)&lt;/em&gt;, 返回 &lt;em&gt;Some(f x)&lt;/em&gt;, f 是给定的函数.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;createEvents&lt;/span&gt; : CreateEvents =
    &lt;span style="color: #8B008B; font-weight: bold"&gt;fun&lt;/span&gt; pricedOrder acknowledgmentEventOpt -&amp;gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;event1&lt;/span&gt; =
        pricedOrder
        |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;PlaceOrderEvent&lt;/span&gt;.OrderPlaced
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;event2Opt&lt;/span&gt; =
        acknowledgmentEventOpt
        |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;Option&lt;/span&gt;.map &lt;span style="color: #008b45; text-decoration: underline"&gt;PlaceOrderEvent&lt;/span&gt;.AcknowledgmentSent
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;event3Opt&lt;/span&gt; =
        pricedOrder
        |&amp;gt; createBillingEvent
        |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;Option&lt;/span&gt;.map &lt;span style="color: #008b45; text-decoration: underline"&gt;PlaceOrderEvent&lt;/span&gt;.BillableOrderPlaced
    &lt;span style="color: #228B22"&gt;// return all the events, how?&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在它们都调用了各自的构造函数, 但有些是 &lt;em&gt;optional&lt;/em&gt; 类型. 我们应该如何处理才能把它们放到一个列表里呢？好吧, 我们可以再次执行之前的一个技巧, 将它们全部转换为更通用的类型.&lt;/p&gt;
&lt;p&gt;对于 &lt;em&gt;OrderPlaced&lt;/em&gt; 可以使用 &lt;em&gt;list.singleton&lt;/em&gt; 将其转换为列表, 而对于 &lt;em&gt;option&lt;/em&gt;, 则可以创建一个称为 &lt;em&gt;listOfOption&lt;/em&gt; 的帮助函数:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;// convert an Option into a List&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;listOfOption&lt;/span&gt; opt =
    &lt;span style="color: #8B008B; font-weight: bold"&gt;match&lt;/span&gt; opt &lt;span style="color: #8B008B; font-weight: bold"&gt;with&lt;/span&gt;
        | Some x -&amp;gt; [x]
        | None -&amp;gt; &lt;span style="color: #658b00"&gt;[]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样, 所有的事件类型都相同了, 我们可以将它们放到另一个列表中返回:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;createEvents&lt;/span&gt; : CreateEvents =
    &lt;span style="color: #8B008B; font-weight: bold"&gt;fun&lt;/span&gt; pricedOrder acknowledgmentEventOpt -&amp;gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;event1&lt;/span&gt; =
        pricedOrder
        |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;PlaceOrderEvent&lt;/span&gt;.OrderPlaced
        |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;List&lt;/span&gt;.singleton
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;event2Opt&lt;/span&gt; =
        acknowledgmentEventOpt
        |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;Option&lt;/span&gt;.map &lt;span style="color: #008b45; text-decoration: underline"&gt;PlaceOrderEvent&lt;/span&gt;.AcknowledgmentSent
        |&amp;gt; listOfOption
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;event3Opt&lt;/span&gt; =
        pricedOrder
        |&amp;gt; createBillingEvent
        |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;Option&lt;/span&gt;.map &lt;span style="color: #008b45; text-decoration: underline"&gt;PlaceOrderEvent&lt;/span&gt;.BillableOrderPlaced
        |&amp;gt; listOfOption
    &lt;span style="color: #228B22"&gt;// return all the events&lt;/span&gt;
    [
        &lt;span style="color: #8B008B; font-weight: bold"&gt;yield&lt;/span&gt;! events1
        &lt;span style="color: #8B008B; font-weight: bold"&gt;yield&lt;/span&gt;! events2
        &lt;span style="color: #8B008B; font-weight: bold"&gt;yield&lt;/span&gt;! events3
    ]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种将不兼容的东西转换或 “提升” 为共享类型的方法是处理组合问题的关键技术.&lt;/p&gt;
&lt;h2 id="composing-the-pipeline-steps-together"&gt;Composing the Pipeline Steps Together&lt;/h2&gt;
&lt;p&gt;现在, 我们已准备好通过将各步骤的实现组合到管道中来完成工作流. 我们希望代码能像下面这样:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;placeOrder&lt;/span&gt; : PlaceOrderWorkflow =
    &lt;span style="color: #8B008B; font-weight: bold"&gt;fun&lt;/span&gt; unvalidatedOrder -&amp;gt;
        unvalidatedOrder
        |&amp;gt; validateOrder
        |&amp;gt; priceOrder
        |&amp;gt; acknowledgeOrder
        |&amp;gt; createEvents
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是有一个问题, 那就是 &lt;em&gt;validateOrder&lt;/em&gt; 除了 &lt;em&gt;UnvalidatedOrder&lt;/em&gt; 之外还有两个额外的输入. 就目前情况而言, 没有办法直接将 &lt;em&gt;PlaceOrder&lt;/em&gt; 工作流连接到 &lt;em&gt;validateOrder&lt;/em&gt; 函数, 因为参数不匹配.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/parameterdonotmatch.png"/&gt;&lt;/p&gt;
&lt;p&gt;同样, &lt;em&gt;validateOrder&lt;/em&gt; 函数也不能连接到 &lt;em&gt;priceOrder&lt;/em&gt; 函数, 因为 &lt;em&gt;priceOrder&lt;/em&gt; 函数有两个输入.&lt;/p&gt;
&lt;p&gt;如&lt;a href="http://www.smallcpp.cn/wu-modeling-workflows-as-pipelines.html#composing-the-workflow-from-the-steps"&gt;之前&lt;/a&gt;所言, 像这样用不同的 “形状” 组合函数是函数编程中的主要挑战之一, 并且已经有了许多技术来解决这个问题.&lt;/p&gt;
&lt;p&gt;大多数解决方案都涉及可怕的 &lt;strong&gt;&lt;em&gt;monad&lt;/em&gt;&lt;/strong&gt;, 而在这里, 我们将使用一种非常简单的方法, 那就是&lt;strong&gt;部分应用&lt;/strong&gt;. 我们将只应用 &lt;em&gt;validateOrder&lt;/em&gt; 三个参数中的两个(两个依赖项), 这会给我们生成一个只有一个输入的新函数.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/parametermatch.png"/&gt;&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;validateOrderWithDependenciesBakedIn&lt;/span&gt; =
    validateOrder checkProductCodeExists checkAddressExists

&lt;span style="color: #228B22"&gt;// new function signature after partial application:&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// UnvalidatedOrder -&amp;gt; ValidatedOrder&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然, 这是一个可怕的名字! 幸运的是, 在 F# 中, 可以在本地对新函数使用与原函数相同的名称 – 这称为 “&lt;em&gt;shadowing&lt;/em&gt;”:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;validateOrder&lt;/span&gt; =
    validateOrder checkProductCodeExists checkAddressExists
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者, 可以在名称中使用刻度号来显示它是原始函数的变体, 如下所示:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;validateOrder&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;'&lt;/span&gt; =
    validateOrder checkProductCodeExists checkAddressExists
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来, 我们可以用同样的方式处理掉 &lt;em&gt;priceOrder&lt;/em&gt; 和 &lt;em&gt;acknowledgeOrder&lt;/em&gt;, 然后我们会得到三个只有一个参数的新函数.&lt;/p&gt;
&lt;p&gt;最终, 工作流主函数 &lt;em&gt;placeOrder&lt;/em&gt; 如下所示:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;placeOrder&lt;/span&gt; : PlaceOrderWorkflow =
    &lt;span style="color: #228B22"&gt;// set up local versions of the pipeline stages&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// using partial application to bake in the dependencies&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;validateOrder&lt;/span&gt; =
        validateOrder checkProductCodeExists checkAddressExists
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;priceOrder&lt;/span&gt; =
        priceOrder getProductPrice
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;acknowledgeOrder&lt;/span&gt; =
        acknowledgeOrder createAcknowledgmentLetter sendAcknowledgment

    &lt;span style="color: #228B22"&gt;// return the workflow function&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;fun&lt;/span&gt; unvalidatedOrder -&amp;gt;
        &lt;span style="color: #228B22"&gt;// compose the pipeline from the new one-parameter functions&lt;/span&gt;
        unvalidatedOrder
        |&amp;gt; validateOrder
        |&amp;gt; priceOrder
        |&amp;gt; acknowledgeOrder
        |&amp;gt; createEvents
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除此之外, 还有一个问题. 在我们的例子中, &lt;em&gt;acknowledgeOrder&lt;/em&gt; 的输出只有事件, 而没有 &lt;em&gt;PricedOrder&lt;/em&gt;, 因此它与 &lt;em&gt;createEvents&lt;/em&gt; 的输入不匹配.&lt;/p&gt;
&lt;p&gt;我们可以为此编写一个适配器, 或者可以简单地改用更命令化的代码样式, 为每个步骤的输出显式地分配一个值, 如下所示:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;placeOrder&lt;/span&gt; : PlaceOrderWorkflow =
    &lt;span style="color: #228B22"&gt;// return the workflow function&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;fun&lt;/span&gt; unvalidatedOrder -&amp;gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;validatedOrder&lt;/span&gt; =
            unvalidatedOrder
            |&amp;gt; validateOrder checkProductCodeExists checkAddressExists
        &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;pricedOrder&lt;/span&gt; =
            validatedOrder
            |&amp;gt; priceOrder getProductPrice
        &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;acknowledgementOption&lt;/span&gt; =
            pricedOrder
            |&amp;gt; acknowledgeOrder createAcknowledgmentLetter sendAcknowledgment
        &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;events&lt;/span&gt; =
            createEvents pricedOrder acknowledgementOption
        events
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它不像管道那么优雅, 但仍然易于理解和维护.&lt;/p&gt;
&lt;p&gt;那么, 剩下的问题就是从哪里获取那两个依赖项? 我们不想把它们变成全局函数, 所以接下来让我们看看如何 “注入” 这些依赖项.&lt;/p&gt;
&lt;h2 id="injecting-dependencies"&gt;Injecting Dependencies&lt;/h2&gt;
&lt;p&gt;(这段话总翻译不好, 还是看原文吧.)&lt;br/&gt;
We have a number of low-level helper functions such as toValidProductCode that take a function parameter representing a service. These are quite deep in the design, so how do we get dependencies from the top level down to the functions that need them?&lt;/p&gt;
&lt;p&gt;在面向对象设计中, 我们将使用依赖注入(&lt;em&gt;dependency injection&lt;/em&gt;) 和 &lt;em&gt;IoC&lt;/em&gt; 容器. 但在函数式编程中, 我们不想那么做, 因为那会让依赖项变得隐式. 相反, 我们始终希望将依赖作为显式参数传递, 以确保依赖是显式的.&lt;/p&gt;
&lt;p&gt;在函数式编程中, 有很多技术可以做到这一点, 例如 “&lt;em&gt;Reader Monad&lt;/em&gt;” 和 “&lt;em&gt;Free Monad&lt;/em&gt;”. 但由于这是本入门书籍, 因此我们将使用最简单的方法, 那就是将所有的依赖项放到顶层函数, 然后将它们传递给内部函数, 内部函数又将它们向下传递到更内部的函数, 依此类推.&lt;/p&gt;
&lt;p&gt;例如, 假设我们已经实现了我们之前定义的辅助函数, 它们都有一个明确的参数显式的表明依赖性:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;// low-level helper functions&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;toAddress&lt;/span&gt; checkAddressExists unvalidatedAddress =  &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;toProductCode&lt;/span&gt; checkProductCodeExists productCode = &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在, 作为创建订单行的一部分, 我们需要创建产品代码, 那意味着 &lt;em&gt;toValidatedOrderLine&lt;/em&gt; 需要使用 &lt;em&gt;toProductCode&lt;/em&gt;, 也就意味着 &lt;em&gt;toValidatedOrderLine&lt;/em&gt; 需要有 &lt;em&gt;checkProductCodeExists&lt;/em&gt; 参数:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;toValidatedOrderLine&lt;/span&gt;
    checkProductExists  &lt;span style="color: #228B22"&gt;// needed for toProductCode, below&lt;/span&gt;
    unvalidatedOrderLine =
        &lt;span style="color: #228B22"&gt;// create the components of the line&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;orderLineId&lt;/span&gt; = &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;productCode&lt;/span&gt; =
            unvalidatedOrderLine.ProductCode
            |&amp;gt; toProductCode checkProductExists  &lt;span style="color: #228B22"&gt;// use service&lt;/span&gt;
        &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再向上移动一个级别, 因为 &lt;em&gt;validateOrder&lt;/em&gt; 函数需要同时使用 &lt;em&gt;toAddress&lt;/em&gt; 和 &lt;em&gt;toValidatedOrderLine&lt;/em&gt;, 所以它需要 &lt;em&gt;checkAddressExists&lt;/em&gt; 和 &lt;em&gt;checkProductCodeExists&lt;/em&gt; 作为额外的参数传入:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;validateOrder&lt;/span&gt; : ValidateOrder =
    &lt;span style="color: #8B008B; font-weight: bold"&gt;fun&lt;/span&gt; checkProductExists &lt;span style="color: #228B22"&gt;// dependency for toValidatedOrderLine&lt;/span&gt;
        checkAddressExists &lt;span style="color: #228B22"&gt;// dependency for toAddress&lt;/span&gt;
        unvalidatedOrder -&amp;gt;
        &lt;span style="color: #228B22"&gt;// build the validated address using the dependency&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;shippingAddress&lt;/span&gt; =
            unvalidatedOrder.ShippingAddress
            |&amp;gt; toAddress checkAddressExists
        &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
        &lt;span style="color: #228B22"&gt;// build the validated order lines using the dependency&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;lines&lt;/span&gt; =
            unvalidatedOrder.Lines
            |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;List&lt;/span&gt;.map (toValidatedOrderLine checkProductExists)
        &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以此类推, 直到找到一个可以预构建好所有依赖项的顶级函数. 在面向对象设计中, 此顶级函数通常称为 “组合根”, 这里我们也使用相同的术语.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;placeOrder&lt;/em&gt; 工作流函数是否可以充当组合根?&lt;/p&gt;
&lt;p&gt;不, 因为构建服务通常涉及访问配置文件(副作用). 最好也为 &lt;em&gt;placeOrder&lt;/em&gt; 工作流本身提供它所需的依赖作为参数, 如下所示:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;placeOrder&lt;/span&gt;
    checkProductExists  &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
    checkAddressExists  &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
    getProductPrice  &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
    createOrderAcknowledgmentLetter  &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
    sendOrderAcknowledgment  &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
    : PlaceOrderWorkflow =
        &lt;span style="color: #8B008B; font-weight: bold"&gt;fun&lt;/span&gt; unvalidatedOrder -&amp;gt;
            &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样做还有一个额外的好处, 即整个工作流很容易测试, 因为所有依赖项都是可伪造的 (&lt;em&gt;fake-able&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;实际上, 组合根函数应尽可能接近应用程序的入口点 – 控制台应用的 &lt;em&gt;main&lt;/em&gt; 函数或长时间运行的应用(如 &lt;em&gt;Web&lt;/em&gt; 服务)的 &lt;em&gt;OnStartup/Application_Start&lt;/em&gt; 处理程序. 例如:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;app&lt;/span&gt; : WebPart =
    &lt;span style="color: #228B22"&gt;// setup the services used by the workflow&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;checkProductExists&lt;/span&gt; =  &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;checkAddressExists&lt;/span&gt; =  &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;getProductPrice&lt;/span&gt; =  &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;createOrderAcknowledgmentLetter&lt;/span&gt; =  &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;sendOrderAcknowledgment&lt;/span&gt; =  &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;toHttpResponse&lt;/span&gt; = &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;

    &lt;span style="color: #228B22"&gt;// partially apply the services to the workflows&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;placeOrder&lt;/span&gt; =
        placeOrder
        checkProductExists
        checkAddressExists
        getProductPrice
        createOrderAcknowledgmentLetter
        sendOrderAcknowledgment

    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;changeOrder&lt;/span&gt; =  &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;cancelOrder&lt;/span&gt; =  &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;

    &lt;span style="color: #228B22"&gt;// set up the routing&lt;/span&gt;
    choose
        [ POST &amp;gt;=&amp;gt; choose
            [ path &lt;span style="color: #CD5555"&gt;"/placeOrder"&lt;/span&gt;
                &amp;gt;=&amp;gt; deserializeOrder  &lt;span style="color: #228B22"&gt;// convert JSON to UnvalidatedOrder&lt;/span&gt;
                &amp;gt;=&amp;gt; placeOrder  &lt;span style="color: #228B22"&gt;// do the workflow&lt;/span&gt;
                &amp;gt;=&amp;gt; postEvents  &lt;span style="color: #228B22"&gt;// post the events onto queues&lt;/span&gt;
                &amp;gt;=&amp;gt; toHttpResponse  &lt;span style="color: #228B22"&gt;// return 200/400/etc based on the output&lt;/span&gt;
              path &lt;span style="color: #CD5555"&gt;"/changeOrder"&lt;/span&gt;
                &amp;gt;=&amp;gt;  &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
              path &lt;span style="color: #CD5555"&gt;"/cancelOrder"&lt;/span&gt;
                &amp;gt;=&amp;gt;  &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
            ]
        ]
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="too-many-dependencies"&gt;Too Many Dependencies?&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;validateOrder&lt;/em&gt; 只有两个依赖. 如果它需要四个, 五个, 甚至更多呢? 如果还有其它步骤也需要大量的依赖项, 则最终的依赖会是爆发式增长. 发生这种情况时, 应该怎么做?&lt;/p&gt;
&lt;p&gt;首先, 可能是函数做了太多的事情. 能把拆分它吗? 如果不行, 则可以将依赖分组到单个结构体中, 并将该结构体作为参数传递.&lt;/p&gt;
&lt;p&gt;常见的情况是子函数的依赖特别复杂. 例如, 假设 &lt;em&gt;checkAddressExists&lt;/em&gt; 函数正在与需要 &lt;em&gt;URI endpoint&lt;/em&gt; 和 &lt;em&gt;credentials&lt;/em&gt; 的 Web 服务通信:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;checkAddressExists&lt;/span&gt; endPoint credentials = ...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们是否必须让这个函数的调用者(&lt;em&gt;toAddress&lt;/em&gt;)也具备那两个参数? 像这样:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;toAddress&lt;/span&gt;
    checkAddressExists
    endPoint  &lt;span style="color: #228B22"&gt;// only needed for checkAddressExists&lt;/span&gt;
    credentials   &lt;span style="color: #228B22"&gt;// only needed for checkAddressExists&lt;/span&gt;
    unvalidatedAddress =
        &lt;span style="color: #228B22"&gt;// call the remote service&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;checkedAddress&lt;/span&gt; = checkAddressExists endPoint credentials unvalidatedAddress
        &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以此类推到更上层的函数:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;validateOrder&lt;/span&gt;
    checkProductExists
    checkAddressExists
    endPoint &lt;span style="color: #228B22"&gt;// only needed for checkAddressExists&lt;/span&gt;
    credentials &lt;span style="color: #228B22"&gt;// only needed for checkAddressExists&lt;/span&gt;
    unvalidatedOrder =
        &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不, 当然不需要这么设计. 这些中间函数不需要知道与 &lt;em&gt;checkAddressExists&lt;/em&gt; 函数的依赖有关的任何信息.&lt;/p&gt;
&lt;p&gt;更好的方法是在 &lt;em&gt;validateOrder&lt;/em&gt; 函数之外再预构建一个所有依赖项都已内置的帮助函数, 然后传递这个帮助函数即可.&lt;/p&gt;
&lt;p&gt;例如, 在下面的代码中, 我们在准备期间将 &lt;em&gt;uri&lt;/em&gt; 和 &lt;em&gt;credentials&lt;/em&gt; 内置到 &lt;em&gt;checkAddressExists&lt;/em&gt; 函数中, 以便以后可以将其作为只有一个参数的函数使用:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;仅仅是例子, 实际上 &lt;em&gt;set up&lt;/em&gt; 阶段应该在更上层(例如 &lt;em&gt;WebPart&lt;/em&gt;), 而不是在 &lt;em&gt;placeOrder&lt;/em&gt; 中.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;placeOrder&lt;/span&gt; : PlaceOrderWorkflow =
    &lt;span style="color: #228B22"&gt;// initialize information (e.g from configuration)&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;endPoint&lt;/span&gt; =  &lt;span style="color: #228B22"&gt;//...&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;credentials&lt;/span&gt; =  &lt;span style="color: #228B22"&gt;//...&lt;/span&gt;

    &lt;span style="color: #228B22"&gt;// make a new version of checkAddressExists&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// with the credentials baked in&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;checkAddressExists&lt;/span&gt; = checkAddressExists endPoint credentials
    &lt;span style="color: #228B22"&gt;// etc&lt;/span&gt;

    &lt;span style="color: #228B22"&gt;// set up the steps in the workflow&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;validateOrder&lt;/span&gt; =
        validateOrder
        checkProductCodeExists
        checkAddressExists  &lt;span style="color: #228B22"&gt;// the new checkAddressExists&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// etc&lt;/span&gt;

    &lt;span style="color: #228B22"&gt;// return the workflow function&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;fun&lt;/span&gt; unvalidatedOrder -&amp;gt;
        &lt;span style="color: #228B22"&gt;// compose the pipeline from the steps ...&lt;/span&gt;
        &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种通过 “预构建” 来减少参数的方法是一种常见的技术, 有助于隐藏复杂性. 当一个函数传递到另一个函数时, “接口”(函数类型)应尽可能少, 并隐藏所有依赖项.&lt;/p&gt;
&lt;h3 id="testing-dependencies"&gt;Testing Dependencies&lt;/h3&gt;
&lt;p&gt;像这样传递依赖关系的一大好处是, 它使核心函数非常易于测试, 因为它很容易 &lt;em&gt;fake&lt;/em&gt; 出有效的依赖, 而无需任何特殊的模拟库 (&lt;em&gt;mocking library&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;例如, 假设我们要测试 &lt;em&gt;validation&lt;/em&gt; 的代码是否有效. 一个测试应该检查, 如果 &lt;em&gt;checkProductCodeExists&lt;/em&gt; 成功, 则整个验证成功. 另一个测试应该检查, 如果 &lt;em&gt;checkProductCodeExists&lt;/em&gt; 失败, 则整个验证都会失败. 让我们看看现在如何编写这些测试.&lt;/p&gt;
&lt;p&gt;这是一些 &lt;em&gt;success case&lt;/em&gt; 的代码, 使用 &lt;em&gt;Arrange/Act/Assert&lt;/em&gt; 模块进行测试:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;open&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;NUnit.Framework&lt;/span&gt;

[&amp;lt;Test&amp;gt;]
&lt;span style="color: #228B22"&gt;// F# allows you to create identifiers with spaces and punctuation in them&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; ``If product exists, validation succeeds``&lt;span style="color: #658b00"&gt;()&lt;/span&gt; =
    &lt;span style="color: #228B22"&gt;// arrange: set up stub versions of service dependencies&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;checkAddressExists&lt;/span&gt; address =
        CheckedAddress address &lt;span style="color: #228B22"&gt;// succeed&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;checkProductCodeExists&lt;/span&gt; productCode =
        &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt; &lt;span style="color: #228B22"&gt;// succeed&lt;/span&gt;

    &lt;span style="color: #228B22"&gt;// arrange: set up input&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;unvalidatedOrder&lt;/span&gt; = &lt;span style="color: #228B22"&gt;//...&lt;/span&gt;

    &lt;span style="color: #228B22"&gt;// act: call validateOrder&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;result&lt;/span&gt; = validateOrder checkProductCodeExists checkAddressExists &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;

    &lt;span style="color: #228B22"&gt;// assert: check that result is a ValidatedOrder, not an error&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到 &lt;em&gt;checkAddressExists&lt;/em&gt; 和 &lt;em&gt;checkProductCodeExists&lt;/em&gt; 函数的 &lt;em&gt;stub&lt;/em&gt; 版本(代表服务)编写起来很简单, 可以在测试中直接进行定义.&lt;/p&gt;
&lt;p&gt;要为 &lt;em&gt;failure case&lt;/em&gt; 编写代码, 我们需要做的就是将 &lt;em&gt;checkProductCodeExists&lt;/em&gt; 函数更改为对于任何产品代码都失败:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;checkProductCodeExists&lt;/span&gt; productCode =
    &lt;span style="color: #8B008B; font-weight: bold"&gt;false&lt;/span&gt; &lt;span style="color: #228B22"&gt;// fail&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这只是一个小例子. 测试是一个很大的主题, 我们这里没有空间可以进入.&lt;/p&gt;
&lt;h2 id="the-assembled-pipeline"&gt;The Assembled Pipeline&lt;/h2&gt;
&lt;p&gt;在本章中, 我们已经看到了分散片段中的所有代码. 让我们将所有这些组合在一起, 并展示如何组装完整的管道.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们将实现特定工作流的所有代码放在同一模块中, 该模块以工作流命名(例如 &lt;em&gt;PlaceOrderWorkflow.fs&lt;/em&gt;).&lt;/li&gt;
&lt;li&gt;在文件的顶部, 我们放置类型定义.&lt;/li&gt;
&lt;li&gt;之后, 我们放置每个步骤的实现.&lt;/li&gt;
&lt;li&gt;最底层, 我们将各步骤组装到主工作流函数中.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然, 我们这里只显示代码内容的大纲.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;module&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;PlaceOrderWorkflow&lt;/span&gt; =
    &lt;span style="color: #228B22"&gt;// make the shared simple types (such as&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// String50 and ProductCode) available.&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;open&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;SimpleTypes&lt;/span&gt;

    &lt;span style="color: #228B22"&gt;// make the public types exposed to the&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// callers available&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;open&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;API&lt;/span&gt;

    &lt;span style="color: #228B22"&gt;// ==============================&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// Part 1: Design&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// ==============================&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// NOTE: the public parts of the workflow -- the API --&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// such as the `PlaceOrderWorkflow` function and its&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// input `UnvalidatedOrder`, are defined elsewhere.&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// The types below are private to the workflow implementation.&lt;/span&gt;

    &lt;span style="color: #228B22"&gt;// ----- Validate Order -----&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CheckProductCodeExists&lt;/span&gt; =
        ProductCode -&amp;gt; &lt;span style="color: #00688B; font-weight: bold"&gt;bool&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CheckedAddress&lt;/span&gt; =
        CheckedAddress &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; UnvalidatedAddress
    &lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CheckAddressExists&lt;/span&gt; =
        UnvalidatedAddress -&amp;gt; CheckedAddress
    &lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;ValidateOrder&lt;/span&gt; =
        CheckProductCodeExists  &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
        -&amp;gt; CheckAddressExists   &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
        -&amp;gt; UnvalidatedOrder  &lt;span style="color: #228B22"&gt;// input&lt;/span&gt;
        -&amp;gt; ValidatedOrder  &lt;span style="color: #228B22"&gt;// output&lt;/span&gt;

    &lt;span style="color: #228B22"&gt;// ----- Price order -----&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;GetProductPrice&lt;/span&gt; = &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;PriceOrder&lt;/span&gt; = &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// etc&lt;/span&gt;

    &lt;span style="color: #228B22"&gt;// ==============================&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// Part 2: Implementation&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// ==============================&lt;/span&gt;

    &lt;span style="color: #228B22"&gt;// ------------------------------&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// ValidateOrder implementation&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// ------------------------------&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;toCustomerInfo&lt;/span&gt; (unvalidatedCustomerInfo: UnvalidatedCustomerInfo) =
        &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;toAddress&lt;/span&gt; (checkAddressExists:CheckAddressExists) unvalidatedAddress =
        &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;predicateToPassthru&lt;/span&gt; = &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;toProductCode&lt;/span&gt; (checkProductCodeExists:CheckProductCodeExists) productCode =
        &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;toOrderQuantity&lt;/span&gt; productCode quantity = &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;toValidatedOrderLine&lt;/span&gt; checkProductExists (unvalidatedOrderLine:UnvalidatedOrderLine) =
        &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// Implementation of ValidateOrder step&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;validateOrder&lt;/span&gt; : ValidateOrder =
        &lt;span style="color: #8B008B; font-weight: bold"&gt;fun&lt;/span&gt; checkProductCodeExists checkAddressExists unvalidatedOrder -&amp;gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;orderId&lt;/span&gt; =
            unvalidatedOrder.OrderId
            |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;OrderId&lt;/span&gt;.create
        &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;customerInfo&lt;/span&gt; = &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;shippingAddress&lt;/span&gt; = &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;billingAddress&lt;/span&gt; = &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;lines&lt;/span&gt; =
            unvalidatedOrder.Lines
            |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;List&lt;/span&gt;.map (toValidatedOrderLine checkProductCodeExists)
        &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;validatedOrder&lt;/span&gt; : ValidatedOrder = {
                OrderId  = orderId
                CustomerInfo = customerInfo
                ShippingAddress = shippingAddress
                BillingAddress = billingAddress
                Lines = lines
            }
            validatedOrder

    &lt;span style="color: #228B22"&gt;// ------------------------------&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// The complete workflow&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// ------------------------------&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;placeOrder&lt;/span&gt;
    checkProductExists  &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
    checkAddressExists  &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
    getProductPrice  &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
    createOrderAcknowledgmentLetter &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
    sendOrderAcknowledgment &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
    : PlaceOrderWorkflow = &lt;span style="color: #228B22"&gt;// definition of function&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;fun&lt;/span&gt; unvalidatedOrder -&amp;gt;
            &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;validatedOrder&lt;/span&gt; =
                unvalidatedOrder
                |&amp;gt; validateOrder checkProductExists checkAddressExists
            &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;pricedOrder&lt;/span&gt; =
                validatedOrder
                |&amp;gt; priceOrder getProductPrice
            &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;acknowledgementOption&lt;/span&gt; =
                pricedOrder
                |&amp;gt; acknowledgeOrder createOrderAcknowledgmentLetter sendOrderAcknowledgment
            &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;events&lt;/span&gt; =
                createEvents pricedOrder acknowledgementOption
            events
&lt;/pre&gt;&lt;/div&gt;</content><category term="函数式"></category><category term="函数式领域建模"></category><category term="函数式"></category><category term="领域驱动"></category><category term="DDD"></category></entry><entry><title>五. Modeling Workflows as Pipelines</title><link href="http://www.smallcpp.cn/wu-modeling-workflows-as-pipelines.html" rel="alternate"></link><published>2019-12-16T23:00:00+08:00</published><updated>2019-12-16T23:00:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2019-12-16:/wu-modeling-workflows-as-pipelines.html</id><summary type="html">
&lt;p&gt;现在开始对 &lt;em&gt;Place Order&lt;/em&gt; 工作流建模, 下面是我们需要建模的摘要:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;workflow "Place Order" =
    input: UnvalidatedOrder
    output (on success):
        OrderAcknowledgmentSent
        AND OrderPlaced (to send to shipping)
        AND BillableOrderPlaced (to send to billing)
    output (on error):
        ValidationError …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">
&lt;p&gt;现在开始对 &lt;em&gt;Place Order&lt;/em&gt; 工作流建模, 下面是我们需要建模的摘要:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;workflow "Place Order" =
    input: UnvalidatedOrder
    output (on success):
        OrderAcknowledgmentSent
        AND OrderPlaced (to send to shipping)
        AND BillableOrderPlaced (to send to billing)
    output (on error):
        ValidationError

    // step 1
    do ValidateOrder
    If order is invalid then:
        return with ValidationError

    // step 2
    do PriceOrder

    // step 3
    do AcknowledgeOrder

    // step 4
    create and return the events
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显然, 工作流由一系列子步骤组成: &lt;em&gt;ValidateOrder&lt;/em&gt;、&lt;em&gt;PriceOrder&lt;/em&gt; 等. 这是非常常见的情况. 许多业务流程都可以被视为一系列文档的转换, 我们可以以同样的方式对工作流进行建模.&lt;/p&gt;
&lt;p&gt;我们将创建一个 &lt;em&gt;pipeline&lt;/em&gt; 来表示业务流程, 而这个 &lt;em&gt;pipeline&lt;/em&gt; 又由一系列较小的 &lt;em&gt;pipeline&lt;/em&gt; 构建而成. 每个较小的 &lt;em&gt;pipeline&lt;/em&gt; 将执行一个转换操作, 最后, 我们将这些较小的管道粘合在一起. 这种编程风格有时被称为 “面向转换编程” (&lt;em&gt;transformation-oriented programming&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/pipeline.png"/&gt;&lt;/p&gt;
&lt;p&gt;遵循函数式编程原则, 我们将确保管道中的每个步骤都设计为无状态且无副作用, 这也意味着每个步骤都可以独立理解和测试. 一旦我们设计好了管道的部件, 我们就只需要实现和组合它们.&lt;/p&gt;
&lt;h1 id="the-workflow-input"&gt;The Workflow Input&lt;/h1&gt;
&lt;p&gt;让我们先看一下工作流的输入.&lt;/p&gt;
&lt;p&gt;工作流的输入应始终是领域对象(我们假定输入已经从 &lt;a href="http://www.smallcpp.cn/er-a-functional-architecture.html#transferring-data-between-bounded-contexts"&gt;DTO&lt;/a&gt; 中反序列化), 在我们的案例中, 它是 &lt;em&gt;UnvalidatedOrder&lt;/em&gt;, 我们之前对此进行了建模:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;UnvalidatedOrder&lt;/span&gt; = {
    OrderId : &lt;span style="color: #00688B; font-weight: bold"&gt;string&lt;/span&gt;
    CustomerInfo : UnvalidatedCustomerInfo
    ShippingAddress : UnvalidatedAddress
    &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="commands-as-input"&gt;Commands as input&lt;/h2&gt;
&lt;p&gt;工作流与启动它的命令&lt;a href="http://www.smallcpp.cn/er-a-functional-architecture.html#workflow-inputs-and-outputs"&gt;相关联&lt;/a&gt;. 从某种意义上说, &lt;em&gt;Place Order&lt;/em&gt; 工作流的实际输入实际上不是订单, 而是命令.&lt;/p&gt;
&lt;p&gt;对于 &lt;em&gt;Place Order&lt;/em&gt; 工作流, 我们将此命令称为 &lt;em&gt;PlaceOrder&lt;/em&gt;. 该命令应包含工作流处理该请求所需的所有内容, 在本例中为上面的 &lt;em&gt;UnvalidatedOrder&lt;/em&gt;. 我们可能还希望跟踪谁创建了命令, 时间戳以及其它的一些元数据, 因此命令类型可能最终看起来像这样:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;PlaceOrder&lt;/span&gt; = {
    OrderForm : UnvalidatedOrder
    Timestamp: DateTime
    UserId: &lt;span style="color: #00688B; font-weight: bold"&gt;string&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// etc&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="sharing-common-structures-using-generics"&gt;Sharing Common Structures Using Generics&lt;/h2&gt;
&lt;p&gt;当然, 我们不止这一个命令需要建模, 而每一个命令都会拥有相对关联工作流所需的数据, 但也会有一些所有命令都通用的数据, 例如 &lt;em&gt;Timestamp&lt;/em&gt; 和 &lt;em&gt;UserId&lt;/em&gt;. 我们真的需要一遍又一遍地实现相同的字段吗? 没有共享它们的方法吗?&lt;/p&gt;
&lt;p&gt;如果我们在进行面向对象的设计, 则显而易见的解决方案是使用包含公共字段的基类, 然后让每个特定的命令都从它继承.&lt;/p&gt;
&lt;p&gt;在函数式的世界中, 我们可以通过使用&lt;strong&gt;泛型&lt;/strong&gt;来实现相同的目标. 我们首先定义一个 &lt;em&gt;Command&lt;/em&gt; 类型, 其中包含通用字段和特定于命令的数据的插槽, 如下所示:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;Command&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;'&lt;/span&gt;data&amp;gt; = {
    Data : &lt;span style="color: #8B008B; font-weight: bold"&gt;'&lt;/span&gt;data
    Timestamp: DateTime
    UserId: &lt;span style="color: #00688B; font-weight: bold"&gt;string&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// etc&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后, 我们只需指定数据插槽中的类型即可创建特定于工作流的命令:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;PlaceOrder&lt;/span&gt; = Command&amp;lt;UnvalidatedOrder&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="combining-multiple-commands-in-one-type"&gt;Combining Multiple Commands in One Type&lt;/h2&gt;
&lt;p&gt;在一些情况下, 一个界限上下文的所有命令都在同一输入通道(例如消息队列)上发送, 因此我们可以用某种方式将它们组成为一个可以序列化的数据结构.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/commands.png"/&gt;&lt;/p&gt;
&lt;p&gt;解决方案很明显: 只需创建一个包含所有命令的 OR 类型. 例如, 如果需要从 &lt;em&gt;PlaceOrder&lt;/em&gt;, &lt;em&gt;ChangeOrder&lt;/em&gt; 和 &lt;em&gt;CancelOrder&lt;/em&gt; 中进行选择, 则可以创建如下类型:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;OrderTakingCommand&lt;/span&gt; =
    | Place &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; PlaceOrder
    | Change &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; ChangeOrder
    | Cancel &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; CancelOrder
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该 OR 类型将映射到 &lt;em&gt;DTO&lt;/em&gt; 并在输入通道上进行序列化和反序列化. 我们只需要在界限上下文的边缘添加一个新的路由或调度阶段(洋葱架构的基础结构层).&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/command-refactor.png"/&gt;&lt;/p&gt;
&lt;h1 id="modeling-an-order-as-a-set-of-states"&gt;Modeling an Order as a Set of States&lt;/h1&gt;
&lt;p&gt;从我们对工作流的先前理解中可以清楚地看到, &lt;em&gt;Order&lt;/em&gt; 并不是一个静态文档, 而实际上是通过一系列不同的状态转换的:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/state.png"/&gt;&lt;/p&gt;
&lt;p&gt;我们应该如何为这些状态建模? 一个简单的方法是创建一个单一的 AND 类型, 该类型使用标志捕获所有不同的状态, 如下所示:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;Order&lt;/span&gt; = {
    OrderId : OrderId
    &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
    IsValidated : &lt;span style="color: #00688B; font-weight: bold"&gt;bool&lt;/span&gt; &lt;span style="color: #228B22"&gt;// set when validated&lt;/span&gt;
    IsPriced : &lt;span style="color: #00688B; font-weight: bold"&gt;bool&lt;/span&gt; &lt;span style="color: #228B22"&gt;// set when priced&lt;/span&gt;
    AmountToBill : &lt;span style="color: #00688B; font-weight: bold"&gt;decimal&lt;/span&gt; option &lt;span style="color: #228B22"&gt;// also set when priced&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但这有很多问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;状态是隐式的, 并且需要大量条件代码才能进行处理.&lt;/li&gt;
&lt;li&gt;有些状态拥有其它状态不需要的数据, 将它们全部记录在一条数据结构中会使设计复杂化. 例如, 仅在 &lt;em&gt;Priced&lt;/em&gt; 状态下才需要 &lt;em&gt;AmountToBill&lt;/em&gt;, 但由于在其它状态中不存在, 因此我们必须将该字段设为可选.&lt;/li&gt;
&lt;li&gt;目前尚不清楚哪些字段与哪些标志相关联. 例如设置 &lt;em&gt;IsPriced&lt;/em&gt; 时需要设置 &lt;em&gt;AmountToBill&lt;/em&gt;, 但是代码设计中并没有强制措施, 所以我们必须依靠注释提醒来保持数据一致性.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一种更好的建模方式是为订单的每个状态创建一个独立的新类型, 这使我们可以消除隐式状态和条件字段.&lt;/p&gt;
&lt;p&gt;可以直接从我们之前创建的领域文档中定义类型. 例如, 下面是 &lt;em&gt;ValidatedOrder&lt;/em&gt; 的领域文档:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;data ValidatedOrder =
    ValidatedCustomerInfo
    AND ValidatedShippingAddress
    AND ValidatedBillingAddress
    AND &lt;span style="color: #00688B; font-weight: bold"&gt;list&lt;/span&gt; &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; ValidatedOrderLine
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而下面这是 &lt;em&gt;ValidatedOrder&lt;/em&gt; 的相应的类型定义, 这是一种直接的翻译(低表示化差异, 除了需要添加 &lt;em&gt;OrderId&lt;/em&gt;, 因为必须在整个工作流中维护订单身份):&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;ValidatedOrder&lt;/span&gt; = {
    OrderId : OrderId
    CustomerInfo : CustomerInfo
    ShippingAddress : Address
    BillingAddress : Address
    OrderLines : ValidatedOrderLine &lt;span style="color: #00688B; font-weight: bold"&gt;list&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以用相同的方式为 &lt;em&gt;PricedOrder&lt;/em&gt; 创建类型, 并为价格信息添加额外的字段:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;PricedOrder&lt;/span&gt; = {
    OrderId : &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
    CustomerInfo : CustomerInfo
    ShippingAddress : Address
    BillingAddress : Address
    &lt;span style="color: #228B22"&gt;// different from ValidatedOrder&lt;/span&gt;
    OrderLines : PricedOrderLine &lt;span style="color: #00688B; font-weight: bold"&gt;list&lt;/span&gt;
    AmountToBill : BillingAmount
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后, 我们可以创建一个顶级类型, 它是所有状态之间的选择:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;Order&lt;/span&gt; =
    | Unvalidated &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; UnvalidatedOrder
    | Validated &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; ValidatedOrder
    | Priced &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; PricedOrder
    &lt;span style="color: #228B22"&gt;// etc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是可以代表生命周期中任何阶段的订单对象, 并且是可以持久化或传达给其它上下文的类型.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请注意, 我们不会在这组选择中包括 &lt;em&gt;Quote&lt;/em&gt;, 因为这不是订单可以进入的状态, 而是一个完全不同的工作流.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="adding-new-state-types-as-requirements-change"&gt;Adding New State Types as Requirements Change&lt;/h2&gt;
&lt;p&gt;关于为每个状态使用单独类型的一个好处是, 可以在不破坏现有代码的情况下添加新状态. 例如, 如果我们需要支持退款, 则可以添加一个新状态 &lt;em&gt;RefundedOrder&lt;/em&gt; 以及该状态所需的任何信息. 因为其它状态是独立定义的, 所以正在使用它们的任何代码都不会受到更改的影响.&lt;/p&gt;
&lt;h1 id="state-machines"&gt;State Machines&lt;/h1&gt;
&lt;p&gt;其实我们在&lt;a href="http://www.smallcpp.cn/si-integrity-and-consistency-in-the-domain.html#capturing-business-rules-in-the-type-system"&gt;之前&lt;/a&gt;也做过类似的设计了. 这些情况在业务建模场景中极为常见. 在典型模型中, 文档或记录可以处于一种或多种状态, 而一种状态到另一种状态的转换由某种类型的命令触发, 这被称为状态机.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/state-machines.png"/&gt;&lt;/p&gt;
&lt;p&gt;我们将在这里讨论的状态机的类型要简单得多, 最多只有少数几种情况, 转换次数很少. 例如:&lt;/p&gt;
&lt;p&gt;例子一, 之前提到的, 电子邮件地址可能具有 “未验证” 和 “已验证” 状态, 可以在其中通过要求用户单击确认电子邮件中的链接来从 “未验证” 转换为 “已验证”.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/state-machines1.png"/&gt;&lt;/p&gt;
&lt;p&gt;例子二, 购物车的状态可能为 “空”, “有效” 和 “已付款”, 可以通过向购物车中添加商品来从 “空” 转变为 “有效”, 并通过支付将其转换为 “已付款”.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/state-machines2.png"/&gt;&lt;/p&gt;
&lt;p&gt;例子三, 包裹交付可能具有 “未交付”, “待交付” 和 “已交付” 三种状态, 您可以通过将包裹放在交付卡车上从 “未交付” 转换为 “已交付”, 依此类推.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/state-machines3.png"/&gt;&lt;/p&gt;
&lt;h2 id="why-use-state-machines"&gt;Why Use State Machines?&lt;/h2&gt;
&lt;p&gt;在这些情况下使用状态机有很多好处:&lt;/p&gt;
&lt;p&gt;— 每个状态可以具有不同的行为.&lt;/p&gt;
&lt;p&gt;例如, 在购物车示例中, 只能为有效的购物车付款. 在上一章中, 当我们讨论 “未验证/已验证” 的电子邮件设计时, 有一条业务规则说只能将密码重置发送到已验证的电子邮件地址. 通过为每个状态使用不同的类型, 我们可以利用编译器确保符合业务规则, 直接在函数签名中对该要求进行编码.&lt;/p&gt;
&lt;p&gt;— 所有状态均被明确记录.&lt;/p&gt;
&lt;p&gt;(没想好怎么翻译, 先放下原文) It is all too easy to have important states that are implicit but never documented. In the shopping cart example, the “empty cart” has different behavior from the “active cart” but it would be rare to see this documented explicitly in code.&lt;/p&gt;
&lt;p&gt;— 它是一种设计工具, 可迫使我们考虑可能发生的每种可能性.&lt;/p&gt;
&lt;p&gt;设计中常见的错误原因是某些边缘情况没有得到处理. 状态机强制考虑所有情况. 例如:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果我们尝试验证已验证的电子邮件, 会发生什么?&lt;/li&gt;
&lt;li&gt;如果我们尝试从空的购物车中删除商品, 会发生什么?&lt;/li&gt;
&lt;li&gt;如果我们尝试交付已处于 “已交付” 状态的包裹, 会发生什么&lt;/li&gt;
&lt;li&gt;等等. 从状态的角度考虑设计会迫使这些问题浮出水面, 并阐明领域逻辑.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="how-to-implement-simple-state-machines-in-f"&gt;How to Implement Simple State Machines in F&lt;/h2&gt;
&lt;p&gt;这是对购物车使用状态机的示例:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;Item&lt;/span&gt; = &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;ActiveCartData&lt;/span&gt; = { UnpaidItems: Item &lt;span style="color: #00688B; font-weight: bold"&gt;list&lt;/span&gt; }

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;PaidCartData&lt;/span&gt; = { PaidItems: Item &lt;span style="color: #00688B; font-weight: bold"&gt;list&lt;/span&gt;; Payment: &lt;span style="color: #00688B; font-weight: bold"&gt;float&lt;/span&gt; }

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;ShoppingCart&lt;/span&gt; =
    | EmptyCart &lt;span style="color: #228B22"&gt;// no data&lt;/span&gt;
    | ActiveCart &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; ActiveCartData
    | PaidCart &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; PaidCartData
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;ActiveCartData&lt;/em&gt; 和 &lt;em&gt;PaidCartData&lt;/em&gt; 状态各自具有自己的类型. &lt;em&gt;EmptyCart&lt;/em&gt; 状态没有与之关联的数据, 因此不需要特殊类型.&lt;/p&gt;
&lt;p&gt;而命令的处理程序是一个接受整个状态机(OR 类型)并返回状态机新版本(更新后的 OR 类型)的函数.&lt;/p&gt;
&lt;p&gt;假设我们要向购物车中添加商品, 状态转换函数 &lt;em&gt;addItem&lt;/em&gt; 带有 &lt;em&gt;ShoppingCart&lt;/em&gt; 参数和要添加的项目, 如下所示:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;addItem&lt;/span&gt; cart item =
    smatch cart &lt;span style="color: #8B008B; font-weight: bold"&gt;with&lt;/span&gt;
    | EmptyCart -&amp;gt;
    &lt;span style="color: #228B22"&gt;// create a new active cart with one item&lt;/span&gt;
    ActiveCart { UnpaidItems = [ item ] }
    | ActiveCart { UnpaidItems = existingItems } -&amp;gt;
    &lt;span style="color: #228B22"&gt;// create a new ActiveCart with the item added&lt;/span&gt;
    ActiveCart { UnpaidItems = item :: existingItems }
    | PaidCart _ -&amp;gt;
    &lt;span style="color: #228B22"&gt;// ignore&lt;/span&gt;
    cart
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果是新的 &lt;em&gt;ShoppingCart&lt;/em&gt; 可能处于或未处于新状态(如果处于 “已付费” 状态).&lt;/p&gt;
&lt;p&gt;或者说我们要为购物车付款. 状态转换函数 &lt;em&gt;makePayment&lt;/em&gt; 带有 &lt;em&gt;ShoppingCart&lt;/em&gt; 参数和付款信息, 如下所示:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;makePayment&lt;/span&gt; cart payment =
    &lt;span style="color: #8B008B; font-weight: bold"&gt;match&lt;/span&gt; cart &lt;span style="color: #8B008B; font-weight: bold"&gt;with&lt;/span&gt;
    | EmptyCart -&amp;gt;
    &lt;span style="color: #228B22"&gt;// ignore&lt;/span&gt;
    cart
    | ActiveCart { UnpaidItems = existingItems } -&amp;gt;
    &lt;span style="color: #228B22"&gt;// create a new PaidCart with the payment&lt;/span&gt;
    PaidCart { PaidItems = existingItems; Payment = payment }
    | PaidCart _ -&amp;gt;
    &lt;span style="color: #228B22"&gt;// ignore&lt;/span&gt;
    cart
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果是新的 &lt;em&gt;ShoppingCart&lt;/em&gt; 可能处于 “已付款” 状态, 也可能未处于 “已付款” 状态(如果已经处于 “空” 或 “已付款” 状态).&lt;/p&gt;
&lt;p&gt;可以看到, 从调用者的角度来看, 状态的集合对于一般操作(&lt;em&gt;ShoppingCart&lt;/em&gt; 类型)被视为 “一件事”, 但是在内部处理时, 每个状态都被单独对待.&lt;/p&gt;
&lt;h1 id="modeling-each-step-in-the-workflow-with-types"&gt;Modeling Each Step in the Workflow With Types&lt;/h1&gt;
&lt;p&gt;状态机方法非常适合建模订单处理工作流, 因此, 现在让我们为每个步骤的细节建模.&lt;/p&gt;
&lt;h2 id="the-validation-step"&gt;The Validation Step&lt;/h2&gt;
&lt;p&gt;让我们从验证开始. 在之前的讨论中, 我们将 &lt;em&gt;ValidateOrder&lt;/em&gt; 子步骤记录为:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;substep "ValidateOrder" =
    input: UnvalidatedOrder
    output: ValidatedOrder OR ValidationError
    dependencies: CheckProductCodeExists, CheckAddressExists
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们可以用刚才讨论的方式定义输入和输出(&lt;em&gt;UnvalidatedOrder&lt;/em&gt; 和 &lt;em&gt;ValidatedOrder&lt;/em&gt;). 但是除了它们, 我们还看到有两个依赖项, 一个依赖项检查产品代码是否存在, 另一个依赖项检查地址是否存在.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/validate-order.png"/&gt;&lt;/p&gt;
&lt;p&gt;我们如何使用类型对这些依赖项建模呢? 简单来说, 我们只把它们当作函数, 函数的类型签名将成为我们稍后需要实现的 “接口”.&lt;/p&gt;
&lt;p&gt;例如, 要检查产品代码是否存在, 我们需要一个函数, 该函数输入一个 &lt;em&gt;ProductCode&lt;/em&gt;, 如果产品目录中存在该代码, 则返回 &lt;em&gt;true&lt;/em&gt;, 否则返回 &lt;em&gt;false&lt;/em&gt;. 我们可以定义一个 &lt;em&gt;CheckProductCodeExists&lt;/em&gt; 类型代表函数:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CheckProductCodeExists&lt;/span&gt; =
    ProductCode -&amp;gt; &lt;span style="color: #00688B; font-weight: bold"&gt;bool&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// ^input ^output&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再来看第二个依赖项, 我们需要一个函数, 该函数输入 &lt;em&gt;UnvalidatedAddress&lt;/em&gt; 并在地址有效时下返回正确地址, 或者在地址无效时返回某种验证错误.&lt;/p&gt;
&lt;p&gt;我们也许还想区分 &lt;em&gt;CheckedAddress&lt;/em&gt; (远程地址检查服务的输出)和 &lt;em&gt;Address&lt;/em&gt; 领域对象, 并且有时需要在它们之间进行转换. 但现在, 我们可以暂时只说 &lt;em&gt;CheckedAddress&lt;/em&gt; 只是 &lt;em&gt;UnvalidatedAddress&lt;/em&gt; 的包装版本:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CheckedAddress&lt;/span&gt; =
    CheckedAddress &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; UnvalidatedAddress
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后, 该远程地址检查服务将 &lt;em&gt;UnvalidatedAddress&lt;/em&gt; 作为输入, 并返回 &lt;em&gt;Result&lt;/em&gt; 类型, 其中对于成功案例具有 &lt;em&gt;CheckedAddress&lt;/em&gt; 值, 对于失败案例具有 &lt;em&gt;AddressValidationError&lt;/em&gt; 值(副作用):&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;AddressValidationError&lt;/span&gt; =
    AddressValidationError &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;string&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CheckAddressExists&lt;/span&gt; =
    UnvalidatedAddress -&amp;gt; Result&amp;lt;CheckedAddress,AddressValidationError&amp;gt;
    &lt;span style="color: #228B22"&gt;// ^input ^output&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义了依赖项之后就可以定义出 &lt;em&gt;ValidateOrder&lt;/em&gt; 函数:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;ValidateOrder&lt;/span&gt; =
    CheckProductCodeExists &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
    -&amp;gt; CheckAddressExists &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
    -&amp;gt; UnvalidatedOrder &lt;span style="color: #228B22"&gt;// input&lt;/span&gt;
    -&amp;gt; Result&amp;lt;ValidatedOrder,ValidationError&amp;gt; &lt;span style="color: #228B22"&gt;// output&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该函数的总返回值必须为 &lt;em&gt;Result&lt;/em&gt;, 因为其中一个依赖项 (&lt;em&gt;CheckAddressExists&lt;/em&gt;）返回 &lt;em&gt;Result&lt;/em&gt;. 当在任何地方使用 &lt;em&gt;Result&lt;/em&gt; 时, 它都会 “污染” 所接触的内容, 并且会传递 “结果”, 直到到达处理它的顶级函数为止.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我们将依赖项放在函数首位, 将主要输入参数放在倒数第二位(输出类型之前). 这样做的原因是使部分应用更容易(在功能上等同于依赖注入).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="the-pricing-step"&gt;The Pricing Step&lt;/h2&gt;
&lt;p&gt;让我们继续设计 &lt;em&gt;PriceOrder&lt;/em&gt; 步骤, 这是原始的领域文档:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;substep "PriceOrder" =
    input: ValidatedOrder
    output: PricedOrder
    dependencies: GetProductPrice
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它也有一个依赖项 – 一个返回给定产品价格的函数.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/price-order.png"/&gt;&lt;/p&gt;
&lt;p&gt;我们可以定义一个 &lt;em&gt;GetProductPrice&lt;/em&gt; 类型来记录这个依赖项:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;GetProductPrice&lt;/span&gt; =
    ProductCode -&amp;gt; Price
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同样, 请注意我们在这里所做的事情. &lt;em&gt;PriceOrder&lt;/em&gt; 函数需要产品目录中的信息, 但是我们没有传递某种重量级的 &lt;em&gt;IProductCatalog&lt;/em&gt; 接口, 而是传递了一个函数 (&lt;em&gt;GetProductPrice&lt;/em&gt;), 该函数恰好代表了我们现阶段对产品目录的需求. 也就是说, &lt;em&gt;GetProductPrice&lt;/em&gt; 充当了一个抽象 – 它隐藏了产品目录的存在, 只向我们提供了所需的功能, 而没有更多(类似接口隔离).&lt;/p&gt;
&lt;p&gt;&lt;em&gt;PriceOrder&lt;/em&gt; 的签名将如下所示:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;PriceOrder&lt;/span&gt; =
    GetProductPrice &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
    -&amp;gt; ValidatedOrder &lt;span style="color: #228B22"&gt;// input&lt;/span&gt;
    -&amp;gt; PricedOrder &lt;span style="color: #228B22"&gt;// output&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个函数始终成功, 因此无需返回 &lt;em&gt;Result&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id="the-acknowledge-order-step"&gt;The Acknowledge Order Step&lt;/h2&gt;
&lt;p&gt;下一步是 &lt;em&gt;Acknowledge&lt;/em&gt; 步骤, 它将创建一封确认信, 并将其发送给客户.&lt;/p&gt;
&lt;p&gt;首先是为 “确认信” 建模. 现在假设它只包含一个 HTML 字符串即可. 我们将 HTML 字符串建模为简单类型, 并将 &lt;em&gt;OrderAcknowledgment&lt;/em&gt; 建模为 AND 类型, 其中包含邮件地址和邮件内容(HTML 字符串):&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;HtmlString&lt;/span&gt; =
    HtmlString &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;string&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;OrderAcknowledgment&lt;/span&gt; = {
    EmailAddress : EmailAddress
    Letter : HtmlString
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们怎么知道这封信的内容是什么? 有可能是根据客户信息和订单详细信息, 然后从某种模板中创建内容.&lt;/p&gt;
&lt;p&gt;但与其将这种逻辑嵌入到工作流中, 不如让它成为其他人的问题! 也就是说, 我们假设某个服务函数将为我们生成内容, 而我们要做的就是将 &lt;em&gt;PricedOrder&lt;/em&gt; 提供给这个服务函数.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CreateOrderAcknowledgmentLetter&lt;/span&gt; =
    PricedOrder -&amp;gt; HtmlString
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们将这个函数作为 &lt;em&gt;Acknowledge&lt;/em&gt; 步骤的依赖项.&lt;/p&gt;
&lt;p&gt;一旦有了信件后, 我们需要发送它. 我们应该怎么做? 我们应该直接调用某种 API, 还是将确认信息写入消息队列, 或者是其它的什么方式?&lt;/p&gt;
&lt;p&gt;幸运的是, 我们现在无需决定这些问题. 我们可以先不讨论确切的实现, 而只关注需要的接口. 和以前一样, 现在我们所需要做的设计就是定义一个函数, 该函数将 &lt;em&gt;OrderAcknowledgment&lt;/em&gt; 作为输入并为我们发送出去 – 我们不在乎具体怎么发.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;SendOrderAcknowledgment&lt;/span&gt; =
    OrderAcknowledgment -&amp;gt; &lt;span style="color: #00688B; font-weight: bold"&gt;unit&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里, 该函数未返回任何结果, 我们使用 &lt;em&gt;unit&lt;/em&gt; 来表示存在一些我们不关心的副作用.&lt;/p&gt;
&lt;p&gt;如果我们想要从 &lt;em&gt;Place Order&lt;/em&gt; 工作流中返回一个 &lt;em&gt;OrderAcknowledgmentSent&lt;/em&gt; 事件, 但是上面这种设计, 我们无法确认是否成功发送. 因此, 我们需要进行更改, 一个明显的选择是返回一个布尔值, 然后我们可以根据它来决定是否创建事件:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;SendOrderAcknowledgment&lt;/span&gt; =
    OrderAcknowledgment -&amp;gt; &lt;span style="color: #00688B; font-weight: bold"&gt;bool&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是, 在设计中布尔值通常是一个错误的选择, 因为布尔值信息不多. 最好使用简单的 &lt;em&gt;Sent/NotSent&lt;/em&gt; OR 类型而不是bool:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;SendResult&lt;/span&gt; = Sent | NotSent

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;SendOrderAcknowledgment&lt;/span&gt; =
    OrderAcknowledgment -&amp;gt; SendResult
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者, 我们应该让服务本身返回 &lt;em&gt;OrderAcnowledgmentSent&lt;/em&gt; 事件?&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;SendOrderAcknowledgment&lt;/span&gt; =
    OrderAcknowledgment -&amp;gt; OrderAcknowledgmentSent option
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但如果这样做, 我们会因为事件类型在领域和服务之间创建了耦合. 因此, 我们现在将继续使用 &lt;em&gt;Sent/NotSent&lt;/em&gt; 方案(以后需要的话可以再更改它).&lt;/p&gt;
&lt;p&gt;最后是定义 &lt;em&gt;Acknowledge Order&lt;/em&gt; 的输出 – &lt;em&gt;OrderAcknowledgmentSent&lt;/em&gt;:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;OrderAcknowledgmentSent&lt;/span&gt; = {
    OrderId : OrderId
    EmailAddress : EmailAddress
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在, 让我们将所有这些放在一起以定义此步骤的函数类型:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;AcknowledgeOrder&lt;/span&gt; =
    CreateOrderAcknowledgmentLetter &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
    -&amp;gt; SendOrderAcknowledgment &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
    -&amp;gt; PricedOrder &lt;span style="color: #228B22"&gt;// input&lt;/span&gt;
    -&amp;gt; OrderAcknowledgmentSent option &lt;span style="color: #228B22"&gt;// output&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该函数返回一个可选事件, 因为可能 &lt;em&gt;acknowledgement&lt;/em&gt; 没有成功发送.&lt;/p&gt;
&lt;h2 id="creating-the-events-to-return"&gt;Creating the Events To Return&lt;/h2&gt;
&lt;p&gt;上一步将为我们创建 &lt;em&gt;OrderAcknowledgmentSent&lt;/em&gt; 事件, 但是我们仍然需要创建 &lt;em&gt;OrderPlaced&lt;/em&gt; 事件(用于运输)和 &lt;em&gt;BillableOrderPlaced&lt;/em&gt; 事件(用于计费).&lt;/p&gt;
&lt;p&gt;这些很容易定义: &lt;em&gt;OrderPlaced&lt;/em&gt; 事件可以只是 &lt;em&gt;PricedOrder&lt;/em&gt; 的别名, 而 &lt;em&gt;BillableOrderPlaced&lt;/em&gt; 只是 &lt;em&gt;PricedOrder&lt;/em&gt; 的一个子集:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;OrderPlaced&lt;/span&gt; = PricedOrder

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;BillableOrderPlaced&lt;/span&gt; = {
  OrderId : OrderId
  BillingAddress: Address
  AmountToBill : BillingAmount
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要实际返回事件, 我们可以创建一个特殊的类型来保存它们, 如下所示:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;PlaceOrderResult&lt;/span&gt; = {
    OrderPlaced : OrderPlaced
    BillableOrderPlaced : BillableOrderPlaced
    OrderAcknowledgmentSent : OrderAcknowledgmentSent option
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是在以后我们很可能会在此工作流中添加新的事件, 定义这样的特殊 AND 类型使更改变得更加困难.&lt;/p&gt;
&lt;p&gt;所以, 为什么我们不让工作流返回事件列表, 其中事件可以是 &lt;em&gt;OrderPlaced&lt;/em&gt;, &lt;em&gt;BillableOrderPlaced&lt;/em&gt;, &lt;em&gt;OrderAcknowledgmentSent&lt;/em&gt; 中的一个.&lt;/p&gt;
&lt;p&gt;也就是说, 我们将定义一个 &lt;em&gt;OrderPlacedEvent&lt;/em&gt;, 它是这样的 OR 类型:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;PlaceOrderEvent&lt;/span&gt; =
    | OrderPlaced &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; OrderPlaced
    | BillableOrderPlaced &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; BillableOrderPlaced
    | AcknowledgmentSent &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; OrderAcknowledgmentSent
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后, 工作流的最后一步将发出这些事件的列表:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CreateEvents&lt;/span&gt; =
    PricedOrder -&amp;gt; PlaceOrderEvent &lt;span style="color: #00688B; font-weight: bold"&gt;list&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果我们需要处理新事件, 可以将其添加到选项中, 而不会破坏整个工作流. 而且, 如果发现相同的事件出现在领域中的多个工作流中, 我们甚至可以升级并创建一个更通用的 &lt;em&gt;OrderTakingDomainEvent&lt;/em&gt; 作为领域中所有事件的选择.&lt;/p&gt;
&lt;h1 id="documenting-effects"&gt;Documenting Effects&lt;/h1&gt;
&lt;p&gt;在&lt;a href="http://www.smallcpp.cn/san-domain-modeling-with-types.html#documenting-effects-in-the-function-signature"&gt;前面的讨论&lt;/a&gt;中, 我们提到了在类型签名中记录副作用: 此函数可以产生什么效果? 会返回错误吗? 它有 I/O 吗?&lt;/p&gt;
&lt;p&gt;让我们快速回顾一下我们所有的依赖关系, 并仔细检查是否需要明确说明此类副作用.&lt;/p&gt;
&lt;h2 id="effects-in-the-validation-step"&gt;Effects in the Validation Step&lt;/h2&gt;
&lt;p&gt;验证步骤具有两个依赖性: &lt;em&gt;CheckProductCodeExists&lt;/em&gt; 和 &lt;em&gt;CheckAddressExists&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;先来看一看 &lt;em&gt;CheckProductCodeExists&lt;/em&gt;:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CheckProductCodeExists&lt;/span&gt; =
    ProductCode -&amp;gt; &lt;span style="color: #00688B; font-weight: bold"&gt;bool&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个函数是远程调用吗? 或者可能会返回错误吗? 让我们假设这些都没有. 我们希望可以使用产品目录的本地缓存, 我们可以快速访问它.&lt;/p&gt;
&lt;p&gt;另外我们已经知道 &lt;em&gt;CheckAddressExists&lt;/em&gt; 函数是远程调用, 而不是领域内的本地服务, 因此它具有 &lt;em&gt;Async&lt;/em&gt; 和 &lt;em&gt;Result&lt;/em&gt; 副作用. 实际上, &lt;em&gt;Async&lt;/em&gt; 和 &lt;em&gt;Result&lt;/em&gt; 经常一起出现, 因此我们通常使用 &lt;em&gt;AsyncResult&lt;/em&gt; 别名将它们组合为一种类型:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;AsyncResult&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;'&lt;/span&gt;success,&lt;span style="color: #8B008B; font-weight: bold"&gt;'&lt;/span&gt;failure&amp;gt; =
    Async&amp;lt;Result&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;'&lt;/span&gt;success,&lt;span style="color: #8B008B; font-weight: bold"&gt;'&lt;/span&gt;failure&amp;gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样, 我们现在可以将 &lt;em&gt;CheckAddressExists&lt;/em&gt; 的返回类型从 &lt;em&gt;Result&lt;/em&gt; 更改为 &lt;em&gt;AsyncResult&lt;/em&gt;, 以指示该函数具有异步和错误副作用:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CheckAddressExists&lt;/span&gt; =
    UnvalidatedAddress -&amp;gt; AsyncResult&amp;lt;CheckedAddress,AddressValidationError&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在从类型签名中可以明显看出 &lt;em&gt;CheckAddressExists&lt;/em&gt; 函数正在执行 I/O, 并且可能会失败. 之前谈到界限上下文时, 我们说自治(&lt;em&gt;autonomy&lt;/em&gt;)是一个关键因素, 那么是否意味着我们应该尝试创建地址验证服务的本地版本? 这取决于 &lt;em&gt;Ollie&lt;/em&gt;(业务领域专家) 提起此服务时是否要求具有很高的可用性(此例中没有).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请记住, 想要自治的主要原因不是性能, 而是致力于高可用的服务.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就像 &lt;em&gt;Result&lt;/em&gt; 一样, &lt;em&gt;Async&lt;/em&gt; 对于包含它的任何代码都具有感染力. 因此必须更改整个 &lt;em&gt;ValidateOrder&lt;/em&gt; 步骤以也返回 &lt;em&gt;AsyncResult&lt;/em&gt;:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;ValidateOrder&lt;/span&gt; =
    CheckProductCodeExists &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
    -&amp;gt; CheckAddressExists &lt;span style="color: #228B22"&gt;// AsyncResult dependency&lt;/span&gt;
    -&amp;gt; UnvalidatedOrder &lt;span style="color: #228B22"&gt;// input&lt;/span&gt;
    -&amp;gt; AsyncResult&amp;lt;ValidatedOrder,ValidationError &lt;span style="color: #00688B; font-weight: bold"&gt;list&lt;/span&gt;&amp;gt; &lt;span style="color: #228B22"&gt;// output&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="effects-in-the-pricing-step"&gt;Effects in the Pricing Step&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;PriceOrder&lt;/em&gt; 步骤只有 &lt;em&gt;GetProductPrice&lt;/em&gt; 一个依赖. 我们将再次假设产品目录是本地的(例如缓存在内存中), 因此这个依赖项不是异步的, 而且据我们所知也不会有错误. 因此 &lt;em&gt;GetProductPrice&lt;/em&gt; 没有任何副作用.&lt;/p&gt;
&lt;p&gt;但是&lt;em&gt;PriceOrder&lt;/em&gt; 步骤本身很可能会返回错误. 假设某商品定价错误, 因此整个 &lt;em&gt;AmountToBill&lt;/em&gt; 很大(或负数). 这是我们应该捕获的东西. 所以现在我们还需要一个错误类型, 我们将其称为 &lt;em&gt;PricingError&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;PriceOrder&lt;/em&gt; 函数现在如下所示:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;PricingError&lt;/span&gt; =
    PricingError &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;string&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;PriceOrder&lt;/span&gt; =
    GetProductPrice &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
    -&amp;gt; ValidatedOrder &lt;span style="color: #228B22"&gt;// input&lt;/span&gt;
    -&amp;gt; Result&amp;lt;PricedOrder,PricingError&amp;gt; &lt;span style="color: #228B22"&gt;// output&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="effects-in-the-acknowledge-step"&gt;Effects in the Acknowledge Step&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;AcknowledgeOrder&lt;/em&gt; 步骤具有两个依赖项:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;CreateOrderAcknowledgmentLetter&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;SendOrderAcknowledgment&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;CreateOrderAcknowledgmentLetter&lt;/em&gt; 函数会返回错误吗? 也许不会, 我们将假定它是本地的, 并使用已缓存的模板. 因此, 总的来说, &lt;em&gt;CreateOrderAcknowledgmentLetter&lt;/em&gt; 函数没有任何需要在类型签名中记录的副作用.&lt;/p&gt;
&lt;p&gt;另一方面, 我们知道 &lt;em&gt;SendOrderAcknowledgment&lt;/em&gt; 将执行 I/O, 因此有异步副作用. 那是否有错误呢？此处我们不在乎错误的详细信息, 即使有错误, 我们也要忽略它并继续执行. 因此, 这意味着修订后的 &lt;em&gt;SendOrderAcknowledgment&lt;/em&gt; 将具有 &lt;em&gt;Async&lt;/em&gt; 类型, 而不是 &lt;em&gt;Result&lt;/em&gt; 类型:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;SendOrderAcknowledgment&lt;/span&gt; =
    OrderAcknowledgment -&amp;gt; Async&amp;lt;SendResult&amp;gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;AcknowledgeOrder&lt;/span&gt; =
    CreateOrderAcknowledgmentLetter &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
    -&amp;gt; SendOrderAcknowledgment &lt;span style="color: #228B22"&gt;// Async dependency&lt;/span&gt;
    -&amp;gt; PricedOrder &lt;span style="color: #228B22"&gt;// input&lt;/span&gt;
    -&amp;gt; Async&amp;lt;OrderAcknowledgmentSent option&amp;gt; &lt;span style="color: #228B22"&gt;// Async output&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="composing-the-workflow-from-the-steps"&gt;Composing the Workflow From the Steps&lt;/h1&gt;
&lt;p&gt;现在我们定义了所有步骤, 当我们实现它们时, 应该能够将一个步骤的输出连接到下一个步骤的输入, 从而建立整个工作流.&lt;/p&gt;
&lt;p&gt;让我们把那些步骤的定义拿出来放在一起, 并删除依赖项, 以便观察仅列出输入和输出.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;ValidateOrder&lt;/span&gt; =
    UnvalidatedOrder &lt;span style="color: #228B22"&gt;// input&lt;/span&gt;
    -&amp;gt; AsyncResult&amp;lt;ValidatedOrder,ValidationError &lt;span style="color: #00688B; font-weight: bold"&gt;list&lt;/span&gt;&amp;gt; &lt;span style="color: #228B22"&gt;// output&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;PriceOrder&lt;/span&gt; =
    ValidatedOrder &lt;span style="color: #228B22"&gt;// input&lt;/span&gt;
    -&amp;gt; Result&amp;lt;PricedOrder,PricingError&amp;gt; &lt;span style="color: #228B22"&gt;// output&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;AcknowledgeOrder&lt;/span&gt; =
    PricedOrder &lt;span style="color: #228B22"&gt;// input&lt;/span&gt;
    -&amp;gt; Async&amp;lt;OrderAcknowledgmentSent option&amp;gt; &lt;span style="color: #228B22"&gt;// output&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CreateEvents&lt;/span&gt; =
    PricedOrder &lt;span style="color: #228B22"&gt;// input&lt;/span&gt;
    -&amp;gt; PlaceOrderEvent &lt;span style="color: #00688B; font-weight: bold"&gt;list&lt;/span&gt; &lt;span style="color: #228B22"&gt;// output&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;PriceOrder&lt;/em&gt; 的输入需要一个 &lt;em&gt;ValidatedOrder&lt;/em&gt;, 但是 &lt;em&gt;ValidateOrder&lt;/em&gt; 的输出是 &lt;em&gt;AsyncResult&lt;/em&gt;, 这似乎根本不匹配. 同样, &lt;em&gt;PriceOrder&lt;/em&gt; 步骤的输出不能用作 &lt;em&gt;AcknowledgeOrder&lt;/em&gt; 的输入, 依此类推.&lt;/p&gt;
&lt;p&gt;为了组合这些函数, 我们将不得不处理输入和输出类型, 以便它们兼容并可以装配在一起. 在进行类型驱动的设计时(type-driven design), 这是一个常见的挑战, 我们将在[实现章节]中了解如何做到这一点.&lt;/p&gt;
&lt;h1 id="are-dependencies-part-of-the-design"&gt;Are Dependencies Part of the Design?&lt;/h1&gt;
&lt;p&gt;在上面的代码中, 我们将对其他上下文的调用(例如 &lt;em&gt;CheckProductCodeExists&lt;/em&gt; 和 &lt;em&gt;ValidateAddress&lt;/em&gt;)视为依赖项记录. 我们为工作流的每个子步骤的依赖都设计了明确的额外参数:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;ValidateOrder&lt;/span&gt; =
    CheckProductCodeExists &lt;span style="color: #228B22"&gt;// explicit dependency&lt;/span&gt;
    -&amp;gt; CheckAddressExists &lt;span style="color: #228B22"&gt;// explicit dependency&lt;/span&gt;
    -&amp;gt; UnvalidatedOrder &lt;span style="color: #228B22"&gt;// input&lt;/span&gt;
    -&amp;gt; AsyncResult&amp;lt;ValidatedOrder,ValidationError &lt;span style="color: #00688B; font-weight: bold"&gt;list&lt;/span&gt;&amp;gt; &lt;span style="color: #228B22"&gt;// output&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;PriceOrder&lt;/span&gt; =
    GetProductPrice &lt;span style="color: #228B22"&gt;// explicit dependency&lt;/span&gt;
    -&amp;gt; ValidatedOrder &lt;span style="color: #228B22"&gt;// input -&amp;gt; Result&amp;lt;PricedOrder,PricingError&amp;gt; // output&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有人可能会争辩说, 任何流程如何执行其工作都应该对我们隐藏, 我们是否真的在乎它需要与哪些系统协作(指明确的额外参数)以实现其目标? 如果从这一角度出发, 流程定义将简化为仅输入和输出, 如下所示:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;ValidateOrder&lt;/span&gt; =
    UnvalidatedOrder &lt;span style="color: #228B22"&gt;// input&lt;/span&gt;
    -&amp;gt; AsyncResult&amp;lt;ValidatedOrder,ValidationError &lt;span style="color: #00688B; font-weight: bold"&gt;list&lt;/span&gt;&amp;gt; &lt;span style="color: #228B22"&gt;// output&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;PriceOrder&lt;/span&gt; =
    ValidatedOrder &lt;span style="color: #228B22"&gt;// input&lt;/span&gt;
    -&amp;gt; Result&amp;lt;PricedOrder,PricingError&amp;gt; &lt;span style="color: #228B22"&gt;// output&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;哪一种方式更好呢? 设计永远不会有正确的答案, 但总有些准则可以遵循:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于中公开出去的 API, 请对调用者隐藏依赖信息.&lt;/li&gt;
&lt;li&gt;对于内部使用的函数, 请明确说明其依赖关系.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这种情况下, 不应公开顶级 &lt;em&gt;PlaceOrder&lt;/em&gt; 工作流函数的依赖项, 因为调用者不需要了解它们. 签名应仅显示输入和输出, 如下所示:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;PlaceOrderWorkflow&lt;/span&gt; =
    PlaceOrder &lt;span style="color: #228B22"&gt;// input&lt;/span&gt;
    -&amp;gt; AsyncResult&amp;lt;PlaceOrderEvent &lt;span style="color: #00688B; font-weight: bold"&gt;list&lt;/span&gt;,PlaceOrderError&amp;gt; &lt;span style="color: #228B22"&gt;// output&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是, 对于工作流中的每个内部步骤, 都应该像在原始设计中那样明确显示依赖性. 这有助于记录每个步骤实际需要的内容. 如果某个步骤的依赖关系发生变化, 那么我们可以更改该步骤的功能定义, 这又将迫使我们更改实现.&lt;/p&gt;
&lt;h1 id="the-complete-pipeline"&gt;The Complete Pipeline&lt;/h1&gt;
&lt;p&gt;我们已经完成了设计的第一步, 让我们再回顾一下. 首先, 我们将记录下公开 API 的类型. 通常, 我们会将它们全部放在一个文件中, 例如 &lt;em&gt;DomainApi.fs&lt;/em&gt; 或其它语言中类似的文件.&lt;/p&gt;
&lt;p&gt;首先是输入的类型定义(也就是触发 &lt;em&gt;Place Order&lt;/em&gt; 工作流的命令 – &lt;em&gt;PlaceOrderCommand&lt;/em&gt;):&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;// ----------------------&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// Input data&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// ----------------------&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;UnvalidatedOrder&lt;/span&gt; = {
    OrderId : &lt;span style="color: #00688B; font-weight: bold"&gt;string&lt;/span&gt;
    CustomerInfo : UnvalidatedCustomer
    shippingAddress : UnvalidatedAddress
} &lt;span style="color: #8B008B"&gt;and&lt;/span&gt; UnvalidatedCustomer = {
    Name : &lt;span style="color: #00688B; font-weight: bold"&gt;string&lt;/span&gt;
    Email : &lt;span style="color: #00688B; font-weight: bold"&gt;string&lt;/span&gt;
} &lt;span style="color: #8B008B"&gt;and&lt;/span&gt; UnvalidatedAddress = &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;

&lt;span style="color: #228B22"&gt;// ----------------------&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// Input Command&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// ----------------------&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;Command&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;'&lt;/span&gt;data&amp;gt; = {
    Data : &lt;span style="color: #8B008B; font-weight: bold"&gt;'&lt;/span&gt;data
    Timestamp: DateTime
    UserId: &lt;span style="color: #00688B; font-weight: bold"&gt;string&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// etc&lt;/span&gt;
}

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;PlaceOrderCommand&lt;/span&gt; = Command&amp;lt;UnvalidatedOrder&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来是输出和工作流本身的定义:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #CD5555"&gt;/// Success output of PlaceOrder workflow&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;OrderPlaced&lt;/span&gt; = &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;BillableOrderPlaced&lt;/span&gt; = &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;OrderAcknowledgmentSent&lt;/span&gt; = &lt;span style="color: #228B22"&gt;//...&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;PlaceOrderEvent&lt;/span&gt; =
    | OrderPlaced &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; OrderPlaced
    | BillableOrderPlaced &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; BillableOrderPlaced
    | AcknowledgmentSent &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; OrderAcknowledgmentSent

&lt;span style="color: #CD5555"&gt;/// Failure output of PlaceOrder workflow&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;PlaceOrderError&lt;/span&gt; = &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;


&lt;span style="color: #228B22"&gt;// ----------------------&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// Public API&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// ----------------------&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;PlaceOrderWorkflow&lt;/span&gt; =
    PlaceOrderCommand &lt;span style="color: #228B22"&gt;// input command&lt;/span&gt;
    -&amp;gt; AsyncResult&amp;lt;PlaceOrderEvent &lt;span style="color: #00688B; font-weight: bold"&gt;list&lt;/span&gt;,PlaceOrderError&amp;gt; &lt;span style="color: #228B22"&gt;// output events&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="the-internal-steps"&gt;The internal steps&lt;/h2&gt;
&lt;p&gt;在单独的实现文件(例如 &lt;em&gt;PlaceOrderWorkflow.fs&lt;/em&gt;)中记录内部子步骤的类型定义, 在这些定义后面, 我们将添加实现.&lt;/p&gt;
&lt;p&gt;首先是代表订单生命周期的内部状态:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;// bring in the types from the domain API module&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;open&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;DomainApi&lt;/span&gt;

&lt;span style="color: #228B22"&gt;// ----------------------&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// Order lifecycle&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// ----------------------&lt;/span&gt;

&lt;span style="color: #228B22"&gt;// validated state&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;ValidatedOrderLine&lt;/span&gt; = &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;ValidatedOrder&lt;/span&gt; = {
    OrderId : OrderId
    CustomerInfo : CustomerInfo
    ShippingAddress : Address
    BillingAddress : Address
    OrderLines : ValidatedOrderLine &lt;span style="color: #00688B; font-weight: bold"&gt;list&lt;/span&gt;
}
&lt;span style="color: #8B008B"&gt;and&lt;/span&gt; OrderId = Undefined
&lt;span style="color: #8B008B"&gt;and&lt;/span&gt; CustomerInfo = &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;
&lt;span style="color: #8B008B"&gt;and&lt;/span&gt; Address = &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;

&lt;span style="color: #228B22"&gt;// priced state&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;PricedOrderLine&lt;/span&gt; = &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;PricedOrder&lt;/span&gt; = &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;

&lt;span style="color: #228B22"&gt;// all states combined&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;Order&lt;/span&gt; =
    | Unvalidated &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; UnvalidatedOrder
    | Validated &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; ValidatedOrder
    | Priced &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; PricedOrder
    &lt;span style="color: #228B22"&gt;// etc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后定义每个内部子步骤:：&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;// ----------------------&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// Definitions of Internal Steps&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// ----------------------&lt;/span&gt;

&lt;span style="color: #228B22"&gt;// ----- Validate order -----&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// services used by ValidateOrder&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CheckProductCodeExists&lt;/span&gt; =
    ProductCode -&amp;gt; &lt;span style="color: #00688B; font-weight: bold"&gt;bool&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;AddressValidationError&lt;/span&gt; = &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CheckedAddress&lt;/span&gt; = &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CheckAddressExists&lt;/span&gt; =
    UnvalidatedAddress
    -&amp;gt; AsyncResult&amp;lt;CheckedAddress,AddressValidationError&amp;gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;ValidateOrder&lt;/span&gt; =
    CheckProductCodeExists &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
    -&amp;gt; CheckAddressExists &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
    -&amp;gt; UnvalidatedOrder &lt;span style="color: #228B22"&gt;// input&lt;/span&gt;
    -&amp;gt; AsyncResult&amp;lt;ValidatedOrder,ValidationError &lt;span style="color: #00688B; font-weight: bold"&gt;list&lt;/span&gt;&amp;gt; &lt;span style="color: #228B22"&gt;// output&lt;/span&gt;
&lt;span style="color: #8B008B"&gt;and&lt;/span&gt; ValidationError = &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;

&lt;span style="color: #228B22"&gt;// ----- Price order -----&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// services used by PriceOrder&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;GetProductPrice&lt;/span&gt; =
    ProductCode -&amp;gt; Price

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;PricingError&lt;/span&gt; = &lt;span style="color: #228B22"&gt;// ...&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;PriceOrder&lt;/span&gt; =
    GetProductPrice &lt;span style="color: #228B22"&gt;// dependency&lt;/span&gt;
    -&amp;gt; ValidatedOrder &lt;span style="color: #228B22"&gt;// input&lt;/span&gt;
    -&amp;gt; Result&amp;lt;PricedOrder,PricingError&amp;gt; &lt;span style="color: #228B22"&gt;// output&lt;/span&gt;

&lt;span style="color: #228B22"&gt;// etc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们已经所有类型集中在一起了, 并随时可以指导实现.&lt;/p&gt;
&lt;h1 id="long-running-workflows"&gt;Long Running Workflows&lt;/h1&gt;
&lt;p&gt;对于管道(&lt;em&gt;pipeline&lt;/em&gt;), 有一个重要的假设, 那就是, 即使有远程系统调用, 该管道也将在大约几秒钟的短时间内完成.&lt;/p&gt;
&lt;p&gt;但是, 如果这些外部服务需要更长的时间才能完成该怎么办? 例如, 如果验证是由人而不是机器来完成的, 那可能会花掉整整一整天的时间, 又或者, 如果定价是由其他某个部门完成的, 那也有可能要花很长时间. 如果这些事都是真的, 它们会影响到哪些设计?&lt;/p&gt;
&lt;p&gt;首先, 我们需要在调用远程服务之前将状态保存到存储中, 然后等待一条消息告诉我们该服务已完成, 然后我们必须从存储中重新加载状态并继续执行该工作流中的下一步. 这比使用普通的异步调用要 “重” 得多, 因为我们需要在每个步骤之间保持状态.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/storage.png"/&gt;&lt;/p&gt;
&lt;p&gt;通过这样做, 我们将原始工作流分解为较小的独立块, 每个块均由事件触发. 我们甚至可以将其视为一系列单独的迷你工作流, 而不是一个工作流.&lt;/p&gt;
&lt;p&gt;在这里, 状态机模式是帮助我们思考的宝贵工具. 在执行每个步骤之前, 从存储中加载订单的当前状态, 然后迷你工作流将订单从当前状态转换为新状态, 最后, 新状态再次保存回存储中.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/state-storage.png"/&gt;&lt;/p&gt;
&lt;p&gt;这类长期运行的工作流有时称为 &lt;em&gt;&lt;a href="http://vasters.com/archive/Sagas.html"&gt;Sagas&lt;/a&gt;&lt;/em&gt;. 每当涉及 “慢人” 时，它们很常见. 另外, 在要将工作流分解成由事件(例如微服务)联系在一起的分离的独立组件时, 也可以使用它们.&lt;/p&gt;
&lt;p&gt;在我们的示例中, 工作流非常简单. 如果事件和状态的数量增加, 并且转换变得复杂, 则可能需要创建一个特殊的组件, 即流程管理器. 该组件负责处理传入的消息, 根据当前状态确定应采取的操作, 然后触发适当的工作流.&lt;/p&gt;</content><category term="函数式"></category><category term="函数式领域建模"></category><category term="函数式"></category><category term="领域驱动"></category><category term="DDD"></category></entry><entry><title>四. Integrity and Consistency in the Domain</title><link href="http://www.smallcpp.cn/si-integrity-and-consistency-in-the-domain.html" rel="alternate"></link><published>2019-12-10T15:00:00+08:00</published><updated>2019-12-10T15:00:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2019-12-10:/si-integrity-and-consistency-in-the-domain.html</id><summary type="html">
&lt;p&gt;现在, 我们构建了一组丰富的领域模型. 接下来要做的是 “&lt;a href="http://www.smallcpp.cn/er-a-functional-architecture.html#trust-boundaries-and-validation"&gt;保护好&lt;/a&gt;” 它, 因此应该采取一些预防措施, 以确保此域中的任何数据都是有效和一致的. 我们的目标是创建一个界限上下文, 该上下文始终包含我们可以信任的数据, 与不受信任的外部世界不同. 如果我们能够确保所有数据始终有效, 则实现可以保持干净, 并且我们可以避免执行防御性编程以及减少单元测试.&lt;/p&gt;
&lt;p&gt;先来看下两个很重要的概念, &lt;a href="http://www.smallcpp.cn/san-domain-modeling-with-types.html#aggregates-enforce-consistency-and-invariants"&gt;上一节&lt;/a&gt;中也有提到.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Integrity&lt;/strong&gt; (or validity) 意味着一段数据遵循正确的业务规则(Guard).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Consistency&lt;/strong&gt; 意味着领域模型的不同部分要与事实一致(有点类似事务).&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Invariants&lt;/strong&gt; are generally business rules/enforcements …&lt;/p&gt;&lt;/blockquote&gt;</summary><content type="html">
&lt;p&gt;现在, 我们构建了一组丰富的领域模型. 接下来要做的是 “&lt;a href="http://www.smallcpp.cn/er-a-functional-architecture.html#trust-boundaries-and-validation"&gt;保护好&lt;/a&gt;” 它, 因此应该采取一些预防措施, 以确保此域中的任何数据都是有效和一致的. 我们的目标是创建一个界限上下文, 该上下文始终包含我们可以信任的数据, 与不受信任的外部世界不同. 如果我们能够确保所有数据始终有效, 则实现可以保持干净, 并且我们可以避免执行防御性编程以及减少单元测试.&lt;/p&gt;
&lt;p&gt;先来看下两个很重要的概念, &lt;a href="http://www.smallcpp.cn/san-domain-modeling-with-types.html#aggregates-enforce-consistency-and-invariants"&gt;上一节&lt;/a&gt;中也有提到.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Integrity&lt;/strong&gt; (or validity) 意味着一段数据遵循正确的业务规则(Guard).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Consistency&lt;/strong&gt; 意味着领域模型的不同部分要与事实一致(有点类似事务).&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Invariants&lt;/strong&gt; are generally business rules/enforcements/requirements that you impose to maintain the &lt;strong&gt;integrity&lt;/strong&gt; of an object at any given time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在我们的例子中:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Integrity&lt;ul&gt;
&lt;li&gt;UnitQuantity 介于 1 和 1000 之间.&lt;/li&gt;
&lt;li&gt;Order 必须始终至少有一个 OrderLine.&lt;/li&gt;
&lt;li&gt;Order 在发送到运输部门之前必须具有经过验证的运输地址.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Consistency&lt;ul&gt;
&lt;li&gt;Order 的帐单总金额应为 OrderLines 的总和. 如果金额不等, 则数据不一致.&lt;/li&gt;
&lt;li&gt;下订单后, 必须创建相应的发票. 如果订单存在, 但发票不存在, 则数据不一致.&lt;/li&gt;
&lt;li&gt;如果折扣凭证代码与订单一起使用, 则必须将凭证代码标记为已使用, 以便无法再次使用. 如果订单引用该凭证, 但凭证未标记为已使用, 则数据不一致.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="integrity"&gt;Integrity&lt;/h1&gt;
&lt;h2 id="integrity-of-simple-values"&gt;Integrity of Simple Values&lt;/h2&gt;
&lt;p&gt;智能构造器&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;// private constructor&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;UnitQuantity&lt;/span&gt; = &lt;span style="color: #8B008B; font-weight: bold"&gt;private&lt;/span&gt; UnitQuantity &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; int

&lt;span style="color: #228B22"&gt;// define a module with the same name as the type&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;module&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;UnitQuantity&lt;/span&gt; =
    &lt;span style="color: #228B22"&gt;// Return the wrapped value&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;value&lt;/span&gt; (UnitQuantity qty) = qty

    &lt;span style="color: #228B22"&gt;// Define a "smart constructor" for UnitQuantity&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// int -&amp;gt; Result&amp;lt;UnitQuantity,string&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;create&lt;/span&gt; qty =
        &lt;span style="color: #8B008B; font-weight: bold"&gt;if&lt;/span&gt; qty &amp;lt; &lt;span style="color: #B452CD"&gt;1&lt;/span&gt; &lt;span style="color: #8B008B; font-weight: bold"&gt;then&lt;/span&gt;
            &lt;span style="color: #228B22"&gt;// failure&lt;/span&gt;
            Error &lt;span style="color: #CD5555"&gt;"UnitQuantity can not be negative"&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;else&lt;/span&gt; &lt;span style="color: #8B008B; font-weight: bold"&gt;if&lt;/span&gt; qty &amp;gt; &lt;span style="color: #B452CD"&gt;1000&lt;/span&gt; &lt;span style="color: #8B008B; font-weight: bold"&gt;then&lt;/span&gt;
            &lt;span style="color: #228B22"&gt;// failure&lt;/span&gt;
            Error &lt;span style="color: #CD5555"&gt;"UnitQuantity can not be more than 1000"&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;else&lt;/span&gt;
            &lt;span style="color: #228B22"&gt;// success -- construct the return value&lt;/span&gt;
            Ok (UnitQuantity qty)

&lt;span style="color: #228B22"&gt;// how to use&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;unitQtyResult&lt;/span&gt; = &lt;span style="color: #008b45; text-decoration: underline"&gt;UnitQuantity&lt;/span&gt;.create &lt;span style="color: #B452CD"&gt;1&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;match&lt;/span&gt; unitQtyResult &lt;span style="color: #8B008B; font-weight: bold"&gt;with&lt;/span&gt;
    | Error msg -&amp;gt;
        printfn &lt;span style="color: #CD5555"&gt;"Failure, Message is %s"&lt;/span&gt; msg
    | Ok uQty -&amp;gt;
        printfn &lt;span style="color: #CD5555"&gt;"Success. Value is %A"&lt;/span&gt; uQty
        &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;innerValue&lt;/span&gt; = &lt;span style="color: #008b45; text-decoration: underline"&gt;UnitQuantity&lt;/span&gt;.value uQty
        printfn &lt;span style="color: #CD5555"&gt;"innerValue is %i"&lt;/span&gt; innerValue
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you have many constrained types like this, you can reduce repetition by using a helper module that contains the common code for the constructors. We don’t have space to show that here, but there is an example in the Common.SimpleTypes.fs file in the sample code for this book.&lt;/p&gt;
&lt;p&gt;以下部分摘要:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;UnitQuantity&lt;/span&gt; = &lt;span style="color: #8B008B; font-weight: bold"&gt;private&lt;/span&gt; UnitQuantity &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; int

&lt;span style="color: #228B22"&gt;// ===============================&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// Reusable constructors and getters for constrained types&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// ===============================&lt;/span&gt;

&lt;span style="color: #228B22"&gt;// Useful functions for constrained types&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;module&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;ConstrainedType&lt;/span&gt; =

    &lt;span style="color: #228B22"&gt;// Create a constrained string using the constructor provided&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// Return Error if input is null, empty, or length &amp;gt; maxLen&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;createString&lt;/span&gt; fieldName ctor maxLen str =
        &lt;span style="color: #8B008B; font-weight: bold"&gt;if&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;String&lt;/span&gt;.IsNullOrEmpty(str) &lt;span style="color: #8B008B; font-weight: bold"&gt;then&lt;/span&gt;
            &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;msg&lt;/span&gt; = sprintf &lt;span style="color: #CD5555"&gt;"%s must not be null or empty"&lt;/span&gt; fieldName
            Error msg
        &lt;span style="color: #8B008B; font-weight: bold"&gt;elif&lt;/span&gt; str.Length &amp;gt; maxLen &lt;span style="color: #8B008B; font-weight: bold"&gt;then&lt;/span&gt;
            &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;msg&lt;/span&gt; = sprintf &lt;span style="color: #CD5555"&gt;"%s must not be more than %i chars"&lt;/span&gt; fieldName maxLen
            Error msg
        &lt;span style="color: #8B008B; font-weight: bold"&gt;else&lt;/span&gt;
            Ok (ctor str)

    &lt;span style="color: #228B22"&gt;// Create a constrained integer using the constructor provided&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// Return Error if input is less than minVal or more than maxVal&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;createInt&lt;/span&gt; fieldName ctor minVal maxVal i =
        &lt;span style="color: #8B008B; font-weight: bold"&gt;if&lt;/span&gt; i &amp;lt; minVal &lt;span style="color: #8B008B; font-weight: bold"&gt;then&lt;/span&gt;
            &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;msg&lt;/span&gt; = sprintf &lt;span style="color: #CD5555"&gt;"%s: Must not be less than %i"&lt;/span&gt; fieldName minVal
            Error msg
        &lt;span style="color: #8B008B; font-weight: bold"&gt;elif&lt;/span&gt; i &amp;gt; maxVal &lt;span style="color: #8B008B; font-weight: bold"&gt;then&lt;/span&gt;
            &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;msg&lt;/span&gt; = sprintf &lt;span style="color: #CD5555"&gt;"%s: Must not be greater than %i"&lt;/span&gt; fieldName maxVal
            Error msg
        &lt;span style="color: #8B008B; font-weight: bold"&gt;else&lt;/span&gt;
            Ok (ctor i)

    &lt;span style="color: #228B22"&gt;// etc&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;module&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;UnitQuantity&lt;/span&gt;  =

    &lt;span style="color: #228B22"&gt;// Return the value inside a UnitQuantity&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;value&lt;/span&gt; (UnitQuantity v) = v

    &lt;span style="color: #228B22"&gt;// Create a UnitQuantity from a int&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// Return Error if input is not an integer between 1 and 1000&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;create&lt;/span&gt; fieldName v =
        &lt;span style="color: #008b45; text-decoration: underline"&gt;ConstrainedType&lt;/span&gt;.createInt fieldName UnitQuantity &lt;span style="color: #B452CD"&gt;1&lt;/span&gt; &lt;span style="color: #B452CD"&gt;1000&lt;/span&gt; v
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="units-of-measure"&gt;Units of Measure&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;f#&lt;/em&gt; 独有&lt;/p&gt;
&lt;h2 id="enforcing-invariants-with-the-type-system"&gt;Enforcing Invariants with the Type System&lt;/h2&gt;
&lt;p&gt;自定义数据类型, 通过类型系统进行限制. 例如, 针对 &lt;em&gt;Order&lt;/em&gt; 必须始终至少有一个 &lt;em&gt;OrderLine&lt;/em&gt; 这个 &lt;em&gt;Invariant&lt;/em&gt;, 我们可以自定义一个列表类型, 这个自定义的列表, 不允许为空.&lt;/p&gt;
&lt;h2 id="capturing-business-rules-in-the-type-system"&gt;Capturing Business Rules in the Type System&lt;/h2&gt;
&lt;p&gt;我们来看一个接近真实的领域需求.&lt;/p&gt;
&lt;p&gt;假设我们的公司要为其客户存储电子邮件地址. 但是, 并非所有电子邮件地址都以相同的方式进行处理. 某些电子邮件地址已经过验证(即客户收到验证电子邮件并单击了验证链接); 而其他电子邮件地址未进行验证, 我们无法确定它们是否有效. 此外, 假设还有一些基于此差异的业务规则, 例如:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只应向未经验证的电子邮件地址发送验证电子邮件(以避免对现有客户发送垃圾邮件)&lt;/li&gt;
&lt;li&gt;只能向已验证的电子邮件地址发送密码重置电子邮件(以防止安全漏洞)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一种常见的方案是添加一个 &lt;em&gt;flag&lt;/em&gt; 标识出是否经过验证:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CustomerEmail&lt;/span&gt; = {
    EmailAddress : EmailAddress
    IsVerified : &lt;span style="color: #00688B; font-weight: bold"&gt;bool&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是, 这种方式的问题在于, 首先, 并不清楚何时以及为什么修改 &lt;em&gt;IsVerified&lt;/em&gt; 标志. 当然, 我们知道, 如果客户的电子邮件地址更改了, 则应将其重新设置为 &lt;em&gt;false&lt;/em&gt; (因为尚未验证新电子邮件). 但是, 代码设计中并没有任何东西可以使该规则明确. 对于开发人员而言, 很容易在更改电子邮件时意外忘记执行此操作, 或者更糟的是完全不了解该规则(因为它可能仅仅被写在注释中).&lt;/p&gt;
&lt;p&gt;同样的, 这可能还有安全漏洞 – 开发人员可能会意外地编写代码将未经验证的电子邮件的标志设置为 &lt;em&gt;true&lt;/em&gt;, 这将允许将密码重置电子邮件发送到未经验证的地址. 当然我们可以通过防御性编程防止这一点, 但是这不是我们推荐的方式.&lt;/p&gt;
&lt;p&gt;那么, 什么是更好的建模方式呢?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Referecne: &lt;a href="http://www.smallcpp.cn/wu-modeling-workflows-as-pipelines.html#state-machines"&gt;State Machines&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;答案是一如既往地关注领域本身. 当领域专家谈论 “已验证” 和 “未验证” 的电子邮件时, 应该将它们建模为独立的事物. 在这种情况下, 当领域专家说 “客户的电子邮件已验证或未验证” 时, 我们应该将其建模为两种类型之间的选择, 例如:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;EmailAddress&lt;/span&gt; = EmailAddress &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; String

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CustomerEmail&lt;/span&gt; =
    | Unverified &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; EmailAddress
    | Verified &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; EmailAddress
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是, 这并不能阻止用一个未经验证的电子邮件构造 &lt;em&gt;Verified&lt;/em&gt; 实例的意外情况. 例如:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;address&lt;/span&gt; = EmailAddress &lt;span style="color: #8B008B; font-weight: bold"&gt;'&lt;/span&gt;xxxx'  &lt;span style="color: #228B22"&gt;// 未经验证&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;verifiedEmail&lt;/span&gt; = Verified address &lt;span style="color: #228B22"&gt;// 但仍可以构造出 Verified&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了解决这个问题, 我们将创建一个新的 &lt;em&gt;VerifiedEmailAddress&lt;/em&gt; 类型用以区别于正常的 &lt;em&gt;EmailAddress&lt;/em&gt; 类型. 现在新的类型如下:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CustomerEmail&lt;/span&gt; =
    | Unverified &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; EmailAddress
    | Verified &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; VerifiedEmailAddress &lt;span style="color: #228B22"&gt;// different from normal EmailAddress&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来, 我们可以为 &lt;em&gt;VerifiedEmailAddress&lt;/em&gt; 提供一个智能构造器, 以便普通代码无法创建该类型的值 – 只有验证服务可以.&lt;/p&gt;
&lt;p&gt;这意味着, 如果我们有一个新的电子邮件地址, 则必须使用 &lt;em&gt;Unverified&lt;/em&gt; 构造 &lt;em&gt;CustomerEmail&lt;/em&gt;, 因为我们没有 &lt;em&gt;VerifiedEmailAddress&lt;/em&gt;, 而获得 &lt;em&gt;VerifiedEmailAddress&lt;/em&gt; 的唯一方法是通过电子邮件验证服务本身.&lt;/p&gt;
&lt;p&gt;这是函数式编程中一个重要的设计准则: “&lt;strong&gt;Make illegal states unrepresentable.&lt;/strong&gt;”, 我们尝试用类型系统来捕获业务规则. 如果我们能够正确实践此操作, 则代码中永远不会存在无效的情况, 并且我们永远不需要为它们编写单元测试 – 我们改为使用 “编译时” 单元测试.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Make illegal states unrepresentable&lt;/em&gt; 没想好怎么翻译…, 这句话的意思是: 使用类型系统让代码本身就无法表现出非法状态. 实践起来基本上就是多用 &lt;em&gt;sum-types&lt;/em&gt; 尽可能细粒度捕获类型.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这种方式的另一个重要好处是, 它实际上可以更好地记录领域. 通常, 一旦我们创建了这些更细粒度的类型, 我们就会立即找到它们的用途. 例如, 现在可以显式记录发送密码重置消息的工作流必须采用 &lt;em&gt;VerifiedEmailAddress&lt;/em&gt; 作为输入, 而不是作为普通的 &lt;em&gt;EmailAddress&lt;/em&gt;.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;SendPasswordResetEmail&lt;/span&gt; = VerifiedEmailAddress -&amp;gt; ...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用此定义, 我们不必担心有人因为没有阅读文档而意外地传入普通的 &lt;em&gt;EmailAddress&lt;/em&gt;. 我们不再需要防御性编程和单元测试(或更少).&lt;/p&gt;
&lt;p&gt;下面是另一个示例, 假设我们有一个业务规则, 需要某种联系客户的方式: “A customer must have an email or a postal address”.&lt;/p&gt;
&lt;p&gt;我们应该如何表示这一点? 显而易见的方式是使用 &lt;em&gt;Email&lt;/em&gt; 和 &lt;em&gt;Address&lt;/em&gt; 属性来创建类型, 如下所示:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;Contact&lt;/span&gt; = {
    Name: Name
    Email: EmailContactInfo
    Address: PostalContactInfo
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但这是一个错误的设计. 这意味着同时需要电子邮件和地址. 好, 现在让它们可选.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;Contact&lt;/span&gt; = {
    Name: Name
    Email: EmailContactInfo option
    Address: PostalContactInfo option
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但这也不正确. 因为有可能电子邮件和地址都为空, 这将破坏业务规则. 当然, 我们可以添加特殊的运行时验证检查(防御性编程), 以确保不会发生这种情况. 但是我们可以做得更好 – &lt;em&gt;Make illegal states unrepresentable&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;诀窍是仔细关注领域并查看规则. 我们了解到这客户:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Has an email address only, or&lt;/li&gt;
&lt;li&gt;Has a postal address only, or&lt;/li&gt;
&lt;li&gt;Has both an email address and a postal address&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这只有三种可能性. 我们如何表示这三种可能性呢? 当然是使用 OR 类型!&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;BothContactMethods&lt;/span&gt; = {
    Email: EmailContactInfo
    Address : PostalContactInfo
}

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;ContactInfo&lt;/span&gt; =
    | EmailOnly &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; EmailContactInfo
    | AddrOnly &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; PostalContactInfo
    | EmailAndAddr &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; BothContactMethods

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;Contact&lt;/span&gt; = {
    Name: Name
    ContactInfo : ContactInfo
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同样, 我们所做的对开发人员有好处 – 少一个测试要写, 因为我们不能意外缺少联系信息; 而且它同样也有利于设计, 代码非常清楚地表明, 只有三种可能的情况, 以及这三种情况的确切内容. 我们不需要看文档, 我们可以只看代码本身 – &lt;strong&gt;代码即文档&lt;/strong&gt;.&lt;/p&gt;
&lt;h1 id="consistency"&gt;Consistency&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Consistency&lt;/em&gt;(一致性)是一个业务术语, 而不是一个技术术语, 一致性的含义始终取决于上下文. 例如, 如果一个产品的价格发生了变化, 订单的上价格是否要随着变化, 还是依然维持以前的价格直到新下一个订单? 这个问题没有绝对正确的答案, 它取决于当前领域业务的需求.&lt;/p&gt;
&lt;p&gt;不过, 一致性确实给设计带来了很大的负担, 而且成本很高, 因此, 如果可以的话, 我们希望避免需要它. 通常, 在需求收集期间, 产品所有者会要求一个不可取且不切实际的一致性级别. 但是, 在许多情况下, 可以避免或延迟对一致性的需求.&lt;/p&gt;
&lt;p&gt;最后, 必须认识到持久化的&lt;strong&gt;原子性&lt;/strong&gt;和一致性是相互关联的. 例如, 如果订单不会以原子方式持久化, 则确保订单在内部一致是没有意义的. 因为如果某一个部分保存失败, 那么以后任何人都将会加载到内部不一致的订单.&lt;/p&gt;
&lt;h2 id="consistency-within-a-single-aggregate"&gt;Consistency Within a Single Aggregate&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.smallcpp.cn/san-domain-modeling-with-types.html#aggregates-enforce-consistency-and-invariants"&gt;聚合&lt;/a&gt;既充当一致性边界, 也充当持久性单元. 让我们看看这在实践中是如何工作的.&lt;/p&gt;
&lt;p&gt;假设我们要求订单的总金额应为各个订单行的总和. 确保一致性的最简单方法是从原始数据中计算信息, 而不是存储计算结果. 在这种情况下, 我们可以在每次需要总计时(在内存中或使用 SQL 查询)对订单行求和.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;// We pass in three parameters:&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// * the top-level order&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// * the id of the order line we want to change&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// * the new price&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;changeOrderLinePrice&lt;/span&gt; order orderLineId newPrice =

    &lt;span style="color: #228B22"&gt;// find orderLine in order.OrderLines using orderLineId&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;orderLine&lt;/span&gt; = order.OrderLines |&amp;gt; findOrderLine orderLineId

    &lt;span style="color: #228B22"&gt;// make a new version of the OrderLine with new price&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;newOrderLine&lt;/span&gt; = {orderLine &lt;span style="color: #8B008B; font-weight: bold"&gt;with&lt;/span&gt; Price = newPrice}

    &lt;span style="color: #228B22"&gt;// create new list of lines, replacing old line with new line&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;newOrderLines&lt;/span&gt; =
        order.OrderLines |&amp;gt; replaceOrderLine orderLineId newOrderLine

    &lt;span style="color: #228B22"&gt;// make a new AmountToBill&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;newAmountToBill&lt;/span&gt; = newOrderLines |&amp;gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;List&lt;/span&gt;.sumBy (&lt;span style="color: #8B008B; font-weight: bold"&gt;fun&lt;/span&gt; line -&amp;gt; line.Price)

    &lt;span style="color: #228B22"&gt;// make a new version of the order with the new lines&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;newOrder&lt;/span&gt; = {
        order &lt;span style="color: #8B008B; font-weight: bold"&gt;with&lt;/span&gt;
        OrderLines = newOrderLines
        AmountToBill = newAmountToBill
    }

    &lt;span style="color: #228B22"&gt;// return the new order&lt;/span&gt;
    newOrder
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果确实需要保留额外的数据(例如存储在顶级订单中的额外金额), 那么我们需要确保它能一直保持同步, 也就是说, 如果其中某一行已更新, 则还必须更新总额以保持数据一致. 显然, 知道如何保持一致性的唯一组件是顶级的订单组件. 这是在订单级别而不是订单行级别执行所有更新的一个很好的理由 – 订单是强制执行一致性边界的聚合.&lt;/p&gt;
&lt;p&gt;另外, 聚合也是原子性的单位, 因此, 如果我们要将此订单保存到数据库中, 我们必须确保在同一事务中插入或更新订单头和订单行.&lt;/p&gt;
&lt;h2 id="consistency-between-different-contexts"&gt;Consistency Between Different Contexts&lt;/h2&gt;
&lt;p&gt;如果我们需要协调不同的上下文, 该怎么办？让我们看一下第二个示例:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下订单后, 必须创建相应的发票. 如果订单存在, 但发票不存在, 则数据不一致.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;开票是计费领域的一部分, 而不是接单领域, 这是否意味着我们需要进入另一个域并操作其中对象? 当然不是. 我们必须使每个界限上下文保持隔离和接偶.&lt;/p&gt;
&lt;p&gt;那是否可以使用计费上下文的公共 API 呢, 例如:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;Ask billing context to create invoice
    If successfully created:
        create order in order-taking context
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此方法比看起来要棘手得多, 因为还需要处理任一更新失败. 当然, 有一些方法可以正确同步不同系统之间的更新(如两阶段提交), 但实际上很少需要这样做. 在现实世界中, 企业通常并不要求每个流程都进入锁定步骤, 等待所有子系统完成一个阶段, 然后再进入下一阶段. 相反, 协调是使用消息异步完成的. 有时, 事情会出错, 但处理罕见错误的成本通常比保持所有内容同步的成本要低得多.&lt;/p&gt;
&lt;p&gt;好, 现在假设我们只需向计费域发送消息(或事件), 然后继续处理订单的其余部分, 而不是等待创建发票. 当然, 会出现一些失败情况, 例如消息丢失或者某种原因创建发票失败, 此时, 我们该怎么处理?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种选择是什么都不做. 然后, 客户得到免费的东西, 企业必须注销成本. 如果错误很少且成本很小, 这可能是完全适当的解决方案.&lt;/li&gt;
&lt;li&gt;另一个选项是检测消息是否丢失并重新发送. 这基本上就是一个调度程序要作的事: 比较两组数据, 如果它们不匹配, 修正错误.&lt;/li&gt;
&lt;li&gt;第三个选项是创建 “补偿” 操作, 以撤消以前的操作或修复错误. 在我们例子中, 这相当于取消订单, 并要求客户将产品发送回来. 更现实地讲, 补偿操作可能被用来执行诸如更正订单中的错误或退款等操作.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在所有这三种情况下, 都不需要在界限上下文之间进行严格地同步操作.&lt;/p&gt;
&lt;p&gt;如果我们对一致性有要求, 那么我们需要实现第二个或第三个选项. 但这种一致性不会立即生效. 相反, 只有在一段时间过后, 系统才会变得一致 – &lt;strong&gt;最终一致性&lt;/strong&gt;. 最终的一致性不是 “可选一致性”, 它要确保系统在未来某个时候保持一致性.&lt;/p&gt;
&lt;p&gt;下面是一个示例. 假设产品价格已更改, 我们确实希望更新尚未发货的所有订单的价格. 如果我们想要立即的一致性, 我们必须在同一事务中更新所有所有订单的价格, 这可能需要一些时间.&lt;/p&gt;
&lt;p&gt;相反, 如果使用异步, 我们可以会创建 &lt;em&gt;PriceChanged&lt;/em&gt; 事件, 从而触发一系列 &lt;em&gt;UpdateOrderWithChangedPrice&lt;/em&gt; 命令以更新未结订单. 这些命令将在产品更改后一段时间进行处理, 也许在几秒钟后, 也许在数小时后. 最终, 订单将更新, 系统将一致.&lt;/p&gt;
&lt;h2 id="consistency-between-aggregates-in-the-same-context"&gt;Consistency Between Aggregates in the Same Context&lt;/h2&gt;
&lt;p&gt;假设两个聚合需要彼此一致, 我们应该在同一事务中一起更新它们, 还是使用最终一致性单独更新它们? 我们应该采取哪种方法?&lt;/p&gt;
&lt;p&gt;通常, 有用的准则是&lt;strong&gt;每个事务只更新一个聚合&lt;/strong&gt;. 如果涉及多个聚合, 则应使用上一小节的消息机制和最终一致性, 即使两个聚合都在同一界限上下文中. 但有时, 特别是如果业务认为工作流是单个事务, 则可能值得将所有受影响的实体都包括在一个事务中.&lt;/p&gt;
&lt;p&gt;一个典型的例子是在两个账户之间转账, 其中一个帐户增加而另一个减少.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;Start transaction
Add X amount to accountA
Remove X amount from accountB
Commit transaction
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果帐户由帐户聚合表示, 那么我们将在同一事务中更新两个不同的聚合. 这不一定是问题, 但它可能是一个可以重构以获得对领域有更深入了解的线索.&lt;/p&gt;
&lt;p&gt;例如, 在这种情况下, 事务通常有自己的标识符, 这意味着它本身就是一个实体. 所以, 为什么不这样建模它:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;MoneyTransfer&lt;/span&gt; = {
    Id: MoneyTransferId
    ToAccount : AccountId
    FromAccount : AccountId
    Amount: Money
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更改后, 帐户实体仍然存在, 但它们将不再直接负责添加或删除资金. 账户的当前余额现在可以通过迭代引用该账户的 &lt;em&gt;MoneyTransfer&lt;/em&gt; 记录来计算. 我们不仅重构了设计, 还了解了有关该领域的一些知识.&lt;/p&gt;
&lt;p&gt;这也表明, 如果没有必要, 您就不必重用聚合. 如果您只需要针对一个用例进行这样的新聚合, 请继续.&lt;/p&gt;
&lt;p&gt;下面这段是原话, 我没弄懂是什么意思…&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This also shows that you shouldn’t feel obligated to reuse aggregates if it doesn’t make sense to do so. If you need to make a new aggregate like this just for one use-case, go ahead.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="multiple-aggregates-acting-on-the-same-data"&gt;Multiple Aggregates Acting on the Same Data&lt;/h2&gt;
&lt;p&gt;我们之前强调过, 聚合会强制执行 &lt;em&gt;Integrity&lt;/em&gt; 约束, 因此, 如果我们有多个对同一数据起作用的聚合, 那么如何确保约束被一致地实施? 例如, 我们可能有一个帐户汇总, 但也有一个 &lt;em&gt;MoneyTransfer&lt;/em&gt; 汇总, 两者都需要确保余额不会变为负数.&lt;/p&gt;
&lt;p&gt;在许多情况下, 如果使用类型对约束进行约束, 则可以在多个聚合之间共享约束. 例如, 可以使用 &lt;em&gt;NonNegativeMoney&lt;/em&gt; 类型来模拟帐户余额不得低于零的要求. 如果这不适用, 则可以使用共享验证功能. 这是功能模型相对于面向对象模型的优势 –– 验证功能不附加至任何特定对象, 也不依赖于全局状态, 因此可以轻松地在不同的工作流程中重用它们.&lt;/p&gt;</content><category term="函数式"></category><category term="函数式"></category><category term="领域驱动"></category><category term="DDD"></category></entry><entry><title>三. Domain Modeling with Types</title><link href="http://www.smallcpp.cn/san-domain-modeling-with-types.html" rel="alternate"></link><published>2019-12-03T15:00:00+08:00</published><updated>2019-12-03T15:00:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2019-12-03:/san-domain-modeling-with-types.html</id><summary type="html">
&lt;h1 id="reviewing-the-domain-model"&gt;Reviewing the Domain Model&lt;/h1&gt;
&lt;p&gt;TODO: 补充需求.&lt;/p&gt;
&lt;p&gt;现在让我们看下已有领域模型的伪代码 (在与领域专家讨论需求时记录下来的):&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;context: Order-Taking
// ----------------------
// Simple types
// ----------------------
// Product codes
data ProductCode = WidgetCode OR GizmoCode
data WidgetCode = string starting with "W" then 4 digits
data …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">
&lt;h1 id="reviewing-the-domain-model"&gt;Reviewing the Domain Model&lt;/h1&gt;
&lt;p&gt;TODO: 补充需求.&lt;/p&gt;
&lt;p&gt;现在让我们看下已有领域模型的伪代码 (在与领域专家讨论需求时记录下来的):&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;context: Order-Taking
// ----------------------
// Simple types
// ----------------------
// Product codes
data ProductCode = WidgetCode OR GizmoCode
data WidgetCode = string starting with "W" then 4 digits
data GizmoCode = ...

// Order Quantity
data OrderQuantity = UnitQuantity OR KilogramQuantity
data UnitQuantity = ...
data KilogramQuantity = ...

// ----------------------
// Order lifecycle
// ----------------------
// ----- unvalidated state -----
data UnvalidatedOrder =
    UnvalidatedCustomerInfo
    AND UnvalidatedShippingAddress
    AND UnvalidatedBillingAddress
    AND list of UnvalidatedOrderLine

data UnvalidatedOrderLine =
    UnvalidatedProductCode
    AND UnvalidatedOrderQuantity

// ----- validated state -----
data ValidatedOrder = ...
data ValidatedOrderLine = ...

// ----- priced state -----
data PricedOrder = ...
data PricedOrderLine = ...

// ----- output events -----
data OrderAcknowledgmentSent = ...
data OrderPlaced = ...
data BillableOrderPlaced = ...

// ----------------------
// Processes
// ----------------------
process "Place Order" =
    input: UnvalidatedOrder
    output (on success):
        OrderAcknowledgmentSent
        AND OrderPlaced (to send to shipping)
        AND BillableOrderPlaced (to send to billing)
    output (on error):
        InvalidOrder

// etc
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们的目标是将此转换为真实的代码.&lt;/p&gt;
&lt;h1 id="modeling-datas-with-types"&gt;Modeling Datas with Types&lt;/h1&gt;
&lt;h2 id="seeing-patterns-in-a-domain-mode"&gt;Seeing Patterns in a Domain Mode&lt;/h2&gt;
&lt;p&gt;可&lt;strong&gt;组合&lt;/strong&gt;的类型系统是实践领域驱动设计的绝佳帮助, 因为只需将类型混合在一起, 即可快速创建复杂的模型. 并且, 在函数式领域建模中, 也有一些常用的模式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Simple values. 基础类型的包装. 因为不会直接使用像 int/string 之类的 “原始” 语言.&lt;/li&gt;
&lt;li&gt;Combinations of values with AND. 也许是它语言中的结构体或类.&lt;/li&gt;
&lt;li&gt;Choices with OR. 某种程序上类似枚举&lt;/li&gt;
&lt;li&gt;Processes. 具有输入和输出的流程&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="modeling-simple-values"&gt;Modeling Simple Values&lt;/h2&gt;
&lt;p&gt;领域专家们一般不会使用 &lt;em&gt;int&lt;/em&gt; 之类的术语进行思考, 他们使用&lt;a href="http://www.smallcpp.cn/yi-introducing-domain-driven-design.html#creating-a-ubiquitous-language"&gt;领域术语&lt;/a&gt; –– &lt;em&gt;OrderId&lt;/em&gt; 和 &lt;em&gt;ProductCode&lt;/em&gt;. 此外, 使用领域术语不容易混淆一些概念, 比如 &lt;em&gt;OrderId&lt;/em&gt; 和 &lt;em&gt;ProductCode&lt;/em&gt; 都是 &lt;em&gt;int&lt;/em&gt;, 但并不意味着它们可以互换. 所以, 为了明确这些类型是不同的, 我们将创建 “包装类型” –– 一种包装基础数据类型的类型.&lt;/p&gt;
&lt;p&gt;在 &lt;em&gt;F#&lt;/em&gt; 中创建 Simple values 的最简单方法是创建 “single-case” 联合类型  –– 只有一个选项的 OR 类型, 比如:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CustomerId&lt;/span&gt; =
    | CustomerId &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; int

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CustomerId&lt;/span&gt; = CustomerId &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; int &lt;span style="color: #228B22"&gt;// 缩写成一行&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;customerId&lt;/span&gt; = CustomerId &lt;span style="color: #B452CD"&gt;42&lt;/span&gt;  &lt;span style="color: #228B22"&gt;// 构造值&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; (CustomerId innerValue) = customerId  &lt;span style="color: #228B22"&gt;// 解构, 模式匹配, innerValue is set to 42&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通常这种 “single-case” 的类型名与构造子名相同.&lt;/p&gt;
&lt;p&gt;现在我们可以审视一下&lt;a href="http://www.smallcpp.cn/san-domain-modeling-with-types.html#reviewing-the-domain-model"&gt;领域模型&lt;/a&gt;, 并转换成部分代码:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;WidgetCode&lt;/span&gt; = WidgetCode &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;string&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;UnitQuantity&lt;/span&gt; = UnitQuantity &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; int
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;KilogramQuantity&lt;/span&gt; = KilogramQuantity &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;decimal&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;这里我们暂时忽视掉取值范围的约束, 后续会说明怎么建模有约束的 Simple values.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外, 遍历 Simple values 的列表要比直接遍历基础数据类型的列表多花费一些开销, 这是因为内存不连续引起的.&lt;br/&gt;
当然, 这些开销通常不大需要关注, 除非我们的领域非常在意性能. 如果是这样的话, 可以使用下面这种方式代替直接建模 Simple values 的列表.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;// type CustomerIds = CustomerIds of CustomerId[]&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CustomerIds&lt;/span&gt; = CustomerIds &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; int&lt;span style="color: #658b00"&gt;[]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="modeling-complex-data"&gt;Modeling Complex Data&lt;/h2&gt;
&lt;p&gt;复杂的类型就要借助到&lt;a href="http://www.smallcpp.cn/han-shu-shi-guan-jian-gai-nian-haskell-miao-shu.html#_4"&gt;代数数据类型&lt;/a&gt;了.&lt;/p&gt;
&lt;p&gt;在领域模型中, 我们看到许多数据结构都是 AND 型关系, 例如, 我们最初的简单订单模型定义为:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;data Order =
    CustomerInfo
    AND ShippingAddress
    AND BillingAddress
    AND list of OrderLines
    AND AmountToBill
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这可以很方便的直接转换成 &lt;em&gt;F#&lt;/em&gt; 代码:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;Order&lt;/span&gt; = {
    CustomerInfo : CustomerInfo
    ShippingAddress : ShippingAddress
    BillingAddress : BillingAddress
    OrderLines : OrderLine &lt;span style="color: #00688B; font-weight: bold"&gt;list&lt;/span&gt;
    AmountToBill : ...
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;建模的时候, 我们会发现存在一些未解答的领域问题.&lt;br/&gt;
例如应该用什么类型来表示 &lt;em&gt;AmountToBill&lt;/em&gt;?  &lt;em&gt;ShippingAddress&lt;/em&gt; 与 &lt;em&gt;BillingAddress&lt;/em&gt; 是相同的类型吗? 等等.&lt;/p&gt;
&lt;p&gt;理想情况是继续请求领域专家的帮助. 例如, 如果他们将帐单地址和发货地址作为不同内容进行讨论, 那么即使它们具有相同的结构, 也最好将它们逻辑上分开. 当然我们不需要&lt;strong&gt;立即&lt;/strong&gt;去寻求帮助, 因为我们可以对&lt;a href="http://www.smallcpp.cn/san-domain-modeling-with-types.html#modeling-unknown-types"&gt;未知类型&lt;/a&gt;进行建模.&lt;/p&gt;
&lt;h2 id="modeling-unknown-types"&gt;Modeling Unknown Types&lt;/h2&gt;
&lt;p&gt;在设计的早期阶段, 通常不会对某些建模问题给出明确答案. 例如我们知道待建模的类型的名字, 但并不清楚它的内部结构.&lt;/p&gt;
&lt;p&gt;这不是问题 –– 我们可以将它们建模为显式的未定义的类型, 该类型充当占位符, 直到在设计过程后期有更好的理解.&lt;/p&gt;
&lt;p&gt;如果要在 F# 中表示未定义的类型, 可以使用异常类型 &lt;em&gt;exn&lt;/em&gt; 并将其别名为 &lt;em&gt;Undefined&lt;/em&gt;; 然后, 就可以在设计模型时使用这个别名, 如下所示:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;Undefined&lt;/span&gt; = &lt;span style="color: #00688B; font-weight: bold"&gt;exn&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CustomerInfo&lt;/span&gt; = Undefined
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;ShippingAddress&lt;/span&gt; = Undefined
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;BillingAddress&lt;/span&gt; = Undefined
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;OrderLine&lt;/span&gt; = Undefined
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;BillingAmount&lt;/span&gt; = Undefined

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;Order&lt;/span&gt; = {
    CustomerInfo : CustomerInfo
    ShippingAddress : ShippingAddress
    BillingAddress : BillingAddress
    OrderLines : OrderLine &lt;span style="color: #00688B; font-weight: bold"&gt;list&lt;/span&gt;
    AmountToBill : BillingAmount
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此方法意味着可以继续使用类型对领域进行建模, 并且编译代码; 但当尝试编写处理这些类型的函数时, 会被强制用更好一点的 “东西” 去替换 &lt;em&gt;Undefined&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id="modeling-with-choice-types"&gt;Modeling with Choice Types&lt;/h2&gt;
&lt;p&gt;在我们的领域中, 我们也看到许多 OR 类型, 例如:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;data ProductCode =
    WidgetCode
    OR GizmoCode

data OrderQuantity =
    UnitQuantity
    OR KilogramQuantity
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以使用 &lt;em&gt;Choices with OR&lt;/em&gt; 对它们进行建模.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;ProductCode&lt;/span&gt; =
    | Widget &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; WidgetCode
    | Gizmo &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; GizmoCode

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;OrderQuantity&lt;/span&gt; =
    | Unit &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; UnitQuantity
    | Kilogram &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; KilogramQuantity
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这种情况下, 区别于 “single-case”, 类型名与构造子名并不需要相同, 例如 &lt;em&gt;Widget&lt;/em&gt; 和 &lt;em&gt;WidgetCode&lt;/em&gt;.&lt;/p&gt;
&lt;h1 id="modeling-workflows-with-functions"&gt;Modeling Workflows with Functions&lt;/h1&gt;
&lt;p&gt;现在我们已经对数据结构 – “the nouns of the ubiquitous language” 进行了建模. 接下来, 我们将对工作流进行建模 – “the verbs of the ubiquitous language”.&lt;/p&gt;
&lt;p&gt;例如, 如果我们有一个验证订单表单的工作流, 我们可能会将其记录为:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;ValidateOrder&lt;/span&gt; = UnvalidatedOrder-&amp;gt; ValidatedOrder
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显而易见, 验证订单流程会将未验证的订单转换为已验证的订单.&lt;/p&gt;
&lt;h2 id="working-with-complex-inputs-and-outputs"&gt;Working with Complex Inputs and Outputs&lt;/h2&gt;
&lt;p&gt;每个函数只有一个输入和一个输出, 但某些工作流可能具有多个输入和输出 –– 我们如何建模?&lt;/p&gt;
&lt;p&gt;我们将从输出开始. 如果工作流具有 &lt;em&gt;outputA&lt;/em&gt; 和 &lt;em&gt;outputB&lt;/em&gt;, 则可以创建 AND 类型来存储它们. 我们在 &lt;em&gt;order-placing&lt;/em&gt; 工作流中看到了这一点: 输出需要三个不同的事件. 因此, 让我们创建一个复合类型来将它们建模为一条记录:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;PlaceOrderEvents&lt;/span&gt; = {
    AcknowledgmentSent : AcknowledgmentSent
    OrderPlaced : OrderPlaced
    BillableOrderPlaced : BillableOrderPlaced
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后, 可以将 &lt;em&gt;order-placing&lt;/em&gt; 工作流建模为函数类型:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;PlaceOrder&lt;/span&gt; = UnvalidatedOrder -&amp;gt; PlaceOrderEvents
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另一方面, 如果工作流具有 &lt;em&gt;outputA&lt;/em&gt; 或 &lt;em&gt;outputB&lt;/em&gt;, 则可以创建一个 OR 类型来存储它们. 例如, 我们简要讨论了将客户邮件分类为报价或订单. 这个过程对产出至少有两种不同的选择:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;process "Categorize Inbound Mail" =
    input: Envelope contents
    output:
        QuoteForm (put on appropriate pile)
        OR OrderForm (put on appropriate pile)
        OR ...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很容易对此进行建模: 只需创建一个新的 OR 类型(例如 &lt;em&gt;CategorizedMail&lt;/em&gt;)来表示结果, 然后让 &lt;em&gt;CategorizeInboundMail&lt;/em&gt; 过程返回该类型. 最后, 我们的模型可能如下所示:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CategorizedMail&lt;/span&gt; =
    | Quote &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; QuoteForm
    | Order &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; OrderForm

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CategorizeInboundMail&lt;/span&gt; = EnvelopeContents -&amp;gt; CategorizedMail
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在, 让我们来看看建模输入. 如果工作流具有不同的输入选择, 则可以创建 OR 类型. 但是, 如果流程有多个必需的输入, 例如下面的 &lt;em&gt;“Calculate Prices&lt;/em&gt;, 我们可以在两种可能的方法之间进行选择.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;"Calculate Prices" =
    input: OrderForm, ProductCatalog
    output: PricedOrder
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个最简单的方法是将每个输入作为单独的参数传递, 如下所示:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CalculatePrices&lt;/span&gt; = OrderForm -&amp;gt; ProductCatalog -&amp;gt; PricedOrder
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者, 我们可以创建新的 AND 类型来同时包含它们, 例如:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CalculatePricesInput&lt;/span&gt; = {
    OrderForm : OrderForm
    ProductCatalog : ProductCatalog
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在函数如下所示:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CalculatePrices&lt;/span&gt; = CalculatePricesInput -&amp;gt; PricedOrder
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;哪一种方式更好?&lt;/p&gt;
&lt;p&gt;在上面的例子中, 如果 &lt;em&gt;ProductCatalog&lt;/em&gt; 是依赖项而不是 “&lt;strong&gt;实际&lt;/strong&gt;” 输入, 则我们希望使用第一种方法(单独的参数). 这使我们能够使用函数式编程中的依赖注入. 我们将在后面 &amp;lt;&amp;lt;依赖注入&amp;gt;&amp;gt; 章节中详细讨论这一点, 届时我们将实现订单处理管道.&lt;/p&gt;
&lt;p&gt;另一方面, 如果两个输入始终是必需的, 并且彼此紧密相连, 则应使用 AND 类型.(在某些情况下, 可以使用 &lt;em&gt;tuples&lt;/em&gt; 作为简单 AND 类型的替代方法, 但通常最好使用命名类型.)&lt;/p&gt;
&lt;h2 id="documenting-effects-in-the-function-signature"&gt;Documenting Effects in the Function Signature&lt;/h2&gt;
&lt;p&gt;我们刚刚看到 &lt;em&gt;ValidateOrder&lt;/em&gt; 可以这样编写:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;ValidateOrder&lt;/span&gt; = UnvalidatedOrder -&amp;gt; ValidatedOrder
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是, 这假定了验证过程始终有效, 并且始终返回已验证订单. 实际上, 这个过程可能会出错, 因此最好通过在函数签名中返回 Result 类型(Either in Haskell)来指示这一点:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;ValidateOrder&lt;/span&gt; =
    UnvalidatedOrder -&amp;gt; Result&amp;lt;ValidatedOrder, ValidationError &lt;span style="color: #00688B; font-weight: bold"&gt;list&lt;/span&gt;&amp;gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;ValidationError&lt;/span&gt; = {
    FieldName : &lt;span style="color: #00688B; font-weight: bold"&gt;string&lt;/span&gt;
    ErrorDescription : &lt;span style="color: #00688B; font-weight: bold"&gt;string&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此签名显示输入是 &lt;em&gt;UnvalidatedOrder&lt;/em&gt;, 如果成功, 则输出为 &lt;em&gt;ValidatedOrder&lt;/em&gt;, 但如果验证失败, 则结果为 &lt;em&gt;ValidationError&lt;/em&gt; 列表, 该列表又包含错误描述及其应用于哪个字段的说明.&lt;/p&gt;
&lt;p&gt;函数编程人员使用术语 “&lt;strong&gt;effects&lt;/strong&gt;” 来描述函数除了其主要输出之外另外执行的事情(函数副作用). 通过使用 &lt;em&gt;Result&lt;/em&gt; 类型, 我们现在已经表明出 &lt;em&gt;ValidateOrder&lt;/em&gt; 可能具有 “error effects” – 类型签名中明确说明, 我们不能保证函数始终成功, 并且我们应该准备好处理错误.&lt;/p&gt;
&lt;p&gt;同样, 我们也可能会希望记录进程是&lt;strong&gt;异步&lt;/strong&gt;的. 我们怎样才能做到这一点?&lt;/p&gt;
&lt;p&gt;在 &lt;em&gt;F#&lt;/em&gt; 中, 我们使用 &lt;em&gt;Async&lt;/em&gt; 类型来表示函数将具有异步效果. 因此, 如果 &lt;em&gt;ValidateOrder&lt;/em&gt; 具有异步效应和错误效果, 我们将编写如下函数类型:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;ValidateOrder&lt;/span&gt; =
    UnvalidatedOrder -&amp;gt; Async&amp;lt;Result&amp;lt;ValidatedOrder,ValidationError &lt;span style="color: #00688B; font-weight: bold"&gt;list&lt;/span&gt;&amp;gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此类型签名现在明确表明:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当我们尝试获取返回值的内容时, 代码不会立即返回.&lt;/li&gt;
&lt;li&gt;当它真的返回结果时, 结果可能是错误.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;像这样显式地列出所有效果很有用, 但它确实使类型签名变得丑陋且复杂, 因此我们通常会为此创建一个&lt;strong&gt;类型别名&lt;/strong&gt;, 使其看起来更美观.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;ValidationResponse&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;'&lt;/span&gt;a&amp;gt; = Async&amp;lt;Result&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;'&lt;/span&gt;a,ValidationError &lt;span style="color: #00688B; font-weight: bold"&gt;list&lt;/span&gt;&amp;gt;&amp;gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;ValidateOrder&lt;/span&gt; =
    UnvalidatedOrder -&amp;gt; ValidationResponse&amp;lt;ValidatedOrder&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="a-question-of-identity-value-objects"&gt;A Question of Identity: Value Objects&lt;/h1&gt;
&lt;p&gt;我们已经了解了对领域数据和工作流建模的基本方法. 现在, 让我们继续研究一种对数据类型进行分类的重要方式 – 基于数据类型是否具有&lt;strong&gt;持久标识&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;在 DDD 术语中, 具有持久身份的对象称为 &lt;strong&gt;Entities&lt;/strong&gt;(实体), 而没有持久身份的对象称为 &lt;strong&gt;Value Objects&lt;/strong&gt;(值对象). 让我们首先讨论值对象.&lt;/p&gt;
&lt;p&gt;在许多情况下, 我们正在处理的数据对象没有身份 – 它们是可互换的. 例如, 出现在所有地方值为 W1234 的 WidgetCode 都彼此相等, 我们不需要区分它们.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;widgetCode1&lt;/span&gt; = WidgetCode &lt;span style="color: #CD5555"&gt;"W1234"&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;widgetCode2&lt;/span&gt; = WidgetCode &lt;span style="color: #CD5555"&gt;"W1234"&lt;/span&gt;
printfn &lt;span style="color: #CD5555"&gt;"%b"&lt;/span&gt; (widgetCode1 = widgetCode2) &lt;span style="color: #228B22"&gt;// prints "true"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;“values without identity” 的概念在领域模型中经常出现, 无论是复杂类型还是简单类型. 例如, 一个 &lt;em&gt;PersonalName&lt;/em&gt; 的 AND 类型可能具有 &lt;em&gt;FirstName&lt;/em&gt; 和 &lt;em&gt;LastName&lt;/em&gt; 两个字段, 因此它比简单的字符串复杂, 但它也是一个值对象, 因为具有相同字段的两个个人名称是可以互换的.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;name1&lt;/span&gt; = {FirstName=&lt;span style="color: #CD5555"&gt;"Alex"&lt;/span&gt;; LastName=&lt;span style="color: #CD5555"&gt;"Adams"&lt;/span&gt;}
&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;name2&lt;/span&gt; = {FirstName=&lt;span style="color: #CD5555"&gt;"Alex"&lt;/span&gt;; LastName=&lt;span style="color: #CD5555"&gt;"Adams"&lt;/span&gt;}
printfn &lt;span style="color: #CD5555"&gt;"%b"&lt;/span&gt; (name1 = name2) &lt;span style="color: #228B22"&gt;// prints "true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例如 &lt;em&gt;“address”&lt;/em&gt; 类型也是值对象, 如果两个值具有相同的街道地址以及城市和邮政编码, 则它们是相同的地址.&lt;/p&gt;
&lt;h2 id="implementing-equality-for-value-objects"&gt;Implementing Equality for Value Objects&lt;/h2&gt;
&lt;p&gt;当我们使用 &lt;em&gt;F＃&lt;/em&gt; 代数类型系统对领域建模时, 默认情况下, 我们创建的类型基于字段的相等性判断 – 我们不需要自己编写任何判断相等性的代码.&lt;/p&gt;
&lt;p&gt;准确地说, 在 &lt;em&gt;F＃&lt;/em&gt; 中, 如果两个 AND 类型值的所有字段都相等, 则两个值(相同类型)相等; 如果两个 OR 类型的选择情况相同, 则两个选择值相等; 这称为结构平等.&lt;/p&gt;
&lt;p&gt;而在其它语言中, 我们可能需要重写 &lt;em&gt;Equals&lt;/em&gt; 之类的方法.&lt;/p&gt;
&lt;h1 id="a-question-of-identity-entities"&gt;A Question of Identity: Entities&lt;/h1&gt;
&lt;p&gt;但是, 我们也经常需要对在现实世界中具有独特标识的事物进行建模, 即使它们的组成发生变化, 但它们依然是同一个事物. 例如, 即使我更改了姓名或地址, 我仍然是同一个人.&lt;/p&gt;
&lt;p&gt;DDD 术语中, 这些事物被称为 &lt;em&gt;Entities&lt;/em&gt;(实体).&lt;/p&gt;
&lt;p&gt;在我们实例的上下文中, 实体通常是某种类型的文档: 订单, 报价, 发票, 客户资料, 产品单等. 它们具有&lt;strong&gt;生命周期&lt;/strong&gt;, 并通过各种业务流程从一种状态转换为另一种状态.&lt;/p&gt;
&lt;p&gt;值对象与实体之间的区别取决于其所在的上下文. 例如, 考虑手机的生命周期.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在制造过程中, 每部手机都会获得一个唯一的序列号, 因此在这种情况下, 它们将被建模为实体.&lt;/li&gt;
&lt;li&gt;在出售时, 序列号无关紧要-所有规格相同的手机都是可以互换的-可以将它们建模为值对象.&lt;/li&gt;
&lt;li&gt;一旦将特定手机出售给特定客户, 身份就会再次变得相关, 应该将其建模为一个实体:  即使更换屏幕或电池, 客户也将其视为同一部手机.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="identifiers-for-entities"&gt;Identifiers for Entities&lt;/h2&gt;
&lt;p&gt;在对实体进行建模时, 我们需要为它们提供唯一的标识符或键, 例如 &lt;em&gt;Order Id&lt;/em&gt;, or &lt;em&gt;Customer Id&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;例如下面的 &lt;em&gt;Contact&lt;/em&gt; 类型, 不管 &lt;em&gt;PhoneNumber&lt;/em&gt; 或 &lt;em&gt;EmailAddress&lt;/em&gt; 属性怎么更改, 它的 &lt;em&gt;ContactId&lt;/em&gt; 属性保持不变.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;ContactId&lt;/span&gt; = ContactId &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; int

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;Contact&lt;/span&gt; = {
    ContactId : ContactId
    PhoneNumber : ...
    EmailAddress: ...
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些标识符从何而来?&lt;/p&gt;
&lt;p&gt;有时, 标识符是由真实世界本身提供的, 例如纸质订单和发票上总是写有某种单号; 但有时, 我们需要使用 UUID, 自动递增数据库表, ID 生成服务等技术自己创建一个人工标识符. 在我们的实例中, 仅假设客户已向我们提供了标识符.&lt;/p&gt;
&lt;h2 id="adding-identifiers-to-data-definitions"&gt;Adding Identifiers to Data Definitions&lt;/h2&gt;
&lt;p&gt;向 AND 类型添加标识符很简单, 只需添加一个字段, 但是如何向 OR 类型添加标识符? 我们应该将标识符放在内部(与每个 case 关联)还是在外部(与任何 case 都不关联)?&lt;/p&gt;
&lt;p&gt;例如, 假设我们有两个发票选项: &lt;em&gt;Unpaid&lt;/em&gt; 和 &lt;em&gt;Paid&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;如果我们使用外部方式对其进行建模, 我们将有一个包含 &lt;em&gt;InvoiceId&lt;/em&gt; 的 AND 类型, 然后在该类型内有一个选择类型 &lt;em&gt;InvoiceInfo&lt;/em&gt;, 其中包含每种发票类型的信息. 该代码将如下所示:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;// Info for the unpaid case (without id)&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;UnpaidInvoiceInfo&lt;/span&gt; = ...

&lt;span style="color: #228B22"&gt;// Info for the paid case (without id)&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;PaidInvoiceInfo&lt;/span&gt; = ...

&lt;span style="color: #228B22"&gt;// Combined information (without id)&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;InvoiceInfo&lt;/span&gt; =
    | Unpaid &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; UnpaidInvoiceInfo
    | Paid &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; PaidInvoiceInfo

&lt;span style="color: #228B22"&gt;// Id for invoice&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;InvoiceId&lt;/span&gt; = ...

&lt;span style="color: #228B22"&gt;// Top level invoice type&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;Invoice&lt;/span&gt; = {
    InvoiceId : InvoiceId &lt;span style="color: #228B22"&gt;// "outside" the two child cases&lt;/span&gt;
    InvoiceInfo : InvoiceInfo
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果使用内部方式, 我们将创建两个单独的类型(&lt;em&gt;UnpaidInvoice&lt;/em&gt; 和 &lt;em&gt;PaidInvoice&lt;/em&gt;), 这两个类型都有自己的 &lt;em&gt;InvoiceId&lt;/em&gt;, 然后是一个在它们之间进行选择的顶级 OR 类型 &lt;em&gt;Invoice&lt;/em&gt;. 该代码将如下所示:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;UnpaidInvoice&lt;/span&gt; = {
    InvoiceId : InvoiceId &lt;span style="color: #228B22"&gt;// id stored "inside"&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// and other info for the unpaid case&lt;/span&gt;
}

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;PaidInvoice&lt;/span&gt; = {
    InvoiceId : InvoiceId &lt;span style="color: #228B22"&gt;// id stored "inside"&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// and other info for the paid case&lt;/span&gt;
}

&lt;span style="color: #228B22"&gt;// top level invoice type&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;Invoice&lt;/span&gt; =
    | Unpaid &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; UnpaidInvoice
    | Paid &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; PaidInvoice
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;相对于外部方式, 内部方式都易于使用模式匹配, 它将所有的数据都放在一起, 包括 &lt;em&gt;id&lt;/em&gt;:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;invoice&lt;/span&gt; = Paid {InvoiceId = ...}

&lt;span style="color: #8B008B; font-weight: bold"&gt;match&lt;/span&gt; invoice &lt;span style="color: #8B008B; font-weight: bold"&gt;with&lt;/span&gt;
    | Unpaid unpaidInvoice -&amp;gt;
      printfn &lt;span style="color: #CD5555"&gt;"The unpaid invoiceId is %A"&lt;/span&gt; unpaidInvoice.InvoiceId
    | Paid paidInvoice -&amp;gt;
      printfn &lt;span style="color: #CD5555"&gt;"The paid invoiceId is %A"&lt;/span&gt; paidInvoice.InvoiceId
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;在实践中, 更常见的是使用内部方法.&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id="implementing-equality-for-entities"&gt;Implementing Equality for Entities&lt;/h2&gt;
&lt;p&gt;前面我们看到, 默认情况下, &lt;em&gt;F＃&lt;/em&gt; 中的相等性判断使用类型的所有字段. 但是, 当我们比较实体时, 我们只想使用标识符字段. 这意味着, 为了在 &lt;em&gt;F＃&lt;/em&gt; 中正确建模实体, 我们必须更改默认行为.&lt;/p&gt;
&lt;p&gt;一种方法是重写相等性判断, 以便仅使用标识符. 要更改默认判断逻辑, 我们必须:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;重写 &lt;em&gt;Equals&lt;/em&gt; 方法.&lt;/li&gt;
&lt;li&gt;重写 &lt;em&gt;GetHashCode&lt;/em&gt; 方法.&lt;/li&gt;
&lt;li&gt;将 &lt;em&gt;CustomEquality&lt;/em&gt; 和 &lt;em&gt;NoComparison&lt;/em&gt; 属性添加到类型中, 以告知编译器我们要更改默认行为.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;[&amp;lt;CustomEquality; NoComparison&amp;gt;]
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;Contact&lt;/span&gt; = {
    ContactId : ContactId
    PhoneNumber : PhoneNumber
    EmailAddress: EmailAddress
}
&lt;span style="color: #8B008B; font-weight: bold"&gt;with&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;override&lt;/span&gt; this.&lt;span style="color: #008b45"&gt;Equals&lt;/span&gt;(&lt;span style="color: #00688B; font-weight: bold"&gt;obj&lt;/span&gt;) =
    &lt;span style="color: #8B008B; font-weight: bold"&gt;match&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;obj&lt;/span&gt; &lt;span style="color: #8B008B; font-weight: bold"&gt;with&lt;/span&gt;
        | :? Contact &lt;span style="color: #8B008B; font-weight: bold"&gt;as&lt;/span&gt; c -&amp;gt; this.ContactId = c.ContactId
        | _ -&amp;gt; &lt;span style="color: #8B008B; font-weight: bold"&gt;false&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;override&lt;/span&gt; this.&lt;span style="color: #008b45"&gt;GetHashCode&lt;/span&gt;&lt;span style="color: #658b00"&gt;()&lt;/span&gt; =
    hash this.ContactId
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="immutability-and-identity"&gt;Immutability and Identity&lt;/h1&gt;
&lt;p&gt;在函数式编程中, 值是不可变的, 这意味着到目前为止定义的对象在初始化后都无法更改.&lt;/p&gt;
&lt;p&gt;对于值对象, 这非常好. 但对实体而言, 则是另一回事. 因为实体有生命周期, 我们希望与实体相关的数据会随着生命周期变化 – 这就是拥有恒定标识符的全部意义. 那么如何使不可变数据结构实现这一点?&lt;/p&gt;
&lt;p&gt;答案是在保留身份的同时使用更改后的数据复制实体. 看起来这些复制操作似乎造成很多额外的工作, 但实际上并不是问题.&lt;/p&gt;
&lt;p&gt;下面是一个如何在 &lt;em&gt;F＃&lt;/em&gt;中更新实体的示例.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其它语言中, 可以使用 &lt;a href="https://medium.com/zyseme-technology/functional-references-lens-and-other-optics-in-scala-e5f7e2fdafe"&gt;Lens(透镜)&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先, 我们将从一个初始值开始:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;initialPerson&lt;/span&gt; = {PersonId=PersonId &lt;span style="color: #B452CD"&gt;42&lt;/span&gt;; Name=&lt;span style="color: #CD5555"&gt;"Joseph"&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要在仅更改某些字段的同时复制值, &lt;em&gt;F＃&lt;/em&gt; 具有 &lt;em&gt;with&lt;/em&gt; 关键字, 其用法如下:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;updatedPerson&lt;/span&gt; = {initialPerson &lt;span style="color: #8B008B; font-weight: bold"&gt;with&lt;/span&gt; Name=&lt;span style="color: #CD5555"&gt;"Joe"&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;复制之后, &lt;em&gt;updatedPerson&lt;/em&gt; 具有不同的名称, 但与 &lt;em&gt;initialPerson&lt;/em&gt; 具有相同的 &lt;em&gt;PersonId&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;使用不可变数据结构的好处是进行任何更改都必须在类型签名中明确表示. 例如, 如果我们要编写一个函数来更改 &lt;em&gt;Person&lt;/em&gt; 中的 &lt;em&gt;Name&lt;/em&gt; 字段, 则不能使用以下签名的函数:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;UpdateName&lt;/span&gt; = Person -&amp;gt; Name -&amp;gt; &lt;span style="color: #00688B; font-weight: bold"&gt;unit&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该函数没有输出, 这意味着没有任何改变(或者说 &lt;em&gt;Person&lt;/em&gt; 没有副使用). 我们的函数必须有一个 &lt;em&gt;Person&lt;/em&gt; 类型作为输出, 如下所示:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;UpdateName&lt;/span&gt; = Person -&amp;gt; Name -&amp;gt; Person
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这清楚地表明, 给定一个人和一个名字, 将返回原始人的某种变体.&lt;/p&gt;
&lt;h1 id="aggregates"&gt;Aggregates&lt;/h1&gt;
&lt;p&gt;让我们仔细看看与我们的设计特别相关的两个数据类型: &lt;em&gt;Order&lt;/em&gt; 和 &lt;em&gt;OrderLine&lt;/em&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;What is &lt;em&gt;OrderLine&lt;/em&gt;?&lt;br/&gt;
下订单时, 订购的货物在订单中, 一种产品表现为一行, 也就是一个品项的产品.&lt;br/&gt;
也就是说, &lt;em&gt;OrderLine&lt;/em&gt; 从属 &lt;em&gt;Order&lt;/em&gt;, 一个 &lt;em&gt;Order&lt;/em&gt; 包含多个 &lt;em&gt;OrderLine&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先, &lt;em&gt;Order&lt;/em&gt; 是实体还是值对象? 显然, 这是一个实体 – &lt;em&gt;Order&lt;/em&gt; 的详细信息可能会随着时间的流逝而变化(待验证-&amp;gt;已验证…), 但是它是相同的一个 &lt;em&gt;Order&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;那 &lt;em&gt;OrderLine&lt;/em&gt; 呢? 如果我们更改特定 &lt;em&gt;OrderLine&lt;/em&gt; 的数量, 它仍然是同一 &lt;em&gt;OrderLine&lt;/em&gt; 吗?&lt;br/&gt;
在大多数设计中, 是这样的, 即使数量或价格随时间发生了变化, 它仍然是相同的 &lt;em&gt;OrderLine&lt;/em&gt;. 因此, &lt;em&gt;OrderLine&lt;/em&gt; 也是一个具有其自身标识符的实体.&lt;/p&gt;
&lt;p&gt;那么问题是, 如果我们更改了一个 &lt;em&gt;OrderLine&lt;/em&gt;, 是否也要更改它所在的 &lt;em&gt;Order&lt;/em&gt;?&lt;br/&gt;
我们的例子中, 答案很明显是更改了 &lt;em&gt;OrderLine&lt;/em&gt; 也要更改整个 &lt;em&gt;Order&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;但事实上, 因为使用了不可变的数据结构, 如果有一个包含不可变 &lt;em&gt;OrderLine&lt;/em&gt; 列表的不可变 &lt;em&gt;Order&lt;/em&gt;, 那么仅仅创建一份 &lt;em&gt;OrderLine&lt;/em&gt; 的副本并不会创建 &lt;em&gt;Order&lt;/em&gt; 的副本.&lt;/p&gt;
&lt;p&gt;所以, 为了更改 &lt;em&gt;Order&lt;/em&gt; 中包含的 &lt;em&gt;OrderLine&lt;/em&gt;, 需要在 &lt;em&gt;Order&lt;/em&gt; 级别进行更改, 而不是 &lt;em&gt;OrderLine&lt;/em&gt; 级别. 例如, 下面是一些用于更新 &lt;em&gt;OrderLine&lt;/em&gt; 价格的伪代码(一个函数):&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #CD5555"&gt;/// We pass in three parameters:&lt;/span&gt;
&lt;span style="color: #CD5555"&gt;/// * the top-level order&lt;/span&gt;
&lt;span style="color: #CD5555"&gt;/// * the id of the order line we want to change&lt;/span&gt;
&lt;span style="color: #CD5555"&gt;/// * the new price&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;changeOrderLinePrice&lt;/span&gt; order orderLineId newPrice =
    &lt;span style="color: #228B22"&gt;// 1. find the line to change using the orderLineId&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;orderLine&lt;/span&gt; = order.OrderLines |&amp;gt; findOrderLine orderLineId

    &lt;span style="color: #228B22"&gt;// 2. make a new version of the OrderLine with the new price&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;newOrderLine&lt;/span&gt; = {orderLine &lt;span style="color: #8B008B; font-weight: bold"&gt;with&lt;/span&gt; Price = newPrice}

    &lt;span style="color: #228B22"&gt;// 3. create a new list of lines, replacing&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// the old line with the new line&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;newOrderLines&lt;/span&gt; =
        order.OrderLines |&amp;gt; replaceOrderLine orderLineId newOrderLine

    &lt;span style="color: #228B22"&gt;// 4. make a new version of the entire order, replacing&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// all the old lines with the new lines&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; &lt;span style="color: #00688B"&gt;newOrder&lt;/span&gt; = {order &lt;span style="color: #8B008B; font-weight: bold"&gt;with&lt;/span&gt; OrderLines = newOrderLines}

    &lt;span style="color: #228B22"&gt;// 5. return the new order&lt;/span&gt;
    newOrder
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终结果(函数的输出)是包含新 &lt;em&gt;OrderLine&lt;/em&gt; 列表的新 &lt;em&gt;Order&lt;/em&gt;, 其中某一个 &lt;em&gt;OrderLine&lt;/em&gt; 具有新价格.&lt;/p&gt;
&lt;p&gt;可以看到, 数据的不变性会导致数据结构中的连锁反应, 因此更改一个低级组件也要强制更改更高级别的组件. 此例中, 即使我们只是需要更改其 “子实体” 之一(&lt;em&gt;OrderLine&lt;/em&gt;), 也总是必须对 &lt;em&gt;Order&lt;/em&gt; 本身进行操作.&lt;/p&gt;
&lt;p&gt;这是一个非常常见的情况: 我们有一个实体的集合, 每个实体都有自己的 ID 以及一些包含它们的 “顶级” 实体. 在 DDD 术语中, 像这样的实体集合称为&lt;strong&gt;聚合&lt;/strong&gt;, 顶层实体称为&lt;strong&gt;聚合根&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;在我们的例子中, 聚合包括 &lt;em&gt;Order&lt;/em&gt; 和 &lt;em&gt;OrderLine&lt;/em&gt; 的列表, 聚合根是 &lt;em&gt;Order&lt;/em&gt; 本身.&lt;/p&gt;
&lt;h2 id="aggregates-enforce-consistency-and-invariants"&gt;Aggregates Enforce Consistency and Invariants&lt;/h2&gt;
&lt;p&gt;在更新数据时, 聚合起着重要作用. 聚合充当&lt;strong&gt;一致性边界&lt;/strong&gt; – 当聚合的一部分更新时, 可能还需要更新其他部分以确保一致性.&lt;/p&gt;
&lt;p&gt;例如, 我们可能会扩展此设计, 以便在顶级 &lt;em&gt;Order&lt;/em&gt; 中存储额外的 &lt;em&gt;TotalPrice&lt;/em&gt;. 那么, 如果其中某一个 &lt;em&gt;OrderLine&lt;/em&gt; 更改了价格, 则还必须更新 &lt;em&gt;TotalPrice&lt;/em&gt; 以保持数据一致. 上面的 &lt;em&gt;changeOrderLinePrice&lt;/em&gt; 函数完成了这个操作. 显然, 知道如何保持一致性的唯一组件是顶级 &lt;em&gt;Order&lt;/em&gt;(聚合根), 因此这是在 &lt;em&gt;Order&lt;/em&gt; 级别而不是 &lt;em&gt;OrderLine&lt;/em&gt; 级别执行更新的另一个原因.&lt;/p&gt;
&lt;p&gt;聚合也是确保&lt;a href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/domain-model-layer-validations"&gt;&lt;strong&gt;不变性(Invariants)&lt;/strong&gt;&lt;/a&gt;的地方. 假设有一个规则, &lt;em&gt;Order&lt;/em&gt; 中始终至少有一个 &lt;em&gt;OrderLine&lt;/em&gt;. 然后, 如果尝试删除 &lt;em&gt;OrderLine&lt;/em&gt;, 则聚合应可确保在仅剩一个 &lt;em&gt;OrderLine&lt;/em&gt; 时出现错误. 后续会有章节讨论这个话题.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Invariants&lt;/strong&gt; are generally business rules/enforcements/requirements that you impose to maintain the &lt;strong&gt;&lt;a href="http://www.smallcpp.cn/si-integrity-and-consistency-in-the-domain.html"&gt;integrity&lt;/a&gt;&lt;/strong&gt; of an object at any given time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="aggregate-references"&gt;Aggregate References&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;此引用非其它语言中的引用类型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在, 假设我们需要有关客户的信息与订单相关联. 可能会诱使你将客户添加为订单的字段, 如下所示:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;Order&lt;/span&gt; = {
    OrderId : OrderId
    Customer : Customer &lt;span style="color: #228B22"&gt;// info about associated customer&lt;/span&gt;
    OrderLines : OrderLine &lt;span style="color: #00688B; font-weight: bold"&gt;list&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// etc&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是, 想想不变性的连锁反应 —— 如果改变了客户的任何部分, 也必须改变订单. 那真的是我们想要的吗?&lt;/p&gt;
&lt;p&gt;更好的设计是存储客户的引用, 而不是整个客户本身. 也就是说, 我们只将 &lt;em&gt;CustomerId&lt;/em&gt; 存储在订单类型中, 如下所示:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;Order&lt;/span&gt; = {
    OrderId : OrderId
    CustomerId : CustomerId &lt;span style="color: #228B22"&gt;// reference to associated customer&lt;/span&gt;
    OrderLines : OrderLine &lt;span style="color: #00688B; font-weight: bold"&gt;list&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;// etc&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用这种方式, 如果我们需要有关客户的完整信息, 先从订单中获取 &lt;em&gt;CustomerId&lt;/em&gt;, 然后从数据库中单独加载相关的客户数据, 而不是将其作为订单的一部分加载.  也就是说, 客户和订单是不同且独立的聚合. 它们各自负责自己的内部一致性, 它们之间的唯一连接是通过聚合根的对象标识符.&lt;/p&gt;
&lt;p&gt;这导致聚合的另一个重要方面: 它们是&lt;strong&gt;持久性&lt;/strong&gt;的基本单位. 如果要从数据库中加载或保存对象, 则应加载或保存整个聚合. 每个数据库事务都应使用单个聚合, 并且不包括多个聚合或跨聚合边界. 后续章节会有案例参考.&lt;/p&gt;
&lt;p&gt;同样, 如果要序列化对象以将其进行传递, 则始终发送整个聚合, 而不是发送其中的一部分.&lt;/p&gt;
&lt;p&gt;明确一点, &lt;strong&gt;并不是所有实体的集合都能成为聚合&lt;/strong&gt;. 例如, 客户列表是实体的集合, 但它不是 DDD 所说的 “聚合”, 因为它没有顶级实体作为聚合根, 并且它一个也不是一致性边界.&lt;/p&gt;
&lt;h2 id="important-role-of-aggregates"&gt;Important Role Of Aggregates&lt;/h2&gt;
&lt;p&gt;以下是聚合在领域模型中的重要作用摘要:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;聚合是领域对象的集合, 可以被视为单个单元, 顶级实体充当聚合根.&lt;/li&gt;
&lt;li&gt;对聚合内对象的所有更改都必须通过聚合根进行, 并且聚合充当一致性边界, 以确保聚合内的所有数据同时正确更新.&lt;/li&gt;
&lt;li&gt;聚合是持久化、数据库事务和数据传输的原子单位.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;定义聚合是设计过程中的一个重要部分. 有时, 相关的实体是同一聚合(&lt;em&gt;OrderLine&lt;/em&gt; 和 &lt;em&gt;Order&lt;/em&gt;)的一部分, 有时它们不是(&lt;em&gt;Customer&lt;/em&gt; 和 &lt;em&gt;Order&lt;/em&gt;). 这是与领域专家协作至关重要的地方: 只有他们才能帮助我们了解实体之间的关系和一致性边界.&lt;/p&gt;
&lt;h1 id="putting-it-all-together"&gt;Putting It All Together&lt;/h1&gt;
&lt;p&gt;我们已经创建了许多类型, 让我们回顾一下它们如何作为一个完整的领域模型组合在一起.&lt;/p&gt;
&lt;p&gt;首先, 我们将所有这些类型放在一个称为 &lt;em&gt;OrderOrder.Domain&lt;/em&gt; 的命名空间中, 该空间用于将这些类型与其他命名空间分开. 换句话说, 我们使用 &lt;em&gt;F#&lt;/em&gt; 中的命名空间来指示 DDD 界限上下文, 至少目前是这样.&lt;/p&gt;
&lt;p&gt;首先是一些值对象, 它们不需要标识符.&lt;/p&gt;
&lt;p&gt;然后是一些实体, 例如订单, 它是一个实体, 具有身份标识, 因此我们必须使用 &lt;em&gt;ID&lt;/em&gt; 对其进行建模. 但我们现在不知道 &lt;em&gt;ID&lt;/em&gt; 是 &lt;em&gt;string&lt;/em&gt;, 还是 &lt;em&gt;int&lt;/em&gt; 还是 &lt;em&gt;guid&lt;/em&gt;, 但我们知道我们需要它, 因此, 现在让我们使用 &lt;em&gt;Undefined&lt;/em&gt;. 我们将以同样的方式处理其他标识符.&lt;/p&gt;
&lt;p&gt;最后, 让我们以工作流本身结束. 工作流的输入 &lt;em&gt;UnvalidatedOrder&lt;/em&gt; 将从订单表单 “原样” 生成, 因此将仅包含 &lt;em&gt;int&lt;/em&gt; 和 &lt;em&gt;string&lt;/em&gt; 等基础类型. 工作流的输出需要两种类型: 工作流成功时的事件类型以及失败类型.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;namespace&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;OrderTaking&lt;/span&gt;.Domain

&lt;span style="color: #228B22"&gt;//&lt;/span&gt;
&lt;span style="color: #228B22"&gt;//&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// 这些都是值对象, 不需要标识符.&lt;/span&gt;
&lt;span style="color: #228B22"&gt;//&lt;/span&gt;
&lt;span style="color: #228B22"&gt;//&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// Product code related&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;WidgetCode&lt;/span&gt; = WidgetCode &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;string&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// constraint: starting with "W" then 4 digits&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;GizmoCode&lt;/span&gt; = GizmoCode &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;string&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// constraint: starting with "G" then 3 digits&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;ProductCode&lt;/span&gt; =
    | Widget &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; WidgetCode
    | Gizmo &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; GizmoCode

&lt;span style="color: #228B22"&gt;// Order Quantity related&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;UnitQuantity&lt;/span&gt; = UnitQuantity &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; int
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;KilogramQuantity&lt;/span&gt; = KilogramQuantity &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;decimal&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;OrderQuantity&lt;/span&gt; =
    | Unit &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; UnitQuantity
    | Kilos &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; KilogramQuantity

&lt;span style="color: #228B22"&gt;//&lt;/span&gt;
&lt;span style="color: #228B22"&gt;//&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// 一些 Undefined 标识符, 以及一些实体.&lt;/span&gt;
&lt;span style="color: #228B22"&gt;//&lt;/span&gt;
&lt;span style="color: #228B22"&gt;//&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;Undefined&lt;/span&gt; = &lt;span style="color: #00688B; font-weight: bold"&gt;exn&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;OrderId&lt;/span&gt; = Undefined
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;OrderLineId&lt;/span&gt; = Undefined
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CustomerId&lt;/span&gt; = Undefined
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CustomerInfo&lt;/span&gt; = Undefined
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;ShippingAddress&lt;/span&gt; = Undefined
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;BillingAddress&lt;/span&gt; = Undefined
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;Price&lt;/span&gt; = Undefined
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;BillingAmount&lt;/span&gt; = Undefined

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;Order&lt;/span&gt; = {
    Id : OrderId &lt;span style="color: #228B22"&gt;// id for entity&lt;/span&gt;
    CustomerId : CustomerId &lt;span style="color: #228B22"&gt;// customer reference&lt;/span&gt;
    ShippingAddress : ShippingAddress
    BillingAddress : BillingAddress
    OrderLines : OrderLine &lt;span style="color: #00688B; font-weight: bold"&gt;list&lt;/span&gt;
    AmountToBill : BillingAmount
}

&lt;span style="color: #8B008B"&gt;and&lt;/span&gt; OrderLine = {
    Id : OrderLineId &lt;span style="color: #228B22"&gt;// id for entity&lt;/span&gt;
    OrderId : OrderId
    ProductCode : ProductCode
    OrderQuantity : OrderQuantity
    Price : Price
}

&lt;span style="color: #228B22"&gt;//&lt;/span&gt;
&lt;span style="color: #228B22"&gt;//&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// 定义工作流及其输入和输出.&lt;/span&gt;
&lt;span style="color: #228B22"&gt;//&lt;/span&gt;
&lt;span style="color: #228B22"&gt;//&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;UnvalidatedOrder&lt;/span&gt; = {
    OrderId : &lt;span style="color: #00688B; font-weight: bold"&gt;string&lt;/span&gt;
    CustomerInfo : ...
    ShippingAddress : ...
    ...
}

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;PlaceOrderEvents&lt;/span&gt; = {
    AcknowledgmentSent : ...
    OrderPlaced : ...
    BillableOrderPlaced : ...
}

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;PlaceOrderError&lt;/span&gt; =
    | ValidationError &lt;span style="color: #8B008B; font-weight: bold"&gt;of&lt;/span&gt; ValidationError &lt;span style="color: #00688B; font-weight: bold"&gt;list&lt;/span&gt;
    | ... &lt;span style="color: #228B22"&gt;// other errors&lt;/span&gt;

&lt;span style="color: #8B008B"&gt;and&lt;/span&gt; ValidationError = {
    FieldName : &lt;span style="color: #00688B; font-weight: bold"&gt;string&lt;/span&gt;
    ErrorDescription : &lt;span style="color: #00688B; font-weight: bold"&gt;string&lt;/span&gt;
}

&lt;span style="color: #CD5555"&gt;/// The "Place Order" process&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;PlaceOrder&lt;/span&gt; =
    UnvalidatedOrder -&amp;gt; Result&amp;lt;PlaceOrderEvents, PlaceOrderError&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但我们的模型尚未完成. 例如, 该如何对订单的不同状态进行建模: 验证、定价等?&lt;/p&gt;</content><category term="函数式"></category><category term="函数式"></category><category term="领域驱动"></category><category term="DDD"></category></entry><entry><title>二. A Functional Architecture</title><link href="http://www.smallcpp.cn/er-a-functional-architecture.html" rel="alternate"></link><published>2019-11-29T13:00:00+08:00</published><updated>2019-11-29T13:00:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2019-11-29:/er-a-functional-architecture.html</id><summary type="html">
&lt;p&gt;在本章中, 我们将简要介绍面向函数式的领域模型的典型软件架构以及将 DDD 概念(如 “界限上下文” 和 “领域事件”)转换为软件的方法.&lt;/p&gt;
&lt;p&gt;当然, 软件架构本身就是一个领域, 因此, 让我们遵循我们自己的建议, 在谈论它时使用 “无处不在的语言”. 我们将使用 Simon Brown 的 “C4” 方法中的术语, 其中软件架构由四个级别组成:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The “&lt;strong&gt;system context&lt;/strong&gt;” is the top level representing …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">
&lt;p&gt;在本章中, 我们将简要介绍面向函数式的领域模型的典型软件架构以及将 DDD 概念(如 “界限上下文” 和 “领域事件”)转换为软件的方法.&lt;/p&gt;
&lt;p&gt;当然, 软件架构本身就是一个领域, 因此, 让我们遵循我们自己的建议, 在谈论它时使用 “无处不在的语言”. 我们将使用 Simon Brown 的 “C4” 方法中的术语, 其中软件架构由四个级别组成:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The “&lt;strong&gt;system context&lt;/strong&gt;” is the top level representing the entire system.&lt;/li&gt;
&lt;li&gt;The system context comprises a number of “&lt;strong&gt;containers&lt;/strong&gt;”, which are deployable units such as a website, a web service, a database, etc.&lt;/li&gt;
&lt;li&gt;Each container in turn comprises a number of “&lt;strong&gt;components&lt;/strong&gt;”, which are the major structural building blocks in the code.&lt;/li&gt;
&lt;li&gt;Finally, each component comprises a number of “&lt;strong&gt;classes”&lt;/strong&gt; (or in a functional architecture, “modules”) that contain a set of low-level methods or functions.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;One of the goals of a good architecture is to define the various boundaries between &lt;strong&gt;containers&lt;/strong&gt;, &lt;strong&gt;components&lt;/strong&gt;, and &lt;strong&gt;modules&lt;/strong&gt;, such that when new requirements arise, as they will, the “cost of change” is minimized.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="https://medium.com/nick-tune-tech-strategy-blog/domain-driven-architecture-diagrams-139a75acb578"&gt;Domain-Driven Architecture Diagrams&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id="bounded-contexts-as-autonomous-software-components"&gt;Bounded Contexts as Autonomous Software Components&lt;/h1&gt;
&lt;p&gt;界限上下文本身就一个具有明确边界的独立子系统, 对应 C4 中的 &lt;em&gt;containers&lt;/em&gt;. 有一些常见的实践可供参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果整个系统被实现为整体部署 (a single container using the C4 terminology above), 那么界限上下文可以被实现成是一个个的具有明确接口定义的单独模块.&lt;/li&gt;
&lt;li&gt;否则的话, 每个界限上下文可以实现成单独可部署的容器 – 面向服务架构(SOA).&lt;/li&gt;
&lt;li&gt;或者, 我们甚至可以更细化, 将每个单独的工作流放入一个独立的可部署容器 – 微服务架构.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;PS, 一个界限上下文可能会包含多个工作流. 例如仓储部门可能会有收货工作流和发货工作流.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是, 在项目的早期阶段, 我们不需要致力于确定到底用哪种实践方式. 随着我们对领域的深入了解, 界限也会相应地发生改变, 而重构整体组件要容易得多, 因此一个&lt;strong&gt;好的实践&lt;/strong&gt;是将系统最初构建为整体组件, 然后仅在需要时才重构为解耦的独立容器. 只要我们能确保界限上下文保持独立低耦合, 那么从逻辑设计转换到物理架构就不会太多问题.&lt;/p&gt;
&lt;p&gt;除非我们确定利大于弊, 否则无需直接转向微服务. 创建真正低耦和的微服务架构非常棘手 – 如果关闭其中的一个微服务, 而其他所有事情都中断了, 那么实际上并不是微服务架构, 而只是一个分布式的整体!&lt;/p&gt;
&lt;h1 id="communicating-between-bounded-contexts"&gt;Communicating Between Bounded Contexts&lt;/h1&gt;
&lt;p&gt;正如&lt;a href="http://www.smallcpp.cn/yi-introducing-domain-driven-design.html#documenting-commands"&gt;前面&lt;/a&gt;所看到的, 我们使用事件在不同界限上下文之间传递信息. 例如, 接单上下文和运输上下文之间的关系可能如下所示:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/communicate.png"/&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Order Taking&lt;/em&gt; 上下文中的 &lt;em&gt;Place Order&lt;/em&gt; 工作流触发了 &lt;em&gt;OrderPlaced&lt;/em&gt; 事件.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;OrderPlaced&lt;/em&gt; 事件放到一个队列中(或其它发布方式).&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Shipping&lt;/em&gt; 上下文监听 &lt;em&gt;OrderPlaced&lt;/em&gt; 事件.&lt;/li&gt;
&lt;li&gt;收到事件后, 将创建 &lt;em&gt;ShipOrder&lt;/em&gt; 命令.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;ShipOrder&lt;/em&gt; 命令启动 &lt;em&gt;Ship Order&lt;/em&gt; 工作流.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Ship Order&lt;/em&gt; 工作流成功完成时, 它将发出 &lt;em&gt;OrderShipped&lt;/em&gt; 事件.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到这是一个完全解耦的设计: 上游组件(接单子系统)和下游组件(运输子系统)彼此不了解, 仅通过事件进行通信. 如果我们想要拥有真正独立自主的组件, 这种解耦至关重要.&lt;/p&gt;
&lt;p&gt;在上下文之间传输事件的确切机制取决于我们选择的架构体系, 也许是消息队列, 也有可能是直接的函数调用; 至于将事件转换为命令的处理程序(例如 &lt;em&gt;OrderPlaced&lt;/em&gt; -&amp;gt; &lt;em&gt;ShipOrder&lt;/em&gt;), 它可以是下游边界的一部分, 也可以由基础设施层(infrastructure)来完成. 具体取决于我们最终选择的架构体系以及要在何处分离事件和命令之间的耦合.&lt;/p&gt;
&lt;p&gt;如之前所述, 项目的早期阶段不需要立即确定事件的通信及转换机制, 我们需要做的是保证不同上下文之间的低耦合.&lt;/p&gt;
&lt;h2 id="transferring-data-between-bounded-contexts"&gt;Transferring Data Between Bounded Contexts&lt;/h2&gt;
&lt;p&gt;通常, 上游发送给下游的事件还需要包含下游处理该事件所需的所有数据. 例如, &lt;em&gt;OrderPlaced&lt;/em&gt; 事件需要包含已下达订单的完整信息.这样就为下游提供了构建相应的 &lt;em&gt;ShipOrder&lt;/em&gt; 命令所需的信息(如果数据太大而无法包含在事件中, 则可以传递共享数据存储的位置).&lt;/p&gt;
&lt;p&gt;传递的数据对象可能在表面上类似于领域对象, 但它们并不相同. 传递的数据对象专门设计用于序列化并作为上下文间基础架构的一部分共享, 我们称这些对象为 &lt;strong&gt;DTO&lt;/strong&gt; (Data Transfer Object). 换句话说, &lt;em&gt;OrderPlaced&lt;/em&gt; 事件中的 &lt;em&gt;OrderDTO&lt;/em&gt; 将包含与 Order 领域对象大多数相同的信息, 但会按照其目的进行不同的结构调整 (后续会说怎么调整, 现在只要知道 DTO 的概念).&lt;/p&gt;
&lt;p&gt;在上游的边界处, 将领域对象转换为 DTO, 再将 DTO 序列化为 JSON/XML 或其它某种序列化格式.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/converted-dto.png"/&gt;&lt;/p&gt;
&lt;p&gt;在下游中, 则是这个过程的逆向: 将 JSON/XML 反序列化为 DTO, 然后将其转换为领域对象.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/converted-domain.png"/&gt;&lt;/p&gt;
&lt;p&gt;实际上, 序列化的顶级 DTO 通常是事件 DTO(因为下游要根据事件去触发命令), 而事件 DTO 又包含子 DTO, 例如 &lt;em&gt;OrderDTO&lt;/em&gt;, 后者又包含其他子 DTO, 例如 &lt;em&gt;OrderLineDTO&lt;/em&gt; 的列表.&lt;/p&gt;
&lt;h2 id="trust-boundaries-and-validation"&gt;Trust Boundaries and Validation&lt;/h2&gt;
&lt;p&gt;界限上下文的界限会充当 “&lt;strong&gt;信任边界&lt;/strong&gt;”. 界限上下文内部的任何内容都将是可信且有效的, 而界限上下文之外的任何内容都将不可信且可能无效的. 因此, 我们将在工作流的开头和结尾添加 “门”, 它们充当可信任领域和不受信任外部世界之间的中介.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/trust.png"/&gt;&lt;/p&gt;
&lt;p&gt;在输入门, 我们将始终验证输入以确保其符合领域模型的约束. 例如, 假设某个订单的某个属性必须为非空且少于 50 个字符. 传入的 &lt;em&gt;OrderDTO&lt;/em&gt; 不会有此类约束, 但是在输入门处进行验证之后, 我们可以确保进入工作流中的 Order 领域对象是有效的. 因为如果验证失败, 则将绕过工作流程并生成错误(后续会说明具体怎么操作).&lt;/p&gt;
&lt;p&gt;输出门的工作则不一样, 它的工作是确保隐私属性不会泄漏到界限上下文之外, 既避免上下文之间的意外耦合, 又出于安全原因. 例如, 运输上下文不需要知道用于支付订单的信用卡号. 因此, 在将领域对象转换为 DTO 的过程中, 输出门通常会故意 “丢失” 一些信息(例如卡号).&lt;/p&gt;
&lt;h1 id="contracts-between-bounded-contexts"&gt;Contracts Between Bounded Contexts&lt;/h1&gt;
&lt;p&gt;虽然我们希望尽可能减少界限上下文之间的耦合, 但是共享的通信格式总是会引起某种耦合 – 事件和相关的 DTO 在界限上下文之间将形成一种契约. 为了使通信成功, 这两个上下文需要针对它们的通用格式达成共识.&lt;/p&gt;
&lt;p&gt;那么谁来决定契约呢? 这依赖于上下文之间的关系(实际上是拥有这些上下文的团队之间的关系), DDD 社区已经总结了一些通用术语:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Shared Kernel&lt;/strong&gt;, 两个上下文互相协商&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Customer/Supplier&lt;/strong&gt; or &lt;strong&gt;Consumer Driven Contract&lt;/strong&gt;, 下游定义契约, 上游遵守&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Conformist&lt;/strong&gt;, 上游定义契约, 下游遵守&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="anti-corruption-layers"&gt;Anti-Corruption Layers&lt;/h2&gt;
&lt;p&gt;通常, 当与外部系统进行通信时, 它们现有的接口可能与我们的领域模型根本不匹配. 在这种情况下, 需要将交互及数据转换为更适合在我们领域中使用的格式, 否则我们的领域模型将因尝试适应外部系统的模型而变得 “被破坏”.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;外部系统&lt;/strong&gt;通常是指第三方系统, 数据存储库甚至是遗留代码. 因为这些系统我们无法和它签订契约, 只能被迫接受.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这种额外的解耦级别在 DDD 术语中称为 “反腐层”, 通常缩写为 &lt;strong&gt;ACL&lt;/strong&gt;, ACL 角色通常由上面提到的 “输入门” 扮演 – 它防止内部干净的领域模型因外界知识而 “被破坏”.&lt;/p&gt;
&lt;p&gt;反腐层的主要目的&lt;strong&gt;不是执行验证或防止数据损坏&lt;/strong&gt;, 而是充当领域之间的 “词汇翻译器”; 同时也避免了以后切换系统时修改核心层代码. 通俗点来讲, 这也是适配器模式或外观模式的应用.&lt;/p&gt;
&lt;p&gt;例如在我们要实现的接单系统中, 可能需要向外部某个地图服务查询订单提供的地址, 因此我们将插入一个显式的反腐层(ACL)用来转换第三方地图服务的领域词汇.&lt;/p&gt;
&lt;h2 id="a-context-map-with-relationships"&gt;A Context Map With Relationships&lt;/h2&gt;
&lt;p&gt;随着我们对领域的了解, 是时候更新之前定义的 &lt;a href="http://www.smallcpp.cn/yi-introducing-domain-driven-design.html#creating-context-maps"&gt;Context Maps&lt;/a&gt; 了.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/context-map2.png"/&gt;&lt;/p&gt;
&lt;p&gt;可以看到, 上下文映射不再只是显示上下文之间的纯粹技术关系, 还显示了拥有上下文的团队之间的关系, 以及我们期望他们如何协作.&lt;/p&gt;
&lt;p&gt;最后, &lt;em&gt;address checking service&lt;/em&gt; 是一个外部系统, 它的模型与我们的领域完全不相似, 因此我们将在与它的交互中插入一个显式的反腐败层(&lt;em&gt;ACL&lt;/em&gt;). 使用第三方组件时, 这是常见的模式. 它可以帮助我们避免供应商锁定, 并在以后改用到其他服务.&lt;/p&gt;
&lt;h1 id="workflows-within-a-bounded-context"&gt;Workflows Within a Bounded Context&lt;/h1&gt;
&lt;p&gt;在探索过程中, 我们将业务工作流视为由命令启动的 &lt;em&gt;mini-process&lt;/em&gt;, 该工作流会生成一个或多个领域事件. 在函数式架构中. 所有这些工作流都将映射成单个函数, 其中输入是命令对象, 而输出是事件对象的列表.&lt;/p&gt;
&lt;p&gt;当创建设计图时, 将工作流表示为带有输入和输出的小管道, 公开工作流(那些从界限上下文之外触发的工作流)将 “伸出” 边界.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/workflow.png"/&gt;&lt;/p&gt;
&lt;p&gt;一个工作流始终包含在单个界限上下文中, 永远不会有通过多个上下文实现 “端到端” 的情况. &lt;a href="http://www.smallcpp.cn/wu-modeling-workflows-as-pipelines.html"&gt;Modeling Workflows as Pipelines&lt;/a&gt;章节中会详细介绍如何对工作流建模.&lt;/p&gt;
&lt;h2 id="workflow-inputs-and-outputs"&gt;Workflow Inputs and Outputs&lt;/h2&gt;
&lt;p&gt;工作流的输入始终是关联了一些数据的命令, 而输出始终是要与其他上下文进行通信的一组事件. 例如, 在 &lt;em&gt;Place Order&lt;/em&gt; 工作流中, 输入是关联了必要数据的 &lt;em&gt;PlaceOrder&lt;/em&gt; 命令, 输出则是一组如 &lt;em&gt;OrderPlaced&lt;/em&gt; 之类的事件.&lt;/p&gt;
&lt;p&gt;但是请记住, 如上面的&lt;a href="http://www.smallcpp.cn/er-a-functional-architecture.html#a-context-map-with-relationships"&gt;映射图&lt;/a&gt;所示, &lt;em&gt;Order Taking Context&lt;/em&gt; 和 &lt;em&gt;Billing Context&lt;/em&gt; 之间是 “Customer/Supplier” 关系. 这意味着, 我们应遵守 &lt;em&gt;Billing&lt;/em&gt; 部门的契约, 仅发送他们需要的信息过去, 而不是一个通用的 &lt;em&gt;OrderPlaced&lt;/em&gt; 事件. 例如, 可能仅仅是账单地址和账单总额, 而不是送货地址或项目列表, 新的事件 &lt;em&gt;BillableOrderPlaced&lt;/em&gt; 结构可能如下所示:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;data BillableOrderPlaced =
    OrderId
    AND BillingAddress
    AND AmountToBill
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同样的道理, 我们可能还希望发出 &lt;em&gt;OrderAcknowledgementSent&lt;/em&gt; 事件.&lt;/p&gt;
&lt;p&gt;现在让我们来绘制 &lt;em&gt;Place Order&lt;/em&gt; 工作流的流程图:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/workflow-diagram.png"/&gt;&lt;/p&gt;
&lt;p&gt;请务必注意, 工作流函数并不会 “发布” 领域事件(它只是返回它们), 图上只是我们的逻辑设计, 如何真正的发布事件则是另一个单独的话题.&lt;/p&gt;
&lt;h2 id="avoid-domain-events-within-a-bounded-context"&gt;Avoid Domain Events Within a Bounded Context&lt;/h2&gt;
&lt;p&gt;在面向对象的设计中, 通常也会有领域事件在界限上下文内部引发. 用这种方式, 工作流在内部引发 &lt;em&gt;OrderPlaced&lt;/em&gt; 事件, 然后会有一些 &lt;em&gt;event handler&lt;/em&gt; 监听到该事件, 并触发后续的流程. 可能如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/oo-event.png"/&gt;&lt;/p&gt;
&lt;p&gt;在函数式设计中, 我们不使用这种方式, 因为它会创建隐藏的依赖. 因此, 如果我们需要一个事件的 “侦听器”, 我们只需将其追加到工作流的末尾, 如下所示:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/function-event.png"/&gt;&lt;/p&gt;
&lt;p&gt;这种方式更明确 – 上下文内没有具有可变状态的全局事件管理器, 因此更易于理解和维护, 我们在 &lt;a href="http://www.smallcpp.cn/liu-implementation-composing-a-pipeline.html"&gt;Implementation: Composing a Pipeline&lt;/a&gt; 章节中将看到如何实践.&lt;/p&gt;
&lt;h1 id="code-structure-within-a-bounded-context"&gt;Code Structure Within a Bounded Context&lt;/h1&gt;
&lt;p&gt;现在来看看界限上下文中的代码结构.&lt;/p&gt;
&lt;p&gt;这个话题已经是老生长谈了, 基本上不是洋葱架构就是六边形架构, 我们这里使用&lt;a href="https://www.infoq.cn/article/2014/11/ddd-onion-architecture"&gt;洋葱架构&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/onion.png"/&gt;&lt;/p&gt;
&lt;p&gt;洋葱架构的本质是依赖倒置原则的应用:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该应用程序围绕独立的对象模型构建&lt;/li&gt;
&lt;li&gt;内层定义接口, 外层实现接口&lt;/li&gt;
&lt;li&gt;耦合方向朝向中心&lt;/li&gt;
&lt;li&gt;所有应用程序核心代码都可以编译并与基础架构分开运行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然, 为了确保所有层都向内依赖, 我们会在 Domain 层使用到&lt;a href="http://www.smallcpp.cn/liu-implementation-composing-a-pipeline.html#injecting-dependencies"&gt;依赖注入&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;依赖注入和往往会遵循依赖倒置原则. 例如 Core 想要使用 Infrastructure 中的功能, 一般情况下就是 Core 要依赖于 Infrastructure 了. 但如果使用依赖倒置, 就变成在 Core 中定义功能接口, 然后将 Infrastructure 对象注入给 Core.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="keep-io-at-the-edges"&gt;Keep I/O at the Edges&lt;/h2&gt;
&lt;p&gt;函数编程的一个主要目标是使用没有副作用的&lt;a href="http://www.smallcpp.cn/han-shu-shi-guan-jian-gai-nian-haskell-miao-shu.html#_2"&gt;纯函数&lt;/a&gt;. 然而大部分的程序都会涉及到 I/O (例如读写数据库), 这是一个有副作用的操作. 那么, 我们要如何处理这部分有副作用的代码呢?&lt;/p&gt;
&lt;p&gt;答案是将任何 I/O 推送到洋葱架构的边缘, 也就是说, 只在工作流的开始或结束时读写数据库, 而不是在工作流内部进行读写.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/onion2.png"/&gt;&lt;/p&gt;
&lt;p&gt;这样还会有一个额外的好处 – 迫使我们关注点分离: 核心 domain 层只涉及业务逻辑, 而持久性和其他 I/O 则是 infrastructural 层该关心的问题.&lt;/p&gt;
&lt;p&gt;事实上, 这种设计也避免了我们无意识的使用 “数据驱动开发”, 因为如果甚至无法从工作流内部访问数据库, 则无法使用数据库对领域进行建模! (后续实践会详细讨论数据库的设计).&lt;/p&gt;</content><category term="函数式"></category><category term="函数式"></category><category term="领域驱动"></category><category term="DDD"></category></entry><entry><title>一. Introducing Domain-Driven Design</title><link href="http://www.smallcpp.cn/yi-introducing-domain-driven-design.html" rel="alternate"></link><published>2019-11-28T10:00:00+08:00</published><updated>2019-11-28T10:00:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2019-11-28:/yi-introducing-domain-driven-design.html</id><summary type="html">
&lt;p&gt;DDD 社区指导我们如何创建通用的模型:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关注业务事件和工作流程, 而不是数据结构 (ps: 职责驱动)&lt;/li&gt;
&lt;li&gt;将问题域划分为较小的子域&lt;/li&gt;
&lt;li&gt;为每个子域创建解决方案模型 (Bounded Contexts – Domain Model)&lt;/li&gt;
&lt;li&gt;开发一种公共语言在项目涉及的每个人之间共享, 并在代码中随处使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="understanding-the-domain-through-business-events"&gt;Understanding the Domain Through Business Events&lt;/h1&gt;
&lt;p&gt;DDD 收集需求的方法强调在开发人员和领域专家之间建立共识, 但是我们该从哪开始?&lt;/p&gt;
&lt;p&gt;第一条准则是 “&lt;strong&gt;专注于业务事件&lt;/strong&gt;”, 因此让我们开始事件风暴会议. 这是开始的方式.&lt;/p&gt;
&lt;p&gt;业务不光有数据, 而且还以某种方式对其进行了转换. 也就是说 …&lt;/p&gt;</summary><content type="html">
&lt;p&gt;DDD 社区指导我们如何创建通用的模型:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关注业务事件和工作流程, 而不是数据结构 (ps: 职责驱动)&lt;/li&gt;
&lt;li&gt;将问题域划分为较小的子域&lt;/li&gt;
&lt;li&gt;为每个子域创建解决方案模型 (Bounded Contexts – Domain Model)&lt;/li&gt;
&lt;li&gt;开发一种公共语言在项目涉及的每个人之间共享, 并在代码中随处使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="understanding-the-domain-through-business-events"&gt;Understanding the Domain Through Business Events&lt;/h1&gt;
&lt;p&gt;DDD 收集需求的方法强调在开发人员和领域专家之间建立共识, 但是我们该从哪开始?&lt;/p&gt;
&lt;p&gt;第一条准则是 “&lt;strong&gt;专注于业务事件&lt;/strong&gt;”, 因此让我们开始事件风暴会议. 这是开始的方式.&lt;/p&gt;
&lt;p&gt;业务不光有数据, 而且还以某种方式对其进行了转换. 也就是说, 可以把业务流程看作一系列数据或文档的转换; 而在转换的过程中创造出了业务价值, 因此了解这些转换如何工作以及它们如何相互关联是非常重要的.&lt;/p&gt;
&lt;p&gt;闲置在那里的数据不会产生任何贡献, 是什么让员工 (或自动化流程) 开始使用该数据并产生价值?
通常是外部触发 (一封邮件到达, 接了个电话), 但也可能是基于时间的触发 (每天上午10点做某事) 或基于观察者 (收件箱中没有其他订单可以处理, 请执行其他操作).
无论是什么, 将其作为设计的一部分捕获都是很重要的, 我们称这些为&lt;strong&gt;领域事件&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;领域事件几乎是我们所有想要建模的业务流程的起点. 例如, “收到新订单”是一个启动接单流程的领域事件. (ps: 即一个业务流程基本上都是由领域事件启动).&lt;/p&gt;
&lt;p&gt;领域事件始终以过去时态书写, 因为那些是已经发生的, 无法更改的事实.&lt;/p&gt;
&lt;h2 id="using-event-storming-to-discover-the-domain"&gt;Using Event Storming to Discover the Domain&lt;/h2&gt;
&lt;p&gt;事件风暴是我们收集业务事件的有效方式之一.&lt;/p&gt;
&lt;p&gt;在事件风暴中, 可以召集各种各样的人（他们了解域的不同部分）来参加研讨会. 与会人员不仅应包括开发人员和领域专家, 还应包括对项目成功感兴趣的所有其他利益相关方. 正如事件风暴者喜欢说的: “任何有疑问的人, 任何有答案的人.”&lt;/p&gt;
&lt;p&gt;研讨会应在一个有大墙壁的房间内举行, 墙壁上应覆盖纸或白板材料, 以便参与者可以在其上张贴或绘制便签. 在会议成功结束时, 墙壁上将覆盖数百个这样的笔记.&lt;/p&gt;
&lt;p&gt;在研讨会期间, 人们在便签上写下业务事件, 然后将其张贴在墙上. 其他人可能会通过发布注释来回应, 这些注释概述了由这些事件触发的业务工作流程. 这些工作流程反过来通常会导致创建其他业务事件. 此外, 注释通常还很可能触发小组之间的进一步讨论. 这样做的目的是让所有参与者都能发布他们所知道的内容, 并提出他们所不知道的问题. 这是一个高度互动的过程, 鼓励每个人都参与其中.&lt;/p&gt;
&lt;h2 id="discovering-the-domain-an-order-taking-system"&gt;Discovering the Domain: An Order-Taking System&lt;/h2&gt;
&lt;p&gt;案例分析. 一家公司的需求:&lt;/p&gt;
&lt;p&gt;“我们是一家小公司, 为其他公司制造零件: 小部件, 小物件等. 我们发展非常快, 我们的现有流程无法跟上. 目前, 我们所做的一切都是基于纸张的, 我们希望将所有这些都让计算机进行处理, 以便我们的员工可以处理大量的订单. 特别是, 我们希望拥有一个自助服务网站, 以便客户自己完成一些任务. 下订单, 检查订单状态等.”&lt;/p&gt;
&lt;p&gt;进行一轮&lt;a href="http://www.smallcpp.cn/yi-introducing-domain-driven-design.html#_1"&gt;事件风暴&lt;/a&gt;后, 我们的墙上也许看起来是这样的:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/event-storm.png"/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一些事件旁边还张贴了业务工作流程, 例如 “place order” 和 “ship order”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;让我们看一下事件风暴可以促进需求收集的哪些方面:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;通用的业务模型&lt;/strong&gt;. 每个人都在同一堵墙上看到相同的东西&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更好的团队协作&lt;/strong&gt;. 所有的团队都参与到讨论, 有可能你的输出会是另一个团队的输入, 所以你可能需要了解的更多&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;发现缺省的需求&lt;/strong&gt;. 在项目开始时需求通常很模糊, 随着讨论的深入, 一些需求会慢慢浮出表面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如下图, 随着讨论的进行, 我们发现了新的需求(&lt;em&gt;发现缺省的需求&lt;/em&gt;): “Acknowledgment sent to customer” 和 “dispatch message sent to customer”, 另外还发现了当接订单部门完成订单处理后, 需要通过 “order placed” 事件通知计费部门(&lt;em&gt;更好的团队协作&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/team-connection.png"/&gt;&lt;/p&gt;
&lt;p&gt;另外需要注意, 任何企业都需要了解过去发生的事情––&lt;strong&gt;报告始终是领域的一部分&lt;/strong&gt;! 确保事件风暴研讨会中包括了报告和其他只读模型(例如UI的视图模型).&lt;/p&gt;
&lt;h2 id="expanding-the-events-to-the-edges"&gt;Expanding the Events to the Edges&lt;/h2&gt;
&lt;p&gt;尽可能多地跟踪事件链到系统边界通常很有用. 我们会问最外边的事件之前是否发生了任何事件.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;  "是什么触发了 Order form received 事件?"
  "我们每天早上打开邮件, 客户会发送订单表格过来, 我们将其分类为订单或报价."
  "所以我们也需要 Mail Received 事件吗?"
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同样, 我们甚至可以将事件扩展到业务的运输方面.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;  "将订单运送给客户后, 是否有可能发生的事件?"
  "如果订单是[已签收交货], 我们将收到快递服务的通知, 那么我添加一个 Shipment received by customer 事件"
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;扩展业务事件扩展是捕获缺失需求的好方法之一, 你可能会发现事件链最终比预期的要长.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/extend-event.png"/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;现在我们关注仅是业务领域层面, 并不涉及到具体的开发设计; 此外, 在开始实现时, 通常不需要一次转换所有系统, 应该从整个系统来看, 首先只转换最受益的部分.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="documenting-commands"&gt;Documenting Commands&lt;/h2&gt;
&lt;p&gt;收集到许多事件后, 我们也许会思考: “是什么原因导致这些领域事件的发生?”. 可能是某人或某物想要进行某项活动, 例如, 客户希望我们收到订单, 或者老板要求我们做某事. DDD 术语中将这些请求称为命令(不要与OO编程中使用的命令模式相混淆).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;命令通常用命令句书写, 很可能会在将来被变函数名.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;并非所有命令都能成功执行, 例如订单可能已丢失, 或者我们正忙于处理更重要的事情. 但是, 如果命令成功执行, 它将启动工作流程, 该工作流程又将创建相应的领域事件. 实际上, 我们将尝试以这种方式对大多数业务流程进行建模. 事件触发命令, 从而启动一些业务工作流程, 工作流程会输出更多的事件, 然后, 这些事件也可以触发其它命令. 这种思考业务流程的方式––具有输入和输入的管道, 非常适合&lt;strong&gt;函数式编程&lt;/strong&gt;的方式.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/command.png"/&gt;&lt;/p&gt;
&lt;p&gt;然后, 使用此方法, &lt;em&gt;order taking&lt;/em&gt; 过程如下所示:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/commandeg.png"/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;并非所有事件都需要与命令关联, 一些事件可能是由调度程序或监视系统或人为触发.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;至于 &lt;em&gt;Place Order&lt;/em&gt; 产生的事件如何触发下一步命令, 参考: &lt;a href="http://www.smallcpp.cn/er-a-functional-architecture.html#communicating-between-bounded-contexts"&gt;Communicating Between Bounded Contexts&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id="partitioning-the-domain-into-subdomains"&gt;Partitioning the Domain into Subdomains&lt;/h1&gt;
&lt;p&gt;现在, 我们有了事件和命令的列表, 并且对各种业务流有了很好的了解. 可以开始进行下一步了.&lt;/p&gt;
&lt;p&gt;第二条准则是 “&lt;strong&gt;将问题域划分为较小的子域&lt;/strong&gt;”. 往往一个大领域可能会被拆分为职责更明确的小领域, 我们称这些为&lt;strong&gt;子域&lt;/strong&gt;. 所以子域是一个相对的概念, 它本身是一个领域, 同时它又是另一个大领域的子域. 例如, “Web编程” 是 “通用编程” 领域的子域. “JavaScript编程” 是 “Web编程” 领域的子域(至少以前是).&lt;/p&gt;
&lt;p&gt;众所周知, 企业内部按职责设有独立的部门, 这很明显地暗示着我们可以在设计中遵循相同的划分. 我们将划分后的各部分称为领域. 那么怎么定义各个领域? 实际上&lt;strong&gt;无须费心去定义各个领域的具体含义&lt;/strong&gt;, 例如 “计费” 领域, 在实践中, 我们只用说 “计费” 是计费部门人员(领域专家)的工作, 而无需努力地为 “计费” 的含义提供明确的词典解释.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="http://www.smallcpp.cn/yi-introducing-domain-driven-design.html#getting-the-contexts-right"&gt;Getting the Contexts Right&lt;/a&gt; 介绍了其它的一些帮助准则.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有的时候领域还会发生重叠. 例如, “CSS” 子域可以被视为 “网络编程” 领域的一部分, 但也可以被视为 “网络设计” 领域的一部分. 因此, 在将领域划分为更小的部分时, 我们必须小心: 我们想要绝对清晰的边界, 但现实世界比这要模糊得多(所以我们需要接下来要说的 &lt;em&gt;Bounded Contexts&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/subdomian.png"/&gt;&lt;/p&gt;
&lt;p&gt;将这种领域划分方法应用于订单处理系统(公司存在 “订单部门”, “运输部门”, “开票部门”):&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/subdomian2.png"/&gt;&lt;/p&gt;
&lt;p&gt;领域之间有些重叠, 接单员必须对开票和运输部门的工作情况有一点了解, 运输员必须对接单和开票部门的工作情况有一点了解, 等等.&lt;/p&gt;
&lt;p&gt;当然, 作为开发人员, 我们实际上需要更深入地了解上述领域. 但是, 现在让我们推迟了解, 继续去学习解决方案的指导原则.&lt;/p&gt;
&lt;h1 id="creating-a-solution-using-bounded-contexts"&gt;Creating a Solution Using Bounded Contexts&lt;/h1&gt;
&lt;p&gt;清楚了问题并不意味着构建解决方案很容易. 解决方案不可能描绘出原始领域中的所有信息, 我们也不希望如此. 我们应该只捕获与解决特定问题有关的信息, 而其它的都不相关.&lt;/p&gt;
&lt;p&gt;因此, 我们需要构建两套不同的体系对 “&lt;strong&gt;问题空间&lt;/strong&gt;” 和 “&lt;strong&gt;解决方案空间&lt;/strong&gt;” 进行区分. 我们将创建问题空间的模型, 仅提取领域中相关的方面, 最后在解决方案空间中重新构建它们(-&amp;gt;领域模型).&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/context.png"/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;领域模型&lt;/em&gt;是解决方案空间的一部分, 而它代表的&lt;em&gt;领域&lt;/em&gt;是问题空间的一部分.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如上图, 在&lt;strong&gt;解决方案空间&lt;/strong&gt;中, 可以看到&lt;strong&gt;问题空间&lt;/strong&gt;中的领域/子域已被映射成了&lt;strong&gt;界限上下文&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么要使用 “上下文”?&lt;/strong&gt;&lt;br/&gt;
因为每个上下文都代表解决方案中的一些专业知识. 在上下文中, 我们共享一种通用语言, 并且设计是连贯一致的. 就像在现实世界中一样, 脱离上下文的信息可能会令人困惑或无法使用.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么要使用 “界限”?&lt;/strong&gt;&lt;br/&gt;
在现实世界中, 领域的边界比较模糊, 领域间有所重叠; 但是在软件世界中, 我们希望减少子系统之间的耦合, 以便它们可以独立开发. 我们可以使用标准软件实践来做到这一点, 例如在子系统之间使用显式API并避免诸如共享代码之类的显示依赖. 不幸的是, 这也意味着我们的领域模型永远不会像现实世界那样丰富, 但是我们可以容忍这一点以换取更低的复杂性和更轻松的维护.&lt;/p&gt;
&lt;p&gt;其实, &lt;strong&gt;界限上下文本身就是一个子域&lt;/strong&gt;, 区别在于, 子域是问题空间的概念, 描述现实世界的业务如何被分解; 而界限上下文是解决方案空间的概念, 描述软件和软件开发是如何被分解的. 使用界限上下文这个词主要是有助于我们在设计解决方案时始终专注于重要的事情: 了解&lt;strong&gt;上下文&lt;/strong&gt;并了解&lt;strong&gt;边界&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;在大多数情况下, 子域和界限上下文是一一对应的, 但是在有遗留系统时, 有可能会有例外. 例如, 问题空间中的部分子域可能在遗留系统中已有实现, 我们待开发的新系统只要直接调用即可, 此时这部分子域会被映射成一个界限上下文.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/context2.png"/&gt;&lt;/p&gt;
&lt;p&gt;不管我们怎样划分领域, 重要的是每个界限上下文都应有明确的&lt;strong&gt;职责&lt;/strong&gt;. 因为当我们实现模型时, 界限上下文会被实现成子系统, 并将完全对应于&lt;a href="http://www.smallcpp.cn/er-a-functional-architecture.html#bounded-contexts-as-autonomous-software-components"&gt;某种软件组件&lt;/a&gt;, 例如单独的 &lt;em&gt;DLL&lt;/em&gt;, 独立服务或简单的命名空间, 取决于我们的软件架构.&lt;/p&gt;
&lt;h2 id="getting-the-contexts-right"&gt;Getting the Contexts Right&lt;/h2&gt;
&lt;p&gt;DDD 的最重要挑战之一是正确设置这些界限上下文. 以下是一些帮助准则:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;观察领域专家&lt;/strong&gt;. 如果他们使用相同的语言并专注于相同的问题, 则他们可能在属于同一个领域(映射到界限上下文).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意现有团队/部门的界限&lt;/strong&gt;. 这些是企业认为的领域/子域(映射到界限上下文)的有力线索. 当然, 这并不总是正确的, 有时同一部门中的人们彼此之间工作不一致; 相反, 可能会有不同部门中的人员紧密合作, 这反过来意味着他们可能在同一领域工作.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不要忘记 “界限”&lt;/strong&gt;. 我们需要明确界限上下文中的 “界限”, 特别是在需求不断变化时. 太大或太模糊的边界相当于根本就没有边界. (当然, 我们也有专门处理需求变化的方案, 在后续会详细介绍)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自主设计&lt;/strong&gt;. 如果两个小组对相同的界限上下文做出贡献, 那么它们可能会朝着不同的方向发展. 这会造成设计越来越混乱. 所以, 相比于试图让每个人都感到高兴的大型上下文, 可独立发展的并且有界限的上下文总是更好.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;为更流畅的业务工作流服务&lt;/strong&gt;. 如果工作流与多个界限上下文进行交互并且经常被它们阻塞或延迟, 请考虑重构界限上下文以使工作流更加流畅, 即使设计变得 “难看”. 也就是说, 始终专注于业务和客户价值, 而不是任何一种 “纯” 设计.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="creating-context-maps"&gt;Creating Context Maps&lt;/h2&gt;
&lt;p&gt;一旦定义了这些上下文, 我们就需要一种方法来表达它们之间的相互作用, 目标不是捕获每个细节, 而是在全局层面提供整个系统的视图. 在 DDD 术语中, 这些图称为上下文映射图.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/函数式领域建模/context-map.png"/&gt;&lt;/p&gt;
&lt;p&gt;在该映射图时, 我们并不关心 “shipping context” 的内部结构, 而只是知道从 “order-taking context” 接收数据, 至于怎么接收的暂时也不关心. 我们非正式地说, “shipping context” 在下游, 而 “order-taking context” 在上游.&lt;/p&gt;
&lt;p&gt;显然, 这两个上下文需要将它们要交换的消息格式达成一致. 通常, 上游对格式的决定权影响更大. 但有时, 下游不够灵活 (例如下游是一个遗留系统), 此时上游必须进行适应, 通常是引入某种&lt;a href="http://www.smallcpp.cn/er-a-functional-architecture.html#contracts-between-bounded-contexts"&gt;适配器组件&lt;/a&gt;作为中介.&lt;/p&gt;
&lt;p&gt;最后, 值得指出的是, 在我们的设计中, 我们可以将所有内容放入一张映射图中(到目前为止). 但在更复杂的设计中, 我们自然会希望创建一系列较小的映射图, 每个映射图都针对特定的子系统.&lt;/p&gt;
&lt;h2 id="focusing-on-the-most-important-bounded-contexts"&gt;Focusing on the Most Important Bounded Contexts&lt;/h2&gt;
&lt;p&gt;是否已有的界限上下文都同样重要? 开始开发时应该关注哪些?&lt;/p&gt;
&lt;p&gt;通常, 某些域比其他域更重要, 这些是&lt;strong&gt;核心域&lt;/strong&gt;, 提供业务优势的领域, 带来收益的领域.&lt;/p&gt;
&lt;p&gt;其他领域也可能是必需的, 但不是核心, 这些称为&lt;strong&gt;支撑域&lt;/strong&gt;; 还有些领域不是企业专有的(例如外部购买的通用服务), 则称为&lt;strong&gt;通用域&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;例如, 对于一家贸易公司而言, 接单和发货域可能是核心域, 因为它们的业务优势是其出色的客户服务; 帐单领域将被视为支撑域; 而货运的交付将被视为通用域, 这意味着他们可以安全地将其外包.&lt;/p&gt;
&lt;p&gt;当然, 现实并不如此简单. 有时同样类型的贸易公司可能会发现其货运的交付对于客户满意度至关重要, 此时货运的交付将被视为核心域. 就像同样是电商, 有的注重销售, 而有的注重售后, 有的注重活动, 还有的注重品质. 所以我们要深入了解目标问题域, 挖掘出真正的核心域.&lt;/p&gt;
&lt;p&gt;专注于那些能够带来最大价值的界限上下文, 然后从那里开始扩展.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PS, 区分支撑域以及通用域可能并不那么重要, 但是识别出核心域还是蛮重要的, 因为核心域会让我们花更多的财力, 人力在上面.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id="creating-a-ubiquitous-language"&gt;Creating a Ubiquitous Language&lt;/h1&gt;
&lt;p&gt;我们之前说过, 开发和领域专家必须共享同一模型.&lt;/p&gt;
&lt;p&gt;这意味着我们设计中的事物必须代表领域专家的心理模型中的真实事物. 也就是说, 如果领域专家称某事为 &lt;em&gt;Order&lt;/em&gt;, 那么我们应该在与之相对应的代码中有一个名为 &lt;em&gt;Order&lt;/em&gt; 的东西, 并且行为方式相同. (在&amp;lt;职业驱动开发中提到过的&lt;strong&gt;低表示差异&lt;/strong&gt;&amp;gt;).&lt;/p&gt;
&lt;p&gt;相应的, 我们在设计中也不应包含不代表领域专家模型的内容. 这意味着没有诸如 &lt;em&gt;OrderFactory&lt;/em&gt;, &lt;em&gt;OrderManager&lt;/em&gt;, &lt;em&gt;OrderHelper&lt;/em&gt; 等之类的术语, 领域专家不会知道这些单词的含义. 当然, 这些术语可能在代码库中出现, 但应避免将它们作为设计的一部分公开.&lt;/p&gt;
&lt;p&gt;我们将这些在团队中每个人之间共享的概念和词汇表称为&lt;strong&gt;通用语言&lt;/strong&gt;. 顾名思义, 这种语言应该在项目中的所有地方使用, 不仅用于需求, 还用于设计, 最重要的是, 源代码.&lt;/p&gt;
&lt;p&gt;通用语言的构建是团队成员互相协作的结果. 我们也不应该期望这种通用语言是静态的–它始终是一项正在进行的工作. 随着设计的发展, 会发现新术语和新概念, 它们会让通用语言相应地发展.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该阶段应该会产出词汇表, 或者 Wiki 之类的东西.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后, 重要的是要认识到, 通常无法拥有覆盖所有领域和上下文的通用语言. 每个上下文都将有一些通用语言的 “方言”, 在不同的方言中,, 一些单词拥有相同的含义, 但有些相同的单词可能意味着不同的含义. 例如, “类” 在 “面向对象的程序设计” 领域中意味的东西和在 “CSS” 领域中完全不同.&lt;/p&gt;
&lt;p&gt;在贸易系统的事件风暴中, 所有与会者在描述事件时都使用了 &lt;em&gt;Order&lt;/em&gt; 一词. 但如果我们在所有地方都使用相同的 &lt;em&gt;Order&lt;/em&gt; 一词而不指定其上下文, 那么很可能会遇到一些痛苦的误解, 这种误解最终会导致开发的失败 – 我们可能会为 “运输子系统” 和 “开票子系统” 中的 &lt;em&gt;Order Class&lt;/em&gt; 设计同样的属性. 但实际上, 运输部门与开票部门对 &lt;em&gt;Order&lt;/em&gt; 的定义有些微不同, 运输部门可能关心库存水平, 物品数量等, 而开票部门可能更关心价格和金钱.&lt;/p&gt;
&lt;h1 id="summarizing-the-concepts-of-domain-driven-design"&gt;Summarizing the Concepts of Domain-Driven Design&lt;/h1&gt;
&lt;p&gt;We’ve been introduced to a lot of new concepts and terminology, so let’s quickly summarize them in one place before moving on.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A Domain is an area of knowledge associated with the problem we are trying to solve. Alternatively a “domain” is that which a “domain expert” is expert in.&lt;/li&gt;
&lt;li&gt;A Domain Model is a set of simplifications that represent those aspects of a domain that are relevant to a particular problem. The domain model is part of the solution space, while the domain that it represents is part of the problem space.&lt;/li&gt;
&lt;li&gt;The Ubiquitous Language is a set of concepts and vocabulary associated with the domain, shared by both the team members and the source code.&lt;/li&gt;
&lt;li&gt;A Bounded Context is a subsystem in the solution space with clear boundaries that distinguish it from other subsystems. A bounded context often corresponds to a subdomain in the problem space. A bounded con- text also has its own set of concepts and vocabulary, its own dialect of the Ubiquitous Language.&lt;/li&gt;
&lt;li&gt;A Context map is a high-level diagram showing a collection of bounded contexts and the relationships between them.&lt;/li&gt;
&lt;li&gt;A Domain Event is a record of something that happened in the system. It is always described in the past tense. An event often triggers additional activity.&lt;/li&gt;
&lt;li&gt;A Command is a request for some process to happen, triggered by a person or another event. If the process succeeds, the state of the system changes and one or more Domain Events are recorded.&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id="_1"&gt;附: 事件风暴&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;You: “Someone start by posting a business event!”&lt;/li&gt;
&lt;li&gt;Ollie: “I’m Ollie from the order-taking department. Mostly we deal with orders and quotes coming in.”&lt;/li&gt;
&lt;li&gt;You: “What triggers this kind of work?”&lt;/li&gt;
&lt;li&gt;Ollie: “When we get forms sent to us by the customer in the mail.”&lt;/li&gt;
&lt;li&gt;You: “So the events would be something like ‘Order form received’ and ‘Quote form received’?”&lt;/li&gt;
&lt;li&gt;Ollie: “Yes. Let me put those up on the wall then.”&lt;/li&gt;
&lt;li&gt;Sam: “I’m Sam from the shipping department. We fulfill those orders when they’re signed off.”&lt;/li&gt;
&lt;li&gt;You: “And how do you know when to do that?”&lt;/li&gt;
&lt;li&gt;Sam: “When we get an order from the order-taking department.”&lt;/li&gt;
&lt;li&gt;You: “What would you call that as an event?”&lt;/li&gt;
&lt;li&gt;Sam: “How about ‘Order Available’?”&lt;/li&gt;
&lt;li&gt;Ollie: “We call an order that’s completed and ready to ship a ‘Placed Order.’ Can we agree on using that term everywhere?”&lt;/li&gt;
&lt;li&gt;Sam: “So ‘Order Placed’ would be the event we care about, yes?”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You get the idea. After a while, we might have list of posted events like this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;‘Order form received’&lt;/li&gt;
&lt;li&gt;‘Order placed’&lt;/li&gt;
&lt;li&gt;‘Order shipped’&lt;/li&gt;
&lt;li&gt;‘Order change requested’&lt;/li&gt;
&lt;li&gt;‘Order cancellation requested’&lt;/li&gt;
&lt;li&gt;‘Return requested’&lt;/li&gt;
&lt;li&gt;‘Quote form received’&lt;/li&gt;
&lt;li&gt;‘Quote provided’&lt;/li&gt;
&lt;li&gt;‘New customer request received’&lt;/li&gt;
&lt;li&gt;‘New customer registered’&lt;/li&gt;
&lt;/ul&gt;</content><category term="函数式"></category><category term="函数式"></category><category term="领域驱动"></category><category term="DDD"></category></entry><entry><title>函数式领域建模 - 用DDD和F＃解决软件复杂性</title><link href="http://www.smallcpp.cn/han-shu-shi-ling-yu-jian-mo-yong-dddhe-fjie-jue-ruan-jian-fu-za-xing.html" rel="alternate"></link><published>2019-11-28T09:00:00+08:00</published><updated>2019-11-28T09:00:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2019-11-28:/han-shu-shi-ling-yu-jian-mo-yong-dddhe-fjie-jue-ruan-jian-fu-za-xing.html</id><content type="html">&lt;p&gt;本书大纲&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一部分 — 了解领域&lt;ul&gt;
&lt;li&gt;什么是 DDD&lt;/li&gt;
&lt;li&gt;通用模型的重要性&lt;/li&gt;
&lt;li&gt;理解领域事件&lt;/li&gt;
&lt;li&gt;拆分领域为子域&lt;/li&gt;
&lt;li&gt;界限上下文&lt;/li&gt;
&lt;li&gt;通用的语言&lt;/li&gt;
&lt;li&gt;总结 DDD 的概念&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content><category term="函数式"></category><category term="函数式"></category><category term="领域驱动"></category><category term="DDD"></category></entry><entry><title>修改 Safari 代码字体</title><link href="http://www.smallcpp.cn/xiu-gai-safari-dai-ma-zi-ti.html" rel="alternate"></link><published>2019-01-17T12:56:00+08:00</published><updated>2019-01-17T12:56:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2019-01-17:/xiu-gai-safari-dai-ma-zi-ti.html</id><summary type="html">&lt;p&gt;工具: &lt;a href="https://tampermonkey.net/?browser=safari"&gt;油猴插件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;添加以下脚本:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;// ==UserScript==&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// @name         使用等宽字体&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// @namespace    https://github.com/uldaman/&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// @version      1.0.0&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// @description  强制修改网页中代码部分为等宽字体!&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// @author       HanXiao&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// @include      *&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// @exclude      *.seedr.cc*&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// @exclude      *console.cloud.google.com/cloudshell*&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// @run-at …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;工具: &lt;a href="https://tampermonkey.net/?browser=safari"&gt;油猴插件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;添加以下脚本:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;// ==UserScript==&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// @name         使用等宽字体&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// @namespace    https://github.com/uldaman/&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// @version      1.0.0&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// @description  强制修改网页中代码部分为等宽字体!&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// @author       HanXiao&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// @include      *&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// @exclude      *.seedr.cc*&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// @exclude      *console.cloud.google.com/cloudshell*&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// @run-at       document-start&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// @grant        unsafeWindow&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// ==/UserScript==&lt;/span&gt;

(&lt;span style="color: #8B008B; font-weight: bold"&gt;function&lt;/span&gt; () {
    &lt;span style="color: #CD5555"&gt;&amp;#39;use strict&amp;#39;&lt;/span&gt;;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; element = &lt;span style="color: #658b00"&gt;document&lt;/span&gt;.createElement(&lt;span style="color: #CD5555"&gt;&amp;quot;link&amp;quot;&lt;/span&gt;);
    element.rel = &lt;span style="color: #CD5555"&gt;&amp;quot;stylesheet&amp;quot;&lt;/span&gt;;
    element.type = &lt;span style="color: #CD5555"&gt;&amp;quot;text/css&amp;quot;&lt;/span&gt;;
    element.href = &lt;span style="color: #CD5555"&gt;&amp;#39;data:text/css, pre, code {font-family: Menlo !important;}&amp;#39;&lt;/span&gt;;
    &lt;span style="color: #658b00"&gt;document&lt;/span&gt;.documentElement.appendChild(element);
    setTimeout(&lt;span style="color: #8B008B; font-weight: bold"&gt;function&lt;/span&gt; () {
        &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; modStyle = &lt;span style="color: #658b00"&gt;document&lt;/span&gt;.querySelector(&lt;span style="color: #CD5555"&gt;&amp;#39;#modCSS_font&amp;#39;&lt;/span&gt;);
        &lt;span style="color: #8B008B; font-weight: bold"&gt;if&lt;/span&gt; (modStyle === &lt;span style="color: #8B008B; font-weight: bold"&gt;null&lt;/span&gt;) {
            modStyle = &lt;span style="color: #658b00"&gt;document&lt;/span&gt;.createElement(&lt;span style="color: #CD5555"&gt;&amp;#39;style&amp;#39;&lt;/span&gt;);
            modStyle.id = &lt;span style="color: #CD5555"&gt;&amp;#39;modCSS_font&amp;#39;&lt;/span&gt;;
            &lt;span style="color: #658b00"&gt;document&lt;/span&gt;.body.appendChild(modStyle);
        }
        modStyle.innerHTML = &lt;span style="color: #CD5555"&gt;&amp;#39;pre, code {font-family: Menlo !important;}&amp;#39;&lt;/span&gt;;
    }, &lt;span style="color: #B452CD"&gt;300&lt;/span&gt;);
})();
&lt;/pre&gt;&lt;/div&gt;</content><category term="工具折腾"></category></entry><entry><title>Js 函数式库</title><link href="http://www.smallcpp.cn/js-han-shu-shi-ku.html" rel="alternate"></link><published>2019-01-16T15:00:00+08:00</published><updated>2019-01-16T15:00:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2019-01-16:/js-han-shu-shi-ku.html</id><summary type="html">
&lt;h1 id="fantasy-land"&gt;Fantasy land&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://github.com/fantasyland/fantasy-land"&gt;Fantasy Land&lt;/a&gt; 是一套 &lt;a href="http://www.smallcpp.cn/han-shu-shi-guan-jian-gai-nian-haskell-miao-shu.html#_7"&gt;TypeClass&lt;/a&gt; 的 JS 描述, 包括但不限于 Functor, Applicative, Monad.&lt;/p&gt;
&lt;p&gt;以下是几个常用的 TypeClass.&lt;/p&gt;
&lt;h2 id="functor"&gt;Functor&lt;/h2&gt;
&lt;p&gt;Haskell 描述: &lt;a href="http://www.smallcpp.cn/han-shu-shi-guan-jian-gai-nian-Haskell-miao-shu.html#functor"&gt;Functor&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Js 描述差不多, 用 map 代替了 fmap.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;F.map(f)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id="applicative"&gt;Applicative&lt;/h2&gt;
&lt;p&gt;Haskell …&lt;/p&gt;</summary><content type="html">
&lt;h1 id="fantasy-land"&gt;Fantasy land&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://github.com/fantasyland/fantasy-land"&gt;Fantasy Land&lt;/a&gt; 是一套 &lt;a href="http://www.smallcpp.cn/han-shu-shi-guan-jian-gai-nian-haskell-miao-shu.html#_7"&gt;TypeClass&lt;/a&gt; 的 JS 描述, 包括但不限于 Functor, Applicative, Monad.&lt;/p&gt;
&lt;p&gt;以下是几个常用的 TypeClass.&lt;/p&gt;
&lt;h2 id="functor"&gt;Functor&lt;/h2&gt;
&lt;p&gt;Haskell 描述: &lt;a href="http://www.smallcpp.cn/han-shu-shi-guan-jian-gai-nian-Haskell-miao-shu.html#functor"&gt;Functor&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Js 描述差不多, 用 map 代替了 fmap.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;F.map(f)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id="applicative"&gt;Applicative&lt;/h2&gt;
&lt;p&gt;Haskell 描述: &lt;a href="http://www.smallcpp.cn/han-shu-shi-guan-jian-gai-nian-Haskell-miao-shu.html#applicative-functor"&gt;Applicative&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Js 中用 ap 代替了 &amp;lt;*&amp;gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A.ap(f)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id="monad"&gt;Monad&lt;/h2&gt;
&lt;p&gt;Haskell 描述: &lt;a href="http://www.smallcpp.cn/han-shu-shi-guan-jian-gai-nian-Haskell-miao-shu.html#monda"&gt;Monad&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Js 中用 chain 代替了 &amp;gt;&amp;gt;=.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;M.chain(f)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id="foldable"&gt;Foldable&lt;/h2&gt;
&lt;p&gt;可折叠的类型, 对应 Haskell 中是实现了各种 fold 函数的 instance. 而 Js 中是实现了 reduce 的 instance.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;reduce :: Foldable f =&amp;gt; f a ~&amp;gt; ((b, a) -&amp;gt; b, b) -&amp;gt; b&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这是 fantasy-land 的表示法, 与 Haskell 有些不同, 解释下:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;reduce :: Foldable f =&amp;gt; f a ~&amp;gt; ((b, a) -&amp;gt; b, b) -&amp;gt; b
'----'    '--------'    '-'    '--------------'   '-'
'           '            '       '                 ' - return type
'           '            '       '
'           '            '       ' - argument types
'           '            '
'           '            ' - method target type
'           '
'           ' - type constraints
'
' - method name
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="setoid"&gt;Setoid&lt;/h2&gt;
&lt;p&gt;实现了 equals 相等性判断的 instance, 类似 Haskell 中的 Eq TypeClass.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;equals :: Setoid a =&amp;gt; a ~&amp;gt; a -&amp;gt; Boolean&lt;/code&gt;&lt;/p&gt;
&lt;h2 id="semigroup"&gt;Semigroup&lt;/h2&gt;
&lt;p&gt;实现了 concat 的 instance, 连接两个 Semigroup.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;concat :: Semigroup a =&amp;gt; a ~&amp;gt; a -&amp;gt; a&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注意, 与 Haskell 的 concat 不同, Haskell 中 concat 声明如下:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;concat :: [[a]] -&amp;gt; [a]&lt;/code&gt;&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;ghci&amp;gt; concat [&lt;span style="color: #CD5555"&gt;"foo"&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;"bar"&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;"car"&lt;/span&gt;]
&lt;span style="color: #CD5555"&gt;"foobarcar"&lt;/span&gt;

ghci&amp;gt; concat [[&lt;span style="color: #B452CD"&gt;3&lt;/span&gt;, &lt;span style="color: #B452CD"&gt;4&lt;/span&gt;, &lt;span style="color: #B452CD"&gt;5&lt;/span&gt;], [&lt;span style="color: #B452CD"&gt;2&lt;/span&gt;, &lt;span style="color: #B452CD"&gt;3&lt;/span&gt;, &lt;span style="color: #B452CD"&gt;4&lt;/span&gt;], [&lt;span style="color: #B452CD"&gt;2&lt;/span&gt;, &lt;span style="color: #B452CD"&gt;1&lt;/span&gt;, &lt;span style="color: #B452CD"&gt;1&lt;/span&gt;]]
[&lt;span style="color: #B452CD"&gt;3&lt;/span&gt;, &lt;span style="color: #B452CD"&gt;4&lt;/span&gt;, &lt;span style="color: #B452CD"&gt;5&lt;/span&gt;, &lt;span style="color: #B452CD"&gt;2&lt;/span&gt;, &lt;span style="color: #B452CD"&gt;3&lt;/span&gt;, &lt;span style="color: #B452CD"&gt;4&lt;/span&gt;, &lt;span style="color: #B452CD"&gt;2&lt;/span&gt;, &lt;span style="color: #B452CD"&gt;1&lt;/span&gt;, &lt;span style="color: #B452CD"&gt;1&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="chainrec"&gt;ChainRec&lt;/h2&gt;
&lt;p&gt;这个类型我找到的资料比较少.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;chainRec :: ChainRec m =&amp;gt; ((a -&amp;gt; c, b -&amp;gt; c, a) -&amp;gt; m c, a) -&amp;gt; m b&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在声明上没有看到 ~&amp;gt;, 是在 &lt;a href="https://github.com/fantasyland/fantasy-land#type-representatives"&gt;type representative&lt;/a&gt; 上进行调用.&lt;/p&gt;
&lt;p&gt;该函数接收两个参数 &lt;code&gt;(f, i)&lt;/code&gt;, f 是一个函数, 这个函数有三个参数:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参数 1, next 函数&lt;/li&gt;
&lt;li&gt;参数 2, done 函数, 与 next 具有相同类型的返回值&lt;/li&gt;
&lt;li&gt;参数 3, value, 累计值, 与 next 的参数类型相同&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;chainRec 调用时, 将 i 做第三个参数调用 f, f 的逻辑需要有分支判断, 用来处理是 next, 还是 done, 以下是 sanctuary-maybe 的例子:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;const&lt;/span&gt; Maybe = require(&lt;span style="color: #CD5555"&gt;"sanctuary-maybe"&lt;/span&gt;)
&lt;span style="color: #8B008B; font-weight: bold"&gt;const&lt;/span&gt; Just = Maybe.Just
&lt;span style="color: #8B008B; font-weight: bold"&gt;const&lt;/span&gt; Nothing = Maybe.Nothing

Maybe[&lt;span style="color: #CD5555"&gt;'fantasy-land/chainRec'&lt;/span&gt;] (
    (next, done, x) =&amp;gt;
        x &amp;lt;= &lt;span style="color: #B452CD"&gt;1&lt;/span&gt; ? Nothing : Just (x &amp;gt;= &lt;span style="color: #B452CD"&gt;1000&lt;/span&gt; ? done (x) : next (x * x)),
        &lt;span style="color: #228B22"&gt;// sanctuary-maybe 内置函数 done, next 两个函数,&lt;/span&gt;
        &lt;span style="color: #228B22"&gt;// 不用管它, 把 done 和 next 的逻辑像上面那样写在函数体内就可以了.&lt;/span&gt;
    &lt;span style="color: #B452CD"&gt;1&lt;/span&gt;
)
&lt;span style="color: #228B22"&gt;// Nothing&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="traversable"&gt;Traversable&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;traverse :: Applicative f, Traversable t =&amp;gt; t a ~&amp;gt; (TypeRep f, a -&amp;gt; f b) -&amp;gt; f (t b)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将返回值为 Applicative 类型的函数映射到一个 Traversable 上, 然后将结果由 Traversable of Applicative 转换为 Applicative of Traversable. 相当于先 chain 再 反转.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;const&lt;/span&gt; Maybe = require(&lt;span style="color: #CD5555"&gt;"sanctuary-maybe"&lt;/span&gt;)
&lt;span style="color: #8B008B; font-weight: bold"&gt;const&lt;/span&gt; Just = Maybe.Just
&lt;span style="color: #8B008B; font-weight: bold"&gt;const&lt;/span&gt; Nothing = Maybe.Nothing
&lt;span style="color: #8B008B; font-weight: bold"&gt;const&lt;/span&gt; safeDiv = n =&amp;gt; d =&amp;gt; d === &lt;span style="color: #B452CD"&gt;0&lt;/span&gt; ? Nothing() : Just(n / d)

R.chain(safeDiv(&lt;span style="color: #B452CD"&gt;10&lt;/span&gt;), [&lt;span style="color: #B452CD"&gt;2&lt;/span&gt;, &lt;span style="color: #B452CD"&gt;4&lt;/span&gt;, &lt;span style="color: #B452CD"&gt;5&lt;/span&gt;])
&lt;span style="color: #228B22"&gt;// [ Just (5), Just (2.5), Just (2) ]&lt;/span&gt;

R.traverse(Just, safeDiv(&lt;span style="color: #B452CD"&gt;10&lt;/span&gt;), [&lt;span style="color: #B452CD"&gt;2&lt;/span&gt;, &lt;span style="color: #B452CD"&gt;4&lt;/span&gt;, &lt;span style="color: #B452CD"&gt;5&lt;/span&gt;])
&lt;span style="color: #228B22"&gt;// Just ([5, 2.5, 2])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="fantasy-land_1"&gt;Fantasy land 的实现&lt;/h1&gt;
&lt;p&gt;有许多的库让 JS 支持函数式风格编程, 大体上它们分为两大类:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供诸多高阶函数的工具库
    + Sanctuary
    + Ramda
    + Lodash-FP
    + Underscore&lt;/li&gt;
&lt;li&gt;提供了 Fantasy land 中 TypeClass 的实现
    + Sanctuary
    + Folktale
    + Fluture
    + Ramda-Fantasy (已废弃)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里有一些推荐:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Maybe: &lt;a href="https://github.com/sanctuary-js/sanctuary-maybe"&gt;sanctuary-js/sanctuary-maybe&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Either: &lt;a href="https://github.com/sanctuary-js/sanctuary-either"&gt;sanctuary-js/sanctuary-either&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Pair: &lt;a href="https://github.com/sanctuary-js/sanctuary-pair"&gt;sanctuary-js/sanctuary-pair&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Identity: &lt;a href="https://github.com/sanctuary-js/sanctuary-identity"&gt;sanctuary-js/sanctuary-identity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Future: &lt;a href="https://github.com/fluture-js/Fluture"&gt;fluture-js/Fluture&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;State: &lt;a href="https://github.com/fantasyland/fantasy-states"&gt;fantasyland/fantasy-states&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Reader: &lt;a href="https://github.com/fantasyland/fantasy-readers"&gt;fantasyland/fantasy-readers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;IO: &lt;a href="https://github.com/fantasyland/fantasy-io"&gt;fantasyland/fantasy-io&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th align="center"&gt;Functor&lt;/th&gt;
&lt;th align="center"&gt;Applicative&lt;/th&gt;
&lt;th align="center"&gt;Monad&lt;/th&gt;
&lt;th align="center"&gt;Foldable&lt;/th&gt;
&lt;th align="center"&gt;Setoid&lt;/th&gt;
&lt;th align="center"&gt;Semigroup&lt;/th&gt;
&lt;th align="center"&gt;ChainRec&lt;/th&gt;
&lt;th align="center"&gt;Traversable&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Maybe&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Either&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Future&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Identity&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Reader&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Pair&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;State&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IO&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;strong&gt;✔︎&lt;/strong&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="sanctuary"&gt;Sanctuary&lt;/h2&gt;
&lt;p&gt;Sanctuary 是一套相对完整的解决方案, 它比 Ramda 更严格, 并提供了一套类似的函数, 同时还提供三个与 Fantasy Land 兼容的数据类型: &lt;code&gt;Maybe&lt;/code&gt;, &lt;code&gt;Either&lt;/code&gt; 和 &lt;code&gt;Pair&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Sanctuary 认为函数比方法更容易使用 (&lt;a href="https://github.com/sanctuary-js/sanctuary-maybe/issues/8"&gt;issue#8&lt;/a&gt;), 所以像 &lt;code&gt;Maybe(10).map(...).filtr(...)...&lt;/code&gt; 这样的链式调用是不支持的, 但可以 &lt;code&gt;pipe&lt;/code&gt; 来组合调用:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;S.pipe ([
  S.map (...),
  S.filter (...),
  S.reverse,
  S.map (...),
])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外, Sanctuary 的 &lt;code&gt;curry&lt;/code&gt; 函数不提供任意长度的函数转换, 只提供了 &lt;code&gt;curry2~5&lt;/code&gt;, 而且没提供 &lt;code&gt;partial&lt;/code&gt; 函数, 附上我自己的实现:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #CD5555"&gt;"use strict"&lt;/span&gt;

&lt;span style="color: #228B22"&gt;/**&lt;/span&gt;
&lt;span style="color: #228B22"&gt; * Returns a curried equivalent of the provided function.&lt;/span&gt;
&lt;span style="color: #228B22"&gt; *&lt;/span&gt;
&lt;span style="color: #228B22"&gt; * let add = (x, y) =&amp;gt; x + y&lt;/span&gt;
&lt;span style="color: #228B22"&gt; * add10 = curry(add)(10)&lt;/span&gt;
&lt;span style="color: #228B22"&gt; */&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;const&lt;/span&gt; curry = (fn) =&amp;gt; {
    &lt;span style="color: #8B008B; font-weight: bold"&gt;return&lt;/span&gt; curriedFn = (...x) =&amp;gt; {
        &lt;span style="color: #8B008B; font-weight: bold"&gt;if&lt;/span&gt; (x.length &amp;lt; fn.length) {
            &lt;span style="color: #8B008B; font-weight: bold"&gt;return&lt;/span&gt; (...y) =&amp;gt; {
                &lt;span style="color: #8B008B; font-weight: bold"&gt;return&lt;/span&gt; curriedFn(...x, ...y)
            }
        }
        &lt;span style="color: #8B008B; font-weight: bold"&gt;return&lt;/span&gt; fn(...x)
    }
}

&lt;span style="color: #228B22"&gt;/**&lt;/span&gt;
&lt;span style="color: #228B22"&gt; * Allowing partial application of any combination of&lt;/span&gt;
&lt;span style="color: #228B22"&gt; * arguments, regardless of their positions.&lt;/span&gt;
&lt;span style="color: #228B22"&gt; *&lt;/span&gt;
&lt;span style="color: #228B22"&gt; * Use `undefined` for a special placeholder values.&lt;/span&gt;
&lt;span style="color: #228B22"&gt; *&lt;/span&gt;
&lt;span style="color: #228B22"&gt; * let delay10Ms = partial(setTimeout, undefined, 10)&lt;/span&gt;
&lt;span style="color: #228B22"&gt; * delay10Ms(() =&amp;gt; console.log("10 Ms passed"))&lt;/span&gt;
&lt;span style="color: #228B22"&gt; */&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;const&lt;/span&gt; partial = (fn, ...partialArgs) =&amp;gt; {
    &lt;span style="color: #8B008B; font-weight: bold"&gt;return&lt;/span&gt; (...fullArgs) =&amp;gt; {
        &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; args = []
        &lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; position = &lt;span style="color: #B452CD"&gt;0&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;for&lt;/span&gt; (&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; i = &lt;span style="color: #B452CD"&gt;0&lt;/span&gt;; i &amp;lt; partialArgs.length; i++) {
            args[i] = partialArgs[i] === &lt;span style="color: #8B008B; font-weight: bold"&gt;undefined&lt;/span&gt;
                ? fullArgs[position++]
                : partialArgs[i]
        }
        &lt;span style="color: #8B008B; font-weight: bold"&gt;return&lt;/span&gt; fn(...args)
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="tutorials"&gt;Tutorials&lt;/h1&gt;
&lt;p&gt;&lt;a href="http://www.xiaojichao.com/post/functional-programming-in-js-with-practical-examples-part-1.html"&gt;实例讲解 JS 函数式编程 (第一部分)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本部分讲解了 Fantasy Land 规范, 以及两个示例:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;示例 1, 使用 &lt;strong&gt;ramda-fantasy.Maybe&lt;/strong&gt; 处理空检查, 使用 &lt;strong&gt;ramda.curry&lt;/strong&gt; 处理全局依赖, 使用 &lt;strong&gt;ramda.path&lt;/strong&gt; 取出对象给定路径上的值.&lt;/li&gt;
&lt;li&gt;示例 2, 使用 &lt;strong&gt;ramda-fantasy.Either&lt;/strong&gt; 抛出错误信息.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="http://www.xiaojichao.com/post/functional-programming-in-js-with-practical-examples-part-2.html"&gt;实例讲解 JS 函数式编程 (第二部分)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本部分讲解了两个示例:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;示例 1, 使用 &lt;strong&gt;Maybe Applicative&lt;/strong&gt; 处理多参函数中多个参数的空检查.&lt;/li&gt;
&lt;li&gt;示例 2, 使用 &lt;strong&gt;Validation Applicative&lt;/strong&gt; 抛出多个错误, 使用 &lt;strong&gt;ramda.curryN&lt;/strong&gt; 让函数调用多次后才真正触发.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://linux.cn/article-7842-1.html"&gt;函数式 TypeScript&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文讲解了以下几项技术:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用函数代替简单值&lt;/li&gt;
&lt;li&gt;数据转换过程管道化 (filter, map, reduce 的运用)&lt;/li&gt;
&lt;li&gt;提取通用函数 (非公共模式, 而是与当前函数域无关的逻辑)&lt;/li&gt;
&lt;/ul&gt;</content><category term="函数式"></category></entry><entry><title>Ramda 算子一览表</title><link href="http://www.smallcpp.cn/ramda-suan-zi-yi-lan-biao.html" rel="alternate"></link><published>2018-12-16T19:00:00+08:00</published><updated>2018-12-16T19:00:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2018-12-16:/ramda-suan-zi-yi-lan-biao.html</id><summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;list&lt;/th&gt;
&lt;th&gt;function&lt;/th&gt;
&lt;th&gt;object&lt;/th&gt;
&lt;th&gt;relation&lt;/th&gt;
&lt;th&gt;logic&lt;/th&gt;
&lt;th&gt;math&lt;/th&gt;
&lt;th&gt;string&lt;/th&gt;
&lt;th&gt;type&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;adjust&lt;/td&gt;
&lt;td&gt;__&lt;/td&gt;
&lt;td&gt;assoc&lt;/td&gt;
&lt;td&gt;clamp&lt;/td&gt;
&lt;td&gt;allPass&lt;/td&gt;
&lt;td&gt;add&lt;/td&gt;
&lt;td&gt;match&lt;/td&gt;
&lt;td&gt;is&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;all&lt;/td&gt;
&lt;td&gt;addIndex&lt;/td&gt;
&lt;td&gt;assocPath&lt;/td&gt;
&lt;td&gt;countBy&lt;/td&gt;
&lt;td&gt;and&lt;/td&gt;
&lt;td&gt;dec&lt;/td&gt;
&lt;td&gt;replace&lt;/td&gt;
&lt;td&gt;isNil&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;any&lt;/td&gt;
&lt;td&gt;always&lt;/td&gt;
&lt;td&gt;clone&lt;/td&gt;
&lt;td&gt;difference&lt;/td&gt;
&lt;td&gt;anyPass&lt;/td&gt;
&lt;td&gt;divide …&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</summary><content type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;list&lt;/th&gt;
&lt;th&gt;function&lt;/th&gt;
&lt;th&gt;object&lt;/th&gt;
&lt;th&gt;relation&lt;/th&gt;
&lt;th&gt;logic&lt;/th&gt;
&lt;th&gt;math&lt;/th&gt;
&lt;th&gt;string&lt;/th&gt;
&lt;th&gt;type&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;adjust&lt;/td&gt;
&lt;td&gt;__&lt;/td&gt;
&lt;td&gt;assoc&lt;/td&gt;
&lt;td&gt;clamp&lt;/td&gt;
&lt;td&gt;allPass&lt;/td&gt;
&lt;td&gt;add&lt;/td&gt;
&lt;td&gt;match&lt;/td&gt;
&lt;td&gt;is&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;all&lt;/td&gt;
&lt;td&gt;addIndex&lt;/td&gt;
&lt;td&gt;assocPath&lt;/td&gt;
&lt;td&gt;countBy&lt;/td&gt;
&lt;td&gt;and&lt;/td&gt;
&lt;td&gt;dec&lt;/td&gt;
&lt;td&gt;replace&lt;/td&gt;
&lt;td&gt;isNil&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;any&lt;/td&gt;
&lt;td&gt;always&lt;/td&gt;
&lt;td&gt;clone&lt;/td&gt;
&lt;td&gt;difference&lt;/td&gt;
&lt;td&gt;anyPass&lt;/td&gt;
&lt;td&gt;divide&lt;/td&gt;
&lt;td&gt;split&lt;/td&gt;
&lt;td&gt;propIs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;aperture&lt;/td&gt;
&lt;td&gt;ap&lt;/td&gt;
&lt;td&gt;dissoc&lt;/td&gt;
&lt;td&gt;differenceWith&lt;/td&gt;
&lt;td&gt;both&lt;/td&gt;
&lt;td&gt;inc&lt;/td&gt;
&lt;td&gt;test&lt;/td&gt;
&lt;td&gt;type&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;append&lt;/td&gt;
&lt;td&gt;apply&lt;/td&gt;
&lt;td&gt;dissocPath&lt;/td&gt;
&lt;td&gt;eqBy&lt;/td&gt;
&lt;td&gt;complement&lt;/td&gt;
&lt;td&gt;mathMod&lt;/td&gt;
&lt;td&gt;toLower&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;chain&lt;/td&gt;
&lt;td&gt;applySpec&lt;/td&gt;
&lt;td&gt;eqProps&lt;/td&gt;
&lt;td&gt;equals&lt;/td&gt;
&lt;td&gt;cond&lt;/td&gt;
&lt;td&gt;mean&lt;/td&gt;
&lt;td&gt;toString&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;concat&lt;/td&gt;
&lt;td&gt;applyTo&lt;/td&gt;
&lt;td&gt;evolve&lt;/td&gt;
&lt;td&gt;gt&lt;/td&gt;
&lt;td&gt;defaultTo&lt;/td&gt;
&lt;td&gt;median&lt;/td&gt;
&lt;td&gt;toUpper&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;contains&lt;/td&gt;
&lt;td&gt;ascend&lt;/td&gt;
&lt;td&gt;forEachObjIndexed&lt;/td&gt;
&lt;td&gt;gte&lt;/td&gt;
&lt;td&gt;either&lt;/td&gt;
&lt;td&gt;modulo&lt;/td&gt;
&lt;td&gt;trim&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;drop&lt;/td&gt;
&lt;td&gt;binary&lt;/td&gt;
&lt;td&gt;has&lt;/td&gt;
&lt;td&gt;identical&lt;/td&gt;
&lt;td&gt;ifElse&lt;/td&gt;
&lt;td&gt;multiply&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dropLast&lt;/td&gt;
&lt;td&gt;bind&lt;/td&gt;
&lt;td&gt;hasIn&lt;/td&gt;
&lt;td&gt;innerJoin&lt;/td&gt;
&lt;td&gt;isEmpty&lt;/td&gt;
&lt;td&gt;negate&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dropLastWhile&lt;/td&gt;
&lt;td&gt;call&lt;/td&gt;
&lt;td&gt;hasPath&lt;/td&gt;
&lt;td&gt;intersection&lt;/td&gt;
&lt;td&gt;not&lt;/td&gt;
&lt;td&gt;product&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dropRepeats&lt;/td&gt;
&lt;td&gt;comparator&lt;/td&gt;
&lt;td&gt;invert&lt;/td&gt;
&lt;td&gt;lt&lt;/td&gt;
&lt;td&gt;or&lt;/td&gt;
&lt;td&gt;subtract&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dropRepeatsWith&lt;/td&gt;
&lt;td&gt;compose&lt;/td&gt;
&lt;td&gt;invertObj&lt;/td&gt;
&lt;td&gt;lte&lt;/td&gt;
&lt;td&gt;pathSatisfies&lt;/td&gt;
&lt;td&gt;sum&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dropWhile&lt;/td&gt;
&lt;td&gt;composeK&lt;/td&gt;
&lt;td&gt;keys&lt;/td&gt;
&lt;td&gt;max&lt;/td&gt;
&lt;td&gt;propSatisfies&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;endsWith&lt;/td&gt;
&lt;td&gt;composeP&lt;/td&gt;
&lt;td&gt;keysIn&lt;/td&gt;
&lt;td&gt;maxBy&lt;/td&gt;
&lt;td&gt;unless&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;filter&lt;/td&gt;
&lt;td&gt;composeWith&lt;/td&gt;
&lt;td&gt;lens&lt;/td&gt;
&lt;td&gt;min&lt;/td&gt;
&lt;td&gt;until&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;find&lt;/td&gt;
&lt;td&gt;construct&lt;/td&gt;
&lt;td&gt;lensIndex&lt;/td&gt;
&lt;td&gt;minBy&lt;/td&gt;
&lt;td&gt;when&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;findIndex&lt;/td&gt;
&lt;td&gt;constructN&lt;/td&gt;
&lt;td&gt;lensPath&lt;/td&gt;
&lt;td&gt;pathEq&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;findLast&lt;/td&gt;
&lt;td&gt;converge&lt;/td&gt;
&lt;td&gt;lensProp&lt;/td&gt;
&lt;td&gt;propEq&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;findLastIndex&lt;/td&gt;
&lt;td&gt;curry&lt;/td&gt;
&lt;td&gt;mapObjIndexed&lt;/td&gt;
&lt;td&gt;sortBy&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;flatten&lt;/td&gt;
&lt;td&gt;curryN&lt;/td&gt;
&lt;td&gt;merge&lt;/td&gt;
&lt;td&gt;sortWith&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;forEach&lt;/td&gt;
&lt;td&gt;descend&lt;/td&gt;
&lt;td&gt;mergeDeepLeft&lt;/td&gt;
&lt;td&gt;symmetricDifference&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fromPairs&lt;/td&gt;
&lt;td&gt;empty&lt;/td&gt;
&lt;td&gt;mergeDeepRight&lt;/td&gt;
&lt;td&gt;symmetricDifferenceWith&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;groupBy&lt;/td&gt;
&lt;td&gt;F&lt;/td&gt;
&lt;td&gt;mergeDeepWith&lt;/td&gt;
&lt;td&gt;union&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;groupWith&lt;/td&gt;
&lt;td&gt;flip&lt;/td&gt;
&lt;td&gt;mergeDeepWithKey&lt;/td&gt;
&lt;td&gt;unionWith&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;head&lt;/td&gt;
&lt;td&gt;identity&lt;/td&gt;
&lt;td&gt;mergeLeft&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;includes&lt;/td&gt;
&lt;td&gt;invoker&lt;/td&gt;
&lt;td&gt;mergeRight&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;indexBy&lt;/td&gt;
&lt;td&gt;juxt&lt;/td&gt;
&lt;td&gt;mergeWith&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;indexOf&lt;/td&gt;
&lt;td&gt;lift&lt;/td&gt;
&lt;td&gt;mergeWithKey&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;init&lt;/td&gt;
&lt;td&gt;liftN&lt;/td&gt;
&lt;td&gt;objOf&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;insert&lt;/td&gt;
&lt;td&gt;memoizeWith&lt;/td&gt;
&lt;td&gt;omit&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;insertAll&lt;/td&gt;
&lt;td&gt;nAry&lt;/td&gt;
&lt;td&gt;over&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;intersperse&lt;/td&gt;
&lt;td&gt;nthArg&lt;/td&gt;
&lt;td&gt;path&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;into&lt;/td&gt;
&lt;td&gt;o&lt;/td&gt;
&lt;td&gt;pathOr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;join&lt;/td&gt;
&lt;td&gt;of&lt;/td&gt;
&lt;td&gt;pick&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;last&lt;/td&gt;
&lt;td&gt;once&lt;/td&gt;
&lt;td&gt;pickAll&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lastIndexOf&lt;/td&gt;
&lt;td&gt;otherwise&lt;/td&gt;
&lt;td&gt;pickBy&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;length&lt;/td&gt;
&lt;td&gt;partial&lt;/td&gt;
&lt;td&gt;project&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;map&lt;/td&gt;
&lt;td&gt;partialRight&lt;/td&gt;
&lt;td&gt;prop&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mapAccum&lt;/td&gt;
&lt;td&gt;pipe&lt;/td&gt;
&lt;td&gt;propOr&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mapAccumRight&lt;/td&gt;
&lt;td&gt;pipeK&lt;/td&gt;
&lt;td&gt;props&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mergeAll&lt;/td&gt;
&lt;td&gt;pipeP&lt;/td&gt;
&lt;td&gt;set&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;none&lt;/td&gt;
&lt;td&gt;pipeWith&lt;/td&gt;
&lt;td&gt;toPairs&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;nth&lt;/td&gt;
&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;toPairsIn&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pair&lt;/td&gt;
&lt;td&gt;tap&lt;/td&gt;
&lt;td&gt;values&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;partition&lt;/td&gt;
&lt;td&gt;then&lt;/td&gt;
&lt;td&gt;valuesIn&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pluck&lt;/td&gt;
&lt;td&gt;thunkify&lt;/td&gt;
&lt;td&gt;view&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;prepend&lt;/td&gt;
&lt;td&gt;tryCatch&lt;/td&gt;
&lt;td&gt;where&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;range&lt;/td&gt;
&lt;td&gt;unapply&lt;/td&gt;
&lt;td&gt;whereEq&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;reduce&lt;/td&gt;
&lt;td&gt;unary&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;reduceBy&lt;/td&gt;
&lt;td&gt;uncurryN&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;reduced&lt;/td&gt;
&lt;td&gt;useWith&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;reduceRight&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;reduceWhile&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;reject&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;remove&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;repeat&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;reverse&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;scan&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sequence&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;slice&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sort&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;splitAt&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;splitEvery&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;splitWhen&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;startsWith&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tail&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;take&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;takeLast&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;takeLastWhile&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;takeWhile&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;times&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;transduce&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;transpose&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;traverse&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;unfold&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;uniq&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;uniqBy&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;uniqWith&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;unnest&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;update&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;without&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;xprod&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;zip&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;zipObj&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;zipWith&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content><category term="函数式"></category></entry><entry><title>函数式关键概念 Haskell 描述</title><link href="http://www.smallcpp.cn/han-shu-shi-guan-jian-gai-nian-haskell-miao-shu.html" rel="alternate"></link><published>2018-12-03T18:00:00+08:00</published><updated>2018-12-03T18:00:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2018-12-03:/han-shu-shi-guan-jian-gai-nian-haskell-miao-shu.html</id><summary type="html">&lt;p&gt;学习 Haskell 过程中接触到的 FP (functional programming) 的一些概念, 并不是 FP 的全部 (PS: 为了容易理解, 尽可能的忽略了数学描述, 而改用开发容易理解的字眼, 所以某些概念可能会描述的并不准确).&lt;/p&gt;

&lt;h1 id="_1"&gt;函数式&lt;/h1&gt;
&lt;h2 id="_2"&gt;纯函数&lt;/h2&gt;
&lt;p&gt;函数式编程中的函数式指的是&lt;strong&gt;数学函数&lt;/strong&gt;, 即我们要编写具有数学函数性质的函数.&lt;/p&gt;
&lt;p&gt;数学中的函数, 为两集合间的一种对应关系:&lt;br/&gt;
输入值集合中的每项元素 x, 对其施加某个法则 f, 皆能对应&lt;strong&gt;唯一&lt;/strong&gt;一项输出值集合中的元素 y …&lt;/p&gt;</summary><content type="html">&lt;p&gt;学习 Haskell 过程中接触到的 FP (functional programming) 的一些概念, 并不是 FP 的全部 (PS: 为了容易理解, 尽可能的忽略了数学描述, 而改用开发容易理解的字眼, 所以某些概念可能会描述的并不准确).&lt;/p&gt;

&lt;h1 id="_1"&gt;函数式&lt;/h1&gt;
&lt;h2 id="_2"&gt;纯函数&lt;/h2&gt;
&lt;p&gt;函数式编程中的函数式指的是&lt;strong&gt;数学函数&lt;/strong&gt;, 即我们要编写具有数学函数性质的函数.&lt;/p&gt;
&lt;p&gt;数学中的函数, 为两集合间的一种对应关系:&lt;br/&gt;
输入值集合中的每项元素 x, 对其施加某个法则 f, 皆能对应&lt;strong&gt;唯一&lt;/strong&gt;一项输出值集合中的元素 y, 记作: &lt;code&gt;y = f(x)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;而在编程中, 意味着我们要创建仅依赖输入就可以完成自身逻辑的函数, 并且对于同一个给定输入, 函数的执行结果总是相同的, 这一属性被称为&lt;strong&gt;引用透明性&lt;/strong&gt;, 而这样的函数则被称为&lt;strong&gt;纯函数&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;对于纯函数, 我们可以应用&lt;strong&gt;代换模型&lt;/strong&gt; (数学中的函数推导), 这让代码具有可推导性, 遵循这一原则, 可以产出&lt;strong&gt;可测试&lt;/strong&gt;, &lt;strong&gt;可并发&lt;/strong&gt;以及&lt;strong&gt;可缓存&lt;/strong&gt;的代码.&lt;/p&gt;
&lt;h2 id="_3"&gt;声明式 &amp;amp; 抽象&lt;/h2&gt;
&lt;p&gt;对于一个问题, 通常分解为两部分:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;要做什么?&lt;/li&gt;
&lt;li&gt;如何去做?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以 js 举例来说, 假设有一个数组, 我想要打印出它的每个元素.&lt;/p&gt;
&lt;p&gt;对于这个问题, 很容易知道”要做什么”指的是: 打印数组元素, 即 &lt;code&gt;console.log()&lt;/code&gt;, 现在我们告诉编译器如何去做:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;var&lt;/span&gt; array = [&lt;span style="color: #B452CD"&gt;1&lt;/span&gt;, &lt;span style="color: #B452CD"&gt;2&lt;/span&gt;, &lt;span style="color: #B452CD"&gt;3&lt;/span&gt;]
&lt;span style="color: #8B008B; font-weight: bold"&gt;for&lt;/span&gt; (i=&lt;span style="color: #B452CD"&gt;0&lt;/span&gt;; i&amp;lt;array.length; i++) {
  console.log(array[i])
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这就是命令式编程, 大部分的代码都在指明&lt;strong&gt;如何去做&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;而函数式不同, 其重心是在声明&lt;strong&gt;要做什么&lt;/strong&gt;, 至于如何去做则被&lt;strong&gt;抽象&lt;/strong&gt;到一些高阶函数中:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;var&lt;/span&gt; array = [&lt;span style="color: #B452CD"&gt;1&lt;/span&gt;, &lt;span style="color: #B452CD"&gt;2&lt;/span&gt;, &lt;span style="color: #B452CD"&gt;3&lt;/span&gt;]
array.forEach(e =&amp;gt; console.log(e))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这就是函数式, 它主张&lt;strong&gt;声明式&lt;/strong&gt;编程和编写&lt;strong&gt;抽象&lt;/strong&gt;的代码. 这就要求选用的编程语言必须支持函数是一等公民.&lt;/p&gt;
&lt;p&gt;把”如何去做”&lt;strong&gt;抽象&lt;/strong&gt;为函数是函数式编程的核心思想, 抽象让我们专注于预订的目标而无须关心”底层”的事情, 上例的 &lt;code&gt;forEach&lt;/code&gt; 是 js 的”底层”函数, 它内置了如何遍历数据的逻辑.&lt;/p&gt;
&lt;p&gt;当然我们也可以自己进行抽象, 这一过程就是&lt;strong&gt;公共模式&lt;/strong&gt;的提取, 参考 &lt;a href="http://www.smallcpp.cn/ji-suan-ji-cheng-xu-de-gou-zao-yu-jie-shi.html#_9"&gt;计算机程序的构造与解释 - 高阶抽象和公共模式&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id="lambda"&gt;柯里化, 函数组合 与 lambda&lt;/h1&gt;
&lt;p&gt;这三个的概念就不多说了, 只提下需要注意的地方, 因为不熟悉 curried 的朋友会写出很多 lambda, 但其实是没必要的. 例如:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #008b45"&gt;map&lt;/span&gt; (&lt;span style="color: #008b45"&gt;\&lt;/span&gt;x &lt;span style="color: #8B008B"&gt;-&amp;gt;&lt;/span&gt; x + &lt;span style="color: #B452CD"&gt;3&lt;/span&gt;) [&lt;span style="color: #B452CD"&gt;1&lt;/span&gt;, &lt;span style="color: #B452CD"&gt;2&lt;/span&gt;, &lt;span style="color: #B452CD"&gt;3&lt;/span&gt;]

&lt;span style="color: #008b45"&gt;map&lt;/span&gt; (+&lt;span style="color: #B452CD"&gt;3&lt;/span&gt;) [&lt;span style="color: #B452CD"&gt;1&lt;/span&gt;, &lt;span style="color: #B452CD"&gt;2&lt;/span&gt;, &lt;span style="color: #B452CD"&gt;3&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两个是等价的. 同理还有函数组合:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #008b45"&gt;map&lt;/span&gt; (&lt;span style="color: #008b45"&gt;\&lt;/span&gt;x &lt;span style="color: #8B008B"&gt;-&amp;gt;&lt;/span&gt; negate (abs x)) [&lt;span style="color: #B452CD"&gt;1&lt;/span&gt;, &lt;span style="color: #B452CD"&gt;2&lt;/span&gt;, &lt;span style="color: #B452CD"&gt;3&lt;/span&gt;]

&lt;span style="color: #008b45"&gt;map&lt;/span&gt; (negate . abs) [&lt;span style="color: #B452CD"&gt;1&lt;/span&gt;, &lt;span style="color: #B452CD"&gt;2&lt;/span&gt;, &lt;span style="color: #B452CD"&gt;3&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外就是关于组合, 之前常见到说: &lt;strong&gt;函数组合满足结合律&lt;/strong&gt;. 即 &lt;code&gt;f . g . z === (f . g) . z == f . (g . z)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;那么这只是定义, 实际应用是什么呢? 举例来说.&lt;/p&gt;
&lt;p&gt;一开始通过组合搞出一个新函数 &lt;code&gt;let one = f . g . z&lt;/code&gt;, 然后又有了新需求通过组合 f 和 g 实现 &lt;code&gt;let two = f . g&lt;/code&gt;, 那此时就可以进行重构 &lt;code&gt;let one = two . z&lt;/code&gt; (我目前只发现结合律这一种实际应用, 如果有另外的, 会再更新).&lt;/p&gt;
&lt;h1 id="_4"&gt;代数数据类型&lt;/h1&gt;
&lt;p&gt;代数数据类型 (ADT, Algebraic data type), 代数数据类型是一种复合类型, 即通过组合其他类型形成的类型.&lt;/p&gt;
&lt;p&gt;之所以叫&lt;strong&gt;代数&lt;/strong&gt;, 是因为类型间的组合形式可以是&lt;strong&gt;和&lt;/strong&gt;或者&lt;strong&gt;积&lt;/strong&gt;, 例如:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;和: &lt;code&gt;data Pair = I Int | D Double&lt;/code&gt;,  此时 Pair 取值范围就是 Int 的范围 &lt;code&gt;+&lt;/code&gt; Double 的范围, 例如 &lt;code&gt;I(10)&lt;/code&gt;, &lt;code&gt;D(5.5)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;积: &lt;code&gt;data Pair = P Int Double&lt;/code&gt;,  此时 Pair 取值范围就是 Int 的范围 &lt;code&gt;*&lt;/code&gt; Double 的范围, 例如 &lt;code&gt;P(10, 5.5)&lt;/code&gt;, &lt;code&gt;P(10, 5.6)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;上面的定义中, &lt;code&gt;I&lt;/code&gt;, &lt;code&gt;D&lt;/code&gt;, &lt;code&gt;P&lt;/code&gt; 是&lt;strong&gt;值构造子&lt;/strong&gt;(/器),  而 &lt;code&gt;Pair&lt;/code&gt; 是&lt;strong&gt;类型构造子&lt;/strong&gt;(/器).&lt;br/&gt;
类型构造子也是可以有参数的, 那被称为类型参数, 参见下节的&lt;em&gt;类型变量&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用&lt;strong&gt;ADT&lt;/strong&gt;以及&lt;strong&gt;递归&lt;/strong&gt;两者结合实现一个保存 int 型数据的 binary trees:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;data&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;Tree&lt;/span&gt; &lt;span style="color: #8B008B"&gt;=&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;Empty&lt;/span&gt; | &lt;span style="color: #00688B; font-weight: bold"&gt;Leaf&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;Int&lt;/span&gt; | &lt;span style="color: #00688B; font-weight: bold"&gt;Node&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;Tree&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;Tree&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;let&lt;/span&gt; tree &lt;span style="color: #8B008B"&gt;=&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;Leaf&lt;/span&gt; &lt;span style="color: #B452CD"&gt;10&lt;/span&gt;

&lt;span style="color: #00688B; font-weight: bold"&gt;:&lt;/span&gt;t tree
&lt;span style="color: #008b45"&gt;tree&lt;/span&gt; &lt;span style="color: #8B008B"&gt;::&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;Tree&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;建立 ADT 只是开始, 我们要做的是对它们使用&lt;strong&gt;模式匹配&lt;/strong&gt;.&lt;/p&gt;
&lt;h1 id="_5"&gt;模式匹配&lt;/h1&gt;
&lt;p&gt;对于某个 ADT 的值来说, 应该可以做到以下两点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果这个类型有一个以上的值构造器, 那么应该可以知道, 这个值是由哪个构造器创建的.&lt;/li&gt;
&lt;li&gt;如果一个值构造器包含不同的成分, 那么应该有办法提取这些成分.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于以上两个问题, Haskell 有一个简单且有效的解决方式, 那就是模式匹配.&lt;/p&gt;
&lt;p&gt;模式匹配允许我们查看值的内部, 并将值所包含的数据绑定到变量上 (这个绑定的过程叫&lt;strong&gt;解构&lt;/strong&gt;).&lt;/p&gt;
&lt;p&gt;模式匹配实际匹配的是&lt;strong&gt;值构造子(/器)&lt;/strong&gt;, 以下是一个例子, 定义了一个二元搜索树, 然后实现了 treeElem 函数来检查元素是否在树中:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;data&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;Tree&lt;/span&gt; a &lt;span style="color: #8B008B"&gt;=&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;Empty&lt;/span&gt; | &lt;span style="color: #00688B; font-weight: bold"&gt;Node&lt;/span&gt; a (&lt;span style="color: #00688B; font-weight: bold"&gt;Tree&lt;/span&gt; a) (&lt;span style="color: #00688B; font-weight: bold"&gt;Tree&lt;/span&gt; a)

&lt;span style="color: #008b45"&gt;treeElem&lt;/span&gt; &lt;span style="color: #8B008B"&gt;::&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;Ord&lt;/span&gt; a &lt;span style="color: #8B008B"&gt;=&amp;gt;&lt;/span&gt; a &lt;span style="color: #8B008B"&gt;-&amp;gt;&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;Tree&lt;/span&gt; a &lt;span style="color: #8B008B"&gt;-&amp;gt;&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;Bool&lt;/span&gt;
&lt;span style="color: #008b45"&gt;treeElem&lt;/span&gt; x &lt;span style="color: #00688B; font-weight: bold"&gt;Empty&lt;/span&gt; &lt;span style="color: #8B008B"&gt;=&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;False&lt;/span&gt;  &lt;span style="color: #228B22"&gt;-- 匹配第一个值构造子 Empty&lt;/span&gt;
&lt;span style="color: #008b45"&gt;treeElem&lt;/span&gt; x (&lt;span style="color: #00688B; font-weight: bold"&gt;Node&lt;/span&gt; a left rigth) &lt;span style="color: #228B22"&gt;-- 匹配第二个值构造子  Node a (Tree a) (Tree a)&lt;/span&gt;
    | x == a &lt;span style="color: #8B008B"&gt;=&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;True&lt;/span&gt;
    | x &amp;lt; a &lt;span style="color: #8B008B"&gt;=&lt;/span&gt; treeElem x left
    | x &amp;gt; a &lt;span style="color: #8B008B"&gt;=&lt;/span&gt; treeElem x right
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果一个 ADT 有很多个值构造子, 需求只用匹配其中一个返回 True, 其它的都返回 False, 这就要用到&lt;strong&gt;万能匹配&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #008b45"&gt;luck&lt;/span&gt; &lt;span style="color: #8B008B"&gt;::&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;Int&lt;/span&gt; a &lt;span style="color: #8B008B"&gt;=&amp;gt;&lt;/span&gt; a &lt;span style="color: #8B008B"&gt;-&amp;gt;&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;Bool&lt;/span&gt;
&lt;span style="color: #008b45"&gt;luck&lt;/span&gt; &lt;span style="color: #B452CD"&gt;7&lt;/span&gt; &lt;span style="color: #8B008B"&gt;=&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;True&lt;/span&gt;
&lt;span style="color: #008b45"&gt;luck&lt;/span&gt; x &lt;span style="color: #8B008B"&gt;=&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;False&lt;/span&gt; &lt;span style="color: #228B22"&gt;-- 万能匹配&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="_6"&gt;类型变量&lt;/h1&gt;
&lt;p&gt;类型变量 (type variable), 是对类型的抽象, 它只是一个抽象, 并不具有实际分配的内存空间.&lt;/p&gt;
&lt;p&gt;一个普通的变量, 例如 int, 它表示任意一个合法范围内的整数, 而一个类型变量, 则表示它可以取任何一种类型, 可以是 int, 可以是 string.&lt;/p&gt;
&lt;p&gt;类型变量主要被用来定义 &lt;strong&gt;ADT&lt;/strong&gt;, 此时它可以被称作&lt;strong&gt;参数化类型&lt;/strong&gt; (Parameterized Type), 例如 Maybe 类型:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;data&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;Maybe&lt;/span&gt; a &lt;span style="color: #8B008B"&gt;=&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;Nothing&lt;/span&gt; | &lt;span style="color: #00688B; font-weight: bold"&gt;Just&lt;/span&gt; a
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Maybe&lt;/code&gt; 是&lt;strong&gt;类型构造子&lt;/strong&gt;(/器), 而 a 就是一个类型参数, 即传递给 Maybe 一个类型, 就能拿到一个新的类型回来, 例如给它 Char 就可以得到一个 &lt;code&gt;Maybe Char&lt;/code&gt; 的新类型;&lt;/p&gt;
&lt;p&gt;再例如, 用&lt;strong&gt;类型变量&lt;/strong&gt;, &lt;strong&gt;ADT&lt;/strong&gt;以及&lt;strong&gt;递归&lt;/strong&gt;三者结合实现 List:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;data&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;List&lt;/span&gt; a &lt;span style="color: #8B008B"&gt;=&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;Empty&lt;/span&gt; | &lt;span style="color: #00688B; font-weight: bold"&gt;Cons&lt;/span&gt; a (&lt;span style="color: #00688B; font-weight: bold"&gt;List&lt;/span&gt; a)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是的, 没错, type variable 就是&lt;strong&gt;泛型编程&lt;/strong&gt;的基础. Haskell 中的泛型实际是针对&lt;strong&gt;值构造子&lt;/strong&gt;(/器)编程, 例如 head 函数:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #00688B; font-weight: bold"&gt;:&lt;/span&gt;t head
&lt;span style="color: #008b45"&gt;head&lt;/span&gt; &lt;span style="color: #8B008B"&gt;::&lt;/span&gt; [a] &lt;span style="color: #8B008B"&gt;-&amp;gt;&lt;/span&gt; a  &lt;span style="color: #228B22"&gt;-- 可以看到 head 的实现只与 [] 有关, 而不关心 [] 里是包裹的究竟是何种类型&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="_7"&gt;类型类&lt;/h1&gt;
&lt;h2 id="what-is"&gt;What is&lt;/h2&gt;
&lt;p&gt;类型类 (type class), 是在参数多态 (parametric polymorphism) 中为类型变量定义约束, 可以联想面向对象中接口对类的行为约束, 接口定义一类必须实现了某些行为, 而类型类定义了必须为类型变量实现某些行为.&lt;/p&gt;
&lt;p&gt;我们针对类型变量进行泛型编程, 但我们的”通用”逻辑只针对某些类型生效, 而不是全部, 例如 &lt;code&gt;(==)&lt;/code&gt;, 这个函数只能接收可以比较大小的类型为参数, 看看它在 haskell 中的定义:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #00688B; font-weight: bold"&gt;:&lt;/span&gt;t (==)
(==) &lt;span style="color: #8B008B"&gt;::&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;Eq&lt;/span&gt; a &lt;span style="color: #8B008B"&gt;=&amp;gt;&lt;/span&gt; a &lt;span style="color: #8B008B"&gt;-&amp;gt;&lt;/span&gt; a &lt;span style="color: #8B008B"&gt;-&amp;gt;&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;Bool&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Eq&lt;/code&gt; 就是一个类型类, 它约束了类型变量 a 的一些行为, 现在来看看 &lt;code&gt;Eq&lt;/code&gt; 定义的行为:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;Eq&lt;/span&gt; a &lt;span style="color: #8B008B; font-weight: bold"&gt;where&lt;/span&gt;
  (==) &lt;span style="color: #8B008B"&gt;::&lt;/span&gt; a &lt;span style="color: #8B008B"&gt;-&amp;gt;&lt;/span&gt; a &lt;span style="color: #8B008B"&gt;-&amp;gt;&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;Bool&lt;/span&gt;
  (/=) &lt;span style="color: #8B008B"&gt;::&lt;/span&gt; a &lt;span style="color: #8B008B"&gt;-&amp;gt;&lt;/span&gt; a &lt;span style="color: #8B008B"&gt;-&amp;gt;&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;Bool&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它表示一个 Eq 类型必须实现了 &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;/=&lt;/code&gt; 操作.&lt;/p&gt;
&lt;h2 id="functor"&gt;Functor&lt;/h2&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;Functor&lt;/span&gt; f &lt;span style="color: #8B008B; font-weight: bold"&gt;where&lt;/span&gt;
  fmap &lt;span style="color: #8B008B"&gt;::&lt;/span&gt; (a &lt;span style="color: #8B008B"&gt;-&amp;gt;&lt;/span&gt; b) &lt;span style="color: #8B008B"&gt;-&amp;gt;&lt;/span&gt; f a &lt;span style="color: #8B008B"&gt;-&amp;gt;&lt;/span&gt; f b
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很简单的定义, 只要一个类型实现 &lt;code&gt;fmap&lt;/code&gt; 操作, 那它就是一个 Functor.&lt;/p&gt;
&lt;p&gt;很多语言中, Functor 就是那些支持 &lt;strong&gt;map&lt;/strong&gt; 操作的集合/容器, 如 List.&lt;/p&gt;
&lt;h2 id="applicative-functor"&gt;Applicative Functor&lt;/h2&gt;
&lt;p&gt;Functor 定义了把一个普通函数应用在 Functor 上的操作, 但如果函数也被包裹在 Functor 内, 那就无法应用, Applicative Functor 就是解决这个问题的:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;Applicative&lt;/span&gt; f &lt;span style="color: #8B008B; font-weight: bold"&gt;where&lt;/span&gt;
  pure &lt;span style="color: #8B008B"&gt;::&lt;/span&gt; a &lt;span style="color: #8B008B"&gt;-&amp;gt;&lt;/span&gt; f a
  (&amp;lt;*&amp;gt;) &lt;span style="color: #8B008B"&gt;::&lt;/span&gt; f (a &lt;span style="color: #8B008B"&gt;-&amp;gt;&lt;/span&gt; b) &lt;span style="color: #8B008B"&gt;-&amp;gt;&lt;/span&gt; f a &lt;span style="color: #8B008B"&gt;-&amp;gt;&lt;/span&gt; f b
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Applicative 的使用场景我遇到的很少…这里就不过多介绍了.&lt;/p&gt;
&lt;h2 id="monad"&gt;Monad&lt;/h2&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;Monad&lt;/span&gt; m &lt;span style="color: #8B008B; font-weight: bold"&gt;where&lt;/span&gt;
  return &lt;span style="color: #8B008B"&gt;::&lt;/span&gt; a &lt;span style="color: #8B008B"&gt;-&amp;gt;&lt;/span&gt; m a
  (&amp;gt;&amp;gt;=) &lt;span style="color: #8B008B"&gt;::&lt;/span&gt; m a &lt;span style="color: #8B008B"&gt;-&amp;gt;&lt;/span&gt; (a &lt;span style="color: #8B008B"&gt;-&amp;gt;&lt;/span&gt; m b) &lt;span style="color: #8B008B"&gt;-&amp;gt;&lt;/span&gt; m b
  ... &lt;span style="color: #228B22"&gt;-- 其它不重要, 关键就是 &amp;gt;&amp;gt;=&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在其它语言中, 这对应的就是 &lt;strong&gt;flatMap&lt;/strong&gt; 操作, 这个 type class 应用的也蛮广泛, 因为在某些情况下, 函数会被设计成返回包裹的值用以封装异常/错误 (例如使用 Maybe), 如果此时对其使用 map 那返回的将是 &lt;code&gt;Maybe[Maybe]&lt;/code&gt;, 换句话说, Functor 类型自动给结果包裹上 context, 而 Monad 则不会, 函数返回的是什么就是什么;&lt;/p&gt;
&lt;p&gt;再次对比下两者的区别:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #008b45"&gt;fmap&lt;/span&gt; &lt;span style="color: #8B008B"&gt;::&lt;/span&gt; (a &lt;span style="color: #8B008B"&gt;-&amp;gt;&lt;/span&gt; b) &lt;span style="color: #8B008B"&gt;-&amp;gt;&lt;/span&gt; f a &lt;span style="color: #8B008B"&gt;-&amp;gt;&lt;/span&gt; f b
(&amp;gt;&amp;gt;=) &lt;span style="color: #8B008B"&gt;::&lt;/span&gt; m a &lt;span style="color: #8B008B"&gt;-&amp;gt;&lt;/span&gt; (a &lt;span style="color: #8B008B"&gt;-&amp;gt;&lt;/span&gt; m b) &lt;span style="color: #8B008B"&gt;-&amp;gt;&lt;/span&gt; m b
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到 &lt;code&gt;fmap&lt;/code&gt; 接收的函数其返回类型是 b, 但 fmap 自己却返回了 f b; 而 &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; 接收的函数其返回类型是 m b, 而其本身也就是返回了 m b.&lt;/p&gt;
&lt;p&gt;对于 Monad 会有 &lt;code&gt;do&lt;/code&gt; 语法糖来使代码更容易阅读:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #00688B; font-weight: bold"&gt;Just&lt;/span&gt; &lt;span style="color: #B452CD"&gt;3&lt;/span&gt; &amp;gt;&amp;gt;= (&lt;span style="color: #008b45"&gt;\&lt;/span&gt;x &lt;span style="color: #8B008B"&gt;-&amp;gt;&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;Just&lt;/span&gt; &lt;span style="color: #CD5555"&gt;"!"&lt;/span&gt; &amp;gt;&amp;gt;= (&lt;span style="color: #008b45"&gt;\&lt;/span&gt;y &lt;span style="color: #8B008B"&gt;-&amp;gt;&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;Just&lt;/span&gt; (show x ++ y)))

&lt;span style="color: #8B008B; font-weight: bold"&gt;do&lt;/span&gt; &lt;span style="color: #228B22"&gt;-- 与上面的代码等价&lt;/span&gt;
&lt;span style="color: #008b45"&gt;x&lt;/span&gt; &lt;span style="color: #8B008B"&gt;&amp;lt;-&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;Just&lt;/span&gt; &lt;span style="color: #B452CD"&gt;3&lt;/span&gt;
&lt;span style="color: #008b45"&gt;y&lt;/span&gt; &lt;span style="color: #8B008B"&gt;&amp;lt;-&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;Just&lt;/span&gt; &lt;span style="color: #CD5555"&gt;"!"&lt;/span&gt;
&lt;span style="color: #00688B; font-weight: bold"&gt;Just&lt;/span&gt; (show x ++ y)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="functor-applicative-monad"&gt;Functor &amp;amp; Applicative &amp;amp; Monad&lt;/h2&gt;
&lt;p&gt;这三者是有联系的, 所有的 Applicative 都必然是 Functor, 而所有的 Monad 都必然是 Applicative:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;Functor&lt;/span&gt; f &lt;span style="color: #8B008B"&gt;=&amp;gt;&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;Applicative&lt;/span&gt; f &lt;span style="color: #8B008B; font-weight: bold"&gt;where&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;-- ...&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;Applicative&lt;/span&gt; m &lt;span style="color: #8B008B"&gt;=&amp;gt;&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;Monad&lt;/span&gt; m &lt;span style="color: #8B008B; font-weight: bold"&gt;where&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;-- ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;PS: 要注意, 这种 &lt;code&gt;class =&amp;gt;&lt;/code&gt; 表示法是依赖关系而不是实现顺序关系, 并不是说一个结构要实现 Monad 要先去实现 Applicative, 而是说实现了 Monad 的结构必然是自实现了 Applicative 的.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="maybe-either"&gt;Maybe &amp;amp; Either&lt;/h2&gt;
&lt;p&gt;Haskell 中 Maybe &amp;amp; Either 都是一个 Monad (如上小节所说, 它们也会是 Functor &amp;amp; Applicative).&lt;/p&gt;
&lt;p&gt;它们会被用来处理一些错误情况, 以 Maybe 来说, 对于 &lt;code&gt;fmap / &amp;lt;*&amp;gt; / &amp;gt;&amp;gt;=&lt;/code&gt; 这此操作, 如果 Maybe 的值是 Nothing, 那这些操作将什么也不做, 仅仅再次返回 Nothing, 在一堆的链式操作中, 如果某一轮出错, 我们让这一轮返回 Nothing, 那后续的操作都将持续返回 Nohing, 最后的结果也将是 Nothing.&lt;/p&gt;
&lt;p&gt;Maybe 对于错误只是简单返回 Nothing, 我们会丢失错误信息, 某些时候可能需要这些信息, 这时可用 Either 代替 Maybe, 可以用 Right 表示正确值, 而用 Left 表示错误的信息.&lt;/p&gt;</content><category term="函数式"></category></entry><entry><title>用费曼技巧读书</title><link href="http://www.smallcpp.cn/yong-fei-man-ji-qiao-du-shu.html" rel="alternate"></link><published>2018-11-26T11:46:00+08:00</published><updated>2018-11-26T11:46:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2018-11-26:/yong-fei-man-ji-qiao-du-shu.html</id><summary type="html">
&lt;p&gt;Reference:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.jianshu.com/p/682872cc0fc8"&gt;读书与皇帝的金扁担&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.studygs.net/chinese/texred2.htm"&gt;SQ3R 阅读方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="_1"&gt;解构目录&lt;/h1&gt;
&lt;p&gt;读书不是从第一页开始, 而是从目录开始. 了解这本书的目录章节, 然后开始思考: 作者为何这样编排结构? 设想你是作者, 在这样的结构下, 结合你的经验和阅历, 你会怎么样来写作各个章节的内容? 解构完目录, 你已预先建立了这本书的属于你自己的框架.&lt;/p&gt;
&lt;p&gt;如果对某些章节有疑问, 那最好不过, 把这部分内容当作你的&lt;em&gt;锚点&lt;/em&gt;, 先别急着去解开疑惑, 或许等你读到那里的时候, 自然会豁然开朗. 这样的体验是美妙的.&lt;/p&gt;
&lt;h1 id="_2"&gt;以章节作为阅读单位&lt;/h1&gt;
&lt;p&gt;每读完一章节, 停下来, 从整体的角度来看, 思考这一章的内容是怎样来支持作者的观点的?&lt;/p&gt;
&lt;p&gt;罗列各个要点 …&lt;/p&gt;</summary><content type="html">
&lt;p&gt;Reference:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.jianshu.com/p/682872cc0fc8"&gt;读书与皇帝的金扁担&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.studygs.net/chinese/texred2.htm"&gt;SQ3R 阅读方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="_1"&gt;解构目录&lt;/h1&gt;
&lt;p&gt;读书不是从第一页开始, 而是从目录开始. 了解这本书的目录章节, 然后开始思考: 作者为何这样编排结构? 设想你是作者, 在这样的结构下, 结合你的经验和阅历, 你会怎么样来写作各个章节的内容? 解构完目录, 你已预先建立了这本书的属于你自己的框架.&lt;/p&gt;
&lt;p&gt;如果对某些章节有疑问, 那最好不过, 把这部分内容当作你的&lt;em&gt;锚点&lt;/em&gt;, 先别急着去解开疑惑, 或许等你读到那里的时候, 自然会豁然开朗. 这样的体验是美妙的.&lt;/p&gt;
&lt;h1 id="_2"&gt;以章节作为阅读单位&lt;/h1&gt;
&lt;p&gt;每读完一章节, 停下来, 从整体的角度来看, 思考这一章的内容是怎样来支持作者的观点的?&lt;/p&gt;
&lt;p&gt;罗列各个要点, 回顾各个要点的论述过程中, 有没有一些自己的感想?&lt;/p&gt;
&lt;h1 id="_3"&gt;输出你学到的东西&lt;/h1&gt;
&lt;p&gt;输入需要输出来强化, 读书对应的最好的练习方式是写作.&lt;/p&gt;
&lt;p&gt;设想以一个老师的身份, 试图把你学到的, 写给一个完全没接触过此方面内容的人. 如果用&lt;em&gt;演讲&lt;/em&gt;的方式, 这会更有效.&lt;/p&gt;</content><category term="杂项"></category></entry><entry><title>柯里化与偏函数</title><link href="http://www.smallcpp.cn/ke-li-hua-yu-pian-han-shu.html" rel="alternate"></link><published>2018-09-06T19:00:00+08:00</published><updated>2018-09-06T19:00:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2018-09-06:/ke-li-hua-yu-pian-han-shu.html</id><summary type="html">&lt;p&gt;&lt;strong&gt;Currying&lt;/strong&gt;: 因为是美国数理逻辑学家哈斯凯尔·柯里(Haskell Curry)发明了这种函数使用技巧, 所以这样用法就以他的名字命名为 Currying, 中文翻译为 “柯里化”.&lt;/p&gt;
&lt;p&gt;我感觉很多人都对函数柯里化(Currying)和偏函数应用(Partial Application)之间的区别搞不清楚, 尤其是在相似的上下文环境中它们同时出现的时候.&lt;/p&gt;

&lt;h1 id="_1"&gt;偏函数应用&lt;/h1&gt;
&lt;p&gt;偏函数应用解决这样的问题: 如果我们有函数是多个参数的, 我们希望能固定其中某几个参数的值.&lt;/p&gt;
&lt;p&gt;几乎所有编程语言中都有非常明显的偏函数应用. 在 C 语言中:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #00688B; font-weight: bold"&gt;int&lt;/span&gt; &lt;span style="color: #008b45"&gt;foo&lt;/span&gt;(&lt;span style="color: #00688B; font-weight: bold"&gt;int&lt;/span&gt; a, &lt;span style="color: #00688B; font-weight: bold"&gt;int …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;&lt;strong&gt;Currying&lt;/strong&gt;: 因为是美国数理逻辑学家哈斯凯尔·柯里(Haskell Curry)发明了这种函数使用技巧, 所以这样用法就以他的名字命名为 Currying, 中文翻译为 “柯里化”.&lt;/p&gt;
&lt;p&gt;我感觉很多人都对函数柯里化(Currying)和偏函数应用(Partial Application)之间的区别搞不清楚, 尤其是在相似的上下文环境中它们同时出现的时候.&lt;/p&gt;

&lt;h1 id="_1"&gt;偏函数应用&lt;/h1&gt;
&lt;p&gt;偏函数应用解决这样的问题: 如果我们有函数是多个参数的, 我们希望能固定其中某几个参数的值.&lt;/p&gt;
&lt;p&gt;几乎所有编程语言中都有非常明显的偏函数应用. 在 C 语言中:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #00688B; font-weight: bold"&gt;int&lt;/span&gt; &lt;span style="color: #008b45"&gt;foo&lt;/span&gt;(&lt;span style="color: #00688B; font-weight: bold"&gt;int&lt;/span&gt; a, &lt;span style="color: #00688B; font-weight: bold"&gt;int&lt;/span&gt; b, &lt;span style="color: #00688B; font-weight: bold"&gt;int&lt;/span&gt; c) {
  &lt;span style="color: #8B008B; font-weight: bold"&gt;return&lt;/span&gt; a + b + c;
}

&lt;span style="color: #00688B; font-weight: bold"&gt;int&lt;/span&gt; &lt;span style="color: #008b45"&gt;foo23&lt;/span&gt;(&lt;span style="color: #00688B; font-weight: bold"&gt;int&lt;/span&gt; a, &lt;span style="color: #00688B; font-weight: bold"&gt;int&lt;/span&gt; c) {
  &lt;span style="color: #8B008B; font-weight: bold"&gt;return&lt;/span&gt; foo(a, &lt;span style="color: #B452CD"&gt;23&lt;/span&gt;, c);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;foo23&lt;/code&gt; 函数实际上就是一个 &lt;code&gt;foo&lt;/code&gt;函数的偏函数应用, 参数 b 的值被固定为 23.&lt;/p&gt;
&lt;p&gt;当然, 像这样明显的偏函数并没有太大的用处; 我们通常会希望编程语言能提供我们某些偏函数特征, 例如, 在 Python 语言中, 我们可以这样做:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;from&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;functools&lt;/span&gt; &lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; partial

&lt;span style="color: #8B008B; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #008b45"&gt;foo&lt;/span&gt;(a, b, c):
  &lt;span style="color: #8B008B; font-weight: bold"&gt;return&lt;/span&gt; a + b + c

foo23 = partial(foo, b=&lt;span style="color: #B452CD"&gt;23&lt;/span&gt;)

foo23(a = &lt;span style="color: #B452CD"&gt;1&lt;/span&gt;, c = &lt;span style="color: #B452CD"&gt;3&lt;/span&gt;) &lt;span style="color: #228B22"&gt;# =&amp;gt; 27&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="_2"&gt;函数柯里化&lt;/h1&gt;
&lt;p&gt;函数柯里化解决的是一个完全不同的问题: 如果我们有几个单参数函数, 并且这是一种支持一等函数(first-class)的语言, 如何去实现一个多参数函数? 柯里化是一种实现多参数函数的方法.&lt;/p&gt;
&lt;p&gt;下面是一个单参数的 Javascript 函数:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;var&lt;/span&gt; foo = &lt;span style="color: #8B008B; font-weight: bold"&gt;function&lt;/span&gt;(a) {
  &lt;span style="color: #8B008B; font-weight: bold"&gt;return&lt;/span&gt; a * a;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果我们受限只能写单参数函数 (在最初, 柯里化也确实是为了在单一参数的 lambda 演算中研究多参函数), 可以像下面这样模拟出一个多参数函数:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;var&lt;/span&gt; foo = &lt;span style="color: #8B008B; font-weight: bold"&gt;function&lt;/span&gt;(a) {
  &lt;span style="color: #8B008B; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #8B008B; font-weight: bold"&gt;function&lt;/span&gt;(b) {
    &lt;span style="color: #8B008B; font-weight: bold"&gt;return&lt;/span&gt; a * a + b * b;
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过这样调用它: &lt;code&gt;foo(3)(4)&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;注意, 函数柯里化提供了一种非常自然的方式来实现某些偏函数应用. 如果你希望函数 &lt;code&gt;foo&lt;/code&gt; 的第一个参数值被固定成 5, 你需要做的就是 &lt;code&gt;var foo5 = foo(5)&lt;/code&gt;. 这就 OK 了, 函数 &lt;code&gt;foo5&lt;/code&gt; 就是 &lt;code&gt;foo&lt;/code&gt; 函数的偏函数.&lt;/p&gt;
&lt;p&gt;当然, Javascript 本身就是支持多参数函数的, 但在一些其它语言里, 比如 Haskell 和 OCaml, 所有的多参数函数都是隐式通过柯里化实现的.&lt;/p&gt;
&lt;h1 id="_3"&gt;总结&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;当要固定的是函数前面的参数, 可用柯里化.&lt;/li&gt;
&lt;li&gt;当要固定的是函数结尾的参数, 可用偏函数.&lt;/li&gt;
&lt;li&gt;偏函数应用是固定多参函数中某些个参数值, 从而得到一个新的函数.&lt;/li&gt;
&lt;li&gt;函数柯里化是一种使用单参数函数来实现多参数函数的方法.&lt;/li&gt;
&lt;li&gt;函数柯里化能够让你轻松的实现某些偏函数应用.&lt;/li&gt;
&lt;li&gt;有些语言(例如 Haskell, OCaml)所有的多参函数都是在内部通过函数柯里化实现的.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="http://www.aqee.net/post/currying-partial-application.html"&gt;原文传送门&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</content><category term="函数式"></category></entry><entry><title>计算机程序的构造与解释</title><link href="http://www.smallcpp.cn/ji-suan-ji-cheng-xu-de-gou-zao-yu-jie-shi.html" rel="alternate"></link><published>2018-08-01T12:36:00+08:00</published><updated>2018-08-01T12:36:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2018-08-01:/ji-suan-ji-cheng-xu-de-gou-zao-yu-jie-shi.html</id><summary type="html">
&lt;h1 id="_1"&gt;函数式编程&lt;/h1&gt;
&lt;p&gt;函数式编程是一种编程典范, 比起指令式(过程式)编程的复杂执行过程, 函数式编程更加强调程序执行的结果, 倡导利用若干简单的执行单元让计算结果不断渐进, 仔细定义每个运算的输入, 以及每个运算返回的内容, 逐层推导复杂的运算, 并且避免使用程序状态以及易变对象.&lt;/p&gt;
&lt;p&gt;以一个多项式求值 &lt;code&gt;a * (b + c)&lt;/code&gt; 举例 (假设存在 &lt;code&gt;add&lt;/code&gt; 和 &lt;code&gt;mul&lt;/code&gt; 方法):&lt;/p&gt;
&lt;p&gt;指令式(过程式)编程:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;x = add(b, c)
y = mul …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">
&lt;h1 id="_1"&gt;函数式编程&lt;/h1&gt;
&lt;p&gt;函数式编程是一种编程典范, 比起指令式(过程式)编程的复杂执行过程, 函数式编程更加强调程序执行的结果, 倡导利用若干简单的执行单元让计算结果不断渐进, 仔细定义每个运算的输入, 以及每个运算返回的内容, 逐层推导复杂的运算, 并且避免使用程序状态以及易变对象.&lt;/p&gt;
&lt;p&gt;以一个多项式求值 &lt;code&gt;a * (b + c)&lt;/code&gt; 举例 (假设存在 &lt;code&gt;add&lt;/code&gt; 和 &lt;code&gt;mul&lt;/code&gt; 方法):&lt;/p&gt;
&lt;p&gt;指令式(过程式)编程:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;x = add(b, c)
y = mul(a, x)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数式编程:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;mul(a, add(b, c))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解释函数式代码的步骤是 &lt;em&gt;求值-应用&lt;/em&gt; 这两大步骤的轮转: 为了对一个组合式求值, 例如: &lt;code&gt;mul(a, add(b, c))&lt;/code&gt;, 必须先对组合式里的每个元素执行求值过程, 然后将求值的结果应用于组合式, 而每个元素的内部又可能包含新的求值过程, 例如 &lt;code&gt;mul(a, add(b, sub(c, d)))&lt;/code&gt;, 所以, 在规则性质上 (即将 mul, add, sub 这些不同的函数均视为相同的抽象求值过程), 这一解释过程其实是递归的:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i67.tinypic.com/98woxu.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;在函数式思想中, 只有纯的、没有副作用的函数, 才是合格的函数.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;副作用指当调用函数时, 除了返回函数值之外, 还对主调用函数产生附加的影响, 例如修改全局变量 (函数外的变量) 或修改参数.&lt;/li&gt;
&lt;li&gt;纯函数是指函数与外界交换数据只有一个唯一渠道——参数和返回值, 如果函数从外界获取数据, 或者向外部输出数据 (比如读取全局变量, 修改全局变量), 那么, 该函数就是非纯函数.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1 id="lisp"&gt;Lisp&lt;/h1&gt;
&lt;h2 id="_2"&gt;序对&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;(cons x y)&lt;/code&gt; 构造一个 &lt;code&gt;[x, y]&lt;/code&gt; 序对&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(car p)&lt;/code&gt; 选择序对 p 的首元素&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(cdr p)&lt;/code&gt; 选择序对 p 的尾元素&lt;/p&gt;
&lt;p&gt;元素可以是任意数据, 包括另一个序对.&lt;/p&gt;
&lt;h2 id="_3"&gt;表&lt;/h2&gt;
&lt;p&gt;如果我们想要表示 &lt;code&gt;[1, 2, 3, 4]&lt;/code&gt; 这个数据, 使用序对, 会有很多种可能, 例如:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;((&lt;span style="color: #B452CD"&gt;1&lt;/span&gt;, &lt;span style="color: #B452CD"&gt;2&lt;/span&gt;), (&lt;span style="color: #B452CD"&gt;3&lt;/span&gt;, &lt;span style="color: #B452CD"&gt;4&lt;/span&gt;))

(&lt;span style="color: #B452CD"&gt;1&lt;/span&gt;, (&lt;span style="color: #B452CD"&gt;2&lt;/span&gt;, &lt;span style="color: #B452CD"&gt;3&lt;/span&gt;), &lt;span style="color: #B452CD"&gt;4&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此就需要一种约定来进行规范, 这就是表, 即序对的序列, 它使用下面这种试来构建多元素数据:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i64.tinypic.com/532y5c.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;即:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;(&lt;span style="color: #658b00"&gt;cons &lt;/span&gt;&lt;span style="color: #B452CD"&gt;1&lt;/span&gt;
    (&lt;span style="color: #658b00"&gt;cons &lt;/span&gt;&lt;span style="color: #B452CD"&gt;2&lt;/span&gt;
        (&lt;span style="color: #658b00"&gt;cons &lt;/span&gt;&lt;span style="color: #B452CD"&gt;3&lt;/span&gt;
            (&lt;span style="color: #658b00"&gt;cons &lt;/span&gt;&lt;span style="color: #B452CD"&gt;4&lt;/span&gt; ()))))  &lt;span style="color: #228B22"&gt;; null? 可以判断序对是否为空 ()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是如果每次构造表都要写一堆 &lt;code&gt;cons&lt;/code&gt; 是个很麻烦的事, 所以 lisp 提供了 &lt;code&gt;list&lt;/code&gt; 函数: &lt;code&gt;(list 1 2 3 4)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;虽然 &lt;code&gt;list&lt;/code&gt; 很方便, 但本质上, 它只是一个语法糖, 用来简便地书写嵌套的 &lt;code&gt;cons&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="_4"&gt;变量&lt;/h2&gt;
&lt;h3 id="let"&gt;let (局部)&lt;/h3&gt;
&lt;p&gt;let 可以一次对多个变量赋值, 但变量只能在 let 的子域中使用.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;(&lt;span style="color: #8B008B; font-weight: bold"&gt;let &lt;/span&gt;((&lt;span style="color: #008b45"&gt;var1&lt;/span&gt; &lt;span style="color: #00688B"&gt;exp1&lt;/span&gt;) (&lt;span style="color: #008b45"&gt;var2&lt;/span&gt; &lt;span style="color: #00688B"&gt;exp2&lt;/span&gt;) ... (&lt;span style="color: #008b45"&gt;varn&lt;/span&gt; &lt;span style="color: #00688B"&gt;expn&lt;/span&gt;))
    &lt;span style="color: #00688B"&gt;exps&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;(&lt;span style="color: #8B008B; font-weight: bold"&gt;let &lt;/span&gt;((&lt;span style="color: #008b45"&gt;a&lt;/span&gt; &lt;span style="color: #B452CD"&gt;1&lt;/span&gt;) (&lt;span style="color: #008b45"&gt;b&lt;/span&gt; &lt;span style="color: #B452CD"&gt;2&lt;/span&gt;) (&lt;span style="color: #008b45"&gt;c&lt;/span&gt; (&lt;span style="color: #658b00"&gt;+ &lt;/span&gt;&lt;span style="color: #B452CD"&gt;5&lt;/span&gt; &lt;span style="color: #B452CD"&gt;3&lt;/span&gt;)))
    (&lt;span style="color: #658b00"&gt;+ &lt;/span&gt;&lt;span style="color: #00688B"&gt;a&lt;/span&gt; (&lt;span style="color: #658b00"&gt;* &lt;/span&gt;&lt;span style="color: #00688B"&gt;b&lt;/span&gt; &lt;span style="color: #00688B"&gt;c&lt;/span&gt;)))
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="define"&gt;define (全局)&lt;/h3&gt;
&lt;p&gt;define 一次只能对一个变量赋值, 变量可在与 define 同一级的域中使用.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;&lt;span style="color: #00688B"&gt;num&lt;/span&gt; &lt;span style="color: #B452CD"&gt;10&lt;/span&gt;)
&lt;span style="color: #00688B"&gt;num&lt;/span&gt; &lt;span style="color: #228B22"&gt;; =&amp;gt; 10&lt;/span&gt;

(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;&lt;span style="color: #00688B"&gt;sum&lt;/span&gt; (&lt;span style="color: #658b00"&gt;+ &lt;/span&gt;&lt;span style="color: #B452CD"&gt;10&lt;/span&gt; &lt;span style="color: #B452CD"&gt;20&lt;/span&gt;))
&lt;span style="color: #00688B"&gt;sum&lt;/span&gt; &lt;span style="color: #228B22"&gt;; =&amp;gt; 30&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="_5"&gt;数据的不变性&lt;/h3&gt;
&lt;p&gt;高级语言中, 变量是一块内存区域的标识, 可以通过修改这个内存区域的存储内容来修改变量的值;&lt;/p&gt;
&lt;p&gt;而在 Lisp 家族中, 变量用于绑定常量与函数. 虽然也可以重定义一个变量, 但这只是让变量换了一个绑定而已.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;&lt;span style="color: #00688B"&gt;a&lt;/span&gt; &lt;span style="color: #B452CD"&gt;1&lt;/span&gt;)
&lt;span style="color: #00688B"&gt;a&lt;/span&gt; &lt;span style="color: #228B22"&gt;; =&amp;gt; 1&lt;/span&gt;

(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;&lt;span style="color: #00688B"&gt;l&lt;/span&gt; (&lt;span style="color: #658b00"&gt;cons &lt;/span&gt;&lt;span style="color: #00688B"&gt;a&lt;/span&gt; &lt;span style="color: #B452CD"&gt;2&lt;/span&gt;))
&lt;span style="color: #00688B"&gt;l&lt;/span&gt; &lt;span style="color: #228B22"&gt;; =&amp;gt; (1 . 2)&lt;/span&gt;

(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;&lt;span style="color: #00688B"&gt;a&lt;/span&gt; &lt;span style="color: #B452CD"&gt;3&lt;/span&gt;)
&lt;span style="color: #00688B"&gt;a&lt;/span&gt; &lt;span style="color: #228B22"&gt;; =&amp;gt; 3&lt;/span&gt;

&lt;span style="color: #00688B"&gt;l&lt;/span&gt; &lt;span style="color: #228B22"&gt;; =&amp;gt; (1 . 2)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="_6"&gt;函数&lt;/h2&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;&lt;span style="color: #00688B"&gt;square&lt;/span&gt; (&lt;span style="color: #8B008B; font-weight: bold"&gt;lambda &lt;/span&gt;(&lt;span style="color: #008b45"&gt;x&lt;/span&gt;) (&lt;span style="color: #658b00"&gt;* &lt;/span&gt;&lt;span style="color: #00688B"&gt;x&lt;/span&gt; &lt;span style="color: #00688B"&gt;x&lt;/span&gt;)))

&lt;span style="color: #228B22"&gt;; 这是通常的写法, 但本质还是上面那种, 只是个语法糖&lt;/span&gt;
(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #008b45"&gt;square&lt;/span&gt; &lt;span style="color: #00688B"&gt;x&lt;/span&gt;) (&lt;span style="color: #658b00"&gt;* &lt;/span&gt;&lt;span style="color: #00688B"&gt;x&lt;/span&gt; &lt;span style="color: #00688B"&gt;x&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(square 10) -&amp;gt; 100&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i65.tinypic.com/2niae5v.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(define (sum) (+ 10 20))&lt;/code&gt;  无参函数&lt;/p&gt;
&lt;h2 id="_7"&gt;分支&lt;/h2&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #658b00"&gt;abs &lt;/span&gt;&lt;span style="color: #00688B"&gt;x&lt;/span&gt;)
    (&lt;span style="color: #8B008B; font-weight: bold"&gt;if &lt;/span&gt;(&lt;span style="color: #658b00"&gt;&amp;lt; &lt;/span&gt;&lt;span style="color: #00688B"&gt;x&lt;/span&gt; &lt;span style="color: #B452CD"&gt;0&lt;/span&gt;)
        (&lt;span style="color: #658b00"&gt;- &lt;/span&gt;&lt;span style="color: #00688B"&gt;x&lt;/span&gt;)
        &lt;span style="color: #00688B"&gt;x&lt;/span&gt;))

(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #658b00"&gt;abs &lt;/span&gt;&lt;span style="color: #00688B"&gt;x&lt;/span&gt;)
    (&lt;span style="color: #008b45"&gt;cond&lt;/span&gt;
        ((&lt;span style="color: #658b00"&gt;&amp;lt; &lt;/span&gt;&lt;span style="color: #00688B"&gt;x&lt;/span&gt; &lt;span style="color: #B452CD"&gt;0&lt;/span&gt;) (&lt;span style="color: #658b00"&gt;- &lt;/span&gt;&lt;span style="color: #00688B"&gt;x&lt;/span&gt;))
        ((&lt;span style="color: #658b00"&gt;= &lt;/span&gt;&lt;span style="color: #00688B"&gt;x&lt;/span&gt; &lt;span style="color: #B452CD"&gt;0&lt;/span&gt;) &lt;span style="color: #B452CD"&gt;0&lt;/span&gt;)
        ((&lt;span style="color: #658b00"&gt;&amp;gt; &lt;/span&gt;&lt;span style="color: #00688B"&gt;x&lt;/span&gt; &lt;span style="color: #B452CD"&gt;0&lt;/span&gt;) &lt;span style="color: #00688B"&gt;x&lt;/span&gt;)))

(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #658b00"&gt;abs &lt;/span&gt;&lt;span style="color: #00688B"&gt;x&lt;/span&gt;)
    (&lt;span style="color: #008b45"&gt;cond&lt;/span&gt;
        ((&lt;span style="color: #658b00"&gt;&amp;lt; &lt;/span&gt;&lt;span style="color: #00688B"&gt;x&lt;/span&gt; &lt;span style="color: #B452CD"&gt;0&lt;/span&gt;) (&lt;span style="color: #658b00"&gt;- &lt;/span&gt;&lt;span style="color: #00688B"&gt;x&lt;/span&gt;))
        ((&lt;span style="color: #658b00"&gt;= &lt;/span&gt;&lt;span style="color: #00688B"&gt;x&lt;/span&gt; &lt;span style="color: #B452CD"&gt;0&lt;/span&gt;) &lt;span style="color: #B452CD"&gt;0&lt;/span&gt;)
        (&lt;span style="color: #8B008B; font-weight: bold"&gt;else &lt;/span&gt;&lt;span style="color: #00688B"&gt;x&lt;/span&gt;)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;cond 有点类似 switch&lt;/p&gt;
&lt;h1 id="_8"&gt;递归/尾递归&lt;/h1&gt;
&lt;p&gt;递归其实是延迟运算, 先分解问题到最小粒度, 计算小问题再将结果向上传递, 最终归并解决原始问题.&lt;/p&gt;
&lt;p&gt;而尾递归是迭代性质的, 即分解问题的过程中直接计算出结果, 并将结果直接应用于下一次计算, 问题分解完了结果也就出来了. (感觉高级语言中的循环迭代, 就像是尾递归的语法糖).&lt;/p&gt;
&lt;p&gt;加法 (&lt;code&gt;1+&lt;/code&gt; &lt;code&gt;-1+&lt;/code&gt; 是内建操作)&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;; 递归&lt;/span&gt;
(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #658b00"&gt;+ &lt;/span&gt;&lt;span style="color: #00688B"&gt;x&lt;/span&gt; &lt;span style="color: #00688B"&gt;y&lt;/span&gt;)
    (&lt;span style="color: #008b45"&gt;cond&lt;/span&gt;
        ((&lt;span style="color: #658b00"&gt;= &lt;/span&gt;&lt;span style="color: #00688B"&gt;x&lt;/span&gt; &lt;span style="color: #B452CD"&gt;0&lt;/span&gt;) &lt;span style="color: #00688B"&gt;y&lt;/span&gt;)
        (&lt;span style="color: #8B008B; font-weight: bold"&gt;else &lt;/span&gt;(&lt;span style="color: #B452CD"&gt;1&lt;/span&gt;&lt;span style="color: #00688B"&gt;+&lt;/span&gt; (&lt;span style="color: #B452CD"&gt;-1&lt;/span&gt;&lt;span style="color: #00688B"&gt;+&lt;/span&gt; &lt;span style="color: #00688B"&gt;x&lt;/span&gt;) &lt;span style="color: #00688B"&gt;y&lt;/span&gt;))))

&lt;span style="color: #228B22"&gt;; 迭代 (尾递归)&lt;/span&gt;
(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #658b00"&gt;+ &lt;/span&gt;&lt;span style="color: #00688B"&gt;x&lt;/span&gt; &lt;span style="color: #00688B"&gt;y&lt;/span&gt;)
    (&lt;span style="color: #008b45"&gt;cond&lt;/span&gt;
        ((&lt;span style="color: #658b00"&gt;= &lt;/span&gt;&lt;span style="color: #00688B"&gt;x&lt;/span&gt; &lt;span style="color: #B452CD"&gt;0&lt;/span&gt;) &lt;span style="color: #00688B"&gt;y&lt;/span&gt;)
        (&lt;span style="color: #8B008B; font-weight: bold"&gt;else &lt;/span&gt;(&lt;span style="color: #658b00"&gt;+ &lt;/span&gt;(&lt;span style="color: #B452CD"&gt;-1&lt;/span&gt;&lt;span style="color: #00688B"&gt;+&lt;/span&gt; &lt;span style="color: #00688B"&gt;x&lt;/span&gt;) (&lt;span style="color: #B452CD"&gt;1&lt;/span&gt;&lt;span style="color: #00688B"&gt;+&lt;/span&gt; &lt;span style="color: #00688B"&gt;y&lt;/span&gt;)))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;斐波那契数列&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;; 递归&lt;/span&gt;
(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #008b45"&gt;fib&lt;/span&gt; &lt;span style="color: #00688B"&gt;n&lt;/span&gt;)
    (&lt;span style="color: #008b45"&gt;cond&lt;/span&gt;
        ((&lt;span style="color: #658b00"&gt;&amp;lt; &lt;/span&gt;&lt;span style="color: #00688B"&gt;n&lt;/span&gt; &lt;span style="color: #B452CD"&gt;2&lt;/span&gt;) &lt;span style="color: #00688B"&gt;n&lt;/span&gt;)
        (&lt;span style="color: #8B008B; font-weight: bold"&gt;else &lt;/span&gt;(&lt;span style="color: #658b00"&gt;+ &lt;/span&gt;(&lt;span style="color: #008b45"&gt;fib&lt;/span&gt; (&lt;span style="color: #658b00"&gt;- &lt;/span&gt;&lt;span style="color: #00688B"&gt;n&lt;/span&gt; &lt;span style="color: #B452CD"&gt;1&lt;/span&gt;))
                 (&lt;span style="color: #008b45"&gt;fib&lt;/span&gt; (&lt;span style="color: #658b00"&gt;- &lt;/span&gt;&lt;span style="color: #00688B"&gt;n&lt;/span&gt; &lt;span style="color: #B452CD"&gt;2&lt;/span&gt;))))))

&lt;span style="color: #228B22"&gt;; 迭代 (尾递归), 这也展示出了递归优化的一般模式 -- 引入一个内部函数来累积结果&lt;/span&gt;
(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #008b45"&gt;fiba&lt;/span&gt; &lt;span style="color: #00688B"&gt;n&lt;/span&gt;)
    (&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #008b45"&gt;fib-iter&lt;/span&gt; &lt;span style="color: #00688B"&gt;a&lt;/span&gt; &lt;span style="color: #00688B"&gt;b&lt;/span&gt; &lt;span style="color: #00688B"&gt;count&lt;/span&gt;)
        (&lt;span style="color: #8B008B; font-weight: bold"&gt;if &lt;/span&gt;(&lt;span style="color: #658b00"&gt;= &lt;/span&gt;&lt;span style="color: #00688B"&gt;count&lt;/span&gt; &lt;span style="color: #B452CD"&gt;0&lt;/span&gt;)
            &lt;span style="color: #00688B"&gt;b&lt;/span&gt;
            (&lt;span style="color: #008b45"&gt;fib-iter&lt;/span&gt; (&lt;span style="color: #658b00"&gt;+ &lt;/span&gt;&lt;span style="color: #00688B"&gt;a&lt;/span&gt; &lt;span style="color: #00688B"&gt;b&lt;/span&gt;) &lt;span style="color: #00688B"&gt;a&lt;/span&gt; (&lt;span style="color: #658b00"&gt;- &lt;/span&gt;&lt;span style="color: #00688B"&gt;count&lt;/span&gt; &lt;span style="color: #B452CD"&gt;1&lt;/span&gt;))))
    (&lt;span style="color: #008b45"&gt;fib-iter&lt;/span&gt; &lt;span style="color: #B452CD"&gt;1&lt;/span&gt; &lt;span style="color: #B452CD"&gt;0&lt;/span&gt; &lt;span style="color: #00688B"&gt;n&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="_9"&gt;高阶抽象和公共模式&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;以下内容中的模块均指函数.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;高阶抽象, 是至少满足下列一个条件的函数:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接受一个或多个函数作为输入&lt;/li&gt;
&lt;li&gt;输出一个函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;公共模式: 提取不同功能中各模块的组合方式, 注意, 这和模块的具体含义无关, 提取的是模块间的 &lt;em&gt;组合方式&lt;/em&gt;. 一般实现公共模式时, 需要用到高阶抽象.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;; 从 a 加到 b&lt;/span&gt;
(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #008b45"&gt;sum-int&lt;/span&gt; &lt;span style="color: #00688B"&gt;a&lt;/span&gt; &lt;span style="color: #00688B"&gt;b&lt;/span&gt;)
    (&lt;span style="color: #008b45"&gt;cond&lt;/span&gt;
        ((&lt;span style="color: #658b00"&gt;&amp;gt; &lt;/span&gt;&lt;span style="color: #00688B"&gt;a&lt;/span&gt; &lt;span style="color: #00688B"&gt;b&lt;/span&gt;) &lt;span style="color: #B452CD"&gt;0&lt;/span&gt;)
        (&lt;span style="color: #8B008B; font-weight: bold"&gt;else &lt;/span&gt;(&lt;span style="color: #658b00"&gt;+ &lt;/span&gt;&lt;span style="color: #00688B"&gt;a&lt;/span&gt; (&lt;span style="color: #008b45"&gt;sum-int&lt;/span&gt; (&lt;span style="color: #B452CD"&gt;1&lt;/span&gt;&lt;span style="color: #00688B"&gt;+&lt;/span&gt; &lt;span style="color: #00688B"&gt;a&lt;/span&gt;) &lt;span style="color: #00688B"&gt;b&lt;/span&gt;)))))

&lt;span style="color: #228B22"&gt;; 从 a 的平方加到 b 的平方&lt;/span&gt;
(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #008b45"&gt;sum-sq&lt;/span&gt; &lt;span style="color: #00688B"&gt;a&lt;/span&gt; &lt;span style="color: #00688B"&gt;b&lt;/span&gt;)
    (&lt;span style="color: #008b45"&gt;cond&lt;/span&gt;
        ((&lt;span style="color: #658b00"&gt;&amp;gt; &lt;/span&gt;&lt;span style="color: #00688B"&gt;a&lt;/span&gt; &lt;span style="color: #00688B"&gt;b&lt;/span&gt;) &lt;span style="color: #B452CD"&gt;0&lt;/span&gt;)
        (&lt;span style="color: #8B008B; font-weight: bold"&gt;else &lt;/span&gt;(&lt;span style="color: #658b00"&gt;+ &lt;/span&gt;(&lt;span style="color: #008b45"&gt;sq&lt;/span&gt; &lt;span style="color: #00688B"&gt;a&lt;/span&gt;) (&lt;span style="color: #008b45"&gt;sum-sq&lt;/span&gt; (&lt;span style="color: #B452CD"&gt;1&lt;/span&gt;&lt;span style="color: #00688B"&gt;+&lt;/span&gt; &lt;span style="color: #00688B"&gt;a&lt;/span&gt;) &lt;span style="color: #00688B"&gt;b&lt;/span&gt;)))))

&lt;span style="color: #228B22"&gt;; 从 a 间隔 2 加到 b&lt;/span&gt;
(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #008b45"&gt;sum-interval&lt;/span&gt; &lt;span style="color: #00688B"&gt;a&lt;/span&gt; &lt;span style="color: #00688B"&gt;b&lt;/span&gt;)
    (&lt;span style="color: #008b45"&gt;cond&lt;/span&gt;
        ((&lt;span style="color: #658b00"&gt;&amp;gt; &lt;/span&gt;&lt;span style="color: #00688B"&gt;a&lt;/span&gt; &lt;span style="color: #00688B"&gt;b&lt;/span&gt;) &lt;span style="color: #B452CD"&gt;0&lt;/span&gt;)
        (&lt;span style="color: #8B008B; font-weight: bold"&gt;else &lt;/span&gt;(&lt;span style="color: #658b00"&gt;+ &lt;/span&gt;&lt;span style="color: #00688B"&gt;a&lt;/span&gt; (&lt;span style="color: #008b45"&gt;sum-interval&lt;/span&gt; (&lt;span style="color: #658b00"&gt;+ &lt;/span&gt;&lt;span style="color: #00688B"&gt;a&lt;/span&gt; &lt;span style="color: #B452CD"&gt;2&lt;/span&gt;) &lt;span style="color: #00688B"&gt;b&lt;/span&gt;)))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从以上过程提取公共模式如下:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #008b45"&gt;&amp;lt;name&amp;gt;&lt;/span&gt; &lt;span style="color: #00688B"&gt;a&lt;/span&gt; &lt;span style="color: #00688B"&gt;b&lt;/span&gt;)
    (&lt;span style="color: #008b45"&gt;cond&lt;/span&gt;
        ((&lt;span style="color: #658b00"&gt;&amp;gt; &lt;/span&gt;&lt;span style="color: #00688B"&gt;a&lt;/span&gt; &lt;span style="color: #00688B"&gt;b&lt;/span&gt;) &lt;span style="color: #B452CD"&gt;0&lt;/span&gt;)
        (&lt;span style="color: #8B008B; font-weight: bold"&gt;else &lt;/span&gt;(&lt;span style="color: #658b00"&gt;+ &lt;/span&gt;(&lt;span style="color: #008b45"&gt;&amp;lt;term&amp;gt;&lt;/span&gt; &lt;span style="color: #00688B"&gt;a&lt;/span&gt;)
                 (&lt;span style="color: #008b45"&gt;&amp;lt;name&amp;gt;&lt;/span&gt; (&lt;span style="color: #008b45"&gt;&amp;lt;next&amp;gt;&lt;/span&gt; &lt;span style="color: #00688B"&gt;a&lt;/span&gt;) &lt;span style="color: #00688B"&gt;b&lt;/span&gt;)))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;开始重构:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;; 高阶抽象, 即公共模式的过程&lt;/span&gt;
(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #008b45"&gt;sum&lt;/span&gt; &lt;span style="color: #00688B"&gt;term&lt;/span&gt; &lt;span style="color: #00688B"&gt;a&lt;/span&gt; &lt;span style="color: #00688B"&gt;next&lt;/span&gt; &lt;span style="color: #00688B"&gt;b&lt;/span&gt;)
    (&lt;span style="color: #008b45"&gt;cond&lt;/span&gt;
        ((&lt;span style="color: #658b00"&gt;&amp;gt; &lt;/span&gt;&lt;span style="color: #00688B"&gt;a&lt;/span&gt; &lt;span style="color: #00688B"&gt;b&lt;/span&gt;) &lt;span style="color: #B452CD"&gt;0&lt;/span&gt;)
        (&lt;span style="color: #8B008B; font-weight: bold"&gt;else &lt;/span&gt;(&lt;span style="color: #658b00"&gt;+ &lt;/span&gt;(&lt;span style="color: #008b45"&gt;term&lt;/span&gt; &lt;span style="color: #00688B"&gt;a&lt;/span&gt;)
                 (&lt;span style="color: #008b45"&gt;sum&lt;/span&gt; &lt;span style="color: #00688B"&gt;term&lt;/span&gt; (&lt;span style="color: #008b45"&gt;next&lt;/span&gt; &lt;span style="color: #00688B"&gt;a&lt;/span&gt;) &lt;span style="color: #00688B"&gt;next&lt;/span&gt; &lt;span style="color: #00688B"&gt;b&lt;/span&gt;)))))

(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #008b45"&gt;sum-int&lt;/span&gt; &lt;span style="color: #00688B"&gt;a&lt;/span&gt; &lt;span style="color: #00688B"&gt;b&lt;/span&gt;)
    (&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #008b45"&gt;term&lt;/span&gt; &lt;span style="color: #00688B"&gt;x&lt;/span&gt;) &lt;span style="color: #00688B"&gt;x&lt;/span&gt;)
    (&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #008b45"&gt;next&lt;/span&gt; &lt;span style="color: #00688B"&gt;x&lt;/span&gt;) (&lt;span style="color: #B452CD"&gt;1&lt;/span&gt;&lt;span style="color: #00688B"&gt;+&lt;/span&gt; &lt;span style="color: #00688B"&gt;x&lt;/span&gt;))
    (&lt;span style="color: #008b45"&gt;sum&lt;/span&gt; &lt;span style="color: #00688B"&gt;term&lt;/span&gt; &lt;span style="color: #00688B"&gt;a&lt;/span&gt; &lt;span style="color: #00688B"&gt;next&lt;/span&gt; &lt;span style="color: #00688B"&gt;b&lt;/span&gt;))

(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #008b45"&gt;sum-sq&lt;/span&gt; &lt;span style="color: #00688B"&gt;a&lt;/span&gt; &lt;span style="color: #00688B"&gt;b&lt;/span&gt;)
    (&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #008b45"&gt;term&lt;/span&gt; &lt;span style="color: #00688B"&gt;x&lt;/span&gt;) (&lt;span style="color: #008b45"&gt;sq&lt;/span&gt; &lt;span style="color: #00688B"&gt;a&lt;/span&gt;))
    (&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #008b45"&gt;next&lt;/span&gt; &lt;span style="color: #00688B"&gt;x&lt;/span&gt;) (&lt;span style="color: #B452CD"&gt;1&lt;/span&gt;&lt;span style="color: #00688B"&gt;+&lt;/span&gt; &lt;span style="color: #00688B"&gt;x&lt;/span&gt;))
    (&lt;span style="color: #008b45"&gt;sum&lt;/span&gt; &lt;span style="color: #00688B"&gt;term&lt;/span&gt; &lt;span style="color: #00688B"&gt;a&lt;/span&gt; &lt;span style="color: #00688B"&gt;next&lt;/span&gt; &lt;span style="color: #00688B"&gt;b&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;高阶抽象有点类似 OOP 的多态/接口, 公共模式则有点像模板方法模式.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以将问题拆分成尽可能多的模块很重要, 并且每一个模块要能够被独立地解释 (如果能够为一段代码块所做的事取一个很好的名字, 那这段代码块就可以抽象出一个新模块, 所以 &lt;strong&gt;关键&lt;/strong&gt; 就在于取名), 这有利于发现公共模式.&lt;/p&gt;
&lt;h1 id="_10"&gt;愿望思维法&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;愿望思维法&lt;/strong&gt; 是一种有效”发现”新模块的实践 (有利于发现 &lt;strong&gt;公共模式&lt;/strong&gt;):&lt;/p&gt;
&lt;p&gt;先用自然语言描述过程, 然后从描述中提取可能的模块, 并假设模块是已经实现好的 (即有完整的函数签名), 然后组合这些模块, 最后再去实现那些愿望.&lt;/p&gt;
&lt;p&gt;例如, 需要实现从一个坐标点走到另一个坐标点的功能, 那么我们可以先假定 &lt;em&gt;坐标点&lt;/em&gt; 的构造函数与选择函数:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;make-point&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x-point&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;y-point&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后就可以实现目标功能 &lt;code&gt;move-point&lt;/code&gt;:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #008b45"&gt;move-point&lt;/span&gt; &lt;span style="color: #00688B"&gt;p1&lt;/span&gt; &lt;span style="color: #00688B"&gt;p2&lt;/span&gt;)
    (&lt;span style="color: #008b45"&gt;make-point&lt;/span&gt; (&lt;span style="color: #658b00"&gt;+ &lt;/span&gt;(&lt;span style="color: #008b45"&gt;x-point&lt;/span&gt; &lt;span style="color: #00688B"&gt;p1&lt;/span&gt;) (&lt;span style="color: #008b45"&gt;x-point&lt;/span&gt; &lt;span style="color: #00688B"&gt;p2&lt;/span&gt;))
                (&lt;span style="color: #658b00"&gt;+ &lt;/span&gt;(&lt;span style="color: #008b45"&gt;y-point&lt;/span&gt; &lt;span style="color: #00688B"&gt;p1&lt;/span&gt;) (&lt;span style="color: #008b45"&gt;y-point&lt;/span&gt; &lt;span style="color: #00688B"&gt;p2&lt;/span&gt;))))

(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;&lt;span style="color: #00688B"&gt;p1&lt;/span&gt; (&lt;span style="color: #008b45"&gt;make-point&lt;/span&gt; &lt;span style="color: #B452CD"&gt;1&lt;/span&gt; &lt;span style="color: #B452CD"&gt;2&lt;/span&gt;))
(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;&lt;span style="color: #00688B"&gt;p2&lt;/span&gt; (&lt;span style="color: #008b45"&gt;make-point&lt;/span&gt; &lt;span style="color: #B452CD"&gt;3&lt;/span&gt; &lt;span style="color: #B452CD"&gt;4&lt;/span&gt;))
(&lt;span style="color: #008b45"&gt;move-point&lt;/span&gt; &lt;span style="color: #00688B"&gt;p1&lt;/span&gt; &lt;span style="color: #00688B"&gt;p2&lt;/span&gt;) &lt;span style="color: #228B22"&gt;; =&amp;gt; 4, 6&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后, 我们去实现 &lt;em&gt;坐标点&lt;/em&gt; 的函数:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #008b45"&gt;make-point&lt;/span&gt; &lt;span style="color: #00688B"&gt;x&lt;/span&gt; &lt;span style="color: #00688B"&gt;y&lt;/span&gt;)
    (&lt;span style="color: #658b00"&gt;cons &lt;/span&gt;&lt;span style="color: #00688B"&gt;x&lt;/span&gt; &lt;span style="color: #00688B"&gt;y&lt;/span&gt;))

(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #008b45"&gt;x-point&lt;/span&gt; &lt;span style="color: #00688B"&gt;p&lt;/span&gt;)
    (&lt;span style="color: #658b00"&gt;car &lt;/span&gt;&lt;span style="color: #00688B"&gt;p&lt;/span&gt;))

(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #008b45"&gt;y-point&lt;/span&gt; &lt;span style="color: #00688B"&gt;p&lt;/span&gt;)
    (&lt;span style="color: #658b00"&gt;cdr &lt;/span&gt;&lt;span style="color: #00688B"&gt;p&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="map"&gt;MAP&lt;/h1&gt;
&lt;p&gt;一些语言中会提供 &lt;code&gt;map&lt;/code&gt; 操作, 例如 Python, &lt;code&gt;map&lt;/code&gt; 接收一个函数 f 和一个 list, 并通过把函数 f 依次作用在 list 的每个元素上, 得到一个新的 list 并返回.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;map&lt;/code&gt; 其实只是一个 &lt;strong&gt;公共模式&lt;/strong&gt;. 例如现要把一个 1 到 10 的 list 放大 10 倍和缩小 5 倍, 那么在没有 &lt;code&gt;map&lt;/code&gt; 之前, 就会写出两个函数:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;&lt;span style="color: #B452CD"&gt;1&lt;/span&gt;&lt;span style="color: #00688B"&gt;-to-10&lt;/span&gt; (&lt;span style="color: #658b00"&gt;list &lt;/span&gt;&lt;span style="color: #B452CD"&gt;0&lt;/span&gt; &lt;span style="color: #B452CD"&gt;1&lt;/span&gt; &lt;span style="color: #B452CD"&gt;2&lt;/span&gt; &lt;span style="color: #B452CD"&gt;3&lt;/span&gt; &lt;span style="color: #B452CD"&gt;4&lt;/span&gt; &lt;span style="color: #B452CD"&gt;5&lt;/span&gt; &lt;span style="color: #B452CD"&gt;6&lt;/span&gt; &lt;span style="color: #B452CD"&gt;7&lt;/span&gt; &lt;span style="color: #B452CD"&gt;8&lt;/span&gt; &lt;span style="color: #B452CD"&gt;9&lt;/span&gt;))

&lt;span style="color: #228B22"&gt;; 放大&lt;/span&gt;
(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #008b45"&gt;magnify&lt;/span&gt; &lt;span style="color: #00688B"&gt;l&lt;/span&gt;)
    (&lt;span style="color: #8B008B; font-weight: bold"&gt;if &lt;/span&gt;(&lt;span style="color: #658b00"&gt;null? &lt;/span&gt;&lt;span style="color: #00688B"&gt;l&lt;/span&gt;)
        ()
        (&lt;span style="color: #658b00"&gt;cons &lt;/span&gt;(&lt;span style="color: #658b00"&gt;* &lt;/span&gt;(&lt;span style="color: #658b00"&gt;car &lt;/span&gt;&lt;span style="color: #00688B"&gt;l&lt;/span&gt;) &lt;span style="color: #B452CD"&gt;10&lt;/span&gt;)
              (&lt;span style="color: #008b45"&gt;magnify&lt;/span&gt; (&lt;span style="color: #658b00"&gt;cdr &lt;/span&gt;&lt;span style="color: #00688B"&gt;l&lt;/span&gt;)))))

&lt;span style="color: #228B22"&gt;; 缩小&lt;/span&gt;
(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #008b45"&gt;shrink&lt;/span&gt; &lt;span style="color: #00688B"&gt;l&lt;/span&gt;)
    (&lt;span style="color: #8B008B; font-weight: bold"&gt;if &lt;/span&gt;(&lt;span style="color: #658b00"&gt;null? &lt;/span&gt;&lt;span style="color: #00688B"&gt;l&lt;/span&gt;)
        ()
        (&lt;span style="color: #658b00"&gt;cons &lt;/span&gt;(&lt;span style="color: #658b00"&gt;/ &lt;/span&gt;(&lt;span style="color: #658b00"&gt;car &lt;/span&gt;&lt;span style="color: #00688B"&gt;l&lt;/span&gt;) &lt;span style="color: #B452CD"&gt;5&lt;/span&gt;)
              (&lt;span style="color: #008b45"&gt;shrink&lt;/span&gt; (&lt;span style="color: #658b00"&gt;cdr &lt;/span&gt;&lt;span style="color: #00688B"&gt;l&lt;/span&gt;)))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很快就可以提取出公共模式:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #008b45"&gt;&amp;lt;name&amp;gt;&lt;/span&gt; &lt;span style="color: #00688B"&gt;l&lt;/span&gt;)
    (&lt;span style="color: #8B008B; font-weight: bold"&gt;if &lt;/span&gt;(&lt;span style="color: #658b00"&gt;null? &lt;/span&gt;&lt;span style="color: #00688B"&gt;l&lt;/span&gt;)
        ()
        (&lt;span style="color: #658b00"&gt;cons &lt;/span&gt;(&lt;span style="color: #008b45"&gt;&amp;lt;operator&amp;gt;&lt;/span&gt; (&lt;span style="color: #658b00"&gt;car &lt;/span&gt;&lt;span style="color: #00688B"&gt;l&lt;/span&gt;))
              (&lt;span style="color: #008b45"&gt;&amp;lt;name&amp;gt;&lt;/span&gt; (&lt;span style="color: #658b00"&gt;cdr &lt;/span&gt;&lt;span style="color: #00688B"&gt;l&lt;/span&gt;)))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后重构出来的高阶抽象就是 &lt;code&gt;map&lt;/code&gt;:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;; 递归版本&lt;/span&gt;
(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #658b00"&gt;map &lt;/span&gt;&lt;span style="color: #00688B"&gt;p&lt;/span&gt; &lt;span style="color: #00688B"&gt;l&lt;/span&gt;)
    (&lt;span style="color: #8B008B; font-weight: bold"&gt;if &lt;/span&gt;(&lt;span style="color: #658b00"&gt;null? &lt;/span&gt;&lt;span style="color: #00688B"&gt;l&lt;/span&gt;)
        ()
        (&lt;span style="color: #658b00"&gt;cons &lt;/span&gt;(&lt;span style="color: #008b45"&gt;p&lt;/span&gt; (&lt;span style="color: #658b00"&gt;car &lt;/span&gt;&lt;span style="color: #00688B"&gt;l&lt;/span&gt;))
              (&lt;span style="color: #658b00"&gt;map &lt;/span&gt;&lt;span style="color: #00688B"&gt;p&lt;/span&gt; (&lt;span style="color: #658b00"&gt;cdr &lt;/span&gt;&lt;span style="color: #00688B"&gt;l&lt;/span&gt;)))))

&lt;span style="color: #228B22"&gt;; 迭代(尾递归)版本&lt;/span&gt;
(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #658b00"&gt;map &lt;/span&gt;&lt;span style="color: #00688B"&gt;p&lt;/span&gt; &lt;span style="color: #00688B"&gt;l&lt;/span&gt;)
    (&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #008b45"&gt;map-iter&lt;/span&gt; &lt;span style="color: #00688B"&gt;remain&lt;/span&gt; &lt;span style="color: #00688B"&gt;result&lt;/span&gt;)
        (&lt;span style="color: #8B008B; font-weight: bold"&gt;if &lt;/span&gt;(&lt;span style="color: #658b00"&gt;null? &lt;/span&gt;&lt;span style="color: #00688B"&gt;remain&lt;/span&gt;)
            &lt;span style="color: #00688B"&gt;result&lt;/span&gt;
            (&lt;span style="color: #008b45"&gt;map-iter&lt;/span&gt; (&lt;span style="color: #658b00"&gt;cdr &lt;/span&gt;&lt;span style="color: #00688B"&gt;remain&lt;/span&gt;)
                      (&lt;span style="color: #658b00"&gt;cons &lt;/span&gt;(&lt;span style="color: #008b45"&gt;p&lt;/span&gt; (&lt;span style="color: #658b00"&gt;car &lt;/span&gt;&lt;span style="color: #00688B"&gt;remain&lt;/span&gt;))
                            &lt;span style="color: #00688B"&gt;result&lt;/span&gt;))))
    (&lt;span style="color: #008b45"&gt;map-iter&lt;/span&gt; &lt;span style="color: #00688B"&gt;l&lt;/span&gt; ()))

&lt;span style="color: #228B22"&gt;; 使用 map 重构&lt;/span&gt;
(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #008b45"&gt;magnify&lt;/span&gt; &lt;span style="color: #00688B"&gt;l&lt;/span&gt;)
    (&lt;span style="color: #658b00"&gt;map &lt;/span&gt;(&lt;span style="color: #8B008B; font-weight: bold"&gt;lambda &lt;/span&gt;(&lt;span style="color: #008b45"&gt;x&lt;/span&gt;) (&lt;span style="color: #658b00"&gt;* &lt;/span&gt;&lt;span style="color: #00688B"&gt;x&lt;/span&gt; &lt;span style="color: #B452CD"&gt;10&lt;/span&gt;)) &lt;span style="color: #00688B"&gt;l&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;迭代(尾递归)版本的 &lt;code&gt;map&lt;/code&gt; 实现有个问题, 返回的新列表是倒置的, 所以需要再反转一下. 原因是因为 &lt;code&gt;cons&lt;/code&gt; 连接元素时, 子 &lt;code&gt;cons&lt;/code&gt; 必须位于第二个参数, 这样才会优化成 &lt;code&gt;list&lt;/code&gt;, 否则就会成为 &lt;code&gt;(((((0 . 10) . 20) . 30) . 40) . 50)&lt;/code&gt; 这样的结构.&lt;/p&gt;
&lt;h1 id="for-each"&gt;For-Each&lt;/h1&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #658b00"&gt;for-each &lt;/span&gt;&lt;span style="color: #00688B"&gt;p&lt;/span&gt; &lt;span style="color: #00688B"&gt;list&lt;/span&gt;)
    (&lt;span style="color: #8B008B; font-weight: bold"&gt;cond &lt;/span&gt;((&lt;span style="color: #658b00"&gt;null? &lt;/span&gt;&lt;span style="color: #00688B"&gt;list&lt;/span&gt;) &lt;span style="color: #00688B"&gt;*done*&lt;/span&gt;)
          (&lt;span style="color: #8B008B; font-weight: bold"&gt;else &lt;/span&gt;(&lt;span style="color: #008b45"&gt;p&lt;/span&gt; (&lt;span style="color: #658b00"&gt;car &lt;/span&gt;&lt;span style="color: #00688B"&gt;list&lt;/span&gt;)
                (&lt;span style="color: #658b00"&gt;for-each &lt;/span&gt;&lt;span style="color: #00688B"&gt;p&lt;/span&gt; (&lt;span style="color: #658b00"&gt;cdr &lt;/span&gt;&lt;span style="color: #00688B"&gt;list&lt;/span&gt;))))))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在网络上, 一些说法将 map, reduce, filter, for-each 等高阶函数做为函数式语言的标准之一, 本人并不认同, 因为只要语言支持高阶抽象 (函数是第一等公民) 就能自己实现出那些高阶函数.&lt;/p&gt;
&lt;h1 id="_11"&gt;数据抽象&lt;/h1&gt;
&lt;p&gt;在函数式思想中, 没有类的概念, 建立数据抽象是利用 &lt;strong&gt;高阶抽象&lt;/strong&gt; 以及 &lt;strong&gt;闭包&lt;/strong&gt;. 例如我们可以自己实现 &lt;code&gt;序对&lt;/code&gt;:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;; 序对的构造函数&lt;/span&gt;
(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #658b00"&gt;cons &lt;/span&gt;&lt;span style="color: #00688B"&gt;a&lt;/span&gt; &lt;span style="color: #00688B"&gt;b&lt;/span&gt;)
    (&lt;span style="color: #8B008B; font-weight: bold"&gt;lambda &lt;/span&gt;(&lt;span style="color: #008b45"&gt;pick&lt;/span&gt;)
        (&lt;span style="color: #8B008B; font-weight: bold"&gt;cond &lt;/span&gt;((&lt;span style="color: #658b00"&gt;= &lt;/span&gt;&lt;span style="color: #00688B"&gt;pick&lt;/span&gt; &lt;span style="color: #B452CD"&gt;1&lt;/span&gt;) &lt;span style="color: #00688B"&gt;a&lt;/span&gt;)
              ((&lt;span style="color: #658b00"&gt;= &lt;/span&gt;&lt;span style="color: #00688B"&gt;pick&lt;/span&gt; &lt;span style="color: #B452CD"&gt;2&lt;/span&gt;) &lt;span style="color: #00688B"&gt;b&lt;/span&gt;))))

&lt;span style="color: #228B22"&gt;; 序对的选择函数&lt;/span&gt;
(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #658b00"&gt;car &lt;/span&gt;&lt;span style="color: #00688B"&gt;x&lt;/span&gt;) (&lt;span style="color: #008b45"&gt;x&lt;/span&gt; &lt;span style="color: #B452CD"&gt;1&lt;/span&gt;))

&lt;span style="color: #228B22"&gt;; 序对的选择函数&lt;/span&gt;
(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #658b00"&gt;cdr &lt;/span&gt;&lt;span style="color: #00688B"&gt;x&lt;/span&gt;) (&lt;span style="color: #008b45"&gt;x&lt;/span&gt; &lt;span style="color: #B452CD"&gt;2&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这也是一种将数据的使用 (例如构造函数与选择函数) 与表示分隔开的 &lt;strong&gt;编程方法学&lt;/strong&gt;: 当我们使用 &lt;code&gt;序对&lt;/code&gt; 时, 其实只是在使用一些函数, 但在”外部”表现上, 它是一种叫 &lt;code&gt;序对&lt;/code&gt; 的数据结构. 即当我们使用 &lt;code&gt;序对&lt;/code&gt; 时, 并不知道它的底层表示, 我们只是定义了 &lt;code&gt;序对&lt;/code&gt; 的 &lt;em&gt;数据公理&lt;/em&gt; (即 cons car cdr), 然后使用这些公理. 这种数据抽象的能力让函数与数据的边界变得越来越模糊.&lt;/p&gt;
&lt;h1 id="_12"&gt;对象状态&lt;/h1&gt;
&lt;p&gt;在构建大型系统时, 将其看成是由一批相互作用的对象组成是一种有用的策略 (另一种策略是流, 即把系统看作一种信号处理系统). 我们已经有了 &lt;strong&gt;数据抽象&lt;/strong&gt; 去进行映射, 但真实系统中的对象会随着时间的流逝不断变化, 而映射它们的软件对象也要适应相应地变化, 因此就需要某种方式来维护对象的状态, 这是一种新的计算模型:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #008b45"&gt;MAKE-COUNTER&lt;/span&gt; &lt;span style="color: #00688B"&gt;x&lt;/span&gt;)
    (&lt;span style="color: #8B008B; font-weight: bold"&gt;lambda &lt;/span&gt;()
        &lt;span style="color: #00688B"&gt;x&lt;/span&gt;
        (&lt;span style="color: #8B008B; font-weight: bold"&gt;set! &lt;/span&gt;&lt;span style="color: #00688B"&gt;x&lt;/span&gt; (&lt;span style="color: #B452CD"&gt;1&lt;/span&gt;&lt;span style="color: #00688B"&gt;+&lt;/span&gt; &lt;span style="color: #00688B"&gt;x&lt;/span&gt;))))

(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;&lt;span style="color: #00688B"&gt;c&lt;/span&gt; (&lt;span style="color: #008b45"&gt;MAKE-COUNTER&lt;/span&gt; &lt;span style="color: #B452CD"&gt;0&lt;/span&gt;)) &lt;span style="color: #228B22"&gt;; c 是从 0 开始的计数器&lt;/span&gt;

(&lt;span style="color: #008b45"&gt;c&lt;/span&gt;) &lt;span style="color: #228B22"&gt;; =&amp;gt; 1&lt;/span&gt;
(&lt;span style="color: #008b45"&gt;c&lt;/span&gt;) &lt;span style="color: #228B22"&gt;; =&amp;gt; 2&lt;/span&gt;
(&lt;span style="color: #008b45"&gt;c&lt;/span&gt;) &lt;span style="color: #228B22"&gt;; =&amp;gt; 3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数 &lt;code&gt;MAKE-COUNTER&lt;/code&gt; 返回了另一个函数, 构建出了一个 &lt;strong&gt;闭包&lt;/strong&gt; 环境, 即返回的函数可以访问 &lt;code&gt;MAKE-COUNTER&lt;/code&gt; 的作用域.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;引入状态的对象具有副作用, 特别是在并发程序中问题会更严重.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id="_13"&gt;面向对象&lt;/h1&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #008b45"&gt;make-account&lt;/span&gt; &lt;span style="color: #00688B"&gt;balance&lt;/span&gt;)

    (&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #008b45"&gt;withdraw&lt;/span&gt; &lt;span style="color: #00688B"&gt;amount&lt;/span&gt;)
        (&lt;span style="color: #8B008B; font-weight: bold"&gt;if &lt;/span&gt;(&lt;span style="color: #658b00"&gt;&amp;gt;= &lt;/span&gt;&lt;span style="color: #00688B"&gt;balance&lt;/span&gt; &lt;span style="color: #00688B"&gt;amount&lt;/span&gt;)
            (&lt;span style="color: #8B008B; font-weight: bold"&gt;begin &lt;/span&gt;(&lt;span style="color: #8B008B; font-weight: bold"&gt;set! &lt;/span&gt;&lt;span style="color: #00688B"&gt;balance&lt;/span&gt; (&lt;span style="color: #658b00"&gt;- &lt;/span&gt;&lt;span style="color: #00688B"&gt;balance&lt;/span&gt; &lt;span style="color: #00688B"&gt;amount&lt;/span&gt;))
                &lt;span style="color: #00688B"&gt;balance&lt;/span&gt;)
            &lt;span style="color: #CD5555"&gt;"Insufficient funds"&lt;/span&gt;))

    (&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #008b45"&gt;deposit&lt;/span&gt; &lt;span style="color: #00688B"&gt;amount&lt;/span&gt;)
        (&lt;span style="color: #8B008B; font-weight: bold"&gt;set! &lt;/span&gt;&lt;span style="color: #00688B"&gt;balance&lt;/span&gt; (&lt;span style="color: #658b00"&gt;+ &lt;/span&gt;&lt;span style="color: #00688B"&gt;balance&lt;/span&gt; &lt;span style="color: #00688B"&gt;amount&lt;/span&gt;))
            &lt;span style="color: #00688B"&gt;balance&lt;/span&gt;)

    (&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;(&lt;span style="color: #008b45"&gt;dispatch&lt;/span&gt; &lt;span style="color: #00688B"&gt;m&lt;/span&gt;)
        (&lt;span style="color: #8B008B; font-weight: bold"&gt;cond &lt;/span&gt;((&lt;span style="color: #658b00"&gt;eq? &lt;/span&gt;&lt;span style="color: #00688B"&gt;m&lt;/span&gt; &lt;span style="color: #CD5555"&gt;'withdraw&lt;/span&gt;) &lt;span style="color: #00688B"&gt;withdraw&lt;/span&gt;)
            ((&lt;span style="color: #658b00"&gt;eq? &lt;/span&gt;&lt;span style="color: #00688B"&gt;m&lt;/span&gt; &lt;span style="color: #CD5555"&gt;'deposit&lt;/span&gt;) &lt;span style="color: #00688B"&gt;deposit&lt;/span&gt;)
            (&lt;span style="color: #8B008B; font-weight: bold"&gt;else &lt;/span&gt;(&lt;span style="color: #008b45"&gt;error&lt;/span&gt; &lt;span style="color: #CD5555"&gt;"Unknown request -- MAKE-ACCOUNT"&lt;/span&gt;
                &lt;span style="color: #00688B"&gt;m&lt;/span&gt;))))

    &lt;span style="color: #00688B"&gt;dispatch&lt;/span&gt;)

(&lt;span style="color: #8B008B; font-weight: bold"&gt;define &lt;/span&gt;&lt;span style="color: #00688B"&gt;A1&lt;/span&gt; (&lt;span style="color: #008b45"&gt;make-account&lt;/span&gt; &lt;span style="color: #B452CD"&gt;100&lt;/span&gt;)) &lt;span style="color: #228B22"&gt;; 生成一个初始有 10 0元、名为 A1 的银行账户&lt;/span&gt;

((&lt;span style="color: #008b45"&gt;A1&lt;/span&gt; &lt;span style="color: #CD5555"&gt;'withdraw&lt;/span&gt;) &lt;span style="color: #B452CD"&gt;20&lt;/span&gt;) &lt;span style="color: #228B22"&gt;; =&amp;gt; 80&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</content><category term="函数式"></category></entry><entry><title>UML和模式应用</title><link href="http://www.smallcpp.cn/umlhe-mo-shi-ying-yong.html" rel="alternate"></link><published>2018-05-05T18:09:00+08:00</published><updated>2018-05-05T18:09:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2018-05-05:/umlhe-mo-shi-ying-yong.html</id><summary type="html">
&lt;h1 id="aup-agile-unified-process"&gt;AUP: Agile Unified Process&lt;/h1&gt;
&lt;p&gt;敏捷统一过程, 轻量级的 RUP.&lt;/p&gt;
&lt;p&gt;本书通过两个案例 &amp;lt;NextGen POS&amp;gt; 和 &amp;lt;MonopolyGame&amp;gt; 将 AUP 贯穿起来. 从 OOA/D 的概念到系统架构中模式的应用, 一层一层的展开, 介绍了如何从最初的软件需求, 结合 UML 帮助软件开发、设计人员更好地进行领域模型的表达和建立, 以及随着迭代的进行, 逐步细化设计, 最终完成一个有弹性、易维护、可扩展 …&lt;/p&gt;</summary><content type="html">
&lt;h1 id="aup-agile-unified-process"&gt;AUP: Agile Unified Process&lt;/h1&gt;
&lt;p&gt;敏捷统一过程, 轻量级的 RUP.&lt;/p&gt;
&lt;p&gt;本书通过两个案例 &amp;lt;NextGen POS&amp;gt; 和 &amp;lt;MonopolyGame&amp;gt; 将 AUP 贯穿起来. 从 OOA/D 的概念到系统架构中模式的应用, 一层一层的展开, 介绍了如何从最初的软件需求, 结合 UML 帮助软件开发、设计人员更好地进行领域模型的表达和建立, 以及随着迭代的进行, 逐步细化设计, 最终完成一个有弹性、易维护、可扩展、封装变化的软件系统.&lt;/p&gt;
&lt;p&gt;这么多内容导致的结果就是都不够深入, 但也起到一个非常好的知识点梳理作用.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/UML和模式应用/AUP.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/UML和模式应用/迭代.png"/&gt;&lt;/p&gt;
&lt;p&gt;注意: 所有制品都是可选的. 我们应遵循敏捷建模的原则, 只对具有创造性、最困难的部分进行建模, 其目的是为理解和沟通, 而不是文档本身.&lt;/p&gt;
&lt;p&gt;OOD 阶段的主要输入/输出我总结如下:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/UML和模式应用/制品.png"/&gt;&lt;/p&gt;
&lt;p&gt;因为是迭代式开发, 所以 OOA 虽然是 OOD 的输入, 但是反过来, OOD 也会促进 OOA 更加成熟. 这是个螺旋式增量精化的过程.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;系统顺序图&lt;/strong&gt;描述了&lt;strong&gt;详述用例文本&lt;/strong&gt;中用户对软件系统的入口操作 (称之为系统操作), 通常由控制器接收这些操作 (控制器是 GRASP 中的一种模式, 后面介绍 GRASP 时再详述, 这里把系统当成一个整体就行了, 系统操作描述的就是用户如何使用系统.)&lt;/p&gt;
&lt;p&gt;OOD 阶段的关键目标就是&lt;strong&gt;用例实现&lt;/strong&gt;: 描述某个用例基于协作对象如何在设计模型中实现, 通常用&lt;strong&gt;交互图&lt;/strong&gt;来描述; 用例实现通常以场景为单位, 因此也称为场景实现.(P233)&lt;/p&gt;
&lt;p&gt;我的理解就是 OOD 所做的大部分工作就是为了实现用例中的场景. 为什么只是大部分? 因为还有部分工作是为了实现&lt;strong&gt;补充性规格说明&lt;/strong&gt;中的非功能性需求.&lt;/p&gt;
&lt;p&gt;因为软件世界是对现实世界的抽象, 所以&lt;strong&gt;领域模型&lt;/strong&gt;指出了需要设计的软件对象, 根据低表示差异, 领域模型通常能启发软件对象的名称及其属性.&lt;/p&gt;
&lt;p&gt;反过来, 设计工作中通常也可能会发现一些在早期领域分析中遗漏的”新”概念, 如果这些”新”概念是有价值的, 会在将来被作为后续设计工作的输入 (通常都是这种情况), 那么应该更新我们的领域模型.&lt;/p&gt;
&lt;p&gt;设计工作还会虚构出一些软件类, 这些软件类的名称的目的可能会与领域模型完全无关 (通常是为了实践 GRASP 的纯虚构及间接性, 后面再具体详述).&lt;/p&gt;
&lt;h1 id="grasp"&gt;GRASP&lt;/h1&gt;
&lt;p&gt;GRASP 定义了 9 个基本的 OO 设计原则/模式, 根据我的理解, 将他们划分成两大类: 应用性模式 和 指导性原则. 如下图所示.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/UML和模式应用/GRASP.png"/&gt;&lt;/p&gt;
&lt;p&gt;应用性模式包含了 6 种软件设计的职责分配方案, 而 3 种指导性原则是对方案的评估.&lt;/p&gt;
&lt;p&gt;另外要阐明一点, 耦合本身并不是问题, 有问题的是对不稳定因素之间的高耦合 (P217,466), 所谓不稳定因素包含: 变化点 和 进化点 (P314).&lt;/p&gt;
&lt;p&gt;通常, 变化点可以在用例详细分析时产生的架构因素中识别出来, 如 POS 系统需要支持多个第三个税金计算器接口、系统需要在数据库不可用时访问本地缓存等;&lt;/p&gt;
&lt;p&gt;而进化点则没那么好分析, 过度的进行远景/未来验证, 这种精力花费并不值得, 我所采用的做法是设计时假定进化不存在, 而当变化真正到来时, 通过重构去完善我的设计, 本书也表明, 对进化点的预防性工程成本要高于对简单设计重做的成本 (P314).&lt;/p&gt;
&lt;h2 id="_1"&gt;低耦合&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;what?&lt;/strong&gt;&lt;br/&gt;
元素与其它元素之间的连接、感知及依赖程序的度量.&lt;/p&gt;
&lt;p&gt;耦合本身并不是问题, 有问题的是对不稳定元素进行耦合, 没有绝对的度量标准来衡量耦合程度的高低, 重要的是估测当前耦合程度, 并估计增加耦合是否会导致问题.&lt;/p&gt;
&lt;p&gt;另一种极端情况就是耦合过低, 或者压根就没有耦合, 要知道, 系统是由相互连接的对象构成, 对象之间通过消息通信;&lt;/p&gt;
&lt;p&gt;如果一个类的耦合过低, 那么说明这个类单独完成了所有职责, 那么就要考虑这些职责是不是相关联的, 也就是高内聚. (这个问题真的见到很多人犯. 定一个超大的类, 然后把所有的职责都给它来完成…)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;why?&lt;/strong&gt;&lt;br/&gt;
当两个元素耦合, 一个发生变化, 则另一个也会受到影响.&lt;/p&gt;
&lt;p&gt;因此, 构建软件最重要的目标之一就是如何降低依赖性, 减少变化带来的影响, 提高重用性.&lt;/p&gt;
&lt;p&gt;较低的耦合往往能够减少修改软件所需的时间、工作量和缺陷.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高耦合的问题:&lt;/strong&gt;&lt;br/&gt;
高耦合会依赖于其它许多类, 当其中任一发生变化, 本体也就可能发生变化&lt;/p&gt;
&lt;p&gt;单独地看本体会难以理解, 需要连带依赖的类一起看&lt;/p&gt;
&lt;p&gt;还是因为过度依赖其它类, 导致本体很难重用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;how?&lt;/strong&gt;&lt;br/&gt;
创建者、信息专家、多态性、间接性、纯虚构, 这些模式指导我们做出支持低耦合的选择.&lt;/p&gt;
&lt;h2 id="_2"&gt;高内聚&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;what?&lt;/strong&gt;&lt;br/&gt;
度量软件元素操作在功能上的相关程度, 也用于度量软件元素完成的工作量.&lt;/p&gt;
&lt;p&gt;根据经验, 高内聚的类的方法数目较少、功能性有较强的关联, 而且不需要做太多的工作.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;why?&lt;/strong&gt;&lt;br/&gt;
不良的内聚 (低内聚) 对象包含众多不同的职责领域, 不仅意味着对象仅依靠本身工作, 而且任何依赖这个低内聚对象的其它对象还会趋于产生不良耦合 (高耦合). 为什么呢? 因为低内聚对象将其它对象的职责”抢”过来了, 那么本来其它对象能自己完成的职责就需要跟这个低内聚对象进行耦合才能完成…所以不良内聚和不良耦合通常是相关的.&lt;/p&gt;
&lt;p&gt;因此, 高内聚保持对象是有重点的、可理解的、可管理的, 并且能够支持低耦合.&lt;/p&gt;
&lt;p&gt;高内聚不止适用在类上, 还适用在方法上, 每个方法应该有其清晰和单独的目标, 并将一组相关的方法置于一个类中, 如果一个方法有超出一个以上的动机而被迫修改, 就靠仔细考虑考虑了.&lt;/p&gt;
&lt;p&gt;一个方法应该只做一件事, 应该短小 、短小、再短小, 更准确地说是每个方法应该是只做抽象概念上的一件事, 而只做一件事的方法是无法把逻辑分段的.&lt;/p&gt;
&lt;p&gt;要确保方法只做一件事,  方法中的语句就要在同一抽象层级上. 不同的抽象层级是有个自上而下的逻辑关系的, 即”then”的关系, 也就是说, 需要在每个函数后面跟着下一抽象层级的函数:
方法 A: (为了做 A 我需要先做 B) 调用 方法 B
方法 B: (为了做 B 我要先做 C, D) 调用方法 C, 方法 D&lt;/p&gt;
&lt;p&gt;例如有 else 或者 case 判断, 那么可能会有问题, 因为它们不是 then 关系, 而且违反开放关闭原则.&lt;/p&gt;
&lt;p&gt;如下是一个重构的例子:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/UML和模式应用/高内聚.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;低内聚的问题:&lt;/strong&gt;&lt;br/&gt;
- 难以理解
- 难以复用
- 难以维护
- 易受变化影响&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;how?&lt;/strong&gt;&lt;br/&gt;
信息专家、纯虚构, 这些模式指导我们做出支持高内聚的选择.&lt;/p&gt;
&lt;p&gt;因此可以用一个简单的方法来衡量: &lt;strong&gt;如果一个类的属性被类中的每个方法所使用, 则该类具有最大内聚性&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;高内聚对应的就是单一职责原则, 这是最简单同时也是最难做到的原则~ 说法很简单: 如果能想到多于一个的动机去改变一个类, 那么这个类就具有多于一个职责, 就应该考虑类的职责分离. 但其实要做到真正的职责单一是件很难的事 (信息专家可以一定程序的保证这点).&lt;/p&gt;
&lt;h2 id="_3"&gt;防止变异&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;what?&lt;/strong&gt;&lt;br/&gt;
如何设计对象、子系统和系统, 使其内部的变化或不稳定性不会对其它元素产生不良影响.&lt;/p&gt;
&lt;p&gt;防止变异其实是个更底层、更通用、更基本的原则. 几乎所有的模式/原则都是防止变异的特例.&lt;/p&gt;
&lt;p&gt;如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/UML和模式应用/防止变异.png"/&gt;&lt;/p&gt;
&lt;p&gt;除了基于上面这些 GRASP 模式/原则外, &lt;strong&gt;GOF&lt;/strong&gt; 中提到的里氏替换原则及迪米特法则也是防止变异有效手段.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;里氏替换&lt;/strong&gt;是个种很简单的思想, 用来指导我们接口/父类的设计, 这种思想指出, 针对父类/接口类型的引用 T, 传递任何一个 T 的实现/子类引用 S, 程序都应该”按照预期”进行工作.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;迪米特法则&lt;/strong&gt; (LOD: law of demeter), 又叫得墨忒耳律, 也叫最小知识原则, 还有一个更简单的定义: 只与直接的朋友通信 (不要和陌生人说话).&lt;/p&gt;
&lt;p&gt;对于一个对象, 其直接朋友包括以下几类:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以参数形式传入到当前对象方法中的对象&lt;/li&gt;
&lt;li&gt;当前对象的成员对象&lt;/li&gt;
&lt;li&gt;如果当前对象的成员对象是一个集合, 那么集合中的元素也都是朋友&lt;/li&gt;
&lt;li&gt;当前对象方法的返回值&lt;/li&gt;
&lt;li&gt;当前对象创建出来的对象 (注意, 从当前对象的朋友那获取到的对象不是直接朋友)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;非以上 5 类的对象最好不要作为局部变量的形式出现在当前对象的内部.&lt;/p&gt;
&lt;p&gt;PS, Clean Code 6.4 章指出, 这里的对象都指的是有行为职责的类, 那些只有属性 (可以有 getter 方法) 的类应该被当作 “数据结构” 来看待, 而不是类. “数据结构” 是不需要遵守 Lod 的, 因为对数据结构而言, 没有行为就没有通信 (getter 方法不能算行为).&lt;/p&gt;
&lt;p&gt;Lod 还有个前提原则: 如果一个方法放在本类中, 即不增加类间的关系, 也对本类不产生负面影响就放在本类中.&lt;/p&gt;
&lt;p&gt;如以下例子:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/UML和模式应用/LOD.png"/&gt;&lt;/p&gt;
&lt;p&gt;打叉的语句依赖于实际中 Sale 对象与 Payment 对象的连接, 这种设计是不稳定的, 因为你不能保证 Sale 对象与 Payment 对象的连接长期有效. 而且这种设计让 Register 与 Payment 耦合.&lt;/p&gt;
&lt;p&gt;该例只是遍历了一层路径, 通常程序遍历的路径越长, 也就越脆弱.&lt;/p&gt;
&lt;p&gt;要遵循这一原则, 上述代码就需要在直接朋友 (Sale) 中添加新的职责, 让它来获取 Payment 提供的信息, 并且对 Register 隐藏了 Payment 的细节:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;Money amount = slae.&lt;span style="color: #658b00"&gt;getThenderedAmountOfPayment&lt;/span&gt;()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;
有一点很重要, 并不总是需要对此进行设计, 应该只对&lt;strong&gt;易变&lt;/strong&gt;或&lt;strong&gt;不稳定&lt;/strong&gt;的元素进行设计, 过度的设计会让系统变得很零碎, 反而不易理解和维护, 如果我们把精力放到”远景/未来验证”或没有实际理由的设计上, 这种精力花费并不得当.&lt;/p&gt;
&lt;p&gt;这就涉及到设计中的两个变更点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变化点: 现有、当前系统或需要中的变化, 例如系统必须支持多个税金计算器接口.&lt;/li&gt;
&lt;li&gt;进化点: 预测将来可能会产生的变化点, 但并不存在于现有需求中.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;理论上, 对变化点和进化点都应进行设计, 然而除非是显然易见的进化点, 否则没有必要去花费精力”猜测”是否存在进化点, 对进化点的预防性工程成本要高于对简单设计重做的成本 (P314).&lt;/p&gt;
&lt;p&gt;在我们最初编程时, 假设进化不会发生, 而当进化真的到来时, 我们就应用设计以隔离以后发生的同种类进化.&lt;/p&gt;
&lt;p&gt;对于应用程序中的每个部分都刻意地进行抽象不是一个好注意, 拒绝不成熟的抽象和抽象本身一样重要.&lt;/p&gt;
&lt;h2 id="_4"&gt;信息专家&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;what?&lt;/strong&gt;&lt;br/&gt;
某个类有完成一个职责所需要的信息, 那这个类就是该职责的信息专家, 可以把该职责安置到这个类中;&lt;/p&gt;
&lt;p&gt;最基本的职责分配原则之一, 可以一定程度的保证单一职责原则;&lt;/p&gt;
&lt;p&gt;除非是控制器或创建者问题, 否则信息专家模式应该是首先要考虑的模式 (P241);&lt;/p&gt;
&lt;p&gt;信息专家对于认知职责和行为职责都适用, 是给对象分配职责的基本原则, 或者说信息专家指导我们如何给对象分配其职责.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;How?&lt;/strong&gt;&lt;br/&gt;
把职责分配给具有完成该职责所需信息的那个类. 反过来说也一样, 即对象应该只完成与其所具有信息相关的职责.&lt;/p&gt;
&lt;p&gt;因此, 分配职责的第一步就是搞清楚 “完成这个职责需要哪个信息?”, 实际应用中有两种情况:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果在当前设计模型中存在相关的类, 则首先查看设计模型.&lt;/li&gt;
&lt;li&gt;否则查看领域模型, 并尝试根据低表示差异映射成设计模型.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;信息专家其实描述了一个很基本的主题: 把职责和需要的数据放在一起. 信息专家能指导我们做出支持高内聚的设计, 如果一个类的属性被类中的每个方法所使用, 则该类具有最大内聚性.&lt;/p&gt;
&lt;p&gt;根据信息专家可能会产生多个候选者, 此时需要根据指导性原则 (低耦合、高内聚、防止变异) 对候选者进行评估.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实践&lt;/strong&gt;&lt;br/&gt;
在绘制交互图时, 应考虑并决定职责, 然后在类图的方法分栏中总结.&lt;/p&gt;
&lt;p&gt;在分配职责时会产生一种”直觉”, 即软件对象的职责通常能描述现实对象的动作. 如果根据信息专家得到的职责违反了这种”直觉”, 也就是说给对象分配了现实领域中它本身不应负责的职责, 就会降低对象的内聚. 通常我们使用纯虚构解决这个问题.&lt;/p&gt;
&lt;h2 id="_5"&gt;创建者&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;what?&lt;/strong&gt;&lt;br/&gt;
谁创建了某个类的新实例?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;How?&lt;/strong&gt;&lt;br/&gt;
创建一个类的实例, 这也是一种职责 (创建职责), 因此创建者模式可以说是信息专家模式的特化, 专指如何分配创建职责.&lt;/p&gt;
&lt;p&gt;它在信息专家模式的基础上新添了几项优先级更高的原则:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;包含或组成聚集 A&lt;/li&gt;
&lt;li&gt;记录 A&lt;/li&gt;
&lt;li&gt;直接使用 A&lt;/li&gt;
&lt;li&gt;具有 A 的初始化数据 (信息专家, 通常是”描述类” P109)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;优先级从上往下是递减, 如应优先考虑有包含或组成聚集关系的对象.&lt;/p&gt;
&lt;p&gt;那么, 为什么会有比信息专家优先级更高的原则呢?&lt;/p&gt;
&lt;p&gt;因为创建者的本质是寻找在任何情况下都与被创建者具有”连接”的对象. 这么做的目的是为了支持低耦合, 因为这两个类之间已经是可见的了, 即存在已有的关联, 因为用它来做为创建者不会增加设计的耦合度.&lt;/p&gt;
&lt;p&gt;如信息专家模式一样, 通常:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果在当前设计模型中存在相关的类, 则首先查看设计模型.&lt;/li&gt;
&lt;li&gt;否则查看领域模型, 并尝试根据低表示差异映射成设计模型.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果一个类是稳定的, 不容易变化的, 那么创建者模式应该是我们的首选, 如果是不稳定元素, 我们应该把创建职责委派给 &lt;strong&gt;GOF&lt;/strong&gt; 中的工厂模式.&lt;/p&gt;
&lt;p&gt;例如, 如下结构, 虽然对 A 使用了多态, 但是对使用者 B 而言, 它还是需要知道 A_1、A_2、A_3 的存在, 而且如果新增了 A_4, 那 B 又得增加 &lt;code&gt;A a = new A_4()&lt;/code&gt; 的代码, 显然这种设计不是我们想要的, 因此可以使用工厂模式对其 A 进行封装.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/UML和模式应用/工厂.png"/&gt;&lt;/p&gt;
&lt;h2 id="_6"&gt;控制器&lt;/h2&gt;
&lt;p&gt;控制器的针对性非常强.&lt;/p&gt;
&lt;p&gt;控制器模式体现&lt;strong&gt;模型-视图分离&lt;/strong&gt;原则 (P153 这里的模型指的是领域层对象, 而不是 MVC 中的 Model), 防止 UI 层与过多的领域层对象发生耦合, 同时也&lt;strong&gt;避免在 UI 层混入应用逻辑&lt;/strong&gt; (简单的来说, 就是 UI 层拿到数据后就可以直接用了), 这样做的好处是当你想更换一种 UI 时, 你无需在新的 UI 中重写应用逻辑.&lt;/p&gt;
&lt;p&gt;补充一点, 模型-视图分离原则除了指导我们避免在 UI 层混入应用逻辑外, 还指导我们领域层不应向上耦合 UI 层 (P415). 那么就会涉及如何刷新 UI 的方案? 有两份种解决方案:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过 UI 层轮询, 通常适用于 Web UI&lt;/li&gt;
&lt;li&gt;基于观察者模式, 通常适用于 GUI&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单的说控制器完成两个任务:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接收 UI 层发送的系统操作&lt;/li&gt;
&lt;li&gt;处理系统的应用逻辑 (注意, 不要内聚领域层的职责)&lt;/li&gt;
&lt;li&gt;对数据流进行封装、转换&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;控制器可以是真实领域对象, 也可以是纯虚构对象. 这取决于你要处理的系统操作有多少;&lt;/p&gt;
&lt;p&gt;如果系统操作相对来说比较少, 并且职责基本都是相关的, 那么可以让代表”整个系统”、”根对象”、”设备”或”子系统”的领域对象来充当控制器, 简单的来说, 就相当于”系统”的外观; 通常来说, 都会有一个领域对象代表”整个系统”, 如 GameSystem、POSSystem, 这些是较好的选择.&lt;/p&gt;
&lt;p&gt;否则, 虚构一个代表用例的控制器是首要选择, 通常被称作用例或会话控制器 (以下统一称为用例控制器), &lt;code&gt;&amp;lt;UseCaseName&amp;gt;Handler&lt;/code&gt; 或者 &lt;code&gt;&amp;lt;UseCaseName&amp;gt;Session&lt;/code&gt; 是对它的有效命名方法, 同一用例场景下的所有系统操作应使用相同的控制器.&lt;/p&gt;
&lt;p&gt;用例控制器维护与同一个用例相关的工作流, 如对数据流进行封装、转换, 还可以维护关于用例状态的信息 (例如 Session), 如果你的系统有完善的异常处理机制, 通常异常也应从底层向上抛出到控制器中处理;&lt;/p&gt;
&lt;p&gt;当存在多个用例控制器时, 会将这些控制器归纳到一起形成&lt;strong&gt;应用层&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;注意要避免控制器的职责过多, 把本应是领域层对象的职责也给分配给控制器是不对的, 这会形成&lt;strong&gt;臃肿控制器&lt;/strong&gt; (这种现象在 MVC 及其它三层模型变体中很常见, 因为它们是贫血模型, 那么必然会造成 Controller 层的臃肿 ).&lt;/p&gt;
&lt;p&gt;再补充一些我个人对 MVC 的理解, 我并不是排斥 MVC, 而是排斥贫血模型, MVC 体现的只是一种分层解耦、关注分离的设计思想, 这是可取的; 我有时依然会使用 MVC, 但是我会在 Controller 与 Model 之间再封装个 Domain 层 (也就是领域层), 而对 Model 的定义是 Domain 与数据库交互传输的数据结构 (struct), 不把它理解为通常的对象, 因为它不能包含对象的职责 (严格意义上这已经不是 MVC 了).&lt;/p&gt;
&lt;h2 id="_7"&gt;多态&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;应该只对不稳定元素进行设计, 而不是过度的设计.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;多态主要解决用来消除代码中&lt;strong&gt;基于类型&lt;/strong&gt;的选择, 实现可插拔的软件构件.&lt;/p&gt;
&lt;p&gt;如果使用 &lt;code&gt;if - else&lt;/code&gt; 或 &lt;code&gt;switch&lt;/code&gt; 语句来设计基于类型的判断, 那么当出现新的类型时, 则需要修改这段逻辑判断块. 多态即是用来解决这个问题的, 说白了就是封装变化.&lt;/p&gt;
&lt;p&gt;使用多态后, 通常会提供一个&lt;strong&gt;工厂函数&lt;/strong&gt;中, 由这个函数去生成对应类型的抽象类, 以此消除外部类对多态子类的依赖.&lt;/p&gt;
&lt;p&gt;一些语言中, 可以使用&lt;strong&gt;反射&lt;/strong&gt;彻底消除变化, 而另一些语言, 却依然要在工厂函数中去使用 &lt;code&gt;if - else&lt;/code&gt; 或 &lt;code&gt;switch&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="_8"&gt;间接性&lt;/h2&gt;
&lt;p&gt;为了避免和易变、复杂的事物直接耦合而虚构出一个中介对象来隔离风险, 这个一个中介对象来将易变、复杂的事物封装起来提供一个统一的接口, 外部只与这个接口发生耦合, 避免与多个对象耦合.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GOF&lt;/strong&gt; 的适配器、外观、中介都是间接性模式.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编程中的多数问题, 都可以通过增加一层间接性来解决, 如果有, 那就多加几层.&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id="_9"&gt;纯虚构&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;实践中, 应少考虑, 尽量用函数式编程.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;软件设计中, 一部分类来自领域模型的解析, 还一部分是基于相关的行为或算法而组织到一起虚构出来的概念, 例如帮助类、领域驱动中的领域服务类等等, 这些在领域中找不到概念, 是虚构出来的类, 所以叫纯虚构.&lt;/p&gt;</content><category term="软件工程"></category></entry><entry><title>连接字符串的几种方式</title><link href="http://www.smallcpp.cn/lian-jie-zi-fu-chuan-de-ji-chong-fang-shi.html" rel="alternate"></link><published>2018-02-09T11:21:00+08:00</published><updated>2018-02-09T11:21:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2018-02-09:/lian-jie-zi-fu-chuan-de-ji-chong-fang-shi.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;转自 hatlonely Golang 语言社区&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最近在做性能优化, 有个函数里面的耗时特别长, 看里面的操作大多是一些字符串拼接的操作, 而字符串拼接在 golang 里面其实有很多种实现.&lt;/p&gt;
&lt;h1 id="_1"&gt;直接使用运算符&lt;/h1&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;func BenchmarkAddStringWithOperator(b *testing.B) {
    hello := "hello"
    world := "world"
    for i := 0; i &amp;lt; b.N; i++ {
        _ = hello + "," + world …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;转自 hatlonely Golang 语言社区&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最近在做性能优化, 有个函数里面的耗时特别长, 看里面的操作大多是一些字符串拼接的操作, 而字符串拼接在 golang 里面其实有很多种实现.&lt;/p&gt;
&lt;h1 id="_1"&gt;直接使用运算符&lt;/h1&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;func BenchmarkAddStringWithOperator(b *testing.B) {
    hello := "hello"
    world := "world"
    for i := 0; i &amp;lt; b.N; i++ {
        _ = hello + "," + world
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;golang 里面的字符串都是不可变的, 每次运算都会产生一个新的字符串, 所以会产生很多临时的无用的字符串, 不仅没有用, 还会给 gc 带来额外的负担, 所以性能比较差.&lt;/p&gt;
&lt;h1 id="fmtsprintf"&gt;fmt.Sprintf()&lt;/h1&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;func BenchmarkAddStringWithSprintf(b *testing.B) {
    hello := "hello"
    world := "world"
    for i := 0; i &amp;lt; b.N; i++ {
        _ = fmt.Sprintf("%s,%s", hello, world)
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;内部使用 &lt;code&gt;[]byte&lt;/code&gt; 实现, 不像直接运算符这种会产生很多临时的字符串, 但是内部的逻辑比较复杂, 有很多额外的判断, 还用到了 interface, 所以性能也不是很好.&lt;/p&gt;
&lt;h1 id="stringsjoin"&gt;strings.Join()&lt;/h1&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;func BenchmarkAddStringWithJoin(b *testing.B) {
    hello := "hello"
    world := "world"
    for i := 0; i &amp;lt; b.N; i++ {
        _ = strings.Join([]string{hello, world}, ",")
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;join 会先根据字符串数组的内容, 计算出一个拼接之后的长度, 然后申请对应大小的内存, 一个一个字符串填入, 在已有一个数组的情况下, 这种效率会很高, 但是本来没有, 去构造这个数据的代价也不小.&lt;/p&gt;
&lt;h1 id="bufferwritestring"&gt;buffer.WriteString()&lt;/h1&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;func BenchmarkAddStringWithBuffer(b *testing.B) {
    hello := "hello"
    world := "world"
    for i := 0; i &amp;lt; 1000; i++ {        var buffer bytes.Buffer
        buffer.WriteString(hello)
        buffer.WriteString(",")
        buffer.WriteString(world)
        _ = buffer.String()
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个比较理想, 可以当成可变字符使用, 对内存的增长也有优化, 如果能预估字符串的长度, 还可以用 &lt;code&gt;buffer.Grow()&lt;/code&gt; 接口来设置 capacity.&lt;/p&gt;
&lt;h1 id="_2"&gt;测试结果&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;BenchmarkAddStringWithOperator-8            50000000             30.3 ns/op&lt;/li&gt;
&lt;li&gt;BenchmarkAddStringWithSprintf-8             5000000              261  ns/op&lt;/li&gt;
&lt;li&gt;BenchmarkAddStringWithJoin-8                30000000             58.7 ns/op&lt;/li&gt;
&lt;li&gt;BenchmarkAddStringWithBuffer-8              2000000000           0.00 ns/op&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个是在我的自己 Mac 上面跑的结果, go 版本 &lt;code&gt;go version go1.8 darwin/amd64&lt;/code&gt;, 这个结果仅供参考, 还是要以实际生产环境的值为准.&lt;/p&gt;
&lt;h1 id="_3"&gt;主要结论&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;在已有字符串数组的场合, 使用 &lt;code&gt;strings.Join()&lt;/code&gt; 能有比较好的性能&lt;/li&gt;
&lt;li&gt;在一些性能要求较高的场合, 尽量使用 &lt;code&gt;buffer.WriteString()&lt;/code&gt; 以获得更好的性能&lt;/li&gt;
&lt;li&gt;性能要求不太高的场合, 直接使用运算符, 代码更简短清晰, 能获得比较好的可读性&lt;/li&gt;
&lt;li&gt;如果需要拼接的不仅仅是字符串, 还有数字之类的其他需求的话, 可以考虑 &lt;code&gt;fmt.Sprintf()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="Golang"></category></entry><entry><title>渗透法学英语</title><link href="http://www.smallcpp.cn/shen-tou-fa-xue-ying-yu.html" rel="alternate"></link><published>2018-02-01T23:50:00+08:00</published><updated>2018-02-01T23:50:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2018-02-01:/shen-tou-fa-xue-ying-yu.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;需先提升英语水平致赖世雄高级水平.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下内容转自公众号「恶魔奶爸Sam」&lt;/p&gt;
&lt;p&gt;1, 选书, 选择&lt;strong&gt;单页&lt;/strong&gt;生词率低于 10 个以下的 (相关书籍推荐原书都有), 最简单的原文书应该是 Goose bump 跟 Magic Tree House, 每个系列都有 60 本以上, 网上 mobi epub 一大堆, 属于 2000 到 3000 词汇量以内可以看懂的 …&lt;/p&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;需先提升英语水平致赖世雄高级水平.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下内容转自公众号「恶魔奶爸Sam」&lt;/p&gt;
&lt;p&gt;1, 选书, 选择&lt;strong&gt;单页&lt;/strong&gt;生词率低于 10 个以下的 (相关书籍推荐原书都有), 最简单的原文书应该是 Goose bump 跟 Magic Tree House, 每个系列都有 60 本以上, 网上 mobi epub 一大堆, 属于 2000 到 3000 词汇量以内可以看懂的 — — 实在不懂, 书虫之类的分级读物总听说过, 600 词就可以看.&lt;/p&gt;
&lt;p&gt;2, 拿手机词典和书 or kindle 阅读, 建议采用欧路词典的文章阅读功能, 词库选用 &lt;code&gt;朗文当代高级英语辞典&lt;/code&gt; + &lt;code&gt;麦克米伦高阶英语词典&lt;/code&gt; — — 词库在这里, 自己安装: &lt;a href="https://site.douban.com/195274/widget/notes/12471872/note/300956080/"&gt;帝热青读书会第一期: 英文词典的分类和使用方法&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;3, 一开始为了培养阅读习惯, 要大量读, 每天至少读 &lt;strong&gt;20&lt;/strong&gt; 页以上, 最好能超过 &lt;strong&gt;50&lt;/strong&gt; 页, 以从阅读中获得乐趣和信息为目的, 而不是以扩大词汇量为目的.&lt;/p&gt;
&lt;p&gt;4, 阅读的好处就不多说了, 想想你为啥要读中文书就知道了. 不过没有中文阅读习惯的人不适合透析法.&lt;/p&gt;
&lt;p&gt;5, 有关每两页查一个单词的目的, 是为了在大量阅读吸收信息语流的过程中, 顺带积累下生词量, 但不是主要目的, 不打断阅读, 不妨碍享受精彩故事.&lt;/p&gt;
&lt;p&gt;6, 但是在不打断阅读节奏和乐趣的前提下, 你想怎么查都可以 — — 用平板电脑可以即指即译, 所以我是每个生词都查.&lt;/p&gt;
&lt;p&gt;7, 第二天的复习非常重要, 但是不要死背, 而是应该&lt;strong&gt;及时删&lt;/strong&gt;单词 — — 第二天看生词本, 如果记得生词, 那么立刻删掉, 只留下不认识的默看一遍 (耗时 20 分钟以内), 然后去大量读书.&lt;/p&gt;
&lt;p&gt;8, 这样做的好处是, 收词 - 删词 - 在阅读中大量遇到 - 忘了再收 - 再删 - 再读 (渗透 - 回渗 - 再渗透 - 固化), 这个办法是利用情景猜单词和额外的稍微记忆相结合, 记忆效果远超所谓的记忆曲线背单词, 学习效果? 收获的绝对不仅仅是词汇量, 而是整体的英文能力, 对英文运用表达能力也有潜移默化的影响 (输入多未必能写出好文章, 但是写的好的人必然输入多).&lt;/p&gt;
&lt;p&gt;9, 坚持 1-2 年, 每天一个小时的阅读, 词汇量过两万很轻松, 过程几乎没有痛苦 (不要逼自己读不喜欢的书), 但还是那句话, 不要以增加词汇量为首要目的, 而是要以增加对英文文本的熟悉感和理解力作为首要目的.&lt;/p&gt;
&lt;p&gt;10, 初期选材尽量选择同一个作家的作品, 词汇范围比较狭窄, 不同词汇经常性出现, 对于词汇记忆效果比较好, 不建议选择新闻类短篇作品.&lt;/p&gt;
&lt;p&gt;11, 建议每天收录的单词最好不要超过 &lt;strong&gt;50&lt;/strong&gt; 个 — — 可以无限制读, 但是收录单词最好不要超过50个, 如果超过了, 去查看下, 有印象的就删掉, 只留没印象的.&lt;/p&gt;
&lt;p&gt;12, 13, 14, 15, 16 没讲什么.&lt;/p&gt;
&lt;p&gt;17, 书单, 但仅限于个人爱好 (男性向多了些) 每个级别要多看, 直到你看本级别的书再也没有什么生词没什么挑战为止, 这个时候越级 (分级不一定准, 个人能力有限, 大家补充)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注 1, 以下所谓级别可以不管难度, 只选择你最感兴趣的读即可, 只要咬牙坚持住一个月, 后面就会越来越顺利.&lt;/li&gt;
&lt;li&gt;注 2, 书可以在 libgen 找到, 教程百科有声书可以在 kickass 和 btdigg 找.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;L1 Goose Bumps 系列和 Magic Tree House 以及 Boxcar每个系列都过 60 本, 两三千词汇而已, 儿童读物.&lt;/p&gt;
&lt;p&gt;L2 动物农场 Roald Dahl 童话全集 Narnia, 儿童读物.&lt;/p&gt;
&lt;p&gt;L3 Sidney Sheldon 20 本 James Hadley Chase 90 本 James Patternson 80 多本 Nicholas Sparks, L3 跟 L2 级别差不多, 都是大量对白, 书很简单, 偶尔会有单词, 对于成人来说, 看 James Patterson 可能比看查理巧克力工厂要有意思一点? 另外 Nicholas Sparks 是写纯爱小说的, 用词比两个 James 稍微难了点 (前三位都是写 thriller 的, 好看之极), 我看过一本《初恋的回忆》一本《分手信》就没怎么看了, 蛮无聊的, 女性向 (比暮光之城好看).&lt;/p&gt;
&lt;p&gt;L4 社科类作品 Peter Hessler 的 Rivertown三部曲, 讲中国小镇支教的故事, Factory Girls 貌似是他老婆写的, 讲中国女工的, 也可以看看, 还有影响力, Malcolm Gladwell 之类的就不多说了, 去 Goodreads 上面搜 business 这个标签出现的很多书单, 排名靠前的都不会太难, 自己看下简介有兴趣看即可.&lt;/p&gt;
&lt;p&gt;L5 经济学人, 纽约时报, 华尔街日报等相关报道, 尤其是对中国的报道, 可以好好精读一番 (我个人最爱的是纽约客官网上的 Letter from China).&lt;/p&gt;
&lt;p&gt;L6 万物简史, DK 百科全书等各种科普类读物 (如果需要备考托福, 建议最好拿万物简史的文本和音频做精听和精读, 里面什么核糖核酸始祖鸟夸克大爆炸之类的词都有, 而且写的生动有趣), TTC 各类文史哲教程, Coursera, Khan Academy 等 Mooc 学院教程.&lt;/p&gt;
&lt;p&gt;L7 傲慢与偏见, 简爱等各种老牌名著, 不限制.&lt;/p&gt;</content><category term="杂项"></category></entry><entry><title>mock fake stub</title><link href="http://www.smallcpp.cn/mock-fake-stub.html" rel="alternate"></link><published>2018-01-23T15:17:00+08:00</published><updated>2018-01-23T15:17:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2018-01-23:/mock-fake-stub.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;只有当&lt;strong&gt;感知&lt;/strong&gt;和&lt;strong&gt;分离&lt;/strong&gt;困难时, 才需要使用这三个特殊 Object. Reference:《修改代码的艺术》.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id="fake-object"&gt;Fake Object&lt;/h5&gt;
&lt;p&gt;仿对象, 实现了依赖的接口, 包含一些简单的数据处理逻辑, 可对外部调用进行&lt;strong&gt;感知&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;如果依赖的类很难构造, 或无法进行感知时, 可使用 Fake Object.&lt;/p&gt;
&lt;h4 id="mock-object"&gt;Mock Object&lt;/h4&gt;
&lt;p&gt;伪对象, Facke 的高级版, 在内部进行了&lt;strong&gt;断言&lt;/strong&gt;处理.&lt;/p&gt;
&lt;h4 id="stub-object"&gt;Stub …&lt;/h4&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;只有当&lt;strong&gt;感知&lt;/strong&gt;和&lt;strong&gt;分离&lt;/strong&gt;困难时, 才需要使用这三个特殊 Object. Reference:《修改代码的艺术》.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id="fake-object"&gt;Fake Object&lt;/h5&gt;
&lt;p&gt;仿对象, 实现了依赖的接口, 包含一些简单的数据处理逻辑, 可对外部调用进行&lt;strong&gt;感知&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;如果依赖的类很难构造, 或无法进行感知时, 可使用 Fake Object.&lt;/p&gt;
&lt;h4 id="mock-object"&gt;Mock Object&lt;/h4&gt;
&lt;p&gt;伪对象, Facke 的高级版, 在内部进行了&lt;strong&gt;断言&lt;/strong&gt;处理.&lt;/p&gt;
&lt;h4 id="stub-object"&gt;Stub Object&lt;/h4&gt;
&lt;p&gt;桩对象, 仅实现了依赖接口, 但无任务逻辑, 只简单的&amp;rdquo;占坑&amp;rdquo;用.&lt;/p&gt;</content><category term="软件工程"></category></entry><entry><title>递归转尾递归</title><link href="http://www.smallcpp.cn/di-gui-zhuan-wei-di-gui.html" rel="alternate"></link><published>2018-01-22T19:36:00+08:00</published><updated>2018-01-22T19:36:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2018-01-22:/di-gui-zhuan-wei-di-gui.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;尾递归 == 伪递归, 只有递, 没有归&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不是所有的递归都可以转成尾递归, 例如回溯的递归实现就不行, 因为回溯是每一次执行都有 n (n &amp;gt; 1) 种状态, 即在递归的每一层都会有多个递归调用.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;递归 (回溯除外) 是一种特殊的隐式图 DFS, 其每一次状态转换都只有一条路径.&lt;/p&gt;
&lt;p&gt;通常, 如果规模为 n 的问题, 可由 n 的子集 (n-1, n/2 等) 的解推导出时, 考虑使用递归 …&lt;/p&gt;&lt;/blockquote&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;尾递归 == 伪递归, 只有递, 没有归&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不是所有的递归都可以转成尾递归, 例如回溯的递归实现就不行, 因为回溯是每一次执行都有 n (n &amp;gt; 1) 种状态, 即在递归的每一层都会有多个递归调用.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;递归 (回溯除外) 是一种特殊的隐式图 DFS, 其每一次状态转换都只有一条路径.&lt;/p&gt;
&lt;p&gt;通常, 如果规模为 n 的问题, 可由 n 的子集 (n-1, n/2 等) 的解推导出时, 考虑使用递归.&lt;/p&gt;
&lt;p&gt;本质是数学中的&lt;strong&gt;归纳法&lt;/strong&gt;, 即证明一个规模为 n 的问题, 分下面两步:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;证明当 n=1 时命题成立&lt;/li&gt;
&lt;li&gt;假设命题对于 n 成立, 证明在此假设下, 命题对于 n+1 也成立&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关键就是找&lt;strong&gt;状态映射&lt;/strong&gt; (n -&amp;gt; n+1).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其它的可优化递归大致分为两种:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无返回值的递归&lt;/li&gt;
&lt;li&gt;有返回值的递归&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;无返回值的递归转尾递归很简单, 就是调下位置, 参考二叉树的前中后遍历.&lt;/p&gt;
&lt;p&gt;而在有返回值的递归中, 当前层的执行需要用到余下层递归的状态 (返回值):&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;// 求 x 的 n 次方, 非递归&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;func&lt;/span&gt; expr(x, n &lt;span style="color: #00688B; font-weight: bold"&gt;int&lt;/span&gt;) &lt;span style="color: #00688B; font-weight: bold"&gt;int&lt;/span&gt; {
  result = &lt;span style="color: #B452CD"&gt;1&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;for&lt;/span&gt; i := &lt;span style="color: #B452CD"&gt;0&lt;/span&gt;; i &amp;lt; n; i++ {
    result = result * x
    }
  &lt;span style="color: #8B008B; font-weight: bold"&gt;return&lt;/span&gt; result
}

&lt;span style="color: #228B22"&gt;// 递归&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;func&lt;/span&gt; expr_2(x, n &lt;span style="color: #00688B; font-weight: bold"&gt;int&lt;/span&gt;) &lt;span style="color: #00688B; font-weight: bold"&gt;int&lt;/span&gt; {
  &lt;span style="color: #8B008B; font-weight: bold"&gt;if&lt;/span&gt; n == &lt;span style="color: #B452CD"&gt;0&lt;/span&gt; {
    &lt;span style="color: #8B008B; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #B452CD"&gt;1&lt;/span&gt;
  }
  &lt;span style="color: #8B008B; font-weight: bold"&gt;return&lt;/span&gt; x * expr_2(x, n - &lt;span style="color: #B452CD"&gt;1&lt;/span&gt;)
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到 &lt;code&gt;expr_2(x, n)&lt;/code&gt; 的解依赖于下一层调用 &lt;code&gt;expr_2(x, n - 1)&lt;/code&gt; 的状态 (返回值).&lt;/p&gt;
&lt;p&gt;尾递归优化的方法就是打破这种依赖关系:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;// 尾递归优化, 关键在参数上&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;func&lt;/span&gt; expr_3(x, n, result &lt;span style="color: #00688B; font-weight: bold"&gt;int&lt;/span&gt;) &lt;span style="color: #00688B; font-weight: bold"&gt;int&lt;/span&gt; {
  &lt;span style="color: #8B008B; font-weight: bold"&gt;if&lt;/span&gt; n == &lt;span style="color: #B452CD"&gt;0&lt;/span&gt; {
    &lt;span style="color: #8B008B; font-weight: bold"&gt;return&lt;/span&gt; result
  }
  &lt;span style="color: #8B008B; font-weight: bold"&gt;return&lt;/span&gt; expr_3(x, n - &lt;span style="color: #B452CD"&gt;1&lt;/span&gt;, result * x)
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;通过对比可以看到, 在正常递归版本中, n 的解依赖于 n-1 的解, 最终结果是在&amp;rdquo;归&amp;rdquo;的过程中累积; 而在尾递归优化中, 是 n-1 的解依赖于 n 的解, 最终结果是在&amp;rdquo;递&amp;rdquo;的过程中累积. 这也是尾递归 == 伪递归的原因.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不是所有的状态 (返回值) 都需要移到参数中, 只考虑被依赖项.&lt;/p&gt;
&lt;/blockquote&gt;</content><category term="软件工程"></category></entry><entry><title>去除 golint 对 self this 的警告</title><link href="http://www.smallcpp.cn/qu-chu-golint-dui-self-this-de-jing-gao.html" rel="alternate"></link><published>2017-12-01T14:00:00+08:00</published><updated>2017-12-01T14:00:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2017-12-01:/qu-chu-golint-dui-self-this-de-jing-gao.html</id><summary type="html">&lt;p&gt;去除 golint 对方法接收者命名为 self、this 的警告.&lt;/p&gt;</summary><content type="html">&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;首先, Go 官方指出不应该将方法的接收者命名为 self 和 this (&lt;a href="https://github.com/golang/go/wiki/CodeReviewComments#receiver-names"&gt;Receiver Names&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;但是早期的版本中并没有做这种要求, 所以很多其它面向对象语言转过来的开发会采用这种命名法, 造成的结果就是用新版的 golint 检测代码时会报一堆的命名警告, 看起来很不舒服. 此时正确的做法应该是重构代码. 如果怕麻烦的话, 也可以像我一样修改 golint 的源代码&amp;hellip;&lt;/p&gt;
&lt;p&gt;golint 项目地址是: &lt;a href="https://github.com/golang/lint"&gt;github.com/golang/lint&lt;/a&gt;. fork 并 clone 到本地.&lt;/p&gt;
&lt;p&gt;将 lint 包下 lint.go 中的以下代码注释掉:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;if&lt;/span&gt; name == &lt;span style="color: #CD5555"&gt;&amp;quot;this&amp;quot;&lt;/span&gt; || name == &lt;span style="color: #CD5555"&gt;&amp;quot;self&amp;quot;&lt;/span&gt; {
  f.errorf(n, &lt;span style="color: #B452CD"&gt;1&lt;/span&gt;, link(ref), category(&lt;span style="color: #CD5555"&gt;&amp;quot;naming&amp;quot;&lt;/span&gt;), &lt;span style="color: #CD5555"&gt;`receiver name should be a reflection of its identity; don&amp;#39;t use generic names such as &amp;quot;this&amp;quot; or &amp;quot;self&amp;quot;`&lt;/span&gt;)
  &lt;span style="color: #8B008B; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后全局替换 &lt;code&gt;github.com/golang/lint&lt;/code&gt; -&gt; &lt;code&gt;github.com/uldaman/lint&lt;/code&gt;, 修改好后 &lt;code&gt;git push&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;主要是因为 golint 包下 golint.go 中用全路径 import 了 lint 包 (&lt;code&gt;import "github.com/golang/lint"&lt;/code&gt;), 应该把路径改成自己的 github 库路径.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后再执行 &lt;code&gt;go get -u github.com/uldaman/lint/golint&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;或者在本地 &lt;code&gt;cd&lt;/code&gt; 到 golint 包下执行 &lt;code&gt;go build -o golint&lt;/code&gt; 直接生成 golint 二进制文件 (要注意是 golint 包下执行, 而不是 lint 包, 因为 main 函数在 golint.go 中).&lt;/p&gt;</content><category term="Golang"></category></entry><entry><title>PlantUML in VSCode</title><link href="http://www.smallcpp.cn/plantuml-in-vscode.html" rel="alternate"></link><published>2017-12-01T13:00:00+08:00</published><updated>2017-12-01T13:00:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2017-12-01:/plantuml-in-vscode.html</id><content type="html">&lt;p&gt;&lt;a href="https://marketplace.visualstudio.com/items?itemName=jebbs.plantuml"&gt;PlantUML for VSCode&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 VSCode 的插件中安装 plantuml&lt;/li&gt;
&lt;li&gt;&lt;code&gt;brew install graphviz&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;brew cask install java&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;plantuml 文件后缀是 &lt;code&gt;.wsd&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Use References:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.jianshu.com/p/e92a52770832"&gt;使用 Sublime + PlantUML 高效地画图&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://archive.3zso.com/archives/plantuml-quickstart.html#orgec32f74"&gt;PlantUML 快速指南&lt;/a&gt;&lt;/p&gt;</content><category term="工具折腾"></category></entry><entry><title>Go test log in VSCode</title><link href="http://www.smallcpp.cn/go-test-log-in-vscode.html" rel="alternate"></link><published>2017-11-30T15:58:00+08:00</published><updated>2017-11-30T15:58:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2017-11-30:/go-test-log-in-vscode.html</id><content type="html">&lt;p&gt;VSCode 中写 go test 时支持直接运行测试, 但是却输不出 log 信息, 这是因为 VSCode 默认执行 &lt;code&gt;go test&lt;/code&gt; 时没有 &lt;code&gt;-v&lt;/code&gt; 参数 (详细输出).&lt;/p&gt;
&lt;p&gt;打开用户设置 (首选项 -&amp;gt; 设置):&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;{
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;quot;go.testFlags&amp;quot;&lt;/span&gt;: [&lt;span style="color: #CD5555"&gt;&amp;quot;-v&amp;quot;&lt;/span&gt;]
}
&lt;/pre&gt;&lt;/div&gt;</content><category term="工具折腾"></category></entry><entry><title>mac tools</title><link href="http://www.smallcpp.cn/mac-tools.html" rel="alternate"></link><published>2017-11-29T19:00:00+08:00</published><updated>2017-11-29T19:00:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2017-11-29:/mac-tools.html</id><content type="html">&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/robbyrussell/oh-my-zsh"&gt;oh-my-zsh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://itunes.apple.com/cn/app/go2shell/id445770608?mt=12"&gt;go2shell&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://supportdownloads.adobe.com/thankyou.jsp?ftpID=5137&amp;amp;fileID=4770"&gt;Adobe Reader&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="工具折腾"></category></entry><entry><title>Open file in new tab in VSCode</title><link href="http://www.smallcpp.cn/open-file-in-new-tab-in-vscode.html" rel="alternate"></link><published>2017-11-29T16:58:00+08:00</published><updated>2017-11-29T16:58:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2017-11-29:/open-file-in-new-tab-in-vscode.html</id><content type="html">&lt;p&gt;在 VSCode 的资源管理器中打开文件会&amp;rdquo;冲&amp;rdquo;掉当前打开的文件, 很不方便.&lt;/p&gt;
&lt;p&gt;这是由于默认在 VSCode 的资源管理器中单击文件是预览模式, 双击才是真正的打开文件, 通过用户设置可以改变这种行为.&lt;/p&gt;
&lt;p&gt;打开用户设置 (首选项 -&amp;gt; 设置):&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;{
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;quot;workbench.editor.enablePreview&amp;quot;&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;false&lt;/span&gt;,
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;quot;workbench.editor.enablePreviewFromQuickOpen&amp;quot;&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;false&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;</content><category term="工具折腾"></category></entry><entry><title>GOPATH in VSCode</title><link href="http://www.smallcpp.cn/gopath-in-vscode.html" rel="alternate"></link><published>2017-11-22T16:58:00+08:00</published><updated>2017-11-22T16:58:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2017-11-22:/gopath-in-vscode.html</id><summary type="html">&lt;p&gt;打开用户设置 (首选项 -&amp;gt; 设置):&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;{
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;quot;go.inferGopath&amp;quot;&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;,
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;quot;go.toolsGopath&amp;quot;&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;&amp;quot;/Users/hanxiao/Desktop/commonGoPath&amp;quot;&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;inferGopath&lt;/strong&gt; 让编辑器自动推断 Gopath, 规则是沿着当前文件向上找到 src 目录, 并将其设为 Gopath (该结果会覆盖 go.gopath 的设置). 所以我们的项目必须满足 Go 推荐的结构, 即源码要位于 &lt;code&gt;gopath/src …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;打开用户设置 (首选项 -&amp;gt; 设置):&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;{
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;quot;go.inferGopath&amp;quot;&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;,
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;quot;go.toolsGopath&amp;quot;&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;&amp;quot;/Users/hanxiao/Desktop/commonGoPath&amp;quot;&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;inferGopath&lt;/strong&gt; 让编辑器自动推断 Gopath, 规则是沿着当前文件向上找到 src 目录, 并将其设为 Gopath (该结果会覆盖 go.gopath 的设置). 所以我们的项目必须满足 Go 推荐的结构, 即源码要位于 &lt;code&gt;gopath/src&lt;/code&gt; 目录下.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;toolsGopath&lt;/strong&gt; 选项建议设置成全局的一个目录, 它被用来存放一些 VSCode 依赖的 go package, 这样还可以避免项目代码直接引用到这些工具的 src.&lt;/p&gt;</content><category term="工具折腾"></category></entry><entry><title>为 bash 设置 Shadowsocks</title><link href="http://www.smallcpp.cn/wei-bash-she-zhi-shadowsocks.html" rel="alternate"></link><published>2017-11-22T16:56:00+08:00</published><updated>2017-11-22T16:56:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2017-11-22:/wei-bash-she-zhi-shadowsocks.html</id><summary type="html">
&lt;blockquote&gt;
&lt;p&gt;socks5 设置方式:&lt;br/&gt;
&lt;code&gt;export ALL_PROXY=socks5://127.0.0.1:1086&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Shadowsocks 是常用的代理工具, 它使用 socks5 协议, 而终端很多工具目前只支持 http 和 https 等协议, 对 socks5 协议支持不够好, 所以为终端设置 shadowsocks 的思路就是将 socks 协议转换成 http 协议 …&lt;/p&gt;</summary><content type="html">
&lt;blockquote&gt;
&lt;p&gt;socks5 设置方式:&lt;br/&gt;
&lt;code&gt;export ALL_PROXY=socks5://127.0.0.1:1086&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Shadowsocks 是常用的代理工具, 它使用 socks5 协议, 而终端很多工具目前只支持 http 和 https 等协议, 对 socks5 协议支持不够好, 所以为终端设置 shadowsocks 的思路就是将 socks 协议转换成 http 协议, 然后为终端设置即可. 可以采用比较知名的 polipo 来实现, polipo 是一个轻量级的缓存 web 代理程序.&lt;/p&gt;
&lt;h1 id="polipo"&gt;安装 polipo&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;brew install polipo&lt;/code&gt;&lt;/p&gt;
&lt;h1 id="parentproxy"&gt;设置 parentProxy&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;vim /usr/local/opt/polipo/*.plist&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;打开 &lt;code&gt;/usr/local/opt/polipo/homebrew.mxcl.polipo.plist&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在 array 标签组里添加 &lt;code&gt;&amp;lt;string&amp;gt;socksParentProxy=localhost:1086&amp;lt;/string&amp;gt;&lt;/code&gt;, 端口是 Shadowsocks 中设置的 socks5 端口.&lt;/p&gt;
&lt;h1 id="polipo_1"&gt;启动 polipo&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;brew services start(/restart) polipo&lt;/code&gt;&lt;/p&gt;
&lt;h1 id="_1"&gt;验证&lt;/h1&gt;
&lt;p&gt;先用正常模式看下当前网络: &lt;code&gt;curl ip.gs&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;再用代理模式看下: &lt;code&gt;http_proxy=http://localhost:8123 curl ip.gs&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;为某个命令设置代理, 前面加上 &lt;code&gt;http_proxy=http://localhost:8123&lt;/code&gt; 后接命令即可 (该方式对 Git 无效).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;8123 是 polipo 的默认端口, 如有需要, 可以修改成其他有效端口.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id="_2"&gt;当前会话全局设置&lt;/h1&gt;
&lt;p&gt;如果嫌每次为每一个命令设置代理比较麻烦, 可以为当前会话设置全局的代理: &lt;code&gt;export http_proxy=http://localhost:8123&lt;/code&gt;.  如果想撤销当前会话的 http_proxy 代理, 使用 &lt;code&gt;unset http_proxy&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;如果想长久设置, 将 export 命令加入 &lt;code&gt;.bashrc&lt;/code&gt; 或者 &lt;code&gt;.bash_profile&lt;/code&gt; 文件.&lt;/p&gt;
&lt;h1 id="git"&gt;设置 Git 代理&lt;/h1&gt;
&lt;p&gt;使用上面的方式对 Git 无效, Git 走代理需要使用 config.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git clone xxxx --config http.proxy=localhost:8123&lt;/code&gt;&lt;/p&gt;</content><category term="工具折腾"></category></entry><entry><title>类型嵌入实践</title><link href="http://www.smallcpp.cn/lei-xing-qian-ru-shi-jian.html" rel="alternate"></link><published>2017-11-10T14:00:00+08:00</published><updated>2017-11-10T14:00:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2017-11-10:/lei-xing-qian-ru-shi-jian.html</id><summary type="html">&lt;p&gt;Go 中没有提供继承的语义, 可以使用组合设计模式, 只需简单的将一个类型嵌入另一个类型就能实现复用.&lt;/p&gt;</summary><content type="html">&lt;p&gt;Go 中没有提供继承的语义, 可以使用组合设计模式, 只需简单的将一个类型嵌入另一个类型就能实现复用 (&lt;a href="http://blog.csdn.net/xuejianing/article/details/6886613"&gt;组合 VS 继承&lt;/a&gt;, 而且继承是静态的, 在写代码时就已经决定子类的上级, 而组合相对来说是动态的, 要到了运行时才知道到底组合了哪个部分类, 因为组合实际上是对象模型, 而非类模型).&lt;/p&gt;
&lt;p&gt;Go 对组合模式进行了优化, 提供了匿名组合, 让组合类可以直接&amp;rdquo;点&amp;rdquo;出部分类的方法 (具体看下面的实践).&lt;/p&gt;
&lt;p&gt;本次实践体现了面向对象的三个原则:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;优先使用组合 (而非继承)&lt;/li&gt;
&lt;li&gt;针对接口编程&lt;/li&gt;
&lt;li&gt;延迟设计&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;假设现在存在一个车类 (Car), 有一个开车方法 (Drive), 如下:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; Car &lt;span style="color: #8B008B; font-weight: bold"&gt;struct&lt;/span&gt; {
}

&lt;span style="color: #8B008B; font-weight: bold"&gt;func&lt;/span&gt; (car *Car) Drive() {
  log.Println(&lt;span style="color: #CD5555"&gt;&amp;quot;开车&amp;quot;&lt;/span&gt;)
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在是没有接口的, &amp;ldquo;过多&amp;rdquo;或&amp;rdquo;太早&amp;rdquo;的设计都是没有意义的.&lt;/p&gt;
&lt;p&gt;然后来了个新需求, 需要设计一个客车类 (PassengerCar), 分析发现 PassengerCar 也需要 Drive 方法, 可以与 Car 类复用, 此时可以考虑剥离接口了 (针对接口编程):&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; Driver &lt;span style="color: #8B008B; font-weight: bold"&gt;interface&lt;/span&gt; { &lt;span style="color: #228B22"&gt;// Go 推荐单一行为的接口, 可用 行为 + er 来命名&lt;/span&gt;
  Drive()
}

&lt;span style="color: #8B008B; font-weight: bold"&gt;type&lt;/span&gt; PassengerCar &lt;span style="color: #8B008B; font-weight: bold"&gt;struct&lt;/span&gt; { &lt;span style="color: #228B22"&gt;// 针对接口编程, 而不是对象, 即应该依赖接口&lt;/span&gt;
  Driver
}

&lt;span style="color: #8B008B; font-weight: bold"&gt;func&lt;/span&gt; (pcar *PassengerCar) TransportPassengers() {
  log.Println(&lt;span style="color: #CD5555"&gt;&amp;quot;运输乘客&amp;quot;&lt;/span&gt;)
}

&lt;span style="color: #8B008B; font-weight: bold"&gt;func&lt;/span&gt; main() {
  pcar := PassengerCar{&lt;span style="color: #658b00"&gt;new&lt;/span&gt;(Car)}
  pcar.Drive()
  pcar.TransportPassengers()
}
&lt;/pre&gt;&lt;/div&gt;</content><category term="Golang"></category></entry><entry><title>Tox P2P 加密聊天工具</title><link href="http://www.smallcpp.cn/tox-p2p-jia-mi-liao-tian-gong-ju.html" rel="alternate"></link><published>2017-09-14T16:37:00+08:00</published><updated>2017-09-14T16:37:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2017-09-14:/tox-p2p-jia-mi-liao-tian-gong-ju.html</id><summary type="html">&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;Tox 是一个与众不同的即时通讯软件, 最大的特点是 P2P 通讯, 没有服务商的服务器储存各种信息, 所有的一切, 都储存在自己的电脑中, 并且完美兼容 Windows、Linux、MAC、IOS 以及 Android 平台.&lt;/p&gt;
&lt;p&gt;这一点带来了利弊两个方面, 好处是这种方式保护了我们的隐私, 避免对话受到外泄和审查, 坏处是一切都储存在你自己的设备上 (电脑、手机), 于是迁移或者多客户端使用就不太方便 (不过可以通过 &lt;a href="http://www.mintos.org/skill/qtox-switch-devices.html"&gt;Tox聊天(4): qTox 异地同一账号登录&lt;/a&gt; 曲线救国&amp;hellip;).&lt;/p&gt;
&lt;p&gt;Tox …&lt;/p&gt;</summary><content type="html">&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;Tox 是一个与众不同的即时通讯软件, 最大的特点是 P2P 通讯, 没有服务商的服务器储存各种信息, 所有的一切, 都储存在自己的电脑中, 并且完美兼容 Windows、Linux、MAC、IOS 以及 Android 平台.&lt;/p&gt;
&lt;p&gt;这一点带来了利弊两个方面, 好处是这种方式保护了我们的隐私, 避免对话受到外泄和审查, 坏处是一切都储存在你自己的设备上 (电脑、手机), 于是迁移或者多客户端使用就不太方便 (不过可以通过 &lt;a href="http://www.mintos.org/skill/qtox-switch-devices.html"&gt;Tox聊天(4): qTox 异地同一账号登录&lt;/a&gt; 曲线救国&amp;hellip;).&lt;/p&gt;
&lt;p&gt;Tox 是匿名的, 每个 Tox 客户端首次启动时会被分配一个 Tox ID, 这是一个 64 位的 Hash 值, 加 8 位 Nospam 码和 4 位校检码, 一共 76 位.&lt;/p&gt;
&lt;p&gt;Tox ID 类似公钥, 你需要将它发给朋友, 以让他们能添加你. 但是好友只能看到你的前 64 位 Hash 值, 后 12 位是可以更换的, 好友看不到.&lt;/p&gt;
&lt;p&gt;公布了 Tox ID 后, 时间长了, 可能会受到一些垃圾请求, 那么, 这时候可以更改 Nospam 码, 也即 ID 后的那 8 位, 系统会自动计算出一个 4 位的校检码, 合成新的 12 位值, 与 64 位 Hash ID 组成一个新的 76 位 Tox ID. 这样, 就不能使再使用原先的 Tox ID 添加你了. 这有效的阻止了广告用户, 删除他们, 换一个 Nospam 码, 世界就安静了.&lt;/p&gt;
&lt;p&gt;倘若觉得 76 位的 ID 太长太麻烦了, 也可以到一些网站注册一个短用户名, 比如在 utox.org, 写一個用戶名, 填上 Tox ID 值, 注册成功后, 就可以让别人添加 yourname@utox.org 来将你加为好友. 不过如果修改了 Nospam 码, 生成了新的 76 位ID, 就得重新再去注册一个.&lt;/p&gt;
&lt;p&gt;但其实官方认为短用户名是没什么意义的. 该软件注重的是隐私, 适合于亲密的人之间交流, 以及不可全信的陌生人之间的交流, 并不是用来聊天交友或者晒照秀隐私的. 并不会频繁添加删除好友, 所以 ID 也并不需要怎么亮眼. 用短 ID 只是为一时的方便而已.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;References&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://tox.chat/download.html"&gt;Download&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.mintos.org/skill/tox-intro.html"&gt;Tox聊天(1): Tox 聊天基础篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.mintos.org/skill/qtox-manual.html"&gt;Tox聊天(2): qTox 聊天实战教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.mintos.org/skill/tox-antox-manual.html"&gt;Tox聊天(3): 安卓版 Antox 上手&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.mintos.org/skill/qtox-switch-devices.html"&gt;Tox聊天(4): qTox 异地同一账号登录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.mintos.org/skill/tox-group-robot.html"&gt;Tox聊天(5): Tox 群聊与机器人&lt;/a&gt;&lt;/p&gt;</content><category term="工具折腾"></category></entry><entry><title>从程序员到软件架构师</title><link href="http://www.smallcpp.cn/cong-cheng-xu-yuan-dao-ruan-jian-jia-gou-shi.html" rel="alternate"></link><published>2017-08-27T13:27:00+08:00</published><updated>2017-08-27T13:27:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2017-08-27:/cong-cheng-xu-yuan-dao-ruan-jian-jia-gou-shi.html</id><summary type="html">&lt;p&gt;从程序员到软件架构师, 那些年走过的路.&lt;/p&gt;</summary><content type="html">&lt;p&gt;最近看了七牛首席构造师 &amp;ndash; 李道兵的分享《&lt;a href="http://mp.weixin.qq.com/s/49dx-8PTuuB8HNy-MtWcxA"&gt;要怎样努力, 才能修炼成一个架构师?&lt;/a&gt;》, 总结的很好, 看完很有收益, 更加坚定以后的方向.&lt;/p&gt;
&lt;p&gt;个人理解, 好的软件架构师应该是经过三个阶段, 一步一个脚印走过来的: &lt;strong&gt;程序员&lt;/strong&gt; -&amp;gt; &lt;strong&gt;软件设计师&lt;/strong&gt; -&amp;gt; &lt;strong&gt;软件架构师&lt;/strong&gt;.&lt;br&gt;
私认为, 这个过程不应该产生&amp;rdquo;跳级&amp;rdquo;, 软件架构师应该具有相当厉害的编码能力, 具有小尺度问题的设计能力, 而那些只会设计&amp;rdquo;概念&amp;rdquo;、&lt;strong&gt;纸上谈兵式&lt;/strong&gt;的架构师, 并不能服众 (至少不能服我), 不要也罢.&lt;/p&gt;
&lt;p&gt;本篇 Blog 记于 2017-08-27, 此时此刻, 我正在软件设计师到软件架构师的道路上摸滚打爬&amp;hellip;甚至可以说连门都还没摸着~~但没关系, 路漫漫其修远兮, 吾将上下而求索嘛.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;程序员&lt;/strong&gt; (2011 ~ 2015): 学工具、学应用, 这个阶段我大概阅读了以下书籍《C 语言程序设计》、《C++ Primer Plus》、《Win32 汇编程序设计》、《Windows 程序设计》、《Windows 核心编程》、《代码大全 2》等, 基本就是一个初阶码农的阶段~~ (因为是野生程序猿, 所以在第一阶段待了太长的时间, 走了很多弯路, 吃了很多苦~)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;软件设计师&lt;/strong&gt; (2015 ~ 2017): 学思想、学模式、学设计, 例如《GoF 设计模式》、《敏捷软件开发: 原则、模式与实践》、《UML 和模式应用》、《修改代码的艺术》, 该阶段下, 除了码农的职责外, 还兼职着软件分析/设计的职责, 也就是会贯穿软件开发生命周期中的需求分析 -&amp;gt; 概要设计 -&amp;gt; 详细设计 -&amp;gt; 代码实现等四个阶段. 架构设计中的&lt;strong&gt;小尺度&lt;/strong&gt;问题的解决方案应该是来自本阶段的学习.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;软件架构师&lt;/strong&gt; (2017 ~ 未来): 这个阶段我还没入门, 所以能总结的并不多, 但感觉该阶段的职责应该是在能熟练解决小尺度问题的基础上, 可以站在更高, 更抽象的角度去解决&lt;strong&gt;大尺度&lt;/strong&gt;问题; 《企业应用架构模式》、《领域驱动设计》、《微服务设计》等都是不错的学习资源, 另外, 需要从很多同行那里吸收经验,  &lt;strong&gt;QCon&lt;/strong&gt;、&lt;strong&gt;ArchSummit&lt;/strong&gt; 以及&lt;strong&gt;七牛架构师实践日&lt;/strong&gt;这些线下分享会都是不错的途径.&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;书单参考: &lt;a href="http://www.smallcpp.cn/shu-dan.html"&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下是我对软件架构师职能的理解, 或者说是对我自己的目标:&lt;/p&gt;
&lt;p&gt;首先, 作为软件架构师, 每一次分析、每一次设计、每一个技术选型都可能是在给开发、测试挖坑, 而软件架构师要确保团队能够在软件架构师的帮助下从坑里再爬出来, 所以软件架构师还应该具有相当厉害的&lt;strong&gt;编码能力&lt;/strong&gt; (自己都不会怎么帮助别人?).&lt;/p&gt;
&lt;p&gt;其次, 软件架构师架构师应该同时具备大尺度 (子系统间) 和 小尺度 (模块间) 的&lt;strong&gt;抽象能力&lt;/strong&gt;, 将对系统的理解转换为系统实现的模型, 用于指导系统各个方面的设计. 除了保证系统的&lt;strong&gt;功能性需求&lt;/strong&gt;外, 还需要洞察系统的&lt;strong&gt;非功能性需求&lt;/strong&gt; (性能、可用性、伸缩性、扩展性、安全性), 识别架构风险和确定技术选型.&lt;/p&gt;
&lt;p&gt;另外, 好的软件架构师需要有一定的&lt;strong&gt;前瞻性&lt;/strong&gt;, 能大概预判系统未来的发展趋势, 引入技术风险解决未来问题, 避免系统短时间内发生重构.&lt;/p&gt;
&lt;p&gt;最后, 软件架构师还需要关注&lt;strong&gt;产品&lt;/strong&gt;的业务规则和业务特点, 如果忽略了这些, 架构也不过是无法落地的空设想.&lt;/p&gt;</content><category term="软件工程"></category></entry><entry><title>Github 常用功能</title><link href="http://www.smallcpp.cn/github-chang-yong-gong-neng.html" rel="alternate"></link><published>2017-08-26T21:28:00+08:00</published><updated>2017-08-26T21:28:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2017-08-26:/github-chang-yong-gong-neng.html</id><summary type="html">
&lt;h1 id="watchstarfork"&gt;Watch、star、fork&lt;/h1&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/github/watch.png"/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示, 每个 github 项目的右上角, 都有三个按钮: &lt;code&gt;Watch&lt;/code&gt;、&lt;code&gt;star&lt;/code&gt;、&lt;code&gt;fork&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="watch"&gt;Watch&lt;/h2&gt;
&lt;p&gt;这个单词在调试程序时经常遇到, 意为监视, 当把某个变量添加到监视后, 就可以实时看到变量的值的变化.&lt;/p&gt;
&lt;p&gt;Github 中的 &lt;code&gt;Watch&lt;/code&gt; 也是类似的功能, 当你监视某个项目后, 如果项目发生变动, 如有人提交了 pull request、发起了 issue 等等情况, 都会在自己的个人通知中心收到一条通知消息, 如果设置了个人邮箱 …&lt;/p&gt;</summary><content type="html">
&lt;h1 id="watchstarfork"&gt;Watch、star、fork&lt;/h1&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/github/watch.png"/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示, 每个 github 项目的右上角, 都有三个按钮: &lt;code&gt;Watch&lt;/code&gt;、&lt;code&gt;star&lt;/code&gt;、&lt;code&gt;fork&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="watch"&gt;Watch&lt;/h2&gt;
&lt;p&gt;这个单词在调试程序时经常遇到, 意为监视, 当把某个变量添加到监视后, 就可以实时看到变量的值的变化.&lt;/p&gt;
&lt;p&gt;Github 中的 &lt;code&gt;Watch&lt;/code&gt; 也是类似的功能, 当你监视某个项目后, 如果项目发生变动, 如有人提交了 pull request、发起了 issue 等等情况, 都会在自己的个人通知中心收到一条通知消息, 如果设置了个人邮箱, 那么还可能收到相应的邮件.&lt;/p&gt;
&lt;p&gt;点击 &lt;code&gt;Watch&lt;/code&gt; 按钮后会出现三个选项:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Not watching, 不监视, 将不会收到与我无关的通知, 只会关注与我有关的动态 (我发起的、主动参与的或被 @ 的)&lt;/li&gt;
&lt;li&gt;Watching, 监视, 关注这个项目的所有动态&lt;/li&gt;
&lt;li&gt;Ignoring, 彻底忽略这个项目的动态, 那意味着连与我有关的重要消息也收不到了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常只会在 &lt;code&gt;Not watching&lt;/code&gt; 和 &lt;code&gt;Watching&lt;/code&gt; 中选择.&lt;/p&gt;
&lt;h2 id="star"&gt;star&lt;/h2&gt;
&lt;p&gt;集&lt;code&gt;点赞&lt;/code&gt;与&lt;code&gt;收藏&lt;/code&gt;功能于一体…&lt;/p&gt;
&lt;p&gt;点击 github 个人头像, 选择 &lt;code&gt;your stars&lt;/code&gt; 可以查看 &lt;code&gt;star&lt;/code&gt; 过的列表.&lt;/p&gt;
&lt;p&gt;然后就没啥好说的了…&lt;/p&gt;
&lt;h2 id="fork"&gt;fork&lt;/h2&gt;
&lt;p&gt;当对别人的项目进行 &lt;code&gt;fork&lt;/code&gt; 后, 就会在自己的仓库生成一份源项目的拷贝, 当然这个拷贝只是 &lt;code&gt;fork&lt;/code&gt; 发生时的项目文件, 如果后续源项目文件发生改变, 必须通过 &lt;a href="http://www.smallcpp.cn/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Github%20%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD.html#pull-request"&gt;pull request&lt;/a&gt; 去同步.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fork&lt;/code&gt; 应该只在需要对开源项目做贡献时才使用, 很多人会把 &lt;code&gt;fork&lt;/code&gt; 当成收藏，这是不对的, 收藏应该使用 &lt;a href="http://www.smallcpp.cn/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Github%20%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD.html#star"&gt;star&lt;/a&gt; 功能.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fork&lt;/code&gt; 别人的源项目后, 应该谨遵 &lt;a href="http://www.smallcpp.cn/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Github%20%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD.html#pull-request"&gt;pull request&lt;/a&gt; 的建议去贡献自己的代码.&lt;/p&gt;
&lt;h1 id="issue"&gt;issue&lt;/h1&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/github/issues.png"/&gt;&lt;/p&gt;
&lt;p&gt;问题列表, 可当该项目的 &lt;strong&gt;todolist&lt;/strong&gt; 使用, 可以选择 issue 的类型, 如 feature、bug 等.&lt;/p&gt;
&lt;p&gt;另外，在 commit 中可以通过 &lt;code&gt;#issue_id&lt;/code&gt; 与某个 issue 关联, 比如 &lt;code&gt;commit message title, #1&lt;/code&gt;, 还可以指定对 issue 的操作:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;commit message title, closed #1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;commit message title, fixed #1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;commit message title, resolved #1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不过在此之前, 需要检查下你的 Github 的注册邮箱与 &lt;code&gt;git config --list&lt;/code&gt; 中设置的 &lt;code&gt;user.email&lt;/code&gt; 是否一致, &lt;strong&gt;只有一致了才能通过 commit 操作 issue&lt;/strong&gt;, 如果不一致, 需要设置下:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;git config --global user.email "email@example.com"

# 如果设置了 config --local, 则需要再检查下
git config --local user.email "email@example.com"
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;issue 中还可以通过指定 &lt;code&gt;Assignee&lt;/code&gt; 则可以将 issue 分配到某位项目成员身上, 为&lt;strong&gt;团队协作&lt;/strong&gt;提供可能.&lt;/p&gt;
&lt;p&gt;最后, issue 是开放的, 作为一个路人, 你可以通过 issue 给别人的项目提 bug.&lt;/p&gt;
&lt;h1 id="pull-request"&gt;Pull Request&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;首先, 要注意一点, 对于 fork 的项目, 最好永远不要直接在 master 分支上进行修改, 因为 fork 的源项目随时会发生更改, 当收到 fork 源更新的通知时, 需要在自己的仓库发起同步 Pull Request, 如果之前直接在 master 上修改了代码, 此时就会出现冲突问题. 所以在 master 分支上应该只用来发起同步 Pull Request.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当 &lt;a href="http://www.smallcpp.cn/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Github%20%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD.html#fork"&gt;fork&lt;/a&gt; 了一个开源项目后, 应该:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;clone 自己仓库的项目到本地&lt;/li&gt;
&lt;li&gt;在本地仓库中新建一个专门的开发分支进行修改&lt;/li&gt;
&lt;li&gt;push 开发分支的修改到自己的 github 仓库&lt;/li&gt;
&lt;li&gt;从开发分支向 fork 源的 master 分支发起推送 Pull Request&lt;/li&gt;
&lt;li&gt;fork 源项目的维护者合并功能到他的 master 分支&lt;/li&gt;
&lt;li&gt;从 fork 源的 master 分支发起同步 Pull Request 到自己仓库项目的 master 分支&lt;/li&gt;
&lt;li&gt;删除开发分支, Pull Request 工作流结束&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/github/newrequest.png"/&gt;&lt;/p&gt;
&lt;p&gt;点击 &lt;code&gt;New pull request&lt;/code&gt; 按钮创建一个新请求.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/github/comparing.png"/&gt;&lt;/p&gt;
&lt;p&gt;该请求是&lt;strong&gt;双向&lt;/strong&gt;的:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当如上图所示, &lt;code&gt;base fork&lt;/code&gt; 选择 fork 的源项目而 &lt;code&gt;head fork&lt;/code&gt; 选择自己的项目时, 创建的请求是把自己项目的更新推送到 -&amp;gt; 源项目.&lt;/li&gt;
&lt;li&gt;反过来, 如果 &lt;code&gt;base fork&lt;/code&gt; 选择自己的项目而 &lt;code&gt;head fork&lt;/code&gt; 选择 fork 的源项目时, 创建的请求是从源项目更新到 -&amp;gt; 自己的项目&lt;/li&gt;
&lt;li&gt;如果无法选择 &lt;code&gt;base fork&lt;/code&gt; 和 &lt;code&gt;head fork&lt;/code&gt;, 可以点击 &lt;code&gt;compare across forks&lt;/code&gt; 试试.&lt;/li&gt;
&lt;/ul&gt;</content><category term="工具折腾"></category></entry><entry><title>位掩码 (权限模型、组合标志)</title><link href="http://www.smallcpp.cn/wei-yan-ma-quan-xian-mo-xing-zu-he-biao-zhi.html" rel="alternate"></link><published>2017-08-22T13:27:00+08:00</published><updated>2017-08-22T13:27:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2017-08-22:/wei-yan-ma-quan-xian-mo-xing-zu-he-biao-zhi.html</id><summary type="html">&lt;p&gt;位运算在程序设计中的使用 &amp;ndash; 位掩码&lt;/p&gt;</summary><content type="html">
&lt;p&gt;位掩码就是一批不重复、只有一位是 1 其它位都是 0 的二进制位, 如 0001、0010、0100、1000, 这就是一组位掩码.&lt;/p&gt;
&lt;p&gt;使用 GoLang 的 const 与 iota 可以很方便的生成一组位掩码:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;const&lt;/span&gt; (
  Noob           = &lt;span style="color: #B452CD"&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style="color: #8B008B; font-weight: bold"&gt;iota&lt;/span&gt; &lt;span style="color: #228B22"&gt;// 1 &amp;lt;&amp;lt; 0 = 000000001 = 1&lt;/span&gt;
  Hipster                    &lt;span style="color: #228B22"&gt;// 1 &amp;lt;&amp;lt; 1 = 000000010 = 2&lt;/span&gt;
  UnixWizard                 &lt;span style="color: #228B22"&gt;// 1 &amp;lt;&amp;lt; 2 = 000000100 = 4&lt;/span&gt;
  StartupFounder             &lt;span style="color: #228B22"&gt;// 1 &amp;lt;&amp;lt; 3 = 000001000 = 8&lt;/span&gt;
)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例用位运算的 &lt;code&gt;&amp;amp;&lt;/code&gt; (与) 和 &lt;code&gt;|&lt;/code&gt; (或), 位掩码可以用来实现&lt;strong&gt;权限模型&lt;/strong&gt;和&lt;strong&gt;组合标志&lt;/strong&gt;等功能.&lt;/p&gt;
&lt;h1 id="_1"&gt;权限模型&lt;/h1&gt;
&lt;p&gt;Linux 中的用户权限也是类似如此实现的, 原理是利用 &lt;code&gt;&amp;amp;&lt;/code&gt; 运算, 只有待运算的两位同时为 1 时, 运算的结果才为 1, 否则为 0.&lt;/p&gt;
&lt;p&gt;&lt;img alt="权限" src="http://www.smallcpp.cn/theme/images/位掩码/权限.png"/&gt;&lt;/p&gt;
&lt;p&gt;如图所示, 假设这是四个通道, 要想通过通道, 就要拥有对应通道的权限. 一种设计方案是用二进制的 0 和 1 来控制权限, 0 表示没有权限, 1 表示有权限, 那么:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个通道的权限就是 1 0 0 0&lt;/li&gt;
&lt;li&gt;第二个通道的权限就是 0 1 0 0&lt;/li&gt;
&lt;li&gt;第三个通道的权限就是 0 0 1 0&lt;/li&gt;
&lt;li&gt;第四个通道的权限就是 0 0 0 1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;好, 现在通道的权限设置好了, 用户的权限也是用四个二进制来表示, 用户想要通过第一个通道, 那他的第一位二进制就要为 1, 其他位不重要 (因为通道权限的后三位是 0, 所以不管用户权限的后三位是什么, &lt;code&gt;&amp;amp;&lt;/code&gt; 运算的结果都是 0).&lt;/p&gt;
&lt;p&gt;当验证时, 拿用户的二进制权限数据和通道对应的二进制权限数据进行 &lt;code&gt;&amp;amp;&lt;/code&gt; 运算, 得到的结果如果不为 0, 则表示用户拥有通过这个通道的权限, 如果为 0, 则没有对应的权限.&lt;/p&gt;
&lt;p&gt;例如, 此时有一个用户想要通过第一个通道, 其拥有的权限是 1 0 0 0.&lt;/p&gt;
&lt;p&gt;&lt;img alt="权限" src="http://www.smallcpp.cn/theme/images/位掩码/通过.png"/&gt;&lt;/p&gt;
&lt;p&gt;OK! 验证通过.&lt;/p&gt;
&lt;p&gt;如果其拥有的权限是 0 1 0 0.&lt;/p&gt;
&lt;p&gt;&lt;img alt="权限" src="http://www.smallcpp.cn/theme/images/位掩码/拒绝.png"/&gt;&lt;/p&gt;
&lt;p&gt;很遗憾, 验证结果为 0, 验证通过失败.&lt;/p&gt;
&lt;p&gt;这是用户单一权限的情况, 如果用户想要多个权限, 比如拥有通过第 1、2 两个通道的权限, 其用户权限该如何表达? 那么可以把两个单一权限进行 &lt;code&gt;|&lt;/code&gt; 运算,  比如 &lt;code&gt;1000 | 0100 = 1100&lt;/code&gt;. 这就是&lt;strong&gt;组合标志&lt;/strong&gt;.&lt;/p&gt;
&lt;h1 id="_2"&gt;组合标志&lt;/h1&gt;
&lt;p&gt;组合标志的一种运用是在&lt;a href="http://www.smallcpp.cn/wei-yan-ma-quan-xian-mo-xing-zu-he-biao-zhi.html#_1"&gt;权限模型&lt;/a&gt;中设置用户权限. 另外在很多系统或语言提供的 API 中也会用到组合标志, 例如 C++ API &lt;code&gt;CreateFile&lt;/code&gt;, 它的一个参数就是设置打开文件的标志: &lt;code&gt;GENERIC_READ | GENERIC_WRITE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其原理是利用 &lt;code&gt;|&lt;/code&gt; 运算, 待运算的两位中只要有一个是 1, 运算的结果就是 1, 又由于同一批位掩码互不重复、并且只有一位是 1, 所以对位掩码进行 &lt;code&gt;|&lt;/code&gt; 运算能得到一个唯一的标志. 例如 &lt;code&gt;1100&lt;/code&gt; 只可能是 &lt;code&gt;1000&lt;/code&gt; 和 &lt;code&gt;0100&lt;/code&gt; 进行 &lt;code&gt;|&lt;/code&gt; 运算得来.&lt;/p&gt;</content><category term="软件工程"></category></entry><entry><title>书单</title><link href="http://www.smallcpp.cn/shu-dan.html" rel="alternate"></link><published>2017-08-19T13:32:00+08:00</published><updated>2017-08-19T13:32:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2017-08-19:/shu-dan.html</id><summary type="html">&lt;p&gt;一部分书是早几年就读过 PDF 的 (还是挑着章节读的 ~ ~), 很多内容其实没搞懂, 当时技术能力跟不上也就得过且过了; 随着这几年不断的提升自我, 对技术也越来越有比较深的领悟, 感觉应该把那些年当糟粕丢弃的精华重新捡起来再读次.&lt;/p&gt;</summary><content type="html">&lt;p&gt;一部分书是早几年就读过 PDF 的 (还是挑着章节读的 ~ ~), 很多内容其实没搞懂, 当时技术能力跟不上也就得过且过了; 随着这几年不断的提升自我, 对技术也越来越有比较深的领悟, 感觉应该把那些年当糟粕丢弃的精华重新捡起来再读次.&lt;/p&gt;
&lt;p&gt;另外一部分书是 17 年初时定下来的计划, 主要是关于架构设计、软件工程方向的.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;代码素养&lt;/strong&gt;
    + &lt;code&gt;代码大全 2&lt;/code&gt;
    + &lt;code&gt;代码整洁之道&lt;/code&gt;
    + &lt;code&gt;.NET 单元测试艺术&lt;/code&gt;
    + &lt;code&gt;Python Web 开发: 测试驱动方法&lt;/code&gt;
    + &lt;code&gt;修改代码的艺术&lt;/code&gt;
    + &lt;code&gt;重构: 改善既有代码的设计&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;软件工程&lt;/strong&gt;
    + &lt;code&gt;UML 和模式应用&lt;/code&gt;
    + &lt;code&gt;敏捷软件开发: 原则、模式与实践&lt;/code&gt;
    + &lt;code&gt;领域驱动设计: 软件核心复杂性应对之道&lt;/code&gt;
    + &lt;code&gt;持续交付发布可靠软件的系统方法&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;软件架构&lt;/strong&gt;
    + &lt;code&gt;企业应用架构模式&lt;/code&gt;
    + &lt;code&gt;微服务设计&lt;/code&gt;
    + &lt;code&gt;构建高性能 web 站点&lt;/code&gt;
    + &lt;code&gt;程序员必读之软件架构&lt;/code&gt;
    + &lt;code&gt;架构即未来&lt;/code&gt;
    + &lt;code&gt;聊聊架构&lt;/code&gt;
    + &lt;code&gt;软件是这样炼成的: 从软件需求分析到软件架构设计&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用&lt;/strong&gt;
    + &lt;code&gt;区块链: 技能驱动金融&lt;/code&gt;
    + &lt;code&gt;Spark 高级数据分析&lt;/code&gt;
    + &lt;code&gt;Spark 快速大数据分析&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="杂项"></category></entry><entry><title>Chrome F12 Network</title><link href="http://www.smallcpp.cn/chrome-f12-network.html" rel="alternate"></link><published>2017-08-15T11:00:00+08:00</published><updated>2017-08-15T11:00:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2017-08-15:/chrome-f12-network.html</id><summary type="html">&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/chromef12/network.png"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;序号 &lt;strong&gt;0&lt;/strong&gt;: 保存 Log, 页面跳转后, 控制台和网络控制台的内容暂时不清空, 保留下来&lt;/li&gt;
&lt;li&gt;序号 &lt;strong&gt;1&lt;/strong&gt;: 禁用缓存, 打钩后, 刷新页面, 所有请求都是 200, 不打勾当你打开重复页面会出现 304&lt;/li&gt;
&lt;li&gt;序号 &lt;strong&gt;2&lt;/strong&gt;: 可以设置模拟网络, 打开当前页&lt;/li&gt;
&lt;li&gt;序号 &lt;strong&gt;3&lt;/strong&gt;: 本页面共发了多少请求, 本页面大小
    * finish: 每次加载完一个资源 (js, css, img) 时间都会累加 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/chromef12/network.png"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;序号 &lt;strong&gt;0&lt;/strong&gt;: 保存 Log, 页面跳转后, 控制台和网络控制台的内容暂时不清空, 保留下来&lt;/li&gt;
&lt;li&gt;序号 &lt;strong&gt;1&lt;/strong&gt;: 禁用缓存, 打钩后, 刷新页面, 所有请求都是 200, 不打勾当你打开重复页面会出现 304&lt;/li&gt;
&lt;li&gt;序号 &lt;strong&gt;2&lt;/strong&gt;: 可以设置模拟网络, 打开当前页&lt;/li&gt;
&lt;li&gt;序号 &lt;strong&gt;3&lt;/strong&gt;: 本页面共发了多少请求, 本页面大小
    * finish: 每次加载完一个资源 (js, css, img) 时间都会累加
    * DOM: 页面的 dom 完成渲染时间
    * load: 就是 dom + finish 的时间, 整个页面完成呈现给客户的时间&lt;/li&gt;
&lt;/ul&gt;</content><category term="工具折腾"></category></entry><entry><title>关于框架</title><link href="http://www.smallcpp.cn/guan-yu-kuang-jia.html" rel="alternate"></link><published>2017-08-13T13:27:00+08:00</published><updated>2017-08-13T13:27:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2017-08-13:/guan-yu-kuang-jia.html</id><summary type="html">&lt;p&gt;成也框架, 败也框架.&lt;/p&gt;</summary><content type="html">&lt;p&gt;轻量级的框架还是蛮有意思的, 但一般宣传什么功能全面的大型框架, 又笨重又臃肿性能也不是很好, 什么功能丰富、不复杂、容易上手, 就这是给小白的&lt;strong&gt;玩具&lt;/strong&gt;, 定义几个 ORM, 然后写几个 Controllers , 就说精通精通某某了, 没有意义啊, 关键是这种大型框架都是基于 MVC 架构的, 而现在很多项目都是产品端/服务端分离, MVC 这种传统 web 贫血架构根本就不适用, 我觉得什么跳出框架去自己研究架构的时候才是真的精通了.&lt;/p&gt;
&lt;p&gt;框架确实是上手非常快的, 新人以此作为突破口未尝不可, 但一定深入框架的本质, 去学习底层实现, 最终跳出框架才是正道.&lt;/p&gt;</content><category term="软件工程"></category></entry><entry><title>Git Rebase</title><link href="http://www.smallcpp.cn/git-rebase.html" rel="alternate"></link><published>2017-08-07T13:00:00+08:00</published><updated>2017-08-07T13:00:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2017-08-07:/git-rebase.html</id><summary type="html">
&lt;p&gt;rebase 比较复杂, 应该是 git 中的高级应用了, 所以单独拿出来做篇 wiki, 转自: &lt;a href="https://ihower.tw/blog"&gt;ihower blog&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id="git-rebase-merge"&gt;使用 git rebase 避免無謂的 merge&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;git pull&lt;/code&gt; 預設的行為是將遠端的 repo. 與本地的 repo. 合併, 這也是 DVCS 的初衷, 將兩個 branch 合併. 但是, 很多時候會發生以下這種情形 …&lt;/p&gt;</summary><content type="html">
&lt;p&gt;rebase 比较复杂, 应该是 git 中的高级应用了, 所以单独拿出来做篇 wiki, 转自: &lt;a href="https://ihower.tw/blog"&gt;ihower blog&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id="git-rebase-merge"&gt;使用 git rebase 避免無謂的 merge&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;git pull&lt;/code&gt; 預設的行為是將遠端的 repo. 與本地的 repo. 合併, 這也是 DVCS 的初衷, 將兩個 branch 合併. 但是, 很多時候會發生以下這種情形:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/gitRebase/git-merge.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;這是因為, 我們團隊的開發模式是本地的 branch 和遠端的 branch 會同步地非常頻繁(通常就是同名稱的 branch, 例如 master), 這兩個 branch 幾乎是完全同步. 這時候就會發現這些 &lt;code&gt;merge&lt;/code&gt; 動作其實沒有必要, 會造成線圖無謂的複雜. 這時候, 會推薦使用以下這個指令:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;git pull --`rebase`
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;加上 &lt;code&gt;rebase&lt;/code&gt; 的意思是:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把本地 repo. 從上次 pull 之後的變更暫存起來&lt;/li&gt;
&lt;li&gt;回復到上次 pull 時的情況&lt;/li&gt;
&lt;li&gt;套用遠端的變更&lt;/li&gt;
&lt;li&gt;最後再套用剛暫存下來的本地變更&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;畫圖說明一下好了, 假設合併前是這樣:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;      D---E master
     /
A---B---C---F origin/master
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用 &lt;code&gt;merge&lt;/code&gt; 合併後:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;      D--------E
     /          \
A---B---C---F----G   master, origin/master
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果是 &lt;code&gt;rebase&lt;/code&gt; 的方式, 就不會有 &lt;code&gt;G&lt;/code&gt; 合併點:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;A---B---C---F---D'---E'   master, origin/master
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意到, 其中 &lt;code&gt;D’&lt;/code&gt;, &lt;code&gt;E’&lt;/code&gt; 的 commit SHA 序號跟本來 &lt;code&gt;D&lt;/code&gt;, &lt;code&gt;E&lt;/code&gt; 是不同的, 因為算是砍掉重新 &lt;code&gt;commit&lt;/code&gt; 了.&lt;/p&gt;
&lt;p&gt;你會問說, 有 &lt;strong&gt;conflict&lt;/strong&gt; 怎麼辦?&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rebase&lt;/code&gt; 跟 &lt;code&gt;merge&lt;/code&gt; 類似, 出現 conflict 一會暫停 &lt;code&gt;rebase&lt;/code&gt; 動作, 需要你手動修復後, 然後才可以繼續動作. 這也是 &lt;code&gt;rebase&lt;/code&gt; 比 &lt;code&gt;merge&lt;/code&gt; 複雜一點的地方:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;merge&lt;/code&gt; 如果發生 conflict, 你只需要解決衝突一次, 然後 commit 出去就完成了.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rebase&lt;/code&gt; 的 conflict 可能會發生在上述步驟 4 的每一次重新套用上, 所以可能需要解決衝突好幾次 (&lt;code&gt;rebase&lt;/code&gt; 時所謂的解決衝突, 其實是直接修改你之前的變更內容, 所以上圖中變成 &lt;code&gt;D’&lt;/code&gt; 跟 &lt;code&gt;E’&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以到底何時該用 &lt;code&gt;merge&lt;/code&gt;? 何時可以 &lt;code&gt;rebase&lt;/code&gt;? 你可能心理也有答案了, 如果你修改比較多, 預期會有較多的 conflict, 建議用 &lt;code&gt;merge&lt;/code&gt; (不過, 如果是多次大範圍的主題式修改, 那是不是應該一開始就多開一個 branch 來做呢?). 如果修改範圍較小, 不太預期有 conflict, 則建議可以加上 &lt;code&gt;rebase&lt;/code&gt; 參數.&lt;/p&gt;
&lt;p&gt;如果想要把 &lt;code&gt;rebase&lt;/code&gt; 當做 &lt;code&gt;git pull&lt;/code&gt; 的預設值, 可以:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;In git &amp;gt;= 1.7.9:
git config --global/local pull.rebase true

In git &amp;lt; 1.7.9:
git config --global/local branch.autosetuprebase always
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="commit"&gt;重建 commit&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;rebase&lt;/code&gt; 的真正潛力是, 我們可以從指定的版號之後, 重新隨你意 commit 一次來重建 history, 超威的. 首先輸入 &lt;code&gt;git rebase -i&lt;/code&gt; 版號 就會可以跳出 editor 可以編輯, 我們可以:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;變更 commit 順序&lt;/li&gt;
&lt;li&gt;將多個 commit 合併 squash&lt;/li&gt;
&lt;li&gt;將一個 commit 打散 (edit 會停著讓你可以 &lt;code&gt;git reset HEAD^&lt;/code&gt; 打散重新 commit, 完成後 &lt;code&gt;git rebase –continue&lt;/code&gt;)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另一種 &lt;code&gt;rebase&lt;/code&gt; 用法是不需要打 &lt;code&gt;-i&lt;/code&gt;, 直接指定另一個 branch 或 tag, 這樣就會重新 commit 另一個 branch 的東西, 然後才 commit 自己的 (也就是上面那段的用法).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git rebase&lt;/code&gt; 若有 conflict 就會停下來, 跟 &lt;code&gt;merge&lt;/code&gt; 一樣處理完 add, 然後 &lt;code&gt;git rebase –continue&lt;/code&gt; 就會繼續 commit (也可以 &lt;code&gt;–skip&lt;/code&gt; 或 &lt;code&gt;–abort&lt;/code&gt; 放棄啦)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rebase&lt;/code&gt; 有個 onto 參數用法, 使用的情境是: 假設你有三個有 dependency 的 branch 分別叫做 master/contact/search, 後來發現 search branch 只有 depend on matser, 於是你可以輸入 &lt;code&gt;git rebase –onto master contact search&lt;/code&gt; 這樣就會讓 search branch 從 master 的地方開始重新 commit.&lt;/p&gt;
&lt;p&gt;再次提醒, &lt;code&gt;rebase&lt;/code&gt; 千萬只能適合東西還沒 push 的情境, 或是你自己的 local 專用私人 branch. &lt;code&gt;rebase&lt;/code&gt; 一個已經 push 出去的 repository, 然後你又把修改的 history push 出去, 是會造成超級大災難的.&lt;/p&gt;
&lt;p&gt;在學習 &lt;code&gt;rebase&lt;/code&gt; 的過程中, 很容易拿來跟 &lt;code&gt;merge&lt;/code&gt; 比較一下. 我發現一個有趣的不同點: 如果有檔案在要被 merged 的 branch 中被刪除, 如果用 &lt;code&gt;rebase&lt;/code&gt; 檔案最後會不存在, 但是用 &lt;code&gt;merge&lt;/code&gt; 的話檔案最後還在.&lt;/p&gt;
&lt;p&gt;另外, 在 &lt;code&gt;rebase&lt;/code&gt; branch 之後, 如果再做 &lt;code&gt;merge&lt;/code&gt;, 就會發現因為 master 直接就是被 &lt;code&gt;merge&lt;/code&gt; 的祖先, 所以線圖直接變成一條線, 而有這種 parent 關係的 &lt;code&gt;merge&lt;/code&gt; 就叫做 fast-forward. 換句話說, 因為沒有發生任何 &lt;code&gt;merge commit&lt;/code&gt;, 也不會發生 conflict, Git 內部單純只是變更 reference 參照, 所以謂之 fast-forward.&lt;/p&gt;
&lt;p&gt;好心提醒, 因為開 local branch 是如此便宜無害, 所以要做 &lt;code&gt;rebase&lt;/code&gt; 時建議您可以先開一個 local branch 來實驗 &lt;code&gt;rebase&lt;/code&gt;. 老實說, &lt;code&gt;rebase&lt;/code&gt; 還挺危險的.&lt;/p&gt;
&lt;p&gt;最後, &lt;code&gt;rebase&lt;/code&gt; 我認為算是 Git 初學者最難理解的功能吧, 但是如果不知道什麼是 &lt;code&gt;rebase&lt;/code&gt;, 就不能說是懂 Git 啊.&lt;/p&gt;</content><category term="工具折腾"></category></entry><entry><title>需求分析 (定义用例)</title><link href="http://www.smallcpp.cn/xu-qiu-fen-xi-ding-yi-yong-li.html" rel="alternate"></link><published>2017-08-05T01:30:00+08:00</published><updated>2017-08-05T01:30:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2017-08-05:/xu-qiu-fen-xi-ding-yi-yong-li.html</id><summary type="html">
&lt;p&gt;在 AUP 中, 需求也不是一次性分析完的, 会是一个不断迭代精化的过程.&lt;/p&gt;
&lt;p&gt;先来个&lt;strong&gt;总结&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;摘要/非正式/用例图&lt;/strong&gt;, 用来快速收集需求, 表达用户可以利用系统作什么, 是粗粒度级别的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;详述用例&lt;/strong&gt;, 用来详细的描述完成用例的所有步骤及各种变化, 不仅仅是用户的操作, 还包括系统处理的事件流和业务流, 注意是黑盒, 不涉及代码.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="_1"&gt;迭代过程&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;先进行高阶需求分析, 仅仅确定用例的名称, 以及关键的非功能性需求&lt;/li&gt;
&lt;li&gt;从高阶需求列表中选取 10% 的列表项进行详细的分析
    1. 核心架构
    2. 高业务价值 …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">
&lt;p&gt;在 AUP 中, 需求也不是一次性分析完的, 会是一个不断迭代精化的过程.&lt;/p&gt;
&lt;p&gt;先来个&lt;strong&gt;总结&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;摘要/非正式/用例图&lt;/strong&gt;, 用来快速收集需求, 表达用户可以利用系统作什么, 是粗粒度级别的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;详述用例&lt;/strong&gt;, 用来详细的描述完成用例的所有步骤及各种变化, 不仅仅是用户的操作, 还包括系统处理的事件流和业务流, 注意是黑盒, 不涉及代码.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="_1"&gt;迭代过程&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;先进行高阶需求分析, 仅仅确定用例的名称, 以及关键的非功能性需求&lt;/li&gt;
&lt;li&gt;从高阶需求列表中选取 10% 的列表项进行详细的分析
    1. 核心架构
    2. 高业务价值
    3. 高风险&lt;/li&gt;
&lt;li&gt;结合早期时间定量的迭代开发, 进行迭代和进化式需求分析, 并且引入频繁的涉众参与、评估和对局部结果的反馈&lt;/li&gt;
&lt;li&gt;根据第 3 步的反馈, 返回第 1 步进行下一轮迭代&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id="furps"&gt;需求分类 (FURPS+)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;功能性 (Functional): 特性、功能、安全性&lt;/li&gt;
&lt;li&gt;可用性 (Usability): 人性化因素、帮助、文档&lt;/li&gt;
&lt;li&gt;可靠性 (Reliability): 故障频率、可恢复性、可预测性&lt;/li&gt;
&lt;li&gt;性能 (Performance): 响应时间、吞吐量、准确性、有效性、资源利用率&lt;/li&gt;
&lt;li&gt;可支持性 (Supportability): 适应性、可维护性、国际化、可配置性&lt;/li&gt;
&lt;li&gt;辅助性及次要的因素 (+):
    + 实现 (Implementation): 资源限制、语言和工具、硬件等
    + 接口 (Interface): 强加于外部系统接口之上的约束
    + 操作 (Operation): 对其操作设置的系统管理
    + 包装 (Packaging): 例如物理的包装盒
    + 授权 (Legal): 许可证或其它方式&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="_2"&gt;如何管理?&lt;/h1&gt;
&lt;p&gt;需求分析会通常会有两个产出:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用例模型: 管理功能需求&lt;/li&gt;
&lt;li&gt;补充性规格说明: 管理所有非功能需求&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="_3"&gt;用例模型&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;用例模型并不是特指 UML 用例图, 用例图只是用例模型的一种方式.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用例是 OOA 阶段非常重要的产出 (另外一个是领域), 也是 OOD 阶段非常重要的输入, OOD 阶段的关键目标之一是&lt;strong&gt;用例实现&lt;/strong&gt;, 即通过 UML 交互图来描述用例基于软件对象如何在设计模型中实现.&lt;/p&gt;
&lt;h2 id="_4"&gt;什么是用例?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;用例就是功能性需求, 或者说是用来描述系统的功能性需求&lt;/li&gt;
&lt;li&gt;通过编写使用系统实现用户目标的情节 (流程) 来发现和记录功能性需求 (强调的是 FURPS+ 中的 F)&lt;/li&gt;
&lt;li&gt;用例的本质是&lt;strong&gt;文本&lt;/strong&gt;形式的情节描述, UML 只是辅助工具, 用例的重点是用文本描述出用户如何使用系统, 而不是 UML 图形, 但并不是 UML 用例图毫无用处, 在用例收集阶段, 可以用来快速构建用例语境图. 参考下面的&lt;a href="http://www.smallcpp.cn/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%20(%E5%AE%9A%E4%B9%89%E7%94%A8%E4%BE%8B).html#_7"&gt;如何记录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;三种常用形式
    + 摘要: 简洁的一段式概要, 通常用于主成功场景, 可用 &lt;a href="http://www.smallcpp.cn/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%20(%E5%AE%9A%E4%B9%89%E7%94%A8%E4%BE%8B).html#_7"&gt;UML 用例图&lt;/a&gt;替代 (目标: 用于早期需求分析, 快速了解主题和范围)
    + 非正式: 非正式的段落格式, 用段落覆盖不能场景 (目标和摘要一样)
    + &lt;strong&gt;详述&lt;/strong&gt;: 详细的所有步骤及各种变化 (事件流), 包含补充部分, 如前置条件和成功保证 (目标: 用于详细描述下一次迭代的 10 %~20% 用例)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_5"&gt;用例元素&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;参与者: 具有行为的事物, 可以是人、另一个系统等
    + 主要参与者: 具有用户目标, 并通过使用系统功能来完成 (目标: 发现驱动用例的用户目标, 主要是人)
    + 协助参与者: 为系统提供服务 (目标: 为了明确外部接口和协议, 主要是另一个系统)
    + 幕后参与者: 在用例行为中具有影响或利益, 但又不是主要或协助参与者, 如政府税收机构 (目标: 为了确保确定并满足所有必要的重要事物)&lt;/li&gt;
&lt;li&gt;场景: 参与者与系统间的交互, 简单的说就是用户操作了什么&lt;/li&gt;
&lt;li&gt;用例: 场景的集合, 描述参与者如何使用系统来实现其目标&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_6"&gt;如何发现用例 (寻找参与者与目标)?&lt;/h2&gt;
&lt;p&gt;首先应识别出&lt;strong&gt;系统边界&lt;/strong&gt;, 然后在系统边界内找出&lt;strong&gt;主要参与者&lt;/strong&gt;, 然后分析其&lt;strong&gt;目标&lt;/strong&gt;. 用例强调参与者的目标和观点, 所以提问总是围绕参与者目标而不是系统本身.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;谁来使用系统?&lt;/li&gt;
&lt;li&gt;谁来启动和停止系统?&lt;/li&gt;
&lt;li&gt;谁来完成用户管理和安全管理?&lt;/li&gt;
&lt;li&gt;谁来完全系统管理?&lt;/li&gt;
&lt;li&gt;时间是参与者吗? 即需要定时任务吗?&lt;/li&gt;
&lt;li&gt;当系统失败时, 是否存在监控进程将系统重新启动?&lt;/li&gt;
&lt;li&gt;软件升级是如何处理的? 是推模式, 还是拉模式?&lt;/li&gt;
&lt;li&gt;除了人作为主要参与者外, 还有其他外部的软件或系统调用该系统的服务吗?&lt;/li&gt;
&lt;li&gt;谁来考察系统活动或性能?&lt;/li&gt;
&lt;li&gt;谁来考察日志? 是否可以远程检索?&lt;/li&gt;
&lt;li&gt;系统发生错误或故障时应通知谁?&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="_7"&gt;如何记录参与者与目标?&lt;/h2&gt;
&lt;p&gt;发现用例后, 有两种记录方式:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;UML 用例图&lt;/strong&gt; (推荐)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;参与者 - 目标&lt;/strong&gt; 列表, 如果使用这种方式, 该表可做为设想制品的一部分&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用例的本质虽然是&lt;strong&gt;文本&lt;/strong&gt;形式的情节描述, 但并不是每一次迭代都需要详述所有的用例, 可以用 UML 用例图快速收集需求 (代替摘要用例), 从而产出用例语境图. 迭代时, 从语境图中选取一部分进行详述.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/如何进行用例分析/用例图.png"/&gt;&lt;/p&gt;
&lt;p&gt;UML 用例图中允许使用&lt;strong&gt;包含&lt;/strong&gt;和&lt;strong&gt;扩展&lt;/strong&gt;两种关系, 虽然也可以绘制出用户在系统上实现目标的情节 (流程), 但 AUP 不建议使用用例图去描述流程控制, 因为 UML 比较专业, 为了让用户早期参与项目, 所以&lt;strong&gt;建议&lt;/strong&gt;用文本形式进行详述. 当场景工作流复杂到文本无法描述时, &lt;strong&gt;UML 活动图&lt;/strong&gt;是很好的选择.&lt;/p&gt;
&lt;h2 id="uml"&gt;UML 制图准则&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;以本质风格编写用例, 摒除用户界面并且关注参与者的意图
    + 本质风格: 摒除 UI 细节并集中于用户真实意图的用例风格
    + 并不是说关注 UI 不好, 只是这并不是早期的需求分析工作&lt;/li&gt;
&lt;li&gt;用语应尽量简洁, 以动词开头, 删除没必要的词汇&lt;/li&gt;
&lt;li&gt;编写黑盒用例
    + 不对系统内部工作、构件或设计进行描述
    + 只通过职责来描述系统
    + 规定系统必须做什么, 而不是如何去做 (这也正是分析与设计的区别)&lt;/li&gt;
&lt;li&gt;采用参与者和参与者目标的视点
    + 关注系统的用户或参与者来编写需求, 询问其目标和典型情况
    + 关注理解参与者所考虑的有价值结果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结: 用例应产生对特定参与者具有价值的可观察结果.&lt;/p&gt;
&lt;h2 id="_8"&gt;详述用例&lt;/h2&gt;
&lt;h3 id="_9"&gt;模板参考&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;alistair.cockburn.us 上提供的模板, 由 Alistair Cockburn 创建, 它是用例建模方法和畅销书的作者.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;用例元素&lt;/th&gt;
&lt;th&gt;注释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;用例编号 (*)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;用例的编号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;用例名 (*)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;以动词开始, 描述一个用户的具体动作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;范围 (*)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;要设计的是什么系统&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;级别&lt;/td&gt;
&lt;td&gt;用户目标或者子功能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;涉众及其关注点 (*)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;关注该用例的人, 及其关注的地方&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;前置条件&lt;/td&gt;
&lt;td&gt;值得告知读者的, 开始前必须为真的条件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;成功保证(后置条件) (*)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;值得告知读者的, 成功完成必须满足的条件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;主成功场景 (*)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;典型的、理想方式的成功场景&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;扩展   (*)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;成功或失败的替代场景&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;特殊需求&lt;/td&gt;
&lt;td&gt;相关的非功能性需求 (通常最终会整理到补充规格说明中)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;技术和数据变元表&lt;/td&gt;
&lt;td&gt;不同的 I/O 方法和数据格式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;发生频率&lt;/td&gt;
&lt;td&gt;影响对实现的调查、测试和时间安排&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;杂项&lt;/td&gt;
&lt;td&gt;例如未决问题&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;带 (*) 的是相对重要的选项, 通常是必填项&lt;/p&gt;
&lt;h3 id="_10"&gt;编写指南&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;级别&lt;/strong&gt;分为用户目标或子功能, 大部分情况下都是用户目标级别, 子功能级别的含义在于当若干用例共享某同一批步骤时, 则将这批步骤分离出来, 创建成子功能级别用例, 以避免重复的公共文本&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用例编号&lt;/strong&gt;, alistair.cockburn.us 上并没有要求, 是我加上的, 主要为了对用例进行整理、排序&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;涉众及其关注点&lt;/strong&gt;比看上去重要的多, 它捕获的是最原始的需求, 系统的目标就是实现涉众的关注点, 所以用例应该包含满足所有涉众关注点的事物&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;前置条件&lt;/strong&gt;与&lt;strong&gt;成功保证&lt;/strong&gt;(后置条件)
    + 前置条件是用户使用系统前的条件, 应只列出需要&lt;strong&gt;引起注意&lt;/strong&gt;、&lt;strong&gt;警惕&lt;/strong&gt;的条件, 例如要使用 POS 机的话收银员必须先完成登录用例; 而有些条件也必须为真, 但并不值得写出, 如必须要有供电
    + 成功保证是指用例场景成功后会产生的&lt;strong&gt;必然的影响&lt;/strong&gt; (即系统必须要执行的扫尾操作, 如更新账务和库存信息、生成票据等), 应该满足所有涉众需求, 通常会是主成功场景的最后几个步骤&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主成功场景&lt;/strong&gt;
    + 描述了满足涉众关注点的典型成功路径 (即所有涉众都得到理想状态)
    + 通常不包括任何条件或分支, 只有一条&lt;strong&gt;主成功路径&lt;/strong&gt;, 因此要用”确认”语句, 而不是”是否”语句, 例如系统验证密码正确, 而不是系统检查密码是否正确, 所有条件或分支都应&lt;strong&gt;推延到扩展&lt;/strong&gt;部分进行说明
    + 描述中&lt;strong&gt;不要涉及 UI&lt;/strong&gt;, 例如以下方式不可取: 用户在输入框中输入账号, 用户在下拉框中选择第二项
    + 场景主要记录以下信息:
        * &lt;strong&gt;参与者之间的交互&lt;/strong&gt;
            * 系统本身也是参与者之一, 每个步骤都要能找到&lt;strong&gt;操作人&lt;/strong&gt;, 应按&lt;strong&gt;主动语态&lt;/strong&gt;来描述, 如用户xxx, 系统xxx
            * 需指出参与者之间的&lt;strong&gt;交互信息&lt;/strong&gt;
                + 如果信息简单, 可直接在步骤中描述: 用户输入用户名和密码
                + 如果信息复杂, 可在&lt;strong&gt;词汇表&lt;/strong&gt;中进行定义: 用户输入注册信息 (参考词汇表 - 注册信息)
        * &lt;strong&gt;确认过程&lt;/strong&gt;
            + 即系统对参与者输入的处理流程, 注意是&lt;strong&gt;业务&lt;/strong&gt;流程, 所以不要暴露系统任何内部组件
            + 如果流程过于复杂, 可以使用 &lt;strong&gt;UML 活动图&lt;/strong&gt;
            + 应将&lt;strong&gt;系统边界&lt;/strong&gt;外的&lt;strong&gt;协助参与者&lt;/strong&gt;体现出来, 并标明是&lt;strong&gt;外部&lt;/strong&gt;参与者, 否则研发会误认为这个功能是属于系统边界内的
                - 如果这个步骤是&lt;strong&gt;系统&lt;/strong&gt;发起的, 可以描述成: 系统通过外部账务系统确认客户缴过费
                - 如果这个步骤是&lt;strong&gt;用户&lt;/strong&gt;发起的, 可以描述成: 用户通过系统从外部账务系统获取充值记录
        * &lt;strong&gt;系统的状态变更&lt;/strong&gt;
            + 通常和成功保证/后置条件有关联, 注意是&lt;strong&gt;黑盒&lt;/strong&gt;描述, 例如系统记录销售信息, 而不是系统将销售信息写入数据库&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扩展&lt;/strong&gt;
    + 主要包括主成功场景的分支
    + 与主成功场景相结合应该满足几乎所有涉众关注点 (有些非功能性关注点则应该放到补充规格说明中描述)
    + 由于扩展场景是主成功场景的分支, 因为通常用与主成功场景对应的序号来标识
        * 如主成功场景中第一步的扩展用 1a、1b 这样描述
        * 某些扩展是几个步骤共用, 如主成功场景第一步到第三步中都有可能出现的扩展则用 1-3a、1-3b 这样描述
        * 还有些扩展贯穿整个主成功场景, 则用 *a、*b 这样描述
        * 某些扩展可能需要执行其他用例 (或者扩展非常复杂, 并且有一定的通用性, 则可单独抽出来形成另一个用例), 此时使用下划线标识这是另一个用例, 如果是用有超链接功能的工具编写用例, 那么点击下划线应可跳转到其所标识的用例
        * 在每一步的扩展结束时应重新回到主成功场景的步骤, 除非扩展指出来其他路径&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特殊需求&lt;/strong&gt;, 这些需求最终会被整理到补充规格说明中作为整体来考虑
    + 与本用例相关的非功能性需求
    + 质量属性 (如性能、可靠性和可用性)
    + 设计约束 (通常对于 I/O 设备)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;技术和数据变元表&lt;/strong&gt; (翻译感觉有点问题, 原文是 Technology and Data Variations List), 介绍特殊的标准和技术, 指定必须如何实现系统 (而非实现系统哪些功能).&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;实例参考 《UML 和模式应用》 P50&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/如何进行用例分析/主成功场景..png"/&gt;&lt;/p&gt;</content><category term="软件工程"></category></entry><entry><title>DDD 领域驱动设计与六边形架构</title><link href="http://www.smallcpp.cn/ddd-ling-yu-qu-dong-she-ji-yu-liu-bian-xing-jia-gou.html" rel="alternate"></link><published>2017-08-04T11:24:00+08:00</published><updated>2017-08-04T11:24:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2017-08-04:/ddd-ling-yu-qu-dong-she-ji-yu-liu-bian-xing-jia-gou.html</id><summary type="html">&lt;p&gt;软件世界是对现实世界的抽象, 而传统的三层架构或 MVC 架构 (参考: &lt;a href="http://www.smallcpp.cn/san-ceng-jia-gou-yu-mvc.html"&gt;三层架构与 MVC&lt;/a&gt;), 却是结构化的生搬硬套, 在这些架构中的设计出来的对象是贫血的, 是“业务逻辑”类, 跟现实世界甚至毫无关系, 那么根据根据现实世界的真实领域, 映射到软件世界的&lt;code&gt;领域驱动设计&lt;/code&gt;和&lt;code&gt;六边形架构&lt;/code&gt;, 才是更好的架构方式, 应用场景更广, 扩展更简单.&lt;/p&gt;
&lt;p&gt;PS, 领域驱动设计继承了职责驱动设计, 或者可以说是职责驱动设计的进化.&lt;/p&gt;
&lt;p&gt;领域驱动设计不是一种设计风格, 也不是一种架构模型, 而是一种思考方式, 指导如何进行职责的划分, 而六边开架构就是一种架构了, &amp;ldquo;六 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;软件世界是对现实世界的抽象, 而传统的三层架构或 MVC 架构 (参考: &lt;a href="http://www.smallcpp.cn/san-ceng-jia-gou-yu-mvc.html"&gt;三层架构与 MVC&lt;/a&gt;), 却是结构化的生搬硬套, 在这些架构中的设计出来的对象是贫血的, 是“业务逻辑”类, 跟现实世界甚至毫无关系, 那么根据根据现实世界的真实领域, 映射到软件世界的&lt;code&gt;领域驱动设计&lt;/code&gt;和&lt;code&gt;六边形架构&lt;/code&gt;, 才是更好的架构方式, 应用场景更广, 扩展更简单.&lt;/p&gt;
&lt;p&gt;PS, 领域驱动设计继承了职责驱动设计, 或者可以说是职责驱动设计的进化.&lt;/p&gt;
&lt;p&gt;领域驱动设计不是一种设计风格, 也不是一种架构模型, 而是一种思考方式, 指导如何进行职责的划分, 而六边开架构就是一种架构了, &amp;ldquo;六&amp;rdquo;只是一个量词, 表明这种架构可以支持多个客户端, 它也被称之为端口与适配器架构, 很适合和领域驱动结合 (在&lt;a href="http://pan.baidu.com/s/1gfIMKqJ"&gt;《实现领域驱动设计》&lt;/a&gt;一书中作者将六边形架构应用于 DDD).&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/软件工程/六边形.png"&gt;&lt;/p&gt;
&lt;p&gt;在六边形架构中, 提出了一种具有对称性特征的架构风格. 在这种架构中, 不同的客户通过&amp;rdquo;平等&amp;rdquo;的方式与系统交互. 包括输入系统 (web，gui) 和输出系统 (database、log、message queue).
需要新的客户吗? 不是问题. 只需要添加一个新的适配器将客户输入转化成能被系统 API 所理解的参数就行了.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于输出系统, 为了不产生反依赖, 可以对其适配器使用观察者模式.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;六边形架构的核心是&lt;strong&gt;领域层&lt;/strong&gt;, 这个需要看完《领域驱动设计》才能有深刻理解, 我现在正在读;&lt;/p&gt;
&lt;p&gt;外界与领域层的交互都通过&lt;strong&gt;应用层&lt;/strong&gt;完成, 应用层是领域层的直接客户 (可有说叫端口层, 想要表达的含义是一样的). 应用层中不应该包含有业务逻辑, 否则就造成了领域逻辑的泄漏, 而应该是很薄的一层, 主要起到协调的作用, 它所做的只是将业务操作代理给我们的领域层, 扮演了系统门面/外观 (Facade) 的角色.&lt;/p&gt;
&lt;p&gt;应用层的本质是《UML与模式应用》中提到 GRASP 中的&lt;strong&gt;控制器&lt;/strong&gt;, 可以参考 《UML与模式应用》 P218、412, 但六边形架构推荐依据&lt;strong&gt;用例&lt;/strong&gt;来创建控制器.&lt;/p&gt;
&lt;p&gt;控制器模式体现&lt;strong&gt;模型-视图&lt;/strong&gt;分离原则 (这里的模型指的是领域层对象, 而不是 MVC 中的 Model), 防止 UI 层与过多的领域层对象发生耦合, 同时也避免在 UI 层混入应用逻辑.&lt;/p&gt;
&lt;p&gt;控制器可以是真实领域对象, 也可以是纯虚构对象. 这取决于你要处理的系统操作有多少:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果系统操作相对来说比较少, 并且职责基本都是相关的, 那么可以让代表整个&amp;rdquo;系统&amp;rdquo;、&amp;rdquo;根对象&amp;rdquo;、&amp;rdquo;设备&amp;rdquo;或&amp;rdquo;子系统&amp;rdquo;的领域对象来充当控制器, 简单的来说, 就相当于&amp;rdquo;系统&amp;rdquo;的外观;&lt;/li&gt;
&lt;li&gt;否则, 虚构一个代表用例的控制器是首要选择, 通常被称作&lt;strong&gt;用例或会话控制器&lt;/strong&gt; (以下统一称为用例控制器), &lt;UseCaseName&gt;Handler 或者 &lt;UseCaseName&gt;Session 是对它的有效命名方法. -- 这也是六边形构架推荐的方式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用例控制器维护与同一个用例相关的工作流, 如对数据流进行封装、转换, 还可以维护关于用例状态的信息 (例如 Session), 如果你的系统有完善的异常处理机制, 通常异常也应从底层向上抛出到控制器中处理;&lt;/p&gt;
&lt;p&gt;注意要避免控制器的&lt;strong&gt;职责过多&lt;/strong&gt;, 把本应是领域层对象的职责也给分配给控制器是不对的, 这会形成臃肿控制器 (这种现象在 MVC 及其它三层模型变体中很常见, 因为它们是贫血模型, 那么必然会造成 Controller 层的臃肿 ).&lt;/p&gt;
&lt;p&gt;在设计控制器时, 通常会采用 GOF 中的&lt;strong&gt;外观模式&lt;/strong&gt;, 例如下图中的 DB.java, 该类为 java.sql 包中复杂且全面的逻辑提供了一个非常简单的、特定于处理 Product 用例的外观.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/软件工程/外观.png"&gt;&lt;/p&gt;</content><category term="软件工程"></category></entry><entry><title>Git pull/clone 时报 early EOF 错</title><link href="http://www.smallcpp.cn/git-pullclone-shi-bao-early-eof-cuo.html" rel="alternate"></link><published>2017-07-24T21:28:00+08:00</published><updated>2017-07-24T21:28:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2017-07-24:/git-pullclone-shi-bao-early-eof-cuo.html</id><summary type="html">&lt;p&gt;错误信息如下:
fatal: The remote end hung up unexpectedly
fatal: early EOF
fatal: unpack-objects failed&lt;/p&gt;
&lt;p&gt;解决方案一:
1. 先启动 git bash
2. 打开一个 cmd, 启动 git 守护进程 &lt;code&gt;sh.exe --login -i -c …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;错误信息如下:
fatal: The remote end hung up unexpectedly
fatal: early EOF
fatal: unpack-objects failed&lt;/p&gt;
&lt;p&gt;解决方案一:
1. 先启动 git bash
2. 打开一个 cmd, 启动 git 守护进程 &lt;code&gt;sh.exe --login -i -c 'git.exe daemon --verbose  '&lt;/code&gt;
3. 在 cmd 中标记一些文本, 注意要保持标记状态, 然后回去 git bash 执行 &lt;code&gt;git reset --hard HEAD&lt;/code&gt; 和 &lt;code&gt;git pull/clone&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;解决方案二:
另外还有一个&lt;a href="https://stackoverflow.com/questions/21277806/fatal-early-eof-fatal-index-pack-failed"&gt;解决方案&lt;/a&gt;没试, 因为上面的方案成功了..&lt;/p&gt;</content><category term="工具折腾"></category></entry><entry><title>文档编辑器鄙视链</title><link href="http://www.smallcpp.cn/wen-dang-bian-ji-qi-bi-shi-lian.html" rel="alternate"></link><published>2017-07-22T16:37:00+08:00</published><updated>2017-07-22T16:37:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2017-07-22:/wen-dang-bian-ji-qi-bi-shi-lian.html</id><content type="html">&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/文档编辑器鄙视链/bslian.png"&gt;&lt;/p&gt;</content><category term="工具折腾"></category></entry><entry><title>迁移 OneNote 说明</title><link href="http://www.smallcpp.cn/qian-yi-onenote-shuo-ming.html" rel="alternate"></link><published>2017-01-23T03:40:00+08:00</published><updated>2017-01-23T03:40:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2017-01-23:/qian-yi-onenote-shuo-ming.html</id><content type="html">&lt;p&gt;微软已经彻底免费了 OneNote, 试用一段时间后感觉超级棒, 以后都将 OneNote 作为主要&lt;strong&gt;笔记&lt;/strong&gt;工具.&lt;/p&gt;
&lt;p&gt;笔记 (读书、学习等)、日志类 -&gt; OneNote&lt;/p&gt;
&lt;p&gt;拾遗、碎片知识、操作指南类 -&gt; &lt;a href="http://wiki.smallcpp.cn"&gt;wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;总结、感想、分析类 -&gt; &lt;a href="http://www.smallcpp.cn"&gt;blog&lt;/a&gt;&lt;/p&gt;</content><category term="杂项"></category></entry><entry><title>11. 回收站的使用</title><link href="http://www.smallcpp.cn/11-hui-shou-zhan-de-shi-yong.html" rel="alternate"></link><published>2016-11-24T10:37:00+08:00</published><updated>2016-11-24T10:37:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-11-24:/11-hui-shou-zhan-de-shi-yong.html</id><summary type="html">&lt;p&gt;回收站的使用&lt;/p&gt;</summary><content type="html">&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;和 Linux 系统的回收站设计一样，HDFS 会为每一个用户创建一个回收站目录: &lt;code&gt;/user/用户名/.Trash/&lt;/code&gt;，开启该功能后, 每一个被用户通过 Shell 删除的文件或目录，都不是直接删除, 而是移动到 HDFS 的回收站内, 回收站中文件都一个生命周期，也就是当系统回收站中的文件或目录在一段时间之后没有被用户回复的话，HDFS 就会自动的把这个文件或目录彻底删除，之后用户就永远也找不回这个文件或目录了.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;每&lt;/strong&gt;个节点上添加配置 &lt;code&gt;core-site.xml&lt;/code&gt;,增加如下内容&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;fs.trash.interval&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;1440&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;1440 指定生命周期, 单位是分钟, 这里就是相当于 24 小时.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;开启回收站后, data 目录会变得复杂, 也会存在有垃圾数据.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Java Api&lt;/strong&gt; 操作方式:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;public&lt;/span&gt; &lt;span style="color: #8B008B; font-weight: bold"&gt;static&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;boolean&lt;/span&gt; &lt;span style="color: #008b45"&gt;rm&lt;/span&gt;(FileSystem fs, Path path, &lt;span style="color: #00688B; font-weight: bold"&gt;boolean&lt;/span&gt; recursive, &lt;span style="color: #00688B; font-weight: bold"&gt;boolean&lt;/span&gt; skipTrash) &lt;span style="color: #8B008B; font-weight: bold"&gt;throws&lt;/span&gt; IOException {

    &lt;span style="color: #8B008B; font-weight: bold"&gt;if&lt;/span&gt; (!skipTrash) {
        Trash trashTmp = &lt;span style="color: #8B008B; font-weight: bold"&gt;new&lt;/span&gt; Trash(fs, conf);
        &lt;span style="color: #8B008B; font-weight: bold"&gt;if&lt;/span&gt; (trashTmp.&lt;span style="color: #658b00"&gt;moveToTrash&lt;/span&gt;(path)) {
            log.&lt;span style="color: #658b00"&gt;info&lt;/span&gt;(&lt;span style="color: #CD5555"&gt;&amp;quot;Moved to trash: &amp;quot;&lt;/span&gt; + path);
            &lt;span style="color: #8B008B; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;;
        }
    }

    &lt;span style="color: #00688B; font-weight: bold"&gt;boolean&lt;/span&gt; ret = fs.&lt;span style="color: #658b00"&gt;delete&lt;/span&gt;(path, recursive);
    &lt;span style="color: #8B008B; font-weight: bold"&gt;if&lt;/span&gt; (ret) {
        log.&lt;span style="color: #658b00"&gt;info&lt;/span&gt;(&lt;span style="color: #CD5555"&gt;&amp;quot;rm: &amp;quot;&lt;/span&gt; + path);
    }
    &lt;span style="color: #8B008B; font-weight: bold"&gt;return&lt;/span&gt; ret;
}
&lt;/pre&gt;&lt;/div&gt;</content><category term="大数据"></category></entry><entry><title>10. 2.X HA (高可靠) 及 Federation (联盟)</title><link href="http://www.smallcpp.cn/10-2x-ha-gao-ke-kao-ji-federation-lian-meng.html" rel="alternate"></link><published>2016-11-23T19:00:00+08:00</published><updated>2016-11-23T19:00:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-11-23:/10-2x-ha-gao-ke-kao-ji-federation-lian-meng.html</id><summary type="html">&lt;p&gt;2.x 用 HA 实现 NameNode 高可靠 及 Federation (联盟)&lt;/p&gt;</summary><content type="html">
&lt;p&gt;首先说明 . . . 也许这两个功能你根本不可能用到上, 因为你的集群规模完全达不到要求.&lt;/p&gt;
&lt;p&gt;在 1.X 时代, 你可能需要再另外建立一个 Hadoop 集群 . . . 想像一下建立一个集群的成本 . . .&lt;/p&gt;
&lt;p&gt;Hadoop 1.x 中, 一个集群就只有一个 NameNode, 这种架构虽然实现简单, 但会产生&lt;strong&gt;单点&lt;/strong&gt;、&lt;strong&gt;内存&lt;/strong&gt;瓶颈、&lt;strong&gt;性能&lt;/strong&gt;
瓶颈等限制.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题一&lt;/strong&gt;, 整个 Hadoop 集群的命名空间都归一个 NameNode 管理, 这样 HDFS 所能存储的文件数量会受到 NameNode 容量的限制;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题二&lt;/strong&gt;, 当集群进行复杂运算时, 也只有一个 NameNode 在运作, 集群的运算性能也会受到 NameNode 的限制.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题三&lt;/strong&gt;, 虽然集群有 Second NameNode 作为辅助节点, 但并不会完成自动切换, 当 NameNode 宕掉时, 还是需要人工去处理.&lt;/p&gt;
&lt;p&gt;虽然仅仅在像 Yahoo 和 Facebook 返种规模的大公司才会面对这样的限制问题, 但在 Hadoop 2.x 中, 官方还是给出了解决方案.&lt;/p&gt;
&lt;h1 id="ha-federation"&gt;HA + Federation 架构图&lt;/h1&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/高可靠联盟/HAFederation.png"/&gt;&lt;/p&gt;
&lt;p&gt;先放张图, 后面的内容将对其进行解释.&lt;/p&gt;
&lt;h1 id="federation"&gt;Federation (联盟/联邦)&lt;/h1&gt;
&lt;p&gt;2.X 时代引入了 Federation, 采用 Federation 的最主要原因很简单, 它能够解决上述的 &lt;strong&gt;问题一&lt;/strong&gt; 和 &lt;strong&gt;问题二&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Federation 提供了 Hadoop 集群多 NameNode 的能力, 让集群可以水平扩展, 一定程度解决了单 NameNode 的&lt;strong&gt;内存&lt;/strong&gt;瓶颈和&lt;strong&gt;性能&lt;/strong&gt;
瓶颈.&lt;/p&gt;
&lt;p&gt;为了&lt;strong&gt;水平扩展&lt;/strong&gt; NameNode, Federation 使用了多个独立的 NameNode, 有各自自己的命名空间, 他们之间相互独立且不需要互相协调, 各自分工, 管理自己的区域, 不需要和其它 &lt;strong&gt;NameNode&lt;/strong&gt; 协调合作, 但是 DataNode 作为统一的块存储设备被所有 NameNode 共享.&lt;/p&gt;
&lt;p&gt;每一个 &lt;strong&gt;DataNode&lt;/strong&gt; 都在所有的 &lt;strong&gt;NameNode&lt;/strong&gt; 进行注册, DataNode 发送心跳信息、块报告到所有的 NameNode 上, 同时呢, 也执行所有 NameNode 发来的命令, 而 NameNode 通过 &lt;strong&gt;Block Pools&lt;/strong&gt; (块池) 对其进行管理.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其实 Federation 主要还是解决了 DataNode 不能被多个 NameNode 共享的问题.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;总结下 Federation:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HDFS 集群扩展性.
    + 多个 NameNode 分管一部分目录空间, 使得一个集群可以扩展到更多节点, 不再像 1.x 中那样由于内存的限制制约文件存储数目.&lt;/li&gt;
&lt;li&gt;性能更高效.
    + 多个 NameNode 管理不同的数据, 且同时对外提供服务, 将为用户提供更高的读写吞吐率.&lt;/li&gt;
&lt;li&gt;良好的隔离性.
    + 用户可根据需要将不同业务数据交由不同 NameNode 管理, 这样不同业务之间影响很小.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/Hadoop新特性/HDFS联邦.png"/&gt;&lt;/p&gt;
&lt;h2 id="_1"&gt;块池&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;块池&lt;/strong&gt;是逻辑上的概念, 就是属于单个命名空间的一组块, 它并不是以 DataNode 的个数来划分, 而是将所有的 DataNode 当成一个整体来划分, 所以, 同一个 DataNode 中的块可以被分给多个不同的 Block Pool.&lt;/p&gt;
&lt;p&gt;Block Pool 允许一个 NameNode 在不通知其他 NameNode 的情况下为一个新的 Block 创建 Block ID, 但由于 DataNode 会向所有 NameNode 发送心跳及块报告, 所以其它 NameNode 也会知道这个 Block 的使用情况, 这样一个 NameNode 失效就不会影响到其下的 DataNode 为其他 NameNode 继续服务.&lt;/p&gt;
&lt;p&gt;当向集群存储数据时, 集群先为其分配 NameNode 创建命名空间, 然后 Block Pools 从 DataNode 上寻找空闲 Block 加入当前 NameNode 所管辖下的块池, 最后 NameNode 将数据存放进这些 Block.&lt;/p&gt;
&lt;h2 id="_2"&gt;多命名空间的管理问题&lt;/h2&gt;
&lt;p&gt;为了方便管理多个命名空间, HDFS Federation 采用了经典的 &lt;strong&gt;Client Side Mount Table&lt;/strong&gt; 方式.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/高可靠联盟/ClientSideMountTable.png"/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示, 每个深色三角形代表一个独立的命名空间, 上方浅色的三角形代表从客户角度去访问下方的子命名空间. 各个深色的命名空间 Mount 到浅色的表中, 客户可以访问不同的挂载点来访问不同的命名空间, 这就如同在 Linux 系统中访问不同&lt;strong&gt;挂载点&lt;/strong&gt;一样.&lt;/p&gt;
&lt;h2 id="federation_1"&gt;配置 Federation&lt;/h2&gt;
&lt;p&gt;还没实操过, 需要的时候参考 (主要是 &lt;code&gt;core-site.xml&lt;/code&gt; 中 &lt;strong&gt;viewfs&lt;/strong&gt; 及 &lt;code&gt;hdfs-site.xml&lt;/code&gt; 中 &lt;strong&gt;nameservices&lt;/strong&gt; 的配置):&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.infoq.com/cn/articles/hadoop-2-0-namenode-ha-federation-practice-zh"&gt;Hadoop 2.0 NameNode HA 和 Federation 实践&lt;/a&gt; (为防止链接失效, 我摘到了 &lt;strong&gt;OneNote&lt;/strong&gt; 中: &lt;code&gt;我的笔记本/Hadoop 拾遗/Hadoop 2.0 NameNode HA 和 Federation 实践&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.cnblogs.com/nb591/p/3535662.html"&gt;搭建 Hadoop 2.2.0 HA &amp;amp;&amp;amp; Federation&lt;/a&gt; (为防止链接失效, 我摘到了 &lt;strong&gt;OneNote&lt;/strong&gt; 中: &lt;code&gt;我的笔记本/Hadoop 拾遗/搭建 Hadoop 2.2.0 HA &amp;amp;&amp;amp; Federation&lt;/code&gt;)&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;需要注意一点的就是, Federation 需要在每个 NameNode 上分别格式化, 第一个 NameNode 可以使用之前的 &lt;code&gt;hdfs namenode -format&lt;/code&gt; 命令进行格式化, 格式化后就会产生一个 &lt;strong&gt;ClusterId&lt;/strong&gt;, 剩下的 NameNode 需要指定 &lt;strong&gt;ClusterId&lt;/strong&gt; 进行格式化: &lt;code&gt;hdfs namenode -format -clusterId&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="java-api"&gt;Java API&lt;/h2&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;ViewFileSystem fsView = (ViewFileSystem)ViewFileSystem.&lt;span style="color: #658b00"&gt;get&lt;/span&gt;(conf);
MountPoint[] m = fsView.&lt;span style="color: #658b00"&gt;getMountPoints&lt;/span&gt;();
&lt;span style="color: #8B008B; font-weight: bold"&gt;for&lt;/span&gt; (MountPoint m1 : m) {
    System.&lt;span style="color: #658b00"&gt;out&lt;/span&gt;.&lt;span style="color: #658b00"&gt;println&lt;/span&gt;(m1.&lt;span style="color: #658b00"&gt;getSrc&lt;/span&gt;());
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="2x"&gt;2.X 高可靠&lt;/h1&gt;
&lt;p&gt;Reference: &lt;a href="http://www.cnblogs.com/sy270321/p/4398815.html"&gt;Hadoop2 NameNode HA 原理详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hadoop2 NameNode HA 方案让 NameNode 有个备份节点, 当 NameNode 宕掉了, 备份节点就接管 NameNode 的职责.&lt;/p&gt;
&lt;h2 id="_3"&gt;原理&lt;/h2&gt;
&lt;p&gt;需要用到集群: &lt;strong&gt;JournalNodes&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;两个 NameNode 通过 JournalNodes 通信, 共享 NameNode 数据.&lt;/p&gt;
&lt;p&gt;NameNode 有两种状态, 一种是激活状态 &lt;strong&gt;Active&lt;/strong&gt;, 另一种是准备状态 &lt;strong&gt;Standby&lt;/strong&gt;;&lt;/p&gt;
&lt;p&gt;Active 对外提供服务, 当 Active 数据发生变化, 它会同步到 JournalNodes, JournalNodes 收到变化后同步给 Standby, 当 Active 宕掉, Standby 就可以接管.&lt;/p&gt;
&lt;h2 id="_4"&gt;接管方式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;手动接管&lt;/li&gt;
&lt;li&gt;自动接管, 要通过 FailoverController (故障转移控制器) 去实现, 而 FailoverController 是属于 &lt;a href="http://www.smallcpp.cn/07-zookeeper-jian-jie.html"&gt;zookeeper&lt;/a&gt; 集群的一部分.&lt;/li&gt;
&lt;/ul&gt;</content><category term="大数据"></category></entry><entry><title>09. 小文件解决方案</title><link href="http://www.smallcpp.cn/09-xiao-wen-jian-jie-jue-fang-an.html" rel="alternate"></link><published>2016-11-23T18:27:00+08:00</published><updated>2016-11-23T18:27:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-11-23:/09-xiao-wen-jian-jie-jue-fang-an.html</id><summary type="html">&lt;p&gt;小文件解决方案&lt;/p&gt;</summary><content type="html">
&lt;blockquote&gt;
&lt;p&gt;所谓的小文件指的是小于一个 block size 的文件.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id="_1"&gt;可选方案&lt;/h1&gt;
&lt;p&gt;对于&lt;strong&gt;尚未上传&lt;/strong&gt;到 HDFS 的文件, 可以采用以下几种方案:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用程序自己合并文件上传 (要根据实际情况来, 因为上传后不好处理)&lt;/li&gt;
&lt;li&gt;SequenceFile/MapFile, 同样需要自己编程上传文件, 上传的数据将被打包成 k, v 的形式&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;通常对于 “the small files problem” 的回应会是: 使用 SequenceFile.&lt;br/&gt;
这种方法是说, 使用 filename 作为 key, 而 file contents 作为 value.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于&lt;strong&gt;已存在&lt;/strong&gt;于 HDFS 上的文件, 可以使用:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hadoop Archives (HAR files, 类似 zip/rar 的文件归档功能, 打完包后, 需要&lt;strong&gt;手动删除&lt;/strong&gt;被打包前的文件)&lt;/li&gt;
&lt;li&gt;CombineFileInputFormat (MR 的内容)&lt;/li&gt;
&lt;li&gt;HBase compact (HBase 的内容, 把多个 HFile 合并成一个 HFile)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CombineFileInputFormat 及 HBase compact 将在后面的 MR 及 HBase 专题记录, 本篇介绍下 Hadoop Archives.&lt;/p&gt;
&lt;h1 id="hadoop-archives"&gt;Hadoop Archives&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;References&lt;/strong&gt;:&lt;br/&gt;
&lt;a href="http://blog.csdn.net/lastsweetop/article/details/9123155"&gt;Hadoop 深入研究: (五) —— Archives&lt;/a&gt;&lt;br/&gt;
&lt;a href="https://my.oschina.net/u/270950/blog/170570"&gt;Hadoop 关于处理大量小文件的问题和解决方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hadoop Archives (HAR files) 是在 0.18.0 版本中引入的, 它的出现就是为了缓解大量小文件消耗 NameNode 内存的问题.&lt;/p&gt;
&lt;p&gt;HAR 文件是通过在 HDFS 上构建一个层次化的文件系统来工作, HAR 文件一旦创建便不可再更改.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/小文件处理/harindex.png"/&gt;&lt;/p&gt;
&lt;p&gt;HAR 文件通过 Hadoop 的 Archive 命令来创建, 而这个命令实际上也是运行了一个 &lt;strong&gt;MapReduce&lt;/strong&gt; 任务来将小文件打包成 HAR.&lt;/p&gt;
&lt;p&gt;对于 client 端来说, 使用 HAR 文件没有任何影响, 所有的原始文件都可见&amp;amp;&amp;amp;透明, 但在HDFS端它内部的文件数减少了.&lt;/p&gt;
&lt;p&gt;通过 HAR 来读取一个文件并不会比直接从 HDFS 中读取文件高效, 而且实际上可能还会稍微&lt;strong&gt;低效&lt;/strong&gt;一点, 因为对每一个 HAR 文件的访问都需要完成两层 index 文件的读取和文件本身数据的读取 (见上图). 并且尽管 HAR 文件可以被用来作为 &lt;strong&gt;MapReduce job&lt;/strong&gt; 的 input, 但是并没有特殊的方法来使 maps 将 HAR 文件中打包的文件当作一个 HDFS 文件处理.&lt;/p&gt;
&lt;p&gt;总结一下就是说 HAR:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过将小文件打包成一个大文件来减少 NameNode 的内存消耗&lt;/li&gt;
&lt;li&gt;虽然可以 HAR 当成一个包传递成 Map 任务, 但是实际处理时, 并不是将它看作一个文件, 而是以打包前的数据进行处理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;创建文件&lt;/strong&gt;: &lt;code&gt;hadoop archive -archiveName xxx.har -p  /src  /dest&lt;/code&gt; (-p 参数指定要打包的目录和目的地目录)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查看内容&lt;/strong&gt;: &lt;code&gt;hadoop fs -lsr har:///dest/xxx.har&lt;/code&gt; (注意 har:/// 协议)&lt;/p&gt;</content><category term="大数据"></category></entry><entry><title>RUP 核心工作流及模板</title><link href="http://www.smallcpp.cn/rup-he-xin-gong-zuo-liu-ji-mo-ban.html" rel="alternate"></link><published>2016-11-14T19:02:00+08:00</published><updated>2016-11-14T19:02:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-11-14:/rup-he-xin-gong-zuo-liu-ji-mo-ban.html</id><summary type="html">&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a href="http://pan.baidu.com/s/1jI4VeHw"&gt;RUP 项目模板&lt;/a&gt; 密码: &lt;code&gt;ownc&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;RUP 中有 9 个核心工作流, 分为 6 个核心过程工作流 (Core Process Workflows) 和 3 个核心支持工作流 (Core Supporting Workflows). 尽管 6 个核心过程工作流可能使人想起传统瀑布模型中的几个阶段, 但应注意迭代过程中的阶段是完全不同的, 这些工作流在整个生命周期中一次又一次被访问. 9 个核心工作流在项目中轮流被使用, 在每一次迭代中以不同的重点和强度重复.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;商业建模&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;商业建模 …&lt;/p&gt;</summary><content type="html">&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a href="http://pan.baidu.com/s/1jI4VeHw"&gt;RUP 项目模板&lt;/a&gt; 密码: &lt;code&gt;ownc&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;RUP 中有 9 个核心工作流, 分为 6 个核心过程工作流 (Core Process Workflows) 和 3 个核心支持工作流 (Core Supporting Workflows). 尽管 6 个核心过程工作流可能使人想起传统瀑布模型中的几个阶段, 但应注意迭代过程中的阶段是完全不同的, 这些工作流在整个生命周期中一次又一次被访问. 9 个核心工作流在项目中轮流被使用, 在每一次迭代中以不同的重点和强度重复.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;商业建模&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;商业建模 (Business Modeling) 工作流描述了如何为新的目标组织开发一个构想, 并基于这个构想在商业用例模型和商业对象模型中定义组织的过程, 角色和责任.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;需求 (Requirement) 工作流的目标是描述系统应该做什么, 并使开发人员和用户就这一描述达成共识. 为了达到该目标, 要对需要的功能和约束进行提取、组织、文档化; 最重要的是理解系统所解决问题的定义和范围.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析和设计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分析和设计 (Analysis &amp;amp; Design) 工作流将需求转化成未来系统的设计, 为系统开发一个健壮的结构并调整设计使其与实现环境相匹配, 优化其性能. 分析设计的结果是一个设计模型和一个可选的分析模型. 设计模型是源代码的抽象, 由设计类和一些描述组成. 设计类被组织成具有良好接口的设计包 (Package) 和设计子系统 (Subsystem), 而描述则体现了类的对象如何协同工作实现用例的功能. 设计活动以体系结构设计为中心, 体系结构由若干结构视图来表达, 结构视图是整个设计的抽象和简化, 该视图中省略了一些细节, 使重要的特点体现得更加清晰. 体系结构不仅仅是良好设计模型的承载媒介, 而且在系统的开发中能提高被创建模型的质量.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实现 (Implementation) 工作流的目的包括以层次化的子系统形式定义代码的组织结构; 以组件的形式 (源文件、二进制文件、可执行文件) 实现类和对象; 将开发出的组件作为单元进行测试以及集成由单个开发者 (或小组) 所产生的结果, 使其成为可执行的系统.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;测试 (Test) 工作流要验证对象间的交互作用, 验证软件中所有组件的正确集成, 检验所有的需求已被正确的实现, 识别并确认缺陷在软件部署之前被提出并处理. RUP提出了迭代的方法, 意味着在整个项目中进行测试, 从而尽可能早地发现缺陷, 从根本上降低了修改缺陷的成本. 测试类似于三维模型, 分别从可靠性、功能性和系统性能来进行.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;部署&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;部署 (Deployment) 工作流的目的是成功的生成版本并将软件分发给最终用户. 部署工作流描述了那些与确保软件产品对最终用户具有可用性相关的活动, 包括: 软件打包、生成软件本身以外的产品、安装软件、为用户提供帮助. 在有些情况下, 还可能包括计划和进行beta测试版、移植现有的软件和数据以及正式验收.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置和变更管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;配置和变更管理工作流描绘了如何在多个成员组成的项目中控制大量的产物. 配置和变更管理工作流提供了准则来管理演化系统中的多个变体, 跟踪软件创建过程中的版本. 工作流描述了如何管理并行开发、分布式开发、如何自动化创建工程. 同时也阐述了对产品修改原因、时间、人员保持审计记录.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;项目管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;软件项目管理 (Project Management) 平衡各种可能产生冲突的目标, 管理风险, 克服各种约束并成功交付使用户满意的产品. 其目标包括: 为项目的管理提供框架, 为计划、人员配备、执行和监控项目提供实用的准则, 为管理风险提供框架等.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;环境&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;环境 (Environment) 工作流的目的是向软件开发组织提供软件开发环境, 包括过程和工具. 环境工作流集中于配置项目过程中所需要的活动, 同样也支持开发项目规范的活动, 提供了逐步的指导手册并介绍了如何在组织中实现过程.&lt;/p&gt;</content><category term="软件工程"></category></entry><entry><title>JMS AMQP 对比表</title><link href="http://www.smallcpp.cn/jms-amqp-dui-bi-biao.html" rel="alternate"></link><published>2016-11-13T18:38:00+08:00</published><updated>2016-11-13T18:38:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-11-13:/jms-amqp-dui-bi-biao.html</id><content type="html">&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/JMSAMQP对比表/jmsamqp.png"&gt;&lt;/p&gt;</content><category term="软件工程"></category></entry><entry><title>Hadoop Storm 概念对照表</title><link href="http://www.smallcpp.cn/hadoop-storm-gai-nian-dui-zhao-biao.html" rel="alternate"></link><published>2016-11-13T18:34:00+08:00</published><updated>2016-11-13T18:34:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-11-13:/hadoop-storm-gai-nian-dui-zhao-biao.html</id><content type="html">&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/搭建Hadoop分布式实验环境/HadoopStorm.png"&gt;&lt;/p&gt;</content><category term="大数据"></category></entry><entry><title>SecureCRT 的安装和使用</title><link href="http://www.smallcpp.cn/securecrt-de-an-zhuang-he-shi-yong.html" rel="alternate"></link><published>2016-11-11T21:09:00+08:00</published><updated>2016-11-11T21:09:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-11-11:/securecrt-de-an-zhuang-he-shi-yong.html</id><summary type="html">&lt;p&gt;&lt;strong&gt;SecureCRT&lt;/strong&gt; 是一款支持 SSH（SSH1 和 SSH2）的终端仿真程序, 同时支持 Telnet 和 rlogin 协议; 它可用于连接运行包括 Windows、Unis 和 linux 在内的远程系统.&lt;/p&gt;
&lt;p&gt;首先下载 SecureCRT 并安装(网上有中文版本下载, 注意找大网站下载, 别下载了被装后门的版本).&lt;/p&gt;
&lt;p&gt;去 Ubuntu 中开启 SSH 功能. (SSH …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;strong&gt;SecureCRT&lt;/strong&gt; 是一款支持 SSH（SSH1 和 SSH2）的终端仿真程序, 同时支持 Telnet 和 rlogin 协议; 它可用于连接运行包括 Windows、Unis 和 linux 在内的远程系统.&lt;/p&gt;
&lt;p&gt;首先下载 SecureCRT 并安装(网上有中文版本下载, 注意找大网站下载, 别下载了被装后门的版本).&lt;/p&gt;
&lt;p&gt;去 Ubuntu 中开启 SSH 功能. (SSH 为 Secure Shell 的缩写, 即安全外壳协议, 它是由 IETF 的网络工作小组（Network Working Group）所制定; SSH 是建立在应用层和传输层基础上的安全协议; 它专为远程登录会话和其他网络服务提供安全性的协议.)
在 Ubuntu 中开启 SSH 功能只需要一句命令: sudo apt-get install openssh-server openssh-client&lt;/p&gt;
&lt;p&gt;查看 Ubuntu 的 ip, 在终端输入命令: ifconfig(注意不是 ipconfig).&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i62.tinypic.com/fvfr40.jpg"&gt;&lt;/p&gt;
&lt;p&gt;记录下 ip 地址.&lt;/p&gt;
&lt;p&gt;返回 SecureCRT 中, 选择 快速连接.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i61.tinypic.com/33lfmt1.jpg"&gt;&lt;/p&gt;
&lt;p&gt;输入 Ubuntu 的 ip 地址和用户名.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i60.tinypic.com/15zo868.jpg"&gt;&lt;/p&gt;
&lt;p&gt;点击连接, 会弹出对话框让输入密码, 输入确定即可.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i57.tinypic.com/6dyec6.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i60.tinypic.com/1zoj2hc.jpg"&gt;&lt;/p&gt;
&lt;p&gt;此时输入中文可能会显示乱码, 这是因为 Ubuntu 的 ssh 默认编码是 utf-8, 而 SecureCRT 却不是, 所以只要把 SecureCRT 的编码改成 utf-8 就可以了.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i60.tinypic.com/344qskp.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i58.tinypic.com/30u3j46.jpg"&gt;&lt;/p&gt;
&lt;p&gt;SecureCRT连接后如果稍长时间不用就会掉线, 往往会造成工作状态的丢失, 如下设置可以始终保持 SecureCRT 的连接:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i62.tinypic.com/2uhr0h3.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i61.tinypic.com/wl7m88.jpg"&gt;&lt;/p&gt;
&lt;p&gt;另外还有几个有用的配置:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i67.tinypic.com/sw6yrt.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i63.tinypic.com/34rjfvd.jpg"&gt;&lt;/p&gt;
&lt;p&gt;现在远程操作环境就搭建好了, 可以在 SecureCRT 中像 Ubuntu 终端那样使用.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i58.tinypic.com/ics9dd.jpg"&gt;&lt;/p&gt;</content><category term="工具折腾"></category></entry><entry><title>浅聊架构师</title><link href="http://www.smallcpp.cn/qian-liao-jia-gou-shi.html" rel="alternate"></link><published>2016-11-10T13:27:00+08:00</published><updated>2016-11-10T13:27:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-11-10:/qian-liao-jia-gou-shi.html</id><summary type="html">&lt;p&gt;简单聊聊架构师及其职责.&lt;/p&gt;</summary><content type="html">&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;成为架构师也许是大部分 IT 人士的目标, 我也不例外, 但在与同事 (同行) 的交流中, 我发现大部分人对架构的理解都是比较片面的, 例如:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运维人员会认为架构师的职责在于为系统提供一个可伸缩、高并发、高可靠的开发/生产环境;&lt;/li&gt;
&lt;li&gt;而开发的眼中, 却认为架构师就是设计出高内聚低耦合、可维护、可扩展的程序代码, 甚至还有些人认为架构就是分层, 比如 &amp;ldquo;三层架构&amp;rdquo;（或者四层、五层&amp;hellip;反正分层越多就说明项目越复杂而且架构就越牛）.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那哪种说法正确呢?&lt;/p&gt;
&lt;p&gt;其实都正确, 只是所处的方向不同, 架构师是一个统称, 不同的架构方法论, 会将架构分为不同视图, 每个视图侧重某一个方面、领域的问题.&lt;/p&gt;
&lt;p&gt;比如希赛推的 &lt;strong&gt;ADMEMS&lt;/strong&gt; 架构体系, 分为以下几种视图:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;物理架构: 描述机器的物理部署、网络拓扑方面.&lt;/li&gt;
&lt;li&gt;数据架构: 描述数据的存储结构、格式等方面.&lt;/li&gt;
&lt;li&gt;运行架构: 描述运行期线程、进程间的交互工作机制.&lt;/li&gt;
&lt;li&gt;逻辑架构: 指如何将代码分成不同模块、组件, 以及之间的职责分配、交互行为.&lt;/li&gt;
&lt;li&gt;开发架构: 主要指开发工具的选择, 程序单元的划分, 开发管理规范流程等方面. 例如分为哪些工程、项目, 源代码管理, 自动化编译构建、测试、部署等.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;目前国际上运用比较广泛的是 &lt;strong&gt;TOGAF&lt;/strong&gt; 架构体系, 它把架构分为业务架构、数据架构、应用架构、技术架构等几个方面.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实际上很少有公司是严格按照这五种视图去分工和设计的, 在我看来, 架构师大致分为两个方向: &lt;strong&gt;系统架构师&lt;/strong&gt;（有些企业叫&lt;strong&gt;运维架构师&lt;/strong&gt;）和&lt;strong&gt;软件架构师&lt;/strong&gt;. 前两种视图, 可以归纳为系统架构, 而后三种架构, 则归为软件架构.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统架构师 (运维架构师)
    + 物理架构
    + 数据架构&lt;/li&gt;
&lt;li&gt;软件架构师
    + 运行架构
    + 逻辑架构
    + 开发架构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在国内大部分中小型互联网公司, 基于处于这种现状, 有些牛逼的人士则身兼两职 (这是不是应该叫 &lt;strong&gt;CTO&lt;/strong&gt;?), 我记得以前有人曾总结过: 天朝的架构师就是&lt;strong&gt;会运维的高级开发&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="缩进" src="http://www.smallcpp.cn/theme/images/架构师/架构师.png"&gt;&lt;/p&gt;
&lt;p&gt;我的方向是软件架构师, 私认为一个软件架构师的职责应该会贯穿整个软件生命周期:&lt;br&gt;
&lt;strong&gt;需求分析&lt;/strong&gt; -&gt; &lt;strong&gt;概要设计&lt;/strong&gt; -&gt; &lt;strong&gt;详细设计&lt;/strong&gt; -&gt; &lt;strong&gt;代码实现&lt;/strong&gt; -&gt; &lt;strong&gt;集成构建、QA&lt;/strong&gt; -&gt; &lt;strong&gt;反复迭代&lt;/strong&gt; -&gt; &lt;strong&gt;项目交付&lt;/strong&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;概要设计是&lt;strong&gt;黑盒&lt;/strong&gt;设计, 系统功能的实现可能需要一些外部参与者, 概要设计即表达出各系统间的关系及交互, 属于&amp;rdquo;外部&amp;rdquo;设计.&lt;/li&gt;
&lt;li&gt;详细设计是&lt;strong&gt;白盒&lt;/strong&gt;设计, 逻辑架构的划分 (分层)、模块的划分、模式的选择、接口的设计、数据库建模等等, 属于&amp;rdquo;内部&amp;rdquo;设计.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果成为软件架构师? 参考: &lt;a href="http://www.smallcpp.cn/cong-cheng-xu-yuan-dao-ruan-jian-jia-gou-shi.html"&gt;从程序员到软件架构师&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我的这篇 blog 的标题是 &amp;ldquo;浅聊&amp;rdquo;, 目的是为了让 IT 新人理解什么是架构师, 以及架构师的职责 (只是我个人的理解), 而至于到底要怎么设计, 就又是另一套可发散性的讨论话题了, 也根本没有什么固定标准可言, 但基本思想是相通的, 重要的东西还是需要以心传心~&lt;/p&gt;</content><category term="软件工程"></category></entry><entry><title>Maven</title><link href="http://www.smallcpp.cn/maven.html" rel="alternate"></link><published>2016-11-09T21:28:00+08:00</published><updated>2016-11-09T21:28:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-11-09:/maven.html</id><summary type="html">
&lt;h1 id="_1"&gt;介绍&lt;/h1&gt;
&lt;p&gt;maven 是一个基于 POM (项目对象模型) 的项目管理和构建自动化工具, 通过它便捷的管理项目生命周期. 即项目的 jar 包依赖、开发、测试、打包和发布.&lt;/p&gt;
&lt;p&gt;可以下载最新版本, 也可以下载经典版本: &lt;a href="http://archive.apache.org/dist/maven/maven-3/3.0.5/binaries/"&gt;maven 3.0.5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于我个人来说, 使用了 maven 最大的好处就是不再需要上网单独下载 jar 包, 只需要在配置文件 &lt;code&gt;pom.xml&lt;/code&gt; 中配置 jar …&lt;/p&gt;</summary><content type="html">
&lt;h1 id="_1"&gt;介绍&lt;/h1&gt;
&lt;p&gt;maven 是一个基于 POM (项目对象模型) 的项目管理和构建自动化工具, 通过它便捷的管理项目生命周期. 即项目的 jar 包依赖、开发、测试、打包和发布.&lt;/p&gt;
&lt;p&gt;可以下载最新版本, 也可以下载经典版本: &lt;a href="http://archive.apache.org/dist/maven/maven-3/3.0.5/binaries/"&gt;maven 3.0.5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于我个人来说, 使用了 maven 最大的好处就是不再需要上网单独下载 jar 包, 只需要在配置文件 &lt;code&gt;pom.xml&lt;/code&gt; 中配置 jar 包的依赖关系, 就可以自动的下载 jar 包到我们的项目中. 当移植项目时也不再需要来回的拷贝依赖包, 只需要复制这个 pom.xml 就可以自动的下载这些 jar 包. 这样做还能避免依赖包版本的不一致的问题.&lt;/p&gt;
&lt;p&gt;maven 通过在 &lt;code&gt;pom.xml&lt;/code&gt; 中配置特定的标识来定义项目名称, 这样既可以唯一的匹配其他的 jar 包, 也可以通过发布, 使别人能使用自己发布的 jar 包:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.smallcpp&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maventest&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;0.0.1&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;packaging&amp;gt;&lt;/span&gt;jar&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/packaging&amp;gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;maventest&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;url&amp;gt;&lt;/span&gt;http://maven.apache.org&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;主要就是上面的几个参数:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;groupId&lt;/strong&gt;: 所述的项目名称, 由于有的项目并不是一个 jar 包构成的, 而是由很多的 jar 包组成的. 因此这个 groupId 就是整个项目的名称.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;artifactId&lt;/strong&gt;: 包的名称.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;version&lt;/strong&gt;: 版本号.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;packaging&lt;/strong&gt;: 包的类型, 一般都是jar, 也可以是war之类的. 如果不填, 默认就是jar.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;name&lt;/strong&gt; 和 &lt;strong&gt;url&lt;/strong&gt;: 一个是名称, 一个是 maven 的地址.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="_2"&gt;配置&lt;/h1&gt;
&lt;p&gt;下载 maven 后解压到任意位置 (例如 D:/apache-maven-3.0.5), 然后在修改环境变量:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;M2_HOME: D/apache-maven-3.0.
PATH: %M2_NOME%/bin
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后打开 cmd 查看是否设置成功:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;mvn -version 查看版本
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的介绍中已经提到过了, maven 会自动下载 jar 包, 所以要配置下本地 jar 包的存放目录, maven 的设置文件是 &lt;code&gt;M2_HOME/conf/settings.xml&lt;/code&gt;, 我们找到其中的 &lt;code&gt;localRepository&lt;/code&gt; 标签, 改成:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;localRepository&amp;gt;F:/.m2/repositorys&amp;lt;/localRepository&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;maven 中三个仓库的概念: &lt;strong&gt;本地仓库&lt;/strong&gt; -&amp;gt; &lt;strong&gt;远程仓库&lt;/strong&gt; -&amp;gt; &lt;strong&gt;中央仓库&lt;/strong&gt;, maven 查找 jar 包也是按这个顺序.&lt;/p&gt;
&lt;p&gt;本地仓库就是我们上面配置的 &lt;code&gt;localRepository&lt;/code&gt;, 当 maven 在这个仓库没有找到想要的 jar 包时, 就会去远程仓库寻找, 远程仓库的地址需要我们自己设置, 如果没有设置 (或者在远程仓库也没找到想要的 jar 包), 就会再去中央仓库中找, 如果还没找到, 就会报错.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;远程仓库&lt;/strong&gt; 可以在项目的 &lt;code&gt;pom.xml&lt;/code&gt; 中设置, 但由于远程仓库的设置通常是想达到全局的效果, 所以也可以在 &lt;code&gt;M2_HOME/conf/settings.xml&lt;/code&gt; 中通过 &lt;strong&gt;profile&lt;/strong&gt; 设置 (具体的 profile 详细说明参见: &lt;a href="http://elim.iteye.com/blog/1900568"&gt;Maven 简介 —— profile 介绍&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;如下, 我们配置了阿里云做为远程仓库, 将其 &lt;strong&gt;id&lt;/strong&gt; 设为 &lt;strong&gt;alimaven&lt;/strong&gt;, 并且在 &lt;code&gt;activeProfile&lt;/code&gt; 标签中激活这个 &lt;strong&gt;id&lt;/strong&gt; (注意, 远程仓库需要 “激活” 才能使用, 除了 &lt;code&gt;activeProfile&lt;/code&gt; 标签, 其它激活方式参见上面的 &lt;em&gt;Maven 简介 —— profile 介绍&lt;/em&gt;).&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;profiles&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;profile&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;alimaven&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;repositories&amp;gt;&lt;/span&gt;
            &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;repository&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;nexus&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;local private nexus&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;url&amp;gt;&lt;/span&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;releases&amp;gt;&lt;/span&gt;
                    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;enabled&amp;gt;&lt;/span&gt;true&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/enabled&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/releases&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;snapshots&amp;gt;&lt;/span&gt;
                    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;enabled&amp;gt;&lt;/span&gt;false&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/enabled&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/snapshots&amp;gt;&lt;/span&gt;
            &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/repository&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/repositories&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;pluginRepositories&amp;gt;&lt;/span&gt;
            &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;pluginRepository&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;nexus&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;local private nexus&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;url&amp;gt;&lt;/span&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;releases&amp;gt;&lt;/span&gt;
                    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;enabled&amp;gt;&lt;/span&gt;true&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/enabled&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/releases&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;snapshots&amp;gt;&lt;/span&gt;
                    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;enabled&amp;gt;&lt;/span&gt;false&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/enabled&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/snapshots&amp;gt;&lt;/span&gt;
            &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/pluginRepository&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/pluginRepositories&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/profile&amp;gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/profiles&amp;gt;&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;activeProfiles&amp;gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;activeProfile&amp;gt;&lt;/span&gt;alimaven&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/activeProfile&amp;gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/activeProfiles&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外, 中央仓库其实就是 maven 默认给我们配好的 &lt;strong&gt;id&lt;/strong&gt; 为 &lt;strong&gt;central&lt;/strong&gt; 的仓库, 它的配置大概像下面这样 (这个配置在 maven 2.0 版本中位于 &lt;code&gt;${M2_HOME}/lib/maven-2.0.10-uber.jar/pom-4.0.0.xml&lt;/code&gt;, 后面的版本我没找到…不过应该也差不多):&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;repositories&amp;gt;&lt;/span&gt;
  &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;repository&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;central&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;Maven Repository Switchboard&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;layout&amp;gt;&lt;/span&gt;default&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/layout&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;url&amp;gt;&lt;/span&gt;http://repo1.maven.org/maven2&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;snapshots&amp;gt;&lt;/span&gt;
      &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;enabled&amp;gt;&lt;/span&gt;false&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/enabled&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/snapshots&amp;gt;&lt;/span&gt;
  &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/repository&amp;gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/repositories&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到中央仓库的 ID 为 &lt;code&gt;central&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;maven 还提供镜像的配置, 让我们可以为仓库设置&lt;strong&gt;镜像&lt;/strong&gt;, 在 &lt;code&gt;M2_HOME/conf/settings.xml&lt;/code&gt; 中的 &lt;code&gt;mirror&lt;/code&gt; 标签配置 (老实说, 为远程仓库配置镜像并没什么卵用, 反正地址都是我自己配, 给中央仓库设计镜像也没有必要, 还不如将镜像地址当做一个远程仓库设置, 这样镜像中找不到 jar 时还会去中央仓库再找一次, 多好 . . .).&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;mirrors&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;mirror&amp;gt;&lt;/span&gt;
          &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;alimaven&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
          &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;aliyun maven&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
          &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;url&amp;gt;&lt;/span&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/url&amp;gt;&lt;/span&gt;
          &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;mirrorOf&amp;gt;&lt;/span&gt;central&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/mirrorOf&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/mirror&amp;gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/mirrors&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;mirrorOf&lt;/code&gt; 标签指定要镜像哪个仓库.&lt;/p&gt;
&lt;h1 id="_3"&gt;生命周期&lt;/h1&gt;
&lt;p&gt;最开始说到 maven 可以便捷的管理项目生命周期, maven 有三套相互独立的生命周期, 请注意这里说的是 “三套”, 而且 “相互独立”, 初学者容易将 maven 的生命周期看成一个整体, 其实不然;&lt;/p&gt;
&lt;p&gt;这三套生命周期分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Clean Lifecycle&lt;/strong&gt; 在进行真正的构建之前进行一些清理工作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Default Lifecycle&lt;/strong&gt; (或称 Build Lifecycle) 构建的核心部分, 编译, 测试, 打包, 部署等等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Site Lifecycle&lt;/strong&gt; 生成项目报告, 站点, 发布站点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Default Lifecycle&lt;/strong&gt; 定义了真正构建时所需要执行的大部分步骤, 它是生命周期中最核心的部分, 它大概如下图这样:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/MAVEN/Default阶段.png"/&gt;&lt;/p&gt;
&lt;p&gt;在每段生命周期内 maven 都提供了 mvn &lt;strong&gt;命令&lt;/strong&gt;来维护该阶段, 对于 Default Lifecycle:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;generate-sources&lt;/strong&gt;: 通常是通过插件支持创建额外的源代码&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;compile&lt;/strong&gt;: 编译项目应用代码&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;test-compile&lt;/strong&gt;: 编译项目单元测试代码&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;test&lt;/strong&gt;: 运行项目单元测试 (一般为 Junit 测试)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;package&lt;/strong&gt;: 打包项目可以执行代码 (以 Jar/War/Ear 形式)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;integration-test&lt;/strong&gt;: 如有需要处理及部署应用以便执行系统集成测试&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;install&lt;/strong&gt;: 将应用打包发布到本地 maven 软件包以便其它 maven 引用 (注意 Install 不是指安装 Java 应用)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;deploy&lt;/strong&gt;: 发布到远程 maven 软件包以便其他 maven 项目下载引用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;阶段内的命令是&lt;strong&gt;有序&lt;/strong&gt;的, 每个命令的调用会自动调用其前面的阶段命令, 所以大部分情况下, 我们使用 &lt;code&gt;mvn install&lt;/code&gt; 就可以了.&lt;/p&gt;
&lt;p&gt;另一个常用的命令是 &lt;code&gt;mvn clean&lt;/code&gt; 用来清理项目环境, 如删除项目目录下的 target 目录 (已发布到本地仓库的需要自行控制), 但它属于 Clean Lifecycle 阶段的命令, 和 &lt;code&gt;mvn install&lt;/code&gt; 在不同的生命周期, 所以执行 &lt;code&gt;mvn install&lt;/code&gt; 时不会主动去执行 &lt;code&gt;mvn clean&lt;/code&gt;, 因此, 我们通常和 package/install 组合使用:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;mvn clean package
或者
mvn clean install
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="eclipse"&gt;Eclipse 插件&lt;/h1&gt;
&lt;p&gt;Eclipse 提供了 maven 插件来方便我们使用, 该插件可以让我们在 Eclipse 上快速新建 maven 项目、导入 maven 项目及转换 maven 项目等.&lt;/p&gt;
&lt;p&gt;新版本的 Eclipse 已集成了 maven 插件, 无须再手动下载, 我们只需配置一下, 主要设置三样: 是否自动下载源码、本地 maven 环境 (Eclipse 有内置的, 不过建议用我们下载的 3.0.5) 以及配置文件目录.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/MAVEN/MAVEN插件设置1.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/MAVEN/MAVEN插件设置2.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/MAVEN/MAVEN插件设置3.png"/&gt;&lt;/p&gt;
&lt;p&gt;我们可以新建 maven 项目, 也可以从现有的 java 项目转换:&lt;/p&gt;
&lt;p&gt;从现有项目&lt;strong&gt;转换&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/MAVEN/现有项目转换MAVEN.png"/&gt;&lt;/p&gt;
&lt;p&gt;或者&lt;strong&gt;新建&lt;/strong&gt; maven 项目:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/MAVEN/新建MAVEN.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/MAVEN/简单项目.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/MAVEN/创建POM.png"/&gt;&lt;/p&gt;
&lt;p&gt;maven 项目的左上角有个 &lt;strong&gt;m&lt;/strong&gt; 标记, 并且项目下有 &lt;code&gt;pom.xml&lt;/code&gt; 文件:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/MAVEN/MAVEN项目结构.png"/&gt;&lt;/p&gt;
&lt;p&gt;并且项目右键多了个一些 maven 选项:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/MAVEN/常用MAVEN菜单.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/MAVEN/MAVENRUNAS.png"/&gt;&lt;/p&gt;
&lt;p&gt;说下 &lt;code&gt;mvn build&lt;/code&gt; 这个选项, mvn 是没有这个命令的, 这个命令菜单是 Eclipse 提供一个接口, 选择该菜单就能通过配置来执行任意 mvn 命令, 如 &lt;code&gt;mvn clean install&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/MAVEN/RUNCONFIG.png"/&gt;&lt;/p&gt;
&lt;p&gt;如果配置错了, 可以在下面这里进行修改:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/MAVEN/RUNCONFIG0.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/MAVEN/RUNCONFIG1.png"/&gt;&lt;/p&gt;
&lt;p&gt;使用了 Eclipse 插件后, 构建项目时会根据 &lt;code&gt;pom.xml&lt;/code&gt; 的配置自动下载依赖包, 但由于我们关闭了 Eclipse 的&lt;strong&gt;自动构建&lt;/strong&gt;, 所以需要手动触发下 maven 去下载 jar 依赖, 执行 Default Lifecycle 阶段的任意命令都能触发下载, 也可以通过下面图示的菜单去触发下载:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/MAVEN/JAR下载.png"/&gt;&lt;/p&gt;
&lt;p&gt;然后就能在 &lt;strong&gt;progress&lt;/strong&gt; 视图看到 Eclipse 进行了下载操作:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/MAVEN/DOWNLOADJAR.png"/&gt;&lt;/p&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/MAVEN/DOWNLOADJAR1.png"/&gt;&lt;/p&gt;
&lt;h1 id="_4"&gt;添加依赖&lt;/h1&gt;
&lt;p&gt;在 Eclipse 中双击打开 &lt;code&gt;pom.xml&lt;/code&gt; 可以以可视化的方式添加依赖 (也可以在项目右键的 maven 菜单中使用该方式):&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/MAVEN/添加依赖0.png"/&gt;&lt;/p&gt;
&lt;p&gt;打开添加依赖窗口后, 在下图中红框处输入内容可以检索本地仓库, 如果本地仓库没有则检索不到:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/MAVEN/添加依赖1.png"/&gt;&lt;/p&gt;
&lt;p&gt;检索不到时候就需要手动填写所依赖 jar 包的 maven 特征:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/MAVEN/添加依赖2.png"/&gt;&lt;/p&gt;
&lt;p&gt;jar 包的特征可以在 &lt;a href="https://mvnrepository.com/"&gt;mvn repository&lt;/a&gt; 搜索得到.&lt;/p&gt;
&lt;p&gt;当然也可以在 &lt;code&gt;pom.xml&lt;/code&gt; 中手动添加:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
  &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
      &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.apache.hadoop&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
      &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;hadoop-common&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
      &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;2.7.3&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
  &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="_5"&gt;打包项目&lt;/h1&gt;
&lt;p&gt;正常打包使用下面的命令就可以了:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;mvn clean package
或者
mvn clean install
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但如果想要将依赖的包一起打进去就需要在 &lt;code&gt;pom.xml&lt;/code&gt; 中添加如下设置:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-assembly-plugin&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;descriptorRefs&amp;gt;&lt;/span&gt;
            &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;descriptorRef&amp;gt;&lt;/span&gt;jar-with-dependencies&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/descriptorRef&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/descriptorRefs&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;archive&amp;gt;&lt;/span&gt;
            &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;manifest&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;mainClass&amp;gt;&amp;lt;/mainClass&amp;gt;&lt;/span&gt;
            &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/manifest&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/archive&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;executions&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;execution&amp;gt;&lt;/span&gt;
            &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;id&amp;gt;&lt;/span&gt;make-assembly&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/id&amp;gt;&lt;/span&gt;
            &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;phase&amp;gt;&lt;/span&gt;package&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/phase&amp;gt;&lt;/span&gt;
            &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;goals&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;goal&amp;gt;&lt;/span&gt;single&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/goal&amp;gt;&lt;/span&gt;
            &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/goals&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/execution&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/executions&amp;gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样再使用 &lt;code&gt;mvn clean package/install&lt;/code&gt; 就可以将项目的所有依赖也一起打进包了.&lt;/p&gt;</content><category term="工具折腾"></category></entry><entry><title>08. 云计算</title><link href="http://www.smallcpp.cn/08-yun-ji-suan.html" rel="alternate"></link><published>2016-11-05T16:03:00+08:00</published><updated>2016-11-05T16:03:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-11-05:/08-yun-ji-suan.html</id><summary type="html">&lt;p&gt;云计算&lt;/p&gt;</summary><content type="html">
&lt;p&gt;在继续 Map-Reduce 课程之前,  我们先补充一下行业知识.&lt;/p&gt;
&lt;h1 id="_1"&gt;超级计算机与云计算之争&lt;/h1&gt;
&lt;p&gt;先看看什么是超级计算机.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;百度百科显示:&lt;br/&gt;
超级计算机指能够执行一般个人电脑无法处理的大资料量与高速运算的电脑, 其基本组成组件与个人电脑的概念无太大差异, 但规格与性能则强大许多, 是一种超大型电子计算机. 超级计算机是计算机中功能最强、运算速度最快、存储容量最大的一类计算机, 多用于国家高科技领域和尖端技术研究, 是一个国家科研实力的体现, 它对国家安全, 经济和社会发展具有举足轻重的意义. 是国家科技发展水平和综合国力的重要标志.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在没有云计算之前, 超级计算机代表着一个国家的科研实力, 围绕超算出现了跑分竞赛, 核心指标是计算效率, 即每秒的浮点运算次数.&lt;br/&gt;
中国超级计算机在 2009 年开始在国际上崭露头角, 天河 1 号、天河 1 号 A 相继稳定世界 TOP 500 榜, 天河 2 号已连续三次夺得超级计算机 TOP 500 竞赛冠军, 并且在下一次竞赛中依然稳操胜券.&lt;br/&gt;
在现在的超级计算机排行榜中, 天河 2 号计算速度为 33.86 千万亿次/秒, 第二名是位于美国能源部 (DOE) 橡树岭国家实验室中的 Titan, 17.59千万亿次/秒, 与天河 2 号差距甚大, 百度 7 千万亿次/秒的超级计算机面世, 在这个榜单中只能屈居第六.&lt;/p&gt;
&lt;p&gt;云计算出现之后, 超级计算机的不少计算场景都被前者所瓜分.&lt;br/&gt;
超级计算机&lt;strong&gt;单机运算&lt;/strong&gt;能力非常惊人;&lt;br/&gt;
而云计算方案则是基于多台计算机, 以 Hadoop 为代表的集群计算系统进行&lt;strong&gt;并行计算&lt;/strong&gt;, Hadoop 负责计算任务分发调度归总.&lt;br/&gt;
两个方案中真正负责计算的都是处理器, 一般是 CPU (百度已开始尝试 GPU).&lt;br/&gt;超级计算机将多个处理单元集中在一起减少任务剑通信延迟, 云计算要跨越不同计算机, 乃至跨越不同机房进行协同计算, 存在任务间通信延迟.&lt;/p&gt;
&lt;p&gt;超级计算机适合&lt;strong&gt;计算密集型场景&lt;/strong&gt;, 比如武器研发、飞行模拟、气候模拟、生育模拟和基因测序;&lt;br/&gt;
而以 Hadoop 为代表的分布式集群则更适合 &lt;strong&gt;IO 密集型&lt;/strong&gt;; 不过从阿里云与华大基因、气象局合作可以看出, 就算是计算密集型领域, 云计算依然有用武之地.&lt;/p&gt;
&lt;p&gt;超级计算机如果能够完成云计算的任务自然不应该被替换, 可惜它有着几个显著的曲线: &lt;strong&gt;成本&lt;/strong&gt;和&lt;strong&gt;能耗&lt;/strong&gt;.&lt;br/&gt;
天河二号总造价成本便高达 18 亿元人民币, 在满载情况下, 天河二号每天耗费是 40 万人民币, 考虑到超级计算机通常负载率不会超过 60%, 通常耗费还相应降低.&lt;br/&gt;
如果再加上软件研发和升级、硬件维护和折旧、研发团队人力成本这些, 年运转成本将十分可观.&lt;br/&gt;
因此, 往往只有政府支持的实验室才肯投入超级计算机研究, 实际上 TOP 10 超级计算机几乎都来自政府或高校背景实验室, 只有少数是 IBM 这样的企业参与.&lt;/p&gt;
&lt;h1 id="_2"&gt;云计算? 云服务?&lt;/h1&gt;
&lt;p&gt;这个问题的答案, 只要你想找, 你能找出 100 种…所以这里仅谈谈我的理解吧.&lt;/p&gt;
&lt;p&gt;个人认为, 云计算并不是单独指某样新产品, 也不是什么新技术, 而是从现有的成熟技术上催生出来的一种新的&lt;strong&gt;技术架构&lt;/strong&gt;, 主要包含了分布式存储、并行计算、虚拟化、自动化部署等; 它的优点是可以对外表现非常优秀的并行计算性能、规模伸缩性和健壮性.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;hadoop&lt;/strong&gt; 在云计算中提供两种能力:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分布式文件系统提供巨大的存储能力&lt;/li&gt;
&lt;li&gt;Map-Reduce 提供快速的并行计算能力 (简单计算)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;而云服务是指以云计算技术架构为支撑演化出来的&lt;strong&gt;服务体系&lt;/strong&gt;, 通过集中拥有的方式, 使用户能得到本身无法得到或者需要高成本才能得到的服务, 降低拥有成本是云服务的核心价值之一.&lt;/p&gt;
&lt;p&gt;云服务的&lt;strong&gt;层次&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;IaaS&lt;/strong&gt;: Infrastructure-as-a-Service（基础设施即服务）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PaaS&lt;/strong&gt;: Platform-as-a-Service（平台即服务）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SaaS&lt;/strong&gt;: Software-as-a-Service（软件即服务）&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;2016 年好像又出来了种 &lt;strong&gt;CaaS&lt;/strong&gt;: Container-as-a-Service (容器即服务), 暂时了解不深, 以后再说.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;云服务的&lt;strong&gt;形态&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;私有云&lt;/li&gt;
&lt;li&gt;公有云&lt;/li&gt;
&lt;li&gt;混合云&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是在国内, 云计算和云服务似乎被认为是同一种东西, 至少在目前看来是这样.&lt;/p&gt;</content><category term="大数据"></category></entry><entry><title>SSH 远程执行脚本的环境变量问题</title><link href="http://www.smallcpp.cn/ssh-yuan-cheng-zhi-xing-jiao-ben-de-huan-jing-bian-liang-wen-ti.html" rel="alternate"></link><published>2016-11-03T23:59:00+08:00</published><updated>2016-11-03T23:59:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-11-03:/ssh-yuan-cheng-zhi-xing-jiao-ben-de-huan-jing-bian-liang-wen-ti.html</id><content type="html">&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;export 导出变量的作用域只即在当前进程及其子进程.&lt;/p&gt;
&lt;p&gt;SSH 远程会话是没有远程主机的环境变量, 解决方法: &lt;code&gt;ssh 远程主机 ". ~/etc/profile &amp;amp;&amp;amp; 命令"&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;有兴趣深纠可参考: &lt;a href="http://feihu.me/blog/2014/env-problem-when-ssh-executing-command-on-remote/#section-10"&gt;ssh 连接远程主机执行脚本的环境变量问题&lt;/a&gt;&lt;/p&gt;</content><category term="工具折腾"></category></entry><entry><title>07. zookeeper 简介</title><link href="http://www.smallcpp.cn/07-zookeeper-jian-jie.html" rel="alternate"></link><published>2016-11-03T23:07:00+08:00</published><updated>2016-11-03T23:07:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-11-03:/07-zookeeper-jian-jie.html</id><summary type="html">&lt;p&gt;zookeeper 简介&lt;/p&gt;</summary><content type="html">
&lt;h1 id="_1"&gt;简介&lt;/h1&gt;
&lt;p&gt;zookeeper 是一个分布式协调服务, 管理分布式环境中的数据, 为分布式应用提供&lt;strong&gt;一致性&lt;/strong&gt;服务的软件, 提供的功能包括: 配置维护、名字服务、分布式同步、组服务等.&lt;/p&gt;
&lt;p&gt;zookeeper 本身也集群, 只要集群里有半数以上, 就能正常为我们服务. 所以 zookeeper 适合安装在是奇数台的集群中.&lt;/p&gt;
&lt;p&gt;zookeeper 集群角色:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;leader&lt;/li&gt;
&lt;li&gt;follower&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;zookeeper 角色不是配置出来的, 而是采用一个名为 Zab 的投票算法内部选举, 客户端向任意节点传数据, 数据都会被推送到 leader, leader 会将数据传到其它 follower.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;补充知识: 投票算法比较有名的有个叫 PAXOS&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多 zookeeper 的细节可以参考: &lt;a href="http://cailin.iteye.com/blog/2014486/"&gt;zookeeper 原理&lt;/a&gt;, 实际上, 对于我们使用者来说, zookeeper 本质上只提供了两个功能:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据保管&lt;/li&gt;
&lt;li&gt;节点监听&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;说到节点, 就要提下 zookeeper 的目标结构, zookeeper 是个树状的层次化结构, 每个树节点叫做 znode, 并且有唯一的路径标识, znode 可以包含&lt;strong&gt;数据&lt;/strong&gt;和&lt;strong&gt;子节点&lt;/strong&gt; (ephemeral 节点除外), 客户端应用可以在节点上设置监听器.&lt;/p&gt;
&lt;p&gt;znode 有四种形式的目录节点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;persistent 永久节点&lt;/li&gt;
&lt;li&gt;persistent_sequential (带自增序号, 自增序号的使用主要用来对推断事件发生的顺序)&lt;/li&gt;
&lt;li&gt;ephemeral 临时节点, 客户端断开链接自删, 不允许建立子节点&lt;/li&gt;
&lt;li&gt;ephemeral_sequential&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="_2"&gt;配置&lt;/h1&gt;
&lt;p&gt;直接去 &lt;a href="http://archive.apache.org/dist/"&gt;http://archive.apache.org/dist/&lt;/a&gt; 下载回来解压就好, 参考 &lt;a href="http://wiki.smallcpp.cn/Hadoop/%E6%90%AD%E5%BB%BA%20Hadoop%20%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83.html#3-hadoop"&gt;Ubuntu 下 Hadoop 的安装&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;首先把 &lt;code&gt;conf/zoo_sample.cfg&lt;/code&gt; 拷贝一份并重命名为 &lt;code&gt;zoo.cfg&lt;/code&gt;, 这就是 zookeeper 的配置文件. 关键配置:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dataDir: 数据目录, 参考 hadoop 的数据目录设置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;server.1~n=ip:port&lt;/code&gt; (port 有两个 2888:3888, 2888 是 leader follower 通讯端口, 3888 是投票端口)
    + 如 server.1=192.168.1.156:2888:3888&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;服务端命令:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bin/zkServer.sh start 启动 zk 集群&lt;/li&gt;
&lt;li&gt;bin/zkServer.sh status 查看 zk 集群状态&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="_3"&gt;客户端工具&lt;/h1&gt;
&lt;p&gt;zookeeper 提供了一个 客户端工具 zkCli.sh, 通过命令 &lt;code&gt;zkCli.sh connect host:port&lt;/code&gt; 就能连上 zk 集群.&lt;/p&gt;
&lt;p&gt;常用命令: &lt;code&gt;ls&lt;/code&gt;、&lt;code&gt;creae&lt;/code&gt;、&lt;code&gt;get&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt;、&lt;code&gt;delete&lt;/code&gt;、&lt;code&gt;rmr&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在 get/ls 时注册 &lt;strong&gt;watch&lt;/strong&gt;, &lt;strong&gt;watch&lt;/strong&gt; 只生效一次, 被触发后就失效了.&lt;/p&gt;
&lt;h1 id="java-api"&gt;Java Api&lt;/h1&gt;
&lt;p&gt;连接 zookeeper 集群:&lt;br/&gt;
&lt;code&gt;zk_obj=zookeeper(zk 集群的 ip:port, timeout, new Watcher(){})&lt;/code&gt; (zookeeper 会开启个守护线程保持和 zk 的长链接).&lt;/p&gt;
&lt;p&gt;在 Watcher 里监听事件并处理 (回调)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;event.getType&lt;/li&gt;
&lt;li&gt;event.getPath&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要注意一下, 有时我们拿到 zk_obj 后, 由于 zk 环境还是准备后, 会导致后续的操作失败, 所以我们拿到 zk_obj 后可以通过 zk_obj.getState() 来判断下当前集群的状态, 当它为 CONNECTED 时才继续操作.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;路径=zk_obj.create(路径, 数据, 权限, 节点模式)

zk_obj.getChildren(路径, 监听器)

节点元数据=zk_obj.exists(路径, 监听器)

zk_obj.getdata(路径, 监听器, null)

zk_obj.delete(路径, -1) 参数2 指定要删除指定版本, -1 表示删除所有版本

zk_obj.setData(路径, 数据, -1) 参数3 同上
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="zookeeper"&gt;zookeeper 应用&lt;/h1&gt;
&lt;p&gt;zookeeper 虽然本质上只提供了两个功能: 数据保管和节点监听, 但是它提供了丰富的 API, 使用这个 API 我们就能写业务逻辑来实现诸多功能, 下面是两个例子.&lt;/p&gt;
&lt;h2 id="_4"&gt;洞察服务器上下线&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;利用 zookeeper 实现客户端实时洞察服务器上下线的变化&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器上线就 -&amp;gt; zk 注册临时节点, 启动服务端业务功能
    + 服务端宕掉或业务功能异常就会和 zk 断开, 临时节点就会被删除&lt;/li&gt;
&lt;li&gt;客户端获取 zk 节点并监听, 获取当前在线服务器列表, 根据规则(如果有)去挑选服务器&lt;/li&gt;
&lt;li&gt;客户端监听到服务节点上下线事件通知重新获取列表并监听&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_5"&gt;共享锁&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;利用 zookeeper 实现分布式共享锁&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户程序启动 -&amp;gt; zk 注册带临时序号的节点 (假设为 uuid)&lt;/li&gt;
&lt;li&gt;获取当前所有 uuid&lt;/li&gt;
&lt;li&gt;uuid 最小的先去访问资源&lt;/li&gt;
&lt;li&gt;访问后将自己的 uuid 删掉, 并注册新的节点&lt;/li&gt;
&lt;li&gt;其他客户程序收到事件变化, 重新获取当前所有 uuid 最小的去访问资源&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_6"&gt;高可用&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;利用 zookeeper 实现高可用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原理都差不多, 无非就是自写逻辑监听 zk 节点变化, 这里分析下 keepalived 与 zookeeper, 参考&lt;a href="https://www.zhihu.com/question/47632675/answer/127669517"&gt;知乎一篇不错的答案&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;keepalived 与 zookeeper 都可以用来实现高可用, 另外常见的还有 DNS.&lt;/p&gt;
&lt;p&gt;先看看优缺点, 就可以看出在实现高可用时的区别. 高可用一般跟负载均衡会一起考虑, 所以下面的比较也会提到负载均衡能力.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Keepalived&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点: 简单, 基本不需要业务层面做任何事情, 就可以实现高可用, 主备容灾. 而且容灾的宕机时间也比较短.&lt;/li&gt;
&lt;li&gt;缺点: 也是简单, 因为 VRRP、主备切换都没有什么复杂的逻辑, 所以无法应对某些特殊场景, 比如主备通信链路出问题, 会导致脑裂. 同时, keepalived 也不容易做负载均衡.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;zookeeper&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点: 可以支持高可用, 负载均衡. 本身是个分布式的服务.&lt;/li&gt;
&lt;li&gt;缺点: 跟业务结合的比较紧密. 需要在业务代码中写好 ZK 使用的逻辑, 比如注册名字. 拉取名字对应的服务地址等.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;DNS&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点: 不复杂, 同时与业务结合的不是很紧密, 通过简单的逻辑就可以实现负载均衡.&lt;/li&gt;
&lt;li&gt;缺点: DNS 容灾是更新 DNS 服务器需要时间, 宕机时间比较长.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以, 区别很明显:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从简单性来说: Keepalived 最简单, DNS 次之, ZK 最复杂.&lt;/li&gt;
&lt;li&gt;从负载均衡能力来看, zookeeper 最强, DNS 次之, Keepalived 最弱.&lt;/li&gt;
&lt;li&gt;从与业务的紧密程度来看: ZK 最紧密, DNS 次之, Keepalived 基本跟业务层面没有关系.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以使用场景, 个人看法, 对于框架级别的业务可能会选择 ZK, 仅仅需要做容灾的用 Keepalived. DNS 的方法介乎两者中间.&lt;/p&gt;
&lt;p&gt;另外, keepalive 只可以选出一台机器作为主机, 所以 keepalive 只能实现 M:1 的备份, zookeeper 可以选出 N 台机器作为主机, 它可以实现 M:N 的备份.&lt;/p&gt;</content><category term="大数据"></category></entry><entry><title>解决复制出来的虚拟机不能启动 DataNode</title><link href="http://www.smallcpp.cn/jie-jue-fu-zhi-chu-lai-de-xu-ni-ji-bu-neng-qi-dong-datanode.html" rel="alternate"></link><published>2016-11-03T22:58:00+08:00</published><updated>2016-11-03T22:58:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-11-03:/jie-jue-fu-zhi-chu-lai-de-xu-ni-ji-bu-neng-qi-dong-datanode.html</id><summary type="html">&lt;p&gt;今天因测试需要, 需要第二台 hadoop 虚拟机, 于是就从 smallcpp01 克隆了一份, 命名为 smallcpp02.&lt;/p&gt;
&lt;p&gt;对第二台主机设置了 主机名、静态IP、 HOSTS、hadoop 配置(就是把一些配置文件里的 ip 和 主机名修改下), 重启虚拟机, 然后重新格式化 hdfs, 启动 Hadoop 服务…&lt;/p&gt;
&lt;p&gt;JPS 后发现, DataNode 并没有被启动…查资料发现问题原因 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;今天因测试需要, 需要第二台 hadoop 虚拟机, 于是就从 smallcpp01 克隆了一份, 命名为 smallcpp02.&lt;/p&gt;
&lt;p&gt;对第二台主机设置了 主机名、静态IP、 HOSTS、hadoop 配置(就是把一些配置文件里的 ip 和 主机名修改下), 重启虚拟机, 然后重新格式化 hdfs, 启动 Hadoop 服务…&lt;/p&gt;
&lt;p&gt;JPS 后发现, DataNode 并没有被启动…查资料发现问题原因.&lt;/p&gt;
&lt;p&gt;原因是每次 format 都会重新创建一个 id, 而生成的 tmp (这是在配置文件中指定的名字, 可以修改) 目录包含了上次 format 时的 id, format 会清空 namenode 下的数据, 但是并不清空 datanode 下的数据, 导致启动时失败, 所要做的就是每次 fotmat 前, 清空 tmp 下的所有目录.&lt;/p&gt;
&lt;p&gt;删除 tmp 文件夹 (&lt;code&gt;rm -rf tmp&lt;/code&gt;)
重新格式化 hdfs (&lt;code&gt;hdfs namenode -format&lt;/code&gt;)
必须要删除 tmp 后再格式化, 不然会启动不了 DataNode.&lt;/p&gt;</content><category term="大数据"></category></entry><entry><title>Ubuntu 安装 ShadowSocks</title><link href="http://www.smallcpp.cn/ubuntu-an-zhuang-shadowsocks.html" rel="alternate"></link><published>2016-11-03T22:32:00+08:00</published><updated>2016-11-03T22:32:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-11-03:/ubuntu-an-zhuang-shadowsocks.html</id><content type="html">&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安装图形界面客户端:
&lt;code&gt;sudo add-apt-repository ppa:hzwhuang/ss-qt5&lt;/code&gt;
&lt;code&gt;sudo apt-get update&lt;/code&gt;
&lt;code&gt;sudo apt-get install shadowsocks-qt5&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="" src="http://i62.tinypic.com/2wcnwy1.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i62.tinypic.com/jjlamt.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i58.tinypic.com/10psqyp.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;将下来, 打开 firefox.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i59.tinypic.com/4ift35.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i57.tinypic.com/2s6udkp.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i60.tinypic.com/33cyi5k.jpg"&gt;&lt;/p&gt;</content><category term="工具折腾"></category></entry><entry><title>配置 SSH 免密码登录</title><link href="http://www.smallcpp.cn/pei-zhi-ssh-mian-mi-ma-deng-lu.html" rel="alternate"></link><published>2016-11-03T22:30:00+08:00</published><updated>2016-11-03T22:30:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-11-03:/pei-zhi-ssh-mian-mi-ma-deng-lu.html</id><summary type="html">&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/SSH/免密码登录原理.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cd ~&lt;/code&gt; 进入根目录&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ls -la&lt;/code&gt; 查看下当前目录文件, 可以看到有个隐藏的 &lt;code&gt;.ssh&lt;/code&gt; 文件夹 (点开头就是隐藏的)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cd .ssh/&lt;/code&gt; 进入 &lt;code&gt;.ssh&lt;/code&gt; 目录, &lt;code&gt;ls&lt;/code&gt; 一下, 看看该目录下有没有 &lt;code&gt;id_rsa&lt;/code&gt;、&lt;code&gt;id_rsa.pub&lt;/code&gt; 两个文件, 如果没有, 就生成一对:
&lt;code&gt;ssh-keygen -t(加密类型) rsa&lt;/code&gt;
&amp;ndash;四个回车&amp;ndash;
然后就会在 &lt;code&gt;.ssh …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/SSH/免密码登录原理.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cd ~&lt;/code&gt; 进入根目录&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ls -la&lt;/code&gt; 查看下当前目录文件, 可以看到有个隐藏的 &lt;code&gt;.ssh&lt;/code&gt; 文件夹 (点开头就是隐藏的)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cd .ssh/&lt;/code&gt; 进入 &lt;code&gt;.ssh&lt;/code&gt; 目录, &lt;code&gt;ls&lt;/code&gt; 一下, 看看该目录下有没有 &lt;code&gt;id_rsa&lt;/code&gt;、&lt;code&gt;id_rsa.pub&lt;/code&gt; 两个文件, 如果没有, 就生成一对:
&lt;code&gt;ssh-keygen -t(加密类型) rsa&lt;/code&gt;
&amp;ndash;四个回车&amp;ndash;
然后就会在 &lt;code&gt;.ssh&lt;/code&gt; 下生成两个文件 &lt;code&gt;id_rsa&lt;/code&gt;、&lt;code&gt;id_rsa.pub&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cp id_rsa.pub authorized_keys&lt;/code&gt;
此时不需要密码就能启动/停止 hadoop 了&amp;hellip;&lt;/p&gt;
&lt;p&gt;如果要向其他主机发送自己的公钥: &lt;code&gt;ssh-copy-id xxx(ip)&lt;/code&gt;&lt;/p&gt;</content><category term="工具折腾"></category></entry><entry><title>06. 使用 Rest 操作 HDFS</title><link href="http://www.smallcpp.cn/06-shi-yong-rest-cao-zuo-hdfs.html" rel="alternate"></link><published>2016-11-03T22:07:00+08:00</published><updated>2016-11-03T22:07:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-11-03:/06-shi-yong-rest-cao-zuo-hdfs.html</id><summary type="html">&lt;p&gt;使用 rest 操作 HDFS&lt;/p&gt;</summary><content type="html">
&lt;p&gt;要使用 rest 操作 HDFS, 需要先开启集群的 rest 服务.&lt;/p&gt;
&lt;h1 id="vim-httpfs-envsh"&gt;vim httpfs-env.sh&lt;/h1&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #658b00"&gt;export&lt;/span&gt; &lt;span style="color: #00688B"&gt;HTTPFS_HTTP_PORT&lt;/span&gt;=&lt;span style="color: #B452CD"&gt;14000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="vim-core-sitexml"&gt;vim core-site.xml&lt;/h1&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;property&amp;gt;&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;&amp;lt;!--可使用节点--&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;hadoop.proxyuser.root.hosts&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;value&amp;gt;&lt;/span&gt;*&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;property&amp;gt;&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;&amp;lt;!--可使用用户组--&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;hadoop.proxyuser.root.groups&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;value&amp;gt;&lt;/span&gt;*&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="hdfs-sitexml"&gt;hdfs-site.xml&lt;/h1&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;property&amp;gt;&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;&amp;lt;!--启动 webhdfs--&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;dfs.webhdfs.enabled&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;value&amp;gt;&lt;/span&gt;true&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="namenode"&gt;重启 NameNode&lt;/h1&gt;
&lt;p&gt;修改好配置文件后, 重新启动 NameNode:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;./stop-all.sh
./start-all.sh
./httpfs.sh start
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后一行就是启动集群的 rest 服务器.&lt;/p&gt;
&lt;h1 id="_1"&gt;测试&lt;/h1&gt;
&lt;p&gt;执行命令 &lt;code&gt;curl -i "http://192.168.1.213:14000/webhdfs/v1?user.name=root&amp;amp;op=LISTSTATUS"&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-i 表示显示 http response 的头信息, 连同网页代码一起.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;api: &lt;code&gt;http://&amp;lt;HOST&amp;gt;:&amp;lt;PORT&amp;gt;/webhdfs/v1/&amp;lt;PATH&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;参数:
    + user.name 操作者
    + op 操作内容&lt;/li&gt;
&lt;li&gt;返回 json 格式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更多命令参考 &lt;a href="http://hadoop.apache.org/docs/r2.7.3/hadoop-project-dist/hadoop-hdfs/WebHDFS.html"&gt;http://hadoop.apache.org/docs/r2.7.3/hadoop-project-dist/hadoop-hdfs/WebHDFS.html&lt;/a&gt;&lt;/p&gt;</content><category term="大数据"></category></entry><entry><title>前端 Js 插件汇总</title><link href="http://www.smallcpp.cn/qian-duan-js-cha-jian-hui-zong.html" rel="alternate"></link><published>2016-11-02T20:29:00+08:00</published><updated>2016-11-02T20:29:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-11-02:/qian-duan-js-cha-jian-hui-zong.html</id><content type="html">&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.htmleaf.com/jQuery/Menu-Navigation/201502141379.html"&gt;基于 bootstrap 的 jQuery 多级列表树插件 (支持 checkbox)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/wangfupeng1988/wangEditor"&gt;基于javascript和css开发的 Web 富文本编辑器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="软件工程"></category></entry><entry><title>常见的驱动设计</title><link href="http://www.smallcpp.cn/chang-jian-de-qu-dong-she-ji.html" rel="alternate"></link><published>2016-10-31T13:57:00+08:00</published><updated>2016-10-31T13:57:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-10-31:/chang-jian-de-qu-dong-she-ji.html</id><summary type="html">&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;DDD: 领域驱动设计, 《领域驱动设计》&lt;/li&gt;
&lt;li&gt;TDD: 测试驱动开发, 《敏捷软件开发》&lt;/li&gt;
&lt;li&gt;BDD: 行为驱动开发, 《C# 测试驱动开发》&lt;/li&gt;
&lt;li&gt;FDD: 特性驱动开发, 《彩色 UML 建模》&lt;/li&gt;
&lt;li&gt;MDD: 元数据驱动开发, 《程序员修炼之道》、《Ruby 元编程》&lt;/li&gt;
&lt;li&gt;EDD: 事件驱动开发, 《发布订阅模式》&lt;/li&gt;
&lt;li&gt;MDD: 消息驱动开发, 参考各种 ESB 实现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比较常见的是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BDD …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;DDD: 领域驱动设计, 《领域驱动设计》&lt;/li&gt;
&lt;li&gt;TDD: 测试驱动开发, 《敏捷软件开发》&lt;/li&gt;
&lt;li&gt;BDD: 行为驱动开发, 《C# 测试驱动开发》&lt;/li&gt;
&lt;li&gt;FDD: 特性驱动开发, 《彩色 UML 建模》&lt;/li&gt;
&lt;li&gt;MDD: 元数据驱动开发, 《程序员修炼之道》、《Ruby 元编程》&lt;/li&gt;
&lt;li&gt;EDD: 事件驱动开发, 《发布订阅模式》&lt;/li&gt;
&lt;li&gt;MDD: 消息驱动开发, 参考各种 ESB 实现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比较常见的是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BDD: Behavior Drive Development 行为驱动开发&lt;/li&gt;
&lt;li&gt;TDD: Test Drive Development 测试驱动开发&lt;/li&gt;
&lt;li&gt;DDD: Domain Drive Design 领域驱动开发&lt;/li&gt;
&lt;/ul&gt;</content><category term="软件工程"></category></entry><entry><title>vim 入门</title><link href="http://www.smallcpp.cn/vim-ru-men.html" rel="alternate"></link><published>2016-10-28T16:37:00+08:00</published><updated>2016-10-28T16:37:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-10-28:/vim-ru-men.html</id><summary type="html">
&lt;h1 id="_1"&gt;配置文件&lt;/h1&gt;
&lt;p&gt;整体 vim 的设置值一般是放置在  &lt;code&gt;/etc/vimrc&lt;/code&gt;  这个文件, 不过, 不建议你修改它, 可以修改 &lt;code&gt;~/.vimrc&lt;/code&gt; 这个文件（默认不存在, 请你自行手动创建! ）, 这是 vim 的用户配置文件.&lt;/p&gt;
&lt;h1 id="vim"&gt;VIM 新特性&lt;/h1&gt;
&lt;h2 id="_2"&gt;区块选择&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;v 字符选择&lt;/li&gt;
&lt;li&gt;V 行选择&lt;/li&gt;
&lt;li&gt;ctrl + v 区块选择&lt;/li&gt;
&lt;li&gt;y 复制选择&lt;/li&gt;
&lt;li&gt;d …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">
&lt;h1 id="_1"&gt;配置文件&lt;/h1&gt;
&lt;p&gt;整体 vim 的设置值一般是放置在  &lt;code&gt;/etc/vimrc&lt;/code&gt;  这个文件, 不过, 不建议你修改它, 可以修改 &lt;code&gt;~/.vimrc&lt;/code&gt; 这个文件（默认不存在, 请你自行手动创建! ）, 这是 vim 的用户配置文件.&lt;/p&gt;
&lt;h1 id="vim"&gt;VIM 新特性&lt;/h1&gt;
&lt;h2 id="_2"&gt;区块选择&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;v 字符选择&lt;/li&gt;
&lt;li&gt;V 行选择&lt;/li&gt;
&lt;li&gt;ctrl + v 区块选择&lt;/li&gt;
&lt;li&gt;y 复制选择&lt;/li&gt;
&lt;li&gt;d 删除选择&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_3"&gt;多档案编辑&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;不常用, 推荐使用多窗口编辑功能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;vim file1 file2 …&lt;/li&gt;
&lt;li&gt;:n 下一个文本&lt;/li&gt;
&lt;li&gt;:N 上一个文本&lt;/li&gt;
&lt;li&gt;:file 列出当前开启的所有文本&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_4"&gt;多窗口编辑&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;:sp [filename] 开启一个新窗口&lt;/li&gt;
&lt;li&gt;[ctrl]+w j / ↓ 先按 ctrl + w 进入窗口切换模式， 再按 j k 上下切换窗口&lt;/li&gt;
&lt;li&gt;[ctrl]+w k / ↑&lt;/li&gt;
&lt;li&gt;[ctrl]+w q 退出当前窗口&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="_5"&gt;快捷键&lt;/h1&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/VIM入门/vim.jpg"/&gt;&lt;/p&gt;
&lt;h2 id="_6"&gt;移动光标的方法&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;快捷键&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;h 或 向左箭头键(←)&lt;/td&gt;
&lt;td&gt;光标向左移动一个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;j 或 向下箭头键(↓)&lt;/td&gt;
&lt;td&gt;光标向下移动一个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;k 或 向上箭头键(↑)&lt;/td&gt;
&lt;td&gt;光标向上移动一个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;l 或 向右箭头键(→)&lt;/td&gt;
&lt;td&gt;光标向右移动一个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;w&lt;/td&gt;
&lt;td&gt;下一个单词的第一个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;W&lt;/td&gt;
&lt;td&gt;下一个长单词的第一个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;e&lt;/td&gt;
&lt;td&gt;下一个单词的最后一个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;E&lt;/td&gt;
&lt;td&gt;下一个长单词的最后一个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;前一个单词的第一个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;前一个长单词的第一个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ge&lt;/td&gt;
&lt;td&gt;前一个单词的最后一个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n hjkl&lt;/td&gt;
&lt;td&gt;进行多次移动&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[Ctrl] + [f]&lt;/td&gt;
&lt;td&gt;屏幕『向下』移动一页, 相当于 [Page Down]按键 (常用)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[Ctrl] + [b]&lt;/td&gt;
&lt;td&gt;屏幕『向上』移动一页, 相当于 [Page Up] 按键 (常用)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[Ctrl] + [d]&lt;/td&gt;
&lt;td&gt;屏幕『向下』移动半页&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[Ctrl] + [u]&lt;/td&gt;
&lt;td&gt;屏幕『向上』移动半页&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;光标移动到非空格符的下一行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;光标移动到非空格符的上一行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n&lt;space&gt;&lt;/space&gt;&lt;/td&gt;
&lt;td&gt;那个 n 表示『数字』, 例如 20 .&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;按下数字后再按空格键, 光标会向右移动这一行的 n 个字符.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;例如 20&lt;space&gt; 则光标会向后面移动 20 个字符距离.&lt;/space&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;0 或功能键[Home]&lt;/td&gt;
&lt;td&gt;这是数字『 0 』: 移动到这一行的最前面字符处 (常用)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$ 或功能键[End]&lt;/td&gt;
&lt;td&gt;移动到这一行的最后面字符处 (常用)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;H&lt;/td&gt;
&lt;td&gt;光标移动到这个屏幕的最上方那一行的第一个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;td&gt;光标移动到这个屏幕的中央那一行的第一个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;td&gt;光标移动到这个屏幕的最下方那一行的第一个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;td&gt;移动到这个档案的最后一行(常用)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;nG&lt;/td&gt;
&lt;td&gt;n 为数字. 移动到这个档案的第 n 行.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;例如 20G 则会移动到这个档案的第 20 行 (可配合 :set nu)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;gg&lt;/td&gt;
&lt;td&gt;移动到这个档案的第一行, 相当于 1G 啊!  (常用)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n&lt;enter&gt;&lt;/enter&gt;&lt;/td&gt;
&lt;td&gt;n 为数字. 光标向下移动 n 行(常用)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="_7"&gt;搜寻与取代&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;快捷键&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/word&lt;/td&gt;
&lt;td&gt;向光标之下寻找一个名称为 word 的字符串.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;例如要在档案内搜寻 vbird 这个字符串, 就输入 /vbird 即可!  (常用)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;?word&lt;/td&gt;
&lt;td&gt;向光标之上寻找一个字符串名称为 word 的字符串.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n&lt;/td&gt;
&lt;td&gt;这个 n 是英文按键. 代表『重复前一个搜寻的动作』.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;举例来说,  如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串,&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;则按下 n 后, 会向下继续搜寻下一个名称为 vbird 的字符串.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;如果是执行 ?vbird 的话, 那么按下 n 则会向上继续搜寻名称为 vbird 的字符串!&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;与 n 功能相反&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:s/word1/word2/g&lt;/td&gt;
&lt;td&gt;替换当前行第一个 word1 为 word2 !&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:%s/word1/word2/g&lt;/td&gt;
&lt;td&gt;替换所有行第一个 word1 为 word2 !&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:n1,n2s/word1/word2/g&lt;/td&gt;
&lt;td&gt;n1 与 n2 为数字. 在第 n1 与 n2 行之间寻找 word1 这个字符串, 并将该字符串取代为 word2 !&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;举例来说, 在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则:  『:100,200s/vbird/VBIRD/g』. (常用)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:1,$s/word1/word2/g&lt;/td&gt;
&lt;td&gt;从第一行到最后一行寻找 word1 字符串, 并将该字符串取代为 word2 ! (常用)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:1,$s/word1/word2/gc&lt;/td&gt;
&lt;td&gt;从第一行到最后一行寻找 word1 字符串, 并将该字符串取代为 word2 !&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;且在取代前显示提示字符给用户确认 (confirm) 是否需要取代! (常用)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="_8"&gt;删除、复制与贴上&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;注意 d 系行命令其实不是删除, 是剪切&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;快捷键&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;x, X&lt;/td&gt;
&lt;td&gt;在一行字当中, x 为向后删除一个字符 (相当于 [del] 按键),&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;nx&lt;/td&gt;
&lt;td&gt;n 为数字, 连续向后删除 n 个字符. 举例来说, 我要连续删除 10 个字符,  『10x』.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dd&lt;/td&gt;
&lt;td&gt;删除游标所在的那一整行(常用)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ndd&lt;/td&gt;
&lt;td&gt;n 为数字. 删除光标所在的向下 n 行, 例如 20dd 则是删除 20 行 (常用)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;d1G&lt;/td&gt;
&lt;td&gt;删除光标所在到第一行的所有数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dG&lt;/td&gt;
&lt;td&gt;删除光标所在到最后一行的所有数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;d$&lt;/td&gt;
&lt;td&gt;删除游标所在处, 到该行的最后一个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;d0&lt;/td&gt;
&lt;td&gt;那个是数字的 0 , 删除游标所在处, 到该行的最前面一个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;diw&lt;/td&gt;
&lt;td&gt;删除光标所在单词, 不包括空白字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;daw&lt;/td&gt;
&lt;td&gt;删除光标所在单词, 包括空白字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dw&lt;/td&gt;
&lt;td&gt;从当前位置删除到下一个单词词首, 包括空格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;de&lt;/td&gt;
&lt;td&gt;从当前位置删除到下一个单词词首, 不包括空格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;yy&lt;/td&gt;
&lt;td&gt;复制游标所在的那一行(常用)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;nyy&lt;/td&gt;
&lt;td&gt;n 为数字. 复制光标所在的向下 n 行, 例如 20yy 则是复制 20 行(常用)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;yiw&lt;/td&gt;
&lt;td&gt;复制光标所在单词, 不包括空白字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;yaw&lt;/td&gt;
&lt;td&gt;复制光标所在单词, 包括空白字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;yw&lt;/td&gt;
&lt;td&gt;从当前位置复制到下一个单词词首, 包括空格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ye&lt;/td&gt;
&lt;td&gt;从当前位置复制到下一个单词词首, 不包括空格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;y1G&lt;/td&gt;
&lt;td&gt;复制游标所在行到第一行的所有数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;yG&lt;/td&gt;
&lt;td&gt;复制游标所在行到最后一行的所有数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;y0&lt;/td&gt;
&lt;td&gt;复制光标所在的那个字符到该行行首的所有数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;y$&lt;/td&gt;
&lt;td&gt;复制光标所在的那个字符到该行行尾的所有数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;p, P&lt;/td&gt;
&lt;td&gt;p 为将已复制的数据在光标下一行贴上, P 则为贴在游标上一行!&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;举例来说, 我目前光标在第 20 行, 且已经复制了 10 行数据.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;则按下 p 后,  那 10 行数据会贴在原本的 20 行之后, 亦即由 21 行开始贴.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行.  (常用)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;J&lt;/td&gt;
&lt;td&gt;将光标所在行与下一行的数据结合成同一行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;重复删除多个数据, 例如向下删除 10 行, [ 10cj ]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;u&lt;/td&gt;
&lt;td&gt;复原前一个动作. (常用)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[Ctrl] + r&lt;/td&gt;
&lt;td&gt;重做上一个动作. (常用)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;不要怀疑! 这就是小数点! 意思是重复前一个动作的意思.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;如果你想要重复删除、重复贴上等等动作, 按下小数点『.』就好了!  (常用)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="_9"&gt;模式切换&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;快捷键&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;i, I&lt;/td&gt;
&lt;td&gt;进入插入模式(Insert mode):&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;i 为『从目前光标所在处插入』&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;I 为『在目前所在行的第一个非空格符处开始插入』.  (常用)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a, A&lt;/td&gt;
&lt;td&gt;进入插入模式(Insert mode):&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;a 为『从目前光标所在的下一个字符处开始插入』&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;A 为『从光标所在行的最后一个字符处开始插入』. (常用)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;o, O&lt;/td&gt;
&lt;td&gt;进入插入模式(Insert mode):  这是英文字母 o 的大小写.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;o 为『在目前光标所在的下一行处插入新的一行』;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;O 为在目前光标所在处的上一行插入新的一行! (常用)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;r, R&lt;/td&gt;
&lt;td&gt;进入取代模式(Replace mode):&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;r 只会取代光标所在的那一个字符一次;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;R会一直取代光标所在的文字, 直到按下 ESC 为止; (常用)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[Esc]&lt;/td&gt;
&lt;td&gt;退出编辑模式, 回到一般模式中(常用)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:w&lt;/td&gt;
&lt;td&gt;将编辑的数据写入硬盘档案中(常用)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:w!&lt;/td&gt;
&lt;td&gt;若文件属性为『只读』时, 强制写入该档案.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:w!&lt;/td&gt;
&lt;td&gt;不过, 到底能不能写入,  还是跟你对该档案的档案权限有关啊!&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:q&lt;/td&gt;
&lt;td&gt;离开 vi (常用)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:q!&lt;/td&gt;
&lt;td&gt;若曾修改过档案, 又不想储存, 使用 ! 为强制离开不储存档案.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;注意一下啊, 那个惊叹号 (!) 在 vi 当中, 常常具有『强制』的意思～&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:wq&lt;/td&gt;
&lt;td&gt;储存后离开, 若为 :wq! 则为强制储存后离开 (常用)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ZZ&lt;/td&gt;
&lt;td&gt;这是大写的 Z 喔! 若档案没有更动, 则不储存离开, 若档案已经被更动过, 则储存后离开!&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:w [filename]&lt;/td&gt;
&lt;td&gt;将编辑的数据储存成另一个档案（类似另存新档）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:r [filename]&lt;/td&gt;
&lt;td&gt;在编辑的数据中, 读入另一个档案的数据;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:r [filename]&lt;/td&gt;
&lt;td&gt;亦即将 『filename』 这个档案内容加到游标所在行后面&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:n1,n2 w [filename]&lt;/td&gt;
&lt;td&gt;将 n1 到 n2 的内容储存成 filename 这个档案.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:! command&lt;/td&gt;
&lt;td&gt;暂时离开 vi 到指令行模式下执行 command 的显示结果!&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;例如:『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息!&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="_10"&gt;环境的变更&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;快捷键&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;:set nu&lt;/td&gt;
&lt;td&gt;显示行号, 设定之后, 会在每一行的前缀显示该行的行号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:set nonu&lt;/td&gt;
&lt;td&gt;与 set nu 相反, 为取消行号!&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="_11"&gt;自动补全&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;快捷键&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;[ctrl]+x  [ctrl]+n&lt;/td&gt;
&lt;td&gt;通过目前正在编辑的这个“文件的内容文字”作为关键字, 予以补齐&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[ctrl]+x  [ctrl]+f&lt;/td&gt;
&lt;td&gt;以当前目录内的“文件名”作为关键字, 予以补齐&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[ctrl]+x  [ctrl]+o&lt;/td&gt;
&lt;td&gt;以扩展名作为语法补充, 以 vim 内置的关键字, 予以补齐&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content><category term="工具折腾"></category></entry><entry><title>高可用高并发网站架构演化 (nginx + keepalived)</title><link href="http://www.smallcpp.cn/gao-ke-yong-gao-bing-fa-wang-zhan-jia-gou-yan-hua-nginx-keepalived.html" rel="alternate"></link><published>2016-10-27T22:27:00+08:00</published><updated>2016-10-27T22:27:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-10-27:/gao-ke-yong-gao-bing-fa-wang-zhan-jia-gou-yan-hua-nginx-keepalived.html</id><summary type="html">&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;nginx + keepalived 的组合通常被用来实现前端高可用.&lt;/p&gt;
&lt;p&gt;在这个组合中, 利用 &lt;strong&gt;nginx&lt;/strong&gt; 的反向代理实现前端的&lt;em&gt;动静分离&lt;/em&gt;和&lt;em&gt;负载均衡&lt;/em&gt;, 如下图.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/高可用高并发架构/nginx.jpg"&gt;&lt;/p&gt;
&lt;p&gt;在以上的体系中, 我们接着将一些通用的服务从动态 Server 上抽离出来单独封装, 动态 Server 通过 &lt;strong&gt;RPC&lt;/strong&gt; 远程调用通用服务, 这样就避免升级通用服务时会更改对所有动态 Server 的问题.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/高可用高并发架构/rpc.jpg"&gt;&lt;/p&gt;
&lt;p&gt;如上图, 如果 RPC 服务器挂掉了, 那所有的 RPC 请求都会出问题 …&lt;/p&gt;</summary><content type="html">&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;nginx + keepalived 的组合通常被用来实现前端高可用.&lt;/p&gt;
&lt;p&gt;在这个组合中, 利用 &lt;strong&gt;nginx&lt;/strong&gt; 的反向代理实现前端的&lt;em&gt;动静分离&lt;/em&gt;和&lt;em&gt;负载均衡&lt;/em&gt;, 如下图.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/高可用高并发架构/nginx.jpg"&gt;&lt;/p&gt;
&lt;p&gt;在以上的体系中, 我们接着将一些通用的服务从动态 Server 上抽离出来单独封装, 动态 Server 通过 &lt;strong&gt;RPC&lt;/strong&gt; 远程调用通用服务, 这样就避免升级通用服务时会更改对所有动态 Server 的问题.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/高可用高并发架构/rpc.jpg"&gt;&lt;/p&gt;
&lt;p&gt;如上图, 如果 RPC 服务器挂掉了, 那所有的 RPC 请求都会出问题, 为此, 同一个通用服务可以准备多台 RPC 服务器, 通过 &lt;strong&gt;dubbo&lt;/strong&gt; 来进行调度, 这样就实现了 RPC 服务器的&lt;em&gt;高并发&lt;/em&gt;及&lt;em&gt;高可用&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/高可用高并发架构/dobbu.jpg"&gt;&lt;/p&gt;
&lt;p&gt;那么问题又来了, 如果 nginx 宕掉了怎么办?&lt;/p&gt;
&lt;p&gt;这时就要让 &lt;strong&gt;keepalived&lt;/strong&gt; 出场了, 借助 keepalived 实现 nginx 的&lt;em&gt;高可用&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;访问网站即访问 IP, keepalived 在这里就是充当着抢这个被访问 IP 的角色, 如下图所示, 我们准备了两台 nginx 服务器, 都装上 keepalived;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/高可用高并发架构/keepalived.jpg"&gt;&lt;/p&gt;
&lt;p&gt;现在, 我们的网站 IP 被上面那个 keepalived 抢到了, 所以当有 IP 请求时, 是上面的 ngnix 在起作用, 一旦它出问题, 下面那个 keepalived 就会抢到前端网站 IP, 这样就实现了 ngnix 的&lt;em&gt;高可用&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;在 keepalived 中, 可以通过自定义脚本实现监控任意进程, 一旦被监控进程挂掉, 就能让 keepalived 放弃对 IP 的抢占.&lt;/p&gt;
&lt;p&gt;另外, 在数据库层面上, 也有一些优化方案, 如读写分离、缓存系统、分库分表等 (&lt;a href="http://www.jianshu.com/p/ddcc3643aec9"&gt;mongodb&lt;/a&gt; 作为一个分布式数据库, 支持自动&lt;a href="http://www.ttlsa.com/mongodb/the-architecture-of-mongodb-mongodb-fragment-cluster-and-simple-construction-scheme/"&gt;分片&lt;/a&gt;); 值得一提的是, 现在有个应用叫 &lt;strong&gt;mycat&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;  mycat 能够帮我们实现分库分表的操作, 并且它也支持 mongodb, 开发者可以根据不同的需求将表分配不同的数据节点, 比如 Table A 存放在关系型数据库中 (如 MySQL), 而 Table B 可能更适合 NoSQL (如 MongoDB), 在 MyCAT 中开发者只需要简单配置, 即可让 MyCAT 完成这一系列操作的路由.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果更进一步, 还可以上 &lt;strong&gt;CDN&lt;/strong&gt; 服务, 把静态资源委托给 CDN.&lt;/p&gt;
&lt;p&gt;这里也顺便补充下 CDN 的知识:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;  CDN 内容分发网络

  CDN 加速将网站的内容缓存在网络边缘 (离用户接入网络最近的地方), 然后在用户访问网站内容的时候, CDN 系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上.

  CDN 服务最初用于确保快速可靠地分发静态内容, 这些内容可以缓存, 最适合在网速庞大的网络中存储和分发, 该网络在几十多个国家的十几个网络中的覆盖 CDN 网络服务器.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这些知识比较偏硬件, 我认为更多的是 IT、运维或者架构师的职责, 对于目前的我来说, 简单的了解下, 知道有这些个东西就足够了, 更多的参考资料可参考:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Refrences&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://freeloda.blog.51cto.com/2033581/1265304"&gt;Linux 高可用 (HA) 集群基本概念详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://freeloda.blog.51cto.com/2033581/1265808"&gt;Linux 高可用 (HA) 集群之 Heartbeat 详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://freeloda.blog.51cto.com/2033581/1270239"&gt;Linux 高可用 (HA) 集群之 heartbeat 基于 crm 进行资源管理详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://freeloda.blog.51cto.com/2033581/1272417"&gt;Linux 高可用 (HA) 集群之 Corosync 详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://freeloda.blog.51cto.com/2033581/1274533"&gt;Linux 高可用 (HA) 集群之 Pacemaker 详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://freeloda.blog.51cto.com/2033581/1275384"&gt;Linux 高可用 (HA) 集群之 DRB 详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://freeloda.blog.51cto.com/2033581/1280962"&gt;Linux 高可用 (HA) 集群之 keepalived 详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.codes51.com/article/detail_573458_1.html"&gt;Nginx + Keepalived 实现站点高可用&lt;/a&gt;&lt;/p&gt;</content><category term="软件工程"></category></entry><entry><title>HDFS Shell 命令</title><link href="http://www.smallcpp.cn/hdfs-shell-ming-ling.html" rel="alternate"></link><published>2016-10-26T15:03:00+08:00</published><updated>2016-10-26T15:03:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-10-26:/hdfs-shell-ming-ling.html</id><summary type="html">
&lt;p&gt;如何使用 Shell 操作 HDFS 参考 Blog: &lt;a href="http://blog.smallcpp.cn/04-shi-yong-shell-cao-zuo-hdfs.html"&gt;使用 Shell 操作 HDFS&lt;/a&gt;&lt;/p&gt;
&lt;h1 id="_1"&gt;常用命令&lt;/h1&gt;
&lt;p&gt;get == copyToLocal&lt;/p&gt;
&lt;p&gt;put == copyFromHdfs&lt;/p&gt;
&lt;h2 id="cp"&gt;cp&lt;/h2&gt;
&lt;p&gt;源和目标都是 hdfs&lt;/p&gt;
&lt;p&gt;-f 覆盖&lt;/p&gt;
&lt;p&gt;-p 保留文件属性 (cp 文件时, 更新时间会变, 所属组也会变成操作者)&lt;/p&gt;
&lt;h2 id="mv"&gt;mv&lt;/h2&gt;
&lt;p&gt;源和目标都是 hdfs&lt;/p&gt;
&lt;h2 id="count"&gt;count …&lt;/h2&gt;</summary><content type="html">
&lt;p&gt;如何使用 Shell 操作 HDFS 参考 Blog: &lt;a href="http://blog.smallcpp.cn/04-shi-yong-shell-cao-zuo-hdfs.html"&gt;使用 Shell 操作 HDFS&lt;/a&gt;&lt;/p&gt;
&lt;h1 id="_1"&gt;常用命令&lt;/h1&gt;
&lt;p&gt;get == copyToLocal&lt;/p&gt;
&lt;p&gt;put == copyFromHdfs&lt;/p&gt;
&lt;h2 id="cp"&gt;cp&lt;/h2&gt;
&lt;p&gt;源和目标都是 hdfs&lt;/p&gt;
&lt;p&gt;-f 覆盖&lt;/p&gt;
&lt;p&gt;-p 保留文件属性 (cp 文件时, 更新时间会变, 所属组也会变成操作者)&lt;/p&gt;
&lt;h2 id="mv"&gt;mv&lt;/h2&gt;
&lt;p&gt;源和目标都是 hdfs&lt;/p&gt;
&lt;h2 id="count"&gt;count&lt;/h2&gt;
&lt;p&gt;统计目录数量&lt;/p&gt;
&lt;p&gt;列出指定目录下的子目录数量 文件数量 目录大小 文件路径&lt;/p&gt;
&lt;p&gt;-q 查看限额&lt;/p&gt;
&lt;p&gt;-h 格式化大小&lt;/p&gt;
&lt;h2 id="du"&gt;du&lt;/h2&gt;
&lt;p&gt;统计目录大小&lt;/p&gt;
&lt;p&gt;-s 汇总&lt;/p&gt;
&lt;p&gt;-h 格式化&lt;/p&gt;
&lt;h2 id="dus"&gt;dus&lt;/h2&gt;
&lt;p&gt;相当于 du -s&lt;/p&gt;
&lt;h2 id="expunge"&gt;expunge&lt;/h2&gt;
&lt;p&gt;清空 hdfs 回收站&lt;/p&gt;
&lt;h2 id="mkdir"&gt;mkdir&lt;/h2&gt;
&lt;p&gt;-p 递归创建&lt;/p&gt;
&lt;h2 id="touchz"&gt;touchz&lt;/h2&gt;
&lt;p&gt;创建空白文件&lt;/p&gt;
&lt;h2 id="rm"&gt;rm&lt;/h2&gt;
&lt;p&gt;-f 文件不存在不提示&lt;/p&gt;
&lt;p&gt;-r 递归&lt;/p&gt;
&lt;p&gt;-R 同 -r&lt;/p&gt;
&lt;h2 id="cattext"&gt;cat/text&lt;/h2&gt;
&lt;p&gt;查看文件内容&lt;/p&gt;
&lt;h2 id="tail"&gt;tail&lt;/h2&gt;
&lt;p&gt;显示最后 1k 的内容&lt;/p&gt;
&lt;p&gt;-f 动态显示新建内容&lt;/p&gt;
&lt;h2 id="setrep"&gt;setrep&lt;/h2&gt;
&lt;p&gt;设置副本?&lt;/p&gt;
&lt;h1 id="dfsadmin"&gt;dfsadmin 系列&lt;/h1&gt;
&lt;h2 id="report"&gt;report&lt;/h2&gt;
&lt;p&gt;集群报告&lt;/p&gt;
&lt;p&gt;-live 活 (默认)&lt;/p&gt;
&lt;p&gt;-dead 死&lt;/p&gt;
&lt;p&gt;-decommissioning 正在解除中&lt;/p&gt;
&lt;h2 id="safemode"&gt;safemode&lt;/h2&gt;
&lt;p&gt;当前集群安全模式 (只读)&lt;/p&gt;
&lt;p&gt;enter 进入安全模式&lt;/p&gt;
&lt;p&gt;leave 离开安全模式&lt;/p&gt;
&lt;p&gt;get 当前状态&lt;/p&gt;
&lt;p&gt;wait&lt;/p&gt;
&lt;h2 id="setquota-quota-dirname"&gt;setQuota quota dirname&lt;/h2&gt;
&lt;p&gt;数量限额, 限定 dirname 下最多有 quota 个文件/目录&lt;/p&gt;
&lt;p&gt;注意, 包含目录本身, 例如有个目录, 两面有两个文件, 那这个目录总共是算 3 个&lt;/p&gt;
&lt;h2 id="clrquota"&gt;clrQuota&lt;/h2&gt;
&lt;p&gt;清除数量限额&lt;/p&gt;
&lt;h2 id="setspacequota-4k-dirname"&gt;setSpaceQuota 4k dirname&lt;/h2&gt;
&lt;p&gt;空间限额, 限定目录空间大小&lt;/p&gt;
&lt;h2 id="clrspacequota"&gt;clrSpaceQuota&lt;/h2&gt;
&lt;p&gt;清除空间限额&lt;/p&gt;
&lt;h2 id="allowsnapshot"&gt;allowSnapshot&lt;/h2&gt;
&lt;p&gt;设置一个目录为可快照: &lt;code&gt;hdfs dfsadmin -allowSnapshot &amp;lt;path&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id="disallowsnapshot"&gt;disallowSnapshot&lt;/h2&gt;
&lt;p&gt;取消目录可快照: &lt;code&gt;hdfs dfsadmin -disallowSnapshot &amp;lt;path&amp;gt;&lt;/code&gt;&lt;/p&gt;</content><category term="大数据"></category></entry><entry><title>Shell 命令</title><link href="http://www.smallcpp.cn/shell-ming-ling.html" rel="alternate"></link><published>2016-10-26T11:19:00+08:00</published><updated>2016-10-26T11:19:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-10-26:/shell-ming-ling.html</id><summary type="html">
&lt;h1 id="_1"&gt;基础使用&lt;/h1&gt;
&lt;h2 id="_2"&gt;执行方式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;方式一:
    + 需在脚本开头指定解释器: #!/bin/bash
    + 给脚本 +x 权限,
    + 输入脚本绝对路径或相对路径:
        * &lt;code&gt;/root/test.sh&lt;/code&gt;
        * &lt;code&gt;./test.sh&lt;/code&gt;
    + 或者在路径前再加个点
        * &lt;code&gt;. ./test.sh&lt;/code&gt;
    + 区别在于前面的会新开一个 bash (不可见), 也就是在当前 bash 变量不共享, 加个 &lt;code&gt;.&lt;/code&gt; 表示在当前脚本执行脚本&lt;/li&gt;
&lt;li&gt;方式二:
    用指定解释器执行 sh test …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">
&lt;h1 id="_1"&gt;基础使用&lt;/h1&gt;
&lt;h2 id="_2"&gt;执行方式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;方式一:
    + 需在脚本开头指定解释器: #!/bin/bash
    + 给脚本 +x 权限,
    + 输入脚本绝对路径或相对路径:
        * &lt;code&gt;/root/test.sh&lt;/code&gt;
        * &lt;code&gt;./test.sh&lt;/code&gt;
    + 或者在路径前再加个点
        * &lt;code&gt;. ./test.sh&lt;/code&gt;
    + 区别在于前面的会新开一个 bash (不可见), 也就是在当前 bash 变量不共享, 加个 &lt;code&gt;.&lt;/code&gt; 表示在当前脚本执行脚本&lt;/li&gt;
&lt;li&gt;方式二:
    用指定解释器执行 sh test.sh&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_3"&gt;接收控制台输入&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;read -p(提示语句) -n(字符个数) -t(等待时间) variable&lt;/code&gt;&lt;/p&gt;
&lt;h2 id="_4"&gt;接收命令返回值&lt;/h2&gt;
&lt;p&gt;A=`ls -l` — 反引号 (飘号)&lt;/p&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;p&gt;A=$(ls -l)&lt;/p&gt;
&lt;h2 id="_5"&gt;定义变量&lt;/h2&gt;
&lt;p&gt;不能有空格, 如果字符串中有空格, 要用引号包围.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;STR="hello wored"&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unset STR&lt;/code&gt; 撤销变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;readonly B=2&lt;/code&gt; 只读变量, 不能 unset&lt;/li&gt;
&lt;li&gt;&lt;code&gt;export&lt;/code&gt; 导出变量为全局环境变量&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_6"&gt;单引号与双引号区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;双引号仅转义空格&lt;/li&gt;
&lt;li&gt;单引号会转义所有特殊字符&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_7"&gt;特殊变量&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$?&lt;/code&gt; 上一个命令的退出状态&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$$&lt;/code&gt; 当前进程编号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$0&lt;/code&gt; 当前脚本名称&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$n&lt;/code&gt; 指定位置参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$#&lt;/code&gt; 参数个数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$*&lt;/code&gt; / &lt;code&gt;$@&lt;/code&gt; 参数列表
    + 区别: 当被双引号包围时, &lt;code&gt;$*&lt;/code&gt; 将参数列表当成一整体, &lt;code&gt;$@&lt;/code&gt; 会将参数分开&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_8"&gt;整数运算&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;expr m + n&lt;/code&gt; (这个命令要有空格)&lt;/p&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$((m+n))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如计算 (2 + 3) * 4&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分两步的写法
    + S=`expr 2 + 3`
    + &lt;code&gt;expr $S\*4&lt;/code&gt; (注意 * 要转义)&lt;/li&gt;
&lt;li&gt;一步的写法
    + echo `expr `expr 2 + 3`*4`
    + 或者 &lt;code&gt;$(((2+3)*4))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="for"&gt;for 循环&lt;/h2&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;for&lt;/span&gt; N &lt;span style="color: #8B008B; font-weight: bold"&gt;in&lt;/span&gt; &lt;span style="color: #B452CD"&gt;1&lt;/span&gt; &lt;span style="color: #B452CD"&gt;2&lt;/span&gt; &lt;span style="color: #B452CD"&gt;3&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;do&lt;/span&gt;
    &lt;span style="color: #658b00"&gt;echo&lt;/span&gt; &lt;span style="color: #00688B"&gt;$N&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;for&lt;/span&gt; N &lt;span style="color: #8B008B; font-weight: bold"&gt;in&lt;/span&gt; {&lt;span style="color: #B452CD"&gt;1&lt;/span&gt;..3}   &lt;span style="color: #228B22"&gt;# 表示 1 到 3&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;do&lt;/span&gt;
    &lt;span style="color: #658b00"&gt;echo&lt;/span&gt; &lt;span style="color: #00688B"&gt;$N&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;for&lt;/span&gt; ((&lt;span style="color: #00688B"&gt;i&lt;/span&gt; = &lt;span style="color: #B452CD"&gt;0&lt;/span&gt;; i &amp;lt;= &lt;span style="color: #B452CD"&gt;5&lt;/span&gt;; i++))
&lt;span style="color: #8B008B; font-weight: bold"&gt;do&lt;/span&gt;
    &lt;span style="color: #658b00"&gt;echo&lt;/span&gt; &lt;span style="color: #00688B"&gt;$i&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="while"&gt;while 循环&lt;/h2&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;while&lt;/span&gt; expre
&lt;span style="color: #8B008B; font-weight: bold"&gt;do&lt;/span&gt;
    &lt;span style="color: #658b00"&gt;echo&lt;/span&gt; &lt;span style="color: #CD5555"&gt;'do something'&lt;/span&gt;
end
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #00688B"&gt;i&lt;/span&gt;=&lt;span style="color: #B452CD"&gt;1&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;while&lt;/span&gt; ((i&amp;lt;&lt;span style="color: #B452CD"&gt;5&lt;/span&gt;))
&lt;span style="color: #8B008B; font-weight: bold"&gt;do&lt;/span&gt;
    &lt;span style="color: #658b00"&gt;echo&lt;/span&gt; &lt;span style="color: #CD5555"&gt;'do something'&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="case"&gt;case 选择&lt;/h2&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;case $1 in
one)
    ...
    ;;
two)
    ...
    ;;
*)
esac
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="if"&gt;if 选择&lt;/h2&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;if&lt;/span&gt; xx
&lt;span style="color: #8B008B; font-weight: bold"&gt;then&lt;/span&gt;
    xx
&lt;span style="color: #8B008B; font-weight: bold"&gt;elif&lt;/span&gt; xx
&lt;span style="color: #8B008B; font-weight: bold"&gt;then&lt;/span&gt;
    xx
&lt;span style="color: #8B008B; font-weight: bold"&gt;else&lt;/span&gt;
    xx
&lt;span style="color: #8B008B; font-weight: bold"&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="_9"&gt;布尔表达式&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;[ xx ]&lt;/code&gt;, 注意 &lt;code&gt;[  ]&lt;/code&gt; 两边有空格 (非空返回 true)&lt;/p&gt;
&lt;p&gt;表达式可使用 &lt;code&gt;$?&lt;/code&gt; 验证 (0 为 true, &amp;gt;0 为 flase)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[ xx ] &amp;amp;&amp;amp; echo OK&lt;/code&gt;, 条件成立, 执行后面的语句&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[ xx ] &amp;amp;&amp;amp; echo OK || echo NO&lt;/code&gt;, 类似三目表达式, 条件成立, echo OK, 不满足执行 echo NO&lt;/p&gt;
&lt;h2 id="_10"&gt;逻辑运算符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;字符串判断
    + &lt;code&gt;=&lt;/code&gt; 等于比较
    + &lt;code&gt;!=&lt;/code&gt; 不等于比较
    + &lt;code&gt;-z&lt;/code&gt;  空字符串
    + &lt;code&gt;-n&lt;/code&gt;  非空字符串&lt;/li&gt;
&lt;li&gt;数值判断
    + &lt;code&gt;-lt&lt;/code&gt; 小于
    + &lt;code&gt;-le&lt;/code&gt; 小于等于
    + &lt;code&gt;-eq&lt;/code&gt; 等于
    + &lt;code&gt;-gt&lt;/code&gt; 大于
    + &lt;code&gt;-ge&lt;/code&gt; 大于等于
    + &lt;code&gt;-ne&lt;/code&gt; 不等于&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_11"&gt;文件判断&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-r&lt;/code&gt;有读权限&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-w&lt;/code&gt;有写权限&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-x&lt;/code&gt;有执行权限&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-f&lt;/code&gt;文件存在并且是一个常规文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-s&lt;/code&gt;文件存在且不为空&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt;文件存在且是一个目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-b&lt;/code&gt;文件存在且是一个块设备&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-L&lt;/code&gt;文件存在且是一个链接&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_12"&gt;函数&lt;/h2&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;function&lt;/span&gt; xxx() / &lt;span style="color: #8B008B; font-weight: bold"&gt;function&lt;/span&gt; start / start()
{
    ...;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;return&lt;/span&gt; int; &lt;span style="color: #228B22"&gt;# 只能返回 int 型 1~255&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数没有形参, 通过调用时指定, 在函数体内, 通过 &lt;code&gt;$1~n&lt;/code&gt; 来取.&lt;/p&gt;
&lt;p&gt;返回值通过 &lt;code&gt;$?&lt;/code&gt; 来获取.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;function&lt;/span&gt; fSum()
{
    &lt;span style="color: #658b00"&gt;echo&lt;/span&gt; &lt;span style="color: #00688B"&gt;$1&lt;/span&gt;, &lt;span style="color: #00688B"&gt;$2&lt;/span&gt;;
    reutrn &lt;span style="color: #8B008B; font-weight: bold"&gt;$((&lt;/span&gt;&lt;span style="color: #00688B"&gt;$1&lt;/span&gt;+&lt;span style="color: #00688B"&gt;$2&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;))&lt;/span&gt;;
}
fSum &lt;span style="color: #B452CD"&gt;3&lt;/span&gt; &lt;span style="color: #B452CD"&gt;2&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="_13"&gt;脚本调试&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;sh -vx xxx.sh&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;p&gt;在脚本中增加 &lt;code&gt;set -x&lt;/code&gt;&lt;/p&gt;
&lt;h1 id="sort"&gt;sort&lt;/h1&gt;
&lt;p&gt;sort 命令对 File 参数指定的文件中的&lt;strong&gt;行&lt;/strong&gt;排序, 并将结果写到标准输出. 如果 File 参数指定多个文件, 那么 sort 命令将这些文件连接起来, 并当作一个文件进行排序.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;sort [-fbMnrtuk] [file or stdin]
选项与参数:
-f  : 忽略大小写的差异, 例如 A 与 a 视为编码相同;
-b  : 忽略最前面的空格符部分;
-M  : 以月份的名字来排序, 例如 JAN, DEC 等等的排序方法;
-n  : 使用 "纯数字" 进行排序(默认是以文字型态来排序的);
-r  : 反向排序;
-u  : 就是 uniq, 相同的数据中, 仅出现一行代表;
-t  : 分隔符, 默认是用 [tab] 键来分隔;
-k  : 以那个区间 (field) 来进行排序的意思
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对 &lt;code&gt;/etc/passwd&lt;/code&gt; 的账号进行排序&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;cat /etc/passwd | sort
adm:x:3:4:adm:/var/adm:/sbin/nologin
apache:x:48:48:Apache:/var/www:/sbin/nologin
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;sort 是默认以首字母来排序, 而且默认是以&lt;strong&gt;字符&lt;/strong&gt;形式来排序, 所以由字母 a 开始升序排序.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/etc/passwd&lt;/code&gt; 内容是以 &lt;code&gt;:&lt;/code&gt; 来分隔的, 我想以第三栏来排序, 该如何? 可以使用 &lt;code&gt;-t&lt;/code&gt;和 &lt;code&gt;-k&lt;/code&gt; 参数:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;cat /etc/passwd | sort -t ':' -k 3
root:x:0:0:root:/root:/bin/bash
uucp:x:10:14:uucp:/var/spool/uucp:/sbin/nologin
operator:x:11:0:operator:/root:/sbin/nologin
bin:x:1:1:bin:/bin:/sbin/nologin
games:x:12:100:games:/usr/games:/sbin/nologin
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;刚提到 sort 默认是以字符来排序的, 如果想要使用数字排序 (注意后面的 n):&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;cat /etc/passwd | sort -t ':' -k 3n
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认是升序排序, 如果要倒序排序, 如下 (注意后面的 r):&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;cat /etc/passwd | sort -t ':' -k 3nr
nobody:x:65534:65534:nobody:/nonexistent:/bin/sh
ntp:x:106:113::/home/ntp:/bin/false
messagebus:x:105:109::/var/run/dbus:/bin/false
sshd:x:104:65534::/var/run/sshd:/usr/sbin/nologin
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果要对 &lt;code&gt;/etc/passwd&lt;/code&gt;, 先以第六个域的第 2 个字符到第 4 个字符进行正向排序, 再基于第一个域进行反向排序:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;cat /etc/passwd | sort -t ':' -k 6.2,6.4 -k 1r
sync:x:4:65534:sync:/bin:/bin/sync
proxy:x:13:13:proxy:/bin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对 &lt;code&gt;/etc/passwd&lt;/code&gt; 的第七个域进行排序, 然后去重:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;cat /etc/passwd | sort -t ':' -k 7 -u
root:x:0:0:root:/root:/bin/bash
syslog:x:101:102::/home/syslog:/bin/false
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
sync:x:4:65534:sync:/bin:/bin/sync
sshd:x:104:65534::/var/run/sshd:/usr/sbin/nologin
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="uniq"&gt;uniq&lt;/h1&gt;
&lt;p&gt;uniq 命令可以去除&lt;strong&gt;排序过&lt;/strong&gt;的文件中的重复行, 因此 uniq 经常和 sort 合用.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;uniq [-icu]
选项与参数:
-i   : 忽略大小写字符的不同;
-c  : 进行计数
-u  : 只显示唯一的行
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如存在一个 testfile 文件, 内容如下:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;hello
world
friend
hello
world
hello
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;直接删除未经排序的文件, 将会发现没有任何行被删除&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;uniq testfile
hello
world
friend
hello
world
hello
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;排序文件后再去重&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;cat words | sort |uniq
friend
hello
world
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;排序之后删除了重复行, 同时在行首位置输出该行重复的次数:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;sort testfile | uniq -c
1 friend
3 hello
2 world
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;仅显示存在重复的行, 并在行首显示该行重复的次数:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;sort testfile | uniq -dc
3 hello
2 world
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;仅显示不重复的行:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;sort testfile | uniq -u
friend
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="cut"&gt;cut&lt;/h1&gt;
&lt;p&gt;cut 命令可以从一个文本文件或者文本流中提取文本列.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;选项与参数:
-d  : 后面接分隔字符. 与 -f 一起使用;
-f  : 依据 -d 的分隔字符将一段信息分割成为数段, 用 -f 取出第几段的意思 (即下标);
-c  : 以字符 (characters) 的单位取出固定字符区间;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如 PATH 变量如下 (以 : 分割):&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;echo $PATH
/bin:/usr/bin:/sbin:/usr/sbin:/usr/local/bin:/usr/X11R6/bin:/usr/games
# 1 | 2       | 3   | 4       | 5            | 6            | 7
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将 PATH 变量取出, 我要找出第五个路径:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;echo $PATH | cut -d ':' -f 5
/usr/local/bin
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将 PATH 变量取出, 我要找出第三和第五个路径:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;echo $PATH | cut -d ':' -f 3,5
/sbin:/usr/local/bin
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将 PATH 变量取出, 我要找出第三到最后一个路径:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;echo $PATH | cut -d ':' -f 3-
/sbin:/usr/sbin:/usr/local/bin:/usr/X11R6/bin:/usr/games
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将 PATH 变量取出, 我要找出第一到第三个路径:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;echo $PATH | cut -d ':' -f 1-3
/bin:/usr/bin:/sbin:
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将 PATH 变量取出, 我要找出第一到第三, 还有第五个路径:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;echo $PATH | cut -d ':' -f 1-3,5
/bin:/usr/bin:/sbin:/usr/local/bin
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="wc"&gt;wc&lt;/h1&gt;
&lt;p&gt;统计文件里面有多少单词, 多少行, 多少字符.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;wc [-lLwmc]
选项与参数:
-l  : 仅列出行;
-L  : 最长行数;
-w  : 仅列出多少字 (英文单字);
-m  : 多少字符;
-c  : 统计文件字节;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认使用 wc 统计 &lt;code&gt;/etc/passwd&lt;/code&gt;&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;wc /etc/passwd
40   45 1719 /etc/passwd
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;40 是行数, 45 是单词数, 1719 是字节数.&lt;/p&gt;
&lt;h1 id="sed"&gt;sed&lt;/h1&gt;
&lt;p&gt;sed 是一种在线编辑器, 它一次处理&lt;strong&gt;一行&lt;/strong&gt;内容 (即以行为处理单位).&lt;/p&gt;
&lt;p&gt;sed 主要用来自动编辑一个或多个文件; 简化对文件的反复操作; 编写转换程序等.&lt;/p&gt;
&lt;p&gt;处理时, 把当前处理的行存储在临时缓冲区中, 称为 “模式空间” (pattern space), 接着用 sed 命令处理缓冲区中的内容, 处理完成后, 把缓冲区的内容送往屏幕, 接着处理下一行, 这样不断重复, 直到文件末尾.&lt;/p&gt;
&lt;p&gt;seb 默认不会改变源文件内容, 除非你使用重定向存储输出或者 &lt;code&gt;-i&lt;/code&gt; 参数.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;sed [-nefr] '[function]'
选项与参数:
-n : 使用安静 (silent) 模式. 默认 seb 会打印所有内容, 安静模式下不打印默认输出 (经常与 p 指令一起用);
-i : 直接修改读取的文件内容, 而不是输出到终端.
-f : 将 sed 的动作写在一个文件内,  -f filename 则可以运行 filename 内的 sed 动作;
-r : sed 的动作支持的是延伸型正规表示法的语法. (默认是基础正规表示法语法)
-e : 多操作, 将多个 seb 操作写成一行;

function (请务必以 ' ' 单引号包围!):
d : 删除;
a : 新增, a 的后面可以接字串, 而这些字串会在新的一行出现 (目前的下一行);
i : 插入, i 的后面可以接字串, 而这些字串会在新的一行出现 (目前的上一行);
s : 替换, s 紧跟的那个字符为分割符 (以字符为单位替换);
c : 替换, c 的后面可以接字串, 这些字串可以取代 n1,n2 之间的行 (以行为单位替换);
p : 指定只打印被修改后的行  (经常与 -n 参数一起用)
q : 完成一个指令后就退出 seb 模式 (如只替换第一个找到的字符)
g : 全局匹配
, : 截取行
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将 &lt;code&gt;/etc/passwd&lt;/code&gt; 的内容列出并且打印行号, 同时, 请将第 2~5 行删除:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;nl 命令用来计算文件中行号&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;nl /etc/passwd | sed '2,5d'
1 root:x:0:0:root:/root:/bin/bash
6 sync:x:5:0:sync:/sbin:/bin/sync
7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
......
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要删除第 3 到最后一行:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;nl /etc/passwd | sed '3,$d'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在第二行后追加 “drink tea” 字样:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;nl /etc/passwd | sed '2a drink tea'
1 root:x:0:0:root:/root:/bin/bash
2 bin:x:1:1:bin:/bin:/sbin/nologin
drink tea
3 daemon:x:2:2:daemon:/sbin:/sbin/nologin
.....
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果是要增加两行以上, 在第二行后面加入两行字, 例如 “Drink tea or ....” 与 “drink beer?”:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;nl /etc/passwd | sed '2a Drink tea or ......\
&amp;gt; drink beer ?'
1 root:x:0:0:root:/root:/bin/bash
2 bin:x:1:1:bin:/bin:/sbin/nologin
Drink tea or ......
drink beer?
3 daemon:x:2:2:daemon:/sbin:/sbin/nologin
.....
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;每一行之间都必须要以反斜杠 &lt;code&gt;\&lt;/code&gt; 来进行新行的添加!&lt;/p&gt;
&lt;p&gt;将第 2-5 行的内容取代成为 “No 2-5 number”:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;nl /etc/passwd | sed '2,5c No 2-5 number'
1 root:x:0:0:root:/root:/bin/bash
No 2-5 number
6 sync:x:5:0:sync:/sbin:/bin/sync
.....
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过这个方法我们就能够将数据整行取代了!&lt;/p&gt;
&lt;p&gt;仅列出 /etc/passwd 文件内的第 5-7 行:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;nl /etc/passwd | sed -n '5,7p'
5 lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
6 sync:x:5:0:sync:/sbin:/bin/sync
7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;搜索 &lt;code&gt;/etc/passwd&lt;/code&gt; 有 root 关键字的行:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;nl /etc/passwd | sed -n '/root/p'
1  root:x:0:0:root:/root:/bin/bash
....
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;删除 &lt;code&gt;/etc/passwd&lt;/code&gt; 所有包含 root 的行, 其他行输出&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;nl /etc/passwd | sed  '/root/d'
2  daemon:x:1:1:daemon:/usr/sbin:/bin/sh
3  bin:x:2:2:bin:/bin:/bin/sh
....
# 第一行的匹配 root 已经删除了
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还可以对匹配的结果做进一步处理, 将动作用花括号包围就可以了, 多动作的话用分号分隔, 如搜索 &lt;code&gt;/etc/passwd&lt;/code&gt;, 将有 root 的行中的 bash 替换为 blueshell:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;nl /etc/passwd | sed -n '/root/{s/bash/blueshell/;p}'
1  root:x:0:0:root:/root:/bin/blueshell
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果只替换第一个 bash 关键字为 blueshell, 就退出:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;nl /etc/passwd | sed -n '/bash/{s/bash/blueshell/;p;q}'
1  root:x:0:0:root:/root:/bin/blueshell
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;s 指令还可以对匹配到的字符串进行替换, s 紧跟的那个字符为分割符, 以下示例用 &lt;code&gt;/&lt;/code&gt; 分割:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;sed 's/aaa/bbb/g' 将所有的 aaa 替换成 bbb, 如果不加 g, 只替换每行找到的第一个 aaa
sed 's/aaa/&amp;amp;bbb/' &amp;amp; 表示用找到的字符追加 bbb, 这里就变成了 aaabbb
sed 's#\(love\)able#\1rs', 替换一部分, 括号里的 love 保留并标识为 1, 所以这里 loveable -&amp;gt; 1rs -&amp;gt; lovers
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;s 指令支持正则表达式.&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;-e&lt;/code&gt; 参数可以将多行 sed 命令连写, 如删除 &lt;code&gt;/etc/passwd&lt;/code&gt; 第三行到末尾的数据, 然后把 bash 替换为 blueshell:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;nl /etc/passwd | sed -e '3,$d' -e 's/bash/blueshell/'
1  root:x:0:0:root:/root:/bin/blueshell
2  daemon:x:1:1:daemon:/usr/sbin:/bin/sh
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="awk"&gt;awk&lt;/h1&gt;
&lt;p&gt;awk 是一个强大的文本分析工具, 相对于 grep 的查找, sed 的编辑, awk 在其对数据分析并生成报告时, 显得尤为强大.&lt;/p&gt;
&lt;p&gt;简单来说 awk 就是把文件&lt;strong&gt;逐行&lt;/strong&gt;的读入, 以&lt;strong&gt;空格&lt;/strong&gt;为默认分隔符将每行切片, 切开的部分再进行各种分析处理.&lt;/p&gt;
&lt;p&gt;awk 的强大以至于它甚至形成了自己的语言体系, 即 AWK 编程, 它允许您创建简短的程序, 这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表, 还有无数其他的功能. , 但对于我来说, 了解它的基础用法就足够了, 更高级的功能我更喜欢用 Python 来完成.&lt;/p&gt;
&lt;p&gt;awk 语言的最基本功能是在文件或者字符串中基于指定规则浏览和抽取信息, awk 抽取信息后, 才能进行其他文本操作.&lt;/p&gt;
&lt;p&gt;完整的 awk 脚本通常用来格式化文本文件中的信息, 通常, awk 是以文件的一行为处理单位的. awk 每接收文件的一行, 然后执行相应的命令, 来处理文本.&lt;/p&gt;
&lt;p&gt;调用 awk 的三种方式:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;1. 命令行方式
awk [-F  field-separator]  'commands'  input-file(s)
其中, commands 是真正 awk 命令, 通过包含两部分内容: 'pattern {action}'
pattern : 要查找的内容 (支持正则, 不指定 pattern, 则对所有行进行 action)
action : 对匹配内容所执行的操作 (不指定 action 则默认输出每行的内容)
-F 域分隔符是可选的. input-file(s) 是待处理的文件.
在 awk 中, 文件的每一行中, 由域分隔符分开的每一项称为一个域. 通常, 在不指名 -F 域分隔符的情况下, 默认的域分隔符是空格或 tab.

2. shell 脚本方式
将所有的 awk 命令插入一个文件, 并使 awk 程序可执行, 然后 awk 命令解释器作为脚本的首行, 一遍通过键入脚本名称来调用.
相当于 shell 脚本首行的: #!/bin/sh
可以换成: #!/bin/awk

3. 将所有的 awk 命令插入一个单独文件, 然后调用:
awk -f awk-script-file input-file(s)
其中, -f 选项加载 awk-script-file 中的 awk 脚本, input-file(s) 跟上面的是一样的.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里着重介绍命令行方式.&lt;/p&gt;
&lt;p&gt;假设 &lt;code&gt;last -n 5&lt;/code&gt; 的输出如下:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;last -n 5
root     pts/1   192.168.1.100  Tue Feb 10 11:21   still logged in
root     pts/1   192.168.1.100  Tue Feb 10 00:46 - 02:28  (01:41)
root     pts/1   192.168.1.100  Mon Feb  9 11:41 - 18:30  (06:48)
dmtsai   pts/1   192.168.1.100  Mon Feb  9 11:41 - 11:41  (00:00)
root     tty1                   Fri Sep  5 14:09 - 14:10  (00:01)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果只是显示最近登录的 5 个帐号的名称:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;last -n 5 | awk  '{print $1}'
root
root
root
dmtsai
root
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;awk 工作流程是这样的:&lt;/p&gt;
&lt;p&gt;读入有 ‘\n’ 换行符分割的一条记录, 然后将记录按指定的域分隔符划分域, 填充域, &lt;code&gt;$0&lt;/code&gt; 则表示所有域, &lt;code&gt;$1&lt;/code&gt; 表示第一个域, &lt;code&gt;$n&lt;/code&gt; 表示第 n 个域. 默认域分隔符是 “空白键” 或 “[tab]键”, 所以 &lt;code&gt;$1&lt;/code&gt; 表示登录用户, &lt;code&gt;$3&lt;/code&gt; 表示登录用户ip, 以此类推.&lt;/p&gt;
&lt;p&gt;下面的操作只显示 &lt;code&gt;/etc/passwd&lt;/code&gt; 的账户和账户对应的 shell, 而账户与 shell 之间以 tab 键分割:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;cat /etc/passwd |awk  -F ':'  '{print $1"\t"$7}'
root    /bin/bash
daemon  /bin/sh
bin     /bin/sh
sys     /bin/sh
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面的操作显示 &lt;code&gt;/etc/passwd&lt;/code&gt; 的账户和账户对应的 shell, 而账户与 shell 之间以逗号分割, 而且在所有行添加列名 “name, shell”, 在最后一行添加 “blue, /bin/nosh”.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;cat /etc/passwd |awk  -F ':'  'BEGIN {print "name,shell"}  {print $1","$7} END {print "blue,/bin/nosh"}'
name,shell
root,/bin/bash
daemon,/bin/sh
bin,/bin/sh
sys,/bin/sh
....
blue,/bin/nosh
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;awk 工作流程是这样的: 先执行 BEGING, 然后处理文件, 最后执行 END 操作.&lt;/p&gt;
&lt;p&gt;搜索 &lt;code&gt;/etc/passwd&lt;/code&gt; 有 root 关键字的所有行:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;awk -F ':' '/root/' /etc/passwd
root:x:0:0:root:/root:/bin/bash
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;搜索 &lt;code&gt;/etc/passwd&lt;/code&gt; 有 root 关键字的所有行, 并显示对应的 shell:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;awk -F ':' '/root/{print $7}' /etc/passwd
/bin/bash
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;awk 有许多内置变量用来设置环境信息, 这些变量可以被改变, 下面给出了最常用的一些变量.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ARGC&lt;/code&gt;
    + 命令行参数个数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ARGV&lt;/code&gt;
    + 命令行参数排列&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ENVIRON&lt;/code&gt;
    + 支持队列中系统环境变量的使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FILENAME&lt;/code&gt;
    + awk 浏览的文件名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FNR&lt;/code&gt;
    + 浏览文件的记录数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FS&lt;/code&gt;
    + 设置输入域分隔符, 等价于命令行 -F选项&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NF&lt;/code&gt;
    + 浏览记录的域的个数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NR&lt;/code&gt;
    + 已读的记录数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OFS&lt;/code&gt;
    + 输出域分隔符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ORS&lt;/code&gt;
    + 输出记录分隔符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RS&lt;/code&gt;
    + 控制记录分隔符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$0~n&lt;/code&gt;
    + 域选择器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;统计 &lt;code&gt;/etc/passwd&lt;/code&gt; 文件名, 每行的行号, 每行的列数, 对应的完整行内容:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;awk  -F ':'  '{print "filename:" FILENAME ", linenumber:" NR ", columns:" NF ", linecontent:"$0}' /etc/passwd
filename:/etc/passwd,linenumber:1,columns:7,linecontent:root:x:0:0:root:/root:/bin/bash
filename:/etc/passwd,linenumber:2,columns:7,linecontent:daemon:x:1:1:daemon:/usr/sbin:/bin/sh
filename:/etc/passwd,linenumber:3,columns:7,linecontent:bin:x:2:2:bin:/bin:/bin/sh
filename:/etc/passwd,linenumber:4,columns:7,linecontent:sys:x:3:3:sys:/dev:/bin/sh
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用 printf 替代 print, 可以让代码更加简洁, 易读:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;awk  -F ':'  '{printf("filename:%10s, linenumber:%s, columns:%s, linecontent:%s\n",FILENAME, NR, NF, $0)}' /etc/passwd
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;printf 函数, 其用法和 c 语言中 printf 基本相似, 可以格式化字符串, 输出复杂时, printf 更加好用, 代码更易懂.&lt;/p&gt;</content><category term="软件工程"></category></entry><entry><title>NodeJs 调试技巧</title><link href="http://www.smallcpp.cn/nodejs-diao-shi-ji-qiao.html" rel="alternate"></link><published>2016-10-24T18:37:00+08:00</published><updated>2016-10-24T18:37:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-10-24:/nodejs-diao-shi-ji-qiao.html</id><summary type="html">
&lt;h1 id="supervisor"&gt;supervisor&lt;/h1&gt;
&lt;p&gt;node.js 的 supervisor 插件可以帮我们监控文件的改动, 自动重启服务器, 这个 supervisor 是 node.js 的一个包 (而不是 python 的那个 supervisor, 别弄混了), 安装起来很简单, 使用 npm 的安装命令就可以, 因为我们需要在控制台运行, 所以需要安装在全局环境中.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;npm install -g supervisor
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就可以使用 supervisor …&lt;/p&gt;</summary><content type="html">
&lt;h1 id="supervisor"&gt;supervisor&lt;/h1&gt;
&lt;p&gt;node.js 的 supervisor 插件可以帮我们监控文件的改动, 自动重启服务器, 这个 supervisor 是 node.js 的一个包 (而不是 python 的那个 supervisor, 别弄混了), 安装起来很简单, 使用 npm 的安装命令就可以, 因为我们需要在控制台运行, 所以需要安装在全局环境中.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;npm install -g supervisor
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就可以使用 supervisor 启动脚本了:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;supervisor sss.js

Running node-supervisor with
  program 'sss.js'
  --watch '.'
  --extensions 'node,js'
  --exec 'node'

Starting child process with 'node sss.js'
Watching directory 'C:\Users\chaoqun.zhu\Desktop\testjs' for changes.
Press rs for restarting the process.
http://127.0.0.1:5586
crashing child
Starting child process with 'node sss.js'
http://127.0.0.1:5586
crashing child
Starting child process with 'node sss.js'
http://127.0.0.1:5586
crashing child
Starting child process with 'node sss.js'
http://127.0.0.1:5586
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="node-debug"&gt;node debug&lt;/h1&gt;
&lt;p&gt;node.js 提供了一个内建调试器来帮助开发者调试应用程序. 想要开启调试器我们需要在代码中加入 debugger 标签, 当 node.js 执行到 debugger 标签时会自动暂停 (debugger 标签相当于在代码中开启一个断点).&lt;/p&gt;
&lt;p&gt;执行命令：&lt;code&gt;node debug xxx.js&lt;/code&gt; 就可以进入调试模式.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/NodeJs调试技巧/nodedebug.png"/&gt;&lt;/p&gt;
&lt;p&gt;以调试模式运行 js 时, 程序会直接断在入口处 (类似 OD 附加程序时), 你可以 cont 一下让程序继续跑起来, 就像 GDB 一样, 可以用 &lt;code&gt;help&lt;/code&gt; 命令查看自己都可以使用哪些调试命令.&lt;/p&gt;
&lt;p&gt;当程序中断时, 可使使用 &lt;code&gt;repl&lt;/code&gt; 进入程序上下文, 此状态下可以即时求值, 和 Chrome 的 Debug 的 Console 是一样的.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;run&lt;/td&gt;
&lt;td&gt;执行脚本, 在入口处会暂停&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;restart&lt;/td&gt;
&lt;td&gt;重新执行脚本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cont, c&lt;/td&gt;
&lt;td&gt;继续执行, 直到遇到下一个断点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;next, n&lt;/td&gt;
&lt;td&gt;单步执行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;step, s&lt;/td&gt;
&lt;td&gt;单步执行并步入函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;out, o&lt;/td&gt;
&lt;td&gt;从函数中步出&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;setBreakpoint(), sb()&lt;/td&gt;
&lt;td&gt;当前行设置断点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;setBreakpoint(‘f()’), sb(…)&lt;/td&gt;
&lt;td&gt;在函数f的第一行设置断点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;setBreakpoint(‘script.js’, 20), sb(…)&lt;/td&gt;
&lt;td&gt;在 script.js 的第 20 行设置断点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;clearBreakpoint, cb(…)&lt;/td&gt;
&lt;td&gt;清除所有断点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;backtrace, bt&lt;/td&gt;
&lt;td&gt;显示当前的调用栈&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;list(5)&lt;/td&gt;
&lt;td&gt;显示当前执行到的前后5行代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;watch(expr)&lt;/td&gt;
&lt;td&gt;把表达式 expr 加入监视列表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;unwatch(expr)&lt;/td&gt;
&lt;td&gt;把表达式 expr 从监视列表移除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;watchers&lt;/td&gt;
&lt;td&gt;显示监视列表中所有的表达式和值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;repl&lt;/td&gt;
&lt;td&gt;在当前上下文打开即时求值环境&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;kill&lt;/td&gt;
&lt;td&gt;终止当前执行的脚本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;scripts&lt;/td&gt;
&lt;td&gt;显示当前已加载的所有脚本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;version&lt;/td&gt;
&lt;td&gt;显示 v8 版本&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id="node-inspector"&gt;node-inspector&lt;/h1&gt;
&lt;p&gt;大部分 node.js 应用都是 web 应用, 所以一些基于 Chrome 的在线调试工具应运而生, 最出名的应该就是 node-inspector 了, 这是一个 node.js 的模块, 安装、使用相当的方便, 首先使用 npm 把其安装在全局环境中.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;npm install -g node-inspector
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;node-inspector 是通过 websocket 方式来转向 debug 输入输出的, 因此, 我们在调试前要先启动 node-inspector 来监听 node.js 的 debug 调试端口, 默认情况下 node-inspector 的端口是 8080, 可以通过参数 &lt;code&gt;--web-port=[port]&lt;/code&gt; 来设置端口.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;node-inspector --web-port=8888
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在启动 node-inpspector 之后, 我们可以通过 &lt;code&gt;--debug&lt;/code&gt; 或 &lt;code&gt;--debug-brk&lt;/code&gt; 来启动 node.js 程序.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;node --debug-brk xxx.js
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;控制台会返回 “debugger listening on port 5858”, 现在打开浏览嚣, 访问 &lt;code&gt;http://localhost:8888/debug?port=5858&lt;/code&gt;, 这时候就会打开一个很像 Chrome 内置调试工具的界面, 并且代码断点在第一行, 下面就可以使用这个来调试了.&lt;/p&gt;
&lt;p&gt;如果你使用 &lt;strong&gt;Sublime&lt;/strong&gt; 作为开发工具的话, 可以安装个 &lt;a href="https://github.com/houfeng0923/NodejsDebug"&gt;NodeJsDebug&lt;/a&gt; 插件;&lt;/p&gt;
&lt;p&gt;安装完以后，打开 &lt;code&gt;nodejs_debug.sublime-settings&lt;/code&gt; 文件, 将 &lt;code&gt;chrome-path&lt;/code&gt; 修改成自己电脑上的 Chrome 目录;&lt;/p&gt;
&lt;p&gt;然后 &lt;code&gt;click item 'Nodejs Debug' on contextmenu&lt;/code&gt; 插件就会代替你依次执行启动 node-inspector、启动要调试的 js、用 Chrome 打开调试的 Web 页面三个步骤.&lt;/p&gt;
&lt;h1 id="eclipse"&gt;使用 Eclipse 调试&lt;/h1&gt;
&lt;p&gt;Eclipse 提供了一个 node.js 的调试插件, 不过我基本不用 Eclipse, 所以这里仅记录下.&lt;/p&gt;</content><category term="工具折腾"></category></entry><entry><title>JSHint 速查</title><link href="http://www.smallcpp.cn/jshint-su-cha.html" rel="alternate"></link><published>2016-10-24T13:40:00+08:00</published><updated>2016-10-24T13:40:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-10-24:/jshint-su-cha.html</id><summary type="html">&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Missing semicolon&lt;/code&gt;:
    + 缺少分号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Use the function form of "use strict"&lt;/code&gt;:
    + 使用标准化定义 function&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Unexpected space after ‘-’&lt;/code&gt;:
    + 在’-&amp;lsquo;后面不应出现空格&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Expected a JSON value&lt;/code&gt;:
    + 请传入一个json的值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Mixed spaces and tabs&lt;/code&gt;:
    + 空格和TAB重复&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Unsafe character&lt;/code&gt;:
    + 不安全的字符 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Missing semicolon&lt;/code&gt;:
    + 缺少分号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Use the function form of "use strict"&lt;/code&gt;:
    + 使用标准化定义 function&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Unexpected space after ‘-’&lt;/code&gt;:
    + 在’-&amp;lsquo;后面不应出现空格&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Expected a JSON value&lt;/code&gt;:
    + 请传入一个json的值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Mixed spaces and tabs&lt;/code&gt;:
    + 空格和TAB重复&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Unsafe character&lt;/code&gt;:
    + 不安全的字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Line too long&lt;/code&gt;:
    + 本行中的字符超过设定的最大长度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Trailing whitespace&lt;/code&gt;:
    + 本行末尾有过多无用空格&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Script URL&lt;/code&gt;:
    + 脚本URL&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Unexpected {a} in ‘{b}’&lt;/code&gt;:
    + 在 ‘{b}’ 中不该出现 {a}&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Unexpected ‘{a}’&lt;/code&gt;:
    + 不该在此出现‘{a}’&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Strings must use doublequote&lt;/code&gt;:
    + 字符串需要用双引号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Unnecessary escapement&lt;/code&gt;:
    + 不需要转义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Control character in string: {a}&lt;/code&gt;:
    + 在字符串中出现了 Control 的字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Avoid \\’&lt;/code&gt;:
    + 避免 \&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Avoid \\v&lt;/code&gt;:
    + 避免 \v&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Avoid \\x-&lt;/code&gt;:
    + 避免 \x-&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Bad escapement&lt;/code&gt;:
    + 错误的转义字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Bad number ‘{a}’&lt;/code&gt;:
    + 错误的数字 ‘{a}’&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Missing space after ‘{a}’&lt;/code&gt;:
    + 在‘{a}’之后缺少空格&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Don’t use extra leading zeros ‘{a}’&lt;/code&gt;:
    + 不要再‘{a}’的前面用多余的0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Avoid 0x-. ‘{a}’&lt;/code&gt;:
    + 避免使用 0x-. ‘{a}’&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A trailing decimal point can be confused with a dot ‘{a}’&lt;/code&gt;:
    + 在‘{a}’中使用点尾随小数点&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Unexpected comment&lt;/code&gt;:
    + 不该在此处出现注释&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Unescaped ‘{a}’&lt;/code&gt;:
    + 没有转义 ‘{a}’&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Unexpected control character in regular expression&lt;/code&gt;:
    + 在正则表达式中出现了 control 字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Unexpected escaped character ‘{a}’ in regular expression&lt;/code&gt;:
    + 在正则表达式中出现了没有转义的字符 ‘{a}’&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Expected ‘{a}’ and instead saw ‘{b}’&lt;/code&gt;:
    + 应该用 ‘{a}’代替‘{b}’&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Spaces are hard to count. Use {{a}}&lt;/code&gt;:
    + 空格难以统计，请使用 {{a}}&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Insecure ‘{a}’&lt;/code&gt;:
    + 不安全的 ‘{a}’&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Empty class&lt;/code&gt;:
    + 空的class&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Expected a number and instead saw ‘{a}’&lt;/code&gt;:
    + 应该用数字代替‘{a}’&lt;/li&gt;
&lt;li&gt;&lt;code&gt;‘{a}’ should not be greater than ‘{b}’&lt;/code&gt;:
    + ‘{a}’不应该比‘{b}’大&lt;/li&gt;
&lt;li&gt;&lt;code&gt;‘hasOwnProperty’ is a really bad name&lt;/code&gt;:
    + ‘hasOwnProperty’ 是关键字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;‘{a}’ was used before it was defined&lt;/code&gt;:
    + ‘{a}’未定义就已经使用了&lt;/li&gt;
&lt;li&gt;&lt;code&gt;‘{a}’ is already defined&lt;/code&gt;:
    + ‘{a}’被重复定义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A dot following a number can be confused with a decimal point&lt;/code&gt;:
    + 数字后面的一个点会被误认为是十进制的小数点&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Confusing minusses&lt;/code&gt;:
    + 容易混淆的负数表达-&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Confusing plusses&lt;/code&gt;:
    + 容易混淆的正数表达+&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Unmatched ‘{a}’&lt;/code&gt;:
    + 无法匹配的‘{a}’&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Expected ‘{a}’ to match ‘{b}’ from line {c} and instead saw ‘{d}’&lt;/code&gt;:
    + 在行{c}中需要用‘{a}’和‘{b}’匹配，用来代替‘{d}’&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Unexpected early end of program&lt;/code&gt;:
    + 程序不可预期的提前终止&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A leading decimal point can be confused with a dot: ‘.{a}’&lt;/code&gt;:
    + ‘{a}’前的点容易混淆成小数点&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Use the array literal notation []&lt;/code&gt;:
    + 使用数组的符号 []&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Expected an operator and instead saw ‘{a}’&lt;/code&gt;:
    + 需要用一个符号来代替‘{a}’&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Unexpected space after ‘{a}’&lt;/code&gt;:
    + 在‘{a}’之后不能出现空格&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Unexpected space before ‘{a}’&lt;/code&gt;:
    + 在‘{a}’之前不能出现空格&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Bad line breaking before ‘{a}’&lt;/code&gt;:
    + 在‘{a}’之前错误的换行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Expected ‘{a}’ to have an indentation at {b} instead at {c}&lt;/code&gt;:
    + ‘{a}’需要在{c}而不是{b}处缩进&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Line breaking error ‘{a}’&lt;/code&gt;:
    + 换行错误 ‘{a}’&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Unexpected use of ‘{a}’&lt;/code&gt;:
    + 此处不能用‘{a}’&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Bad operand&lt;/code&gt;:
    + 错误的操作数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Use the isNaN function to compare with NaN&lt;/code&gt;:
    + 使用isNaN来与NaN比较&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Confusing use of ‘{a}’&lt;/code&gt;:
    + 容易混淆的‘{a}’的使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Read only&lt;/code&gt;:
    + 只读的属性&lt;/li&gt;
&lt;li&gt;&lt;code&gt;‘{a}’ is a function&lt;/code&gt;:
    + ‘{a}’是一个函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Bad assignment&lt;/code&gt;:
    + 错误的赋值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Do not assign to the exception parameter&lt;/code&gt;:
    + 不要给额外的参数赋值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Expected an identifier in an assignment and instead saw a function invocation&lt;/code&gt;:
    + 在赋值的语句中需要有一个标识符，而不是一个方法的调用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Expected an identifier and instead saw ‘{a}’ (a reserved word)&lt;/code&gt;:
    + 需要有一个标识符，而不是‘{a}’(保留字符)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Missing name in function declaration&lt;/code&gt;:
    + 在方法声明中缺少名称&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Expected an identifier and instead saw ‘{a}’&lt;/code&gt;:
    + 需要有一个标识符，而不是‘{a}’&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Inner functions should be listed at the top of the outer function&lt;/code&gt;:
    + 内部函数的声明应该放在此函数的顶部。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Unreachable ‘{a}’ after ‘{b}’&lt;/code&gt;:
    + 在‘{b}’之后无法获取‘{a}’&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Unnecessary semicolon&lt;/code&gt;:
    + 不必要的分号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Label ‘{a}’ on {b} statement&lt;/code&gt;:
    + 将‘{a}’放在{b}的声明中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Label ‘{a}’ looks like a javascript url&lt;/code&gt;:
    + ‘{a}’看上去像一个js的链接&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Expected an assignment or function call and instead saw an expression&lt;/code&gt;:
    + 需要一个赋值或者一个函数调用，而不是一个表达式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Do not use ‘new’ for side effects&lt;/code&gt;:
    + 不要用’new’语句&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Unnecessary "use strict"&lt;/code&gt;:
    + 不必要的 &amp;ldquo;use strict&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Missing "use strict" statement&lt;/code&gt;:
    + 缺少 &amp;ldquo;use strict&amp;rdquo; 的声明&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Empty block&lt;/code&gt;:
    + 空的模块&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Unexpected /*member ‘{a}’&lt;/code&gt;:
    + 不应出现 /*元素 ‘{a}’&lt;/li&gt;
&lt;li&gt;&lt;code&gt;‘{a}’ is a statement label&lt;/code&gt;:
    + ‘{a}’是一个声明&lt;/li&gt;
&lt;li&gt;&lt;code&gt;‘{a}’ used out of scope&lt;/code&gt;:
    + ‘{a}’使用超出范围&lt;/li&gt;
&lt;li&gt;&lt;code&gt;‘{a}’ is not allowed&lt;/code&gt;:
    + 不允许使用‘{a}’&lt;/li&gt;
&lt;li&gt;&lt;code&gt;‘{a}’ is not defined&lt;/code&gt;:
    + ‘{a}’没有被定义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Use ‘{a}’ to compare with ‘{b}’&lt;/code&gt;:
    + 使用‘{a}’与‘{b}’相比&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Variables should not be deleted&lt;/code&gt;:
    + 变量需要被删除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Use the object literal notation {}&lt;/code&gt;:
    + 使用对象的文字符号 {}&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Do not use {a} as a constructor&lt;/code&gt;:
    + 不要使用{a}作为一个构造对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;The Function constructor is eval&lt;/code&gt;:
    + The Function constructor is eval&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A constructor name should start with an uppercase letter&lt;/code&gt;:
    + 一个构造对象的名称必须用大写字母开头&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Bad constructor&lt;/code&gt;:
    + 错误的构造对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Weird construction. Delete ‘new’&lt;/code&gt;:
    + 构造对象有误，请删除’new’&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Missing ‘()’ invoking a constructor&lt;/code&gt;:
    + 缺少括号()&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Avoid arguments.{a}&lt;/code&gt;:
    + 避免参数.{a}&lt;/li&gt;
&lt;li&gt;&lt;code&gt;document.write can be a form of eval&lt;/code&gt;:
    + document.write 是 eval 的一种形式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;eval is evil&lt;/code&gt;:
    + 尽量不要使用eval&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Math is not a function&lt;/code&gt;:
    + Math不是一个函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Missing ‘new’ prefix when invoking a constructor&lt;/code&gt;:
    + 此处缺少了’new’&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Missing radix parameter&lt;/code&gt;:
    + 缺少参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Implied eval is evil. Pass a function instead of a string&lt;/code&gt;:
    + 传递一个函数，而不是一个字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Bad invocation&lt;/code&gt;:
    + 错误的调用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;['{a}'] is better written in dot notation&lt;/code&gt;:
    + [&amp;lsquo;{a}&amp;rsquo;]最好用点.的方式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Extra comma&lt;/code&gt;:
    + 多余的逗号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Don’t make functions within a loop&lt;/code&gt;:
    + 不要用循环的方式创建函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Unexpected parameter ‘{a}’ in get {b} function&lt;/code&gt;:
    + 在{b}方法中不该用到参数‘{a}’&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Duplicate member ‘{a}’&lt;/code&gt;:
    + 重复的‘{a}’&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Expected to see a statement and instead saw a block&lt;/code&gt;:
    + 此处应该是语句声明&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Too many var statements&lt;/code&gt;:
    + 过多var的声明&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Redefinition of ‘{a}’&lt;/code&gt;:
    + ‘{a}’被重复定义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;It is not necessary to initialize ‘{a}’ to ‘undefined’&lt;/code&gt;:
    + 无需将‘{a}’初始化为 ’undefined’&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Expected a conditional expression and instead saw an assignment&lt;/code&gt;:
    + 此处需要一个表达式，而不是赋值语句&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Expected a ‘break’ statement before ‘case’&lt;/code&gt;:
    + 在 ’case’ 之前需要有 ’break’&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Expected a ‘break’ statement before ‘default’&lt;/code&gt;:
    + 在 ’default’ 之前需要有 ’break’&lt;/li&gt;
&lt;li&gt;&lt;code&gt;This ‘switch’ should be an ‘if’&lt;/code&gt;:
    + 此处 ’switch’ 应该是 ’if’&lt;/li&gt;
&lt;li&gt;&lt;code&gt;All ‘debugger’ statements should be removed&lt;/code&gt;:
    + 请删除 ’debugger’ 的语句&lt;/li&gt;
&lt;li&gt;&lt;code&gt;‘{a}’ is not a statement label&lt;/code&gt;:
    + ‘{a}’不是一个声明标签&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Expected an assignment or function call and instead saw an expression&lt;/code&gt;:
    + 需要一个语句或者一个函数调用，而不是一个表达式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Function declarations should not be placed in blocks. Use a function expression or move the statement to the top of the outer function&lt;/code&gt;:
    + 函数的声明不能放在类似if的块中，需要放在外部函数的顶部&lt;/li&gt;
&lt;/ul&gt;</content><category term="工具折腾"></category></entry><entry><title>05. 使用 Java Api 操作 HDFS</title><link href="http://www.smallcpp.cn/05-shi-yong-java-api-cao-zuo-hdfs.html" rel="alternate"></link><published>2016-10-23T20:26:00+08:00</published><updated>2016-10-23T20:26:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-10-23:/05-shi-yong-java-api-cao-zuo-hdfs.html</id><summary type="html">&lt;p&gt;使用 Java Api 操作 HDFS&lt;/p&gt;</summary><content type="html">
&lt;p&gt;以 Hadoop 权威指南 (第三版) 3.5.2 为例.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;java.io.InputStream&lt;/span&gt;;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;java.net.URI&lt;/span&gt;;

&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;org.apache.hadoop.conf.Configuration&lt;/span&gt;;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;org.apache.hadoop.fs.FileSystem&lt;/span&gt;;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;org.apache.hadoop.fs.Path&lt;/span&gt;;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;org.apache.hadoop.io.IOUtils&lt;/span&gt;;

&lt;span style="color: #8B008B; font-weight: bold"&gt;public&lt;/span&gt; &lt;span style="color: #8B008B; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;FileSystemCat&lt;/span&gt; {
    &lt;span style="color: #8B008B; font-weight: bold"&gt;public&lt;/span&gt; &lt;span style="color: #8B008B; font-weight: bold"&gt;static&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;void&lt;/span&gt; &lt;span style="color: #008b45"&gt;main&lt;/span&gt;(String[] args) &lt;span style="color: #8B008B; font-weight: bold"&gt;throws&lt;/span&gt; Exception {
        String uri = args[&lt;span style="color: #B452CD"&gt;0&lt;/span&gt;];
        FileSystem fs = FileSystem.&lt;span style="color: #658b00"&gt;get&lt;/span&gt;(URI.&lt;span style="color: #658b00"&gt;create&lt;/span&gt;(uri), &lt;span style="color: #8B008B; font-weight: bold"&gt;new&lt;/span&gt; Configuration());
        InputStream in = &lt;span style="color: #8B008B; font-weight: bold"&gt;null&lt;/span&gt;;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;try&lt;/span&gt; {
            in = fs.&lt;span style="color: #658b00"&gt;open&lt;/span&gt;(&lt;span style="color: #8B008B; font-weight: bold"&gt;new&lt;/span&gt; Path(uri));
            IOUtils.&lt;span style="color: #658b00"&gt;copyBytes&lt;/span&gt;(&lt;span style="color: #00688B; font-weight: bold"&gt;int&lt;/span&gt;, System.&lt;span style="color: #658b00"&gt;out&lt;/span&gt;, &lt;span style="color: #B452CD"&gt;4096&lt;/span&gt;, &lt;span style="color: #8B008B; font-weight: bold"&gt;false&lt;/span&gt;);
        } &lt;span style="color: #8B008B; font-weight: bold"&gt;finally&lt;/span&gt; {
            IOUtils.&lt;span style="color: #658b00"&gt;closeStream&lt;/span&gt;(in);
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码就不解释了, 主要记录一下环境设置.&lt;/p&gt;
&lt;h1 id="_1"&gt;环境变量&lt;/h1&gt;
&lt;p&gt;如果你是参考我的 Wiki &lt;a href="http://wiki.smallcpp.cn/Hadoop/%E6%90%AD%E5%BB%BA%20Hadoop%20%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83.html#33"&gt;搭建 Hadoop 分布式实验环境&lt;/a&gt; 搭建的实验环境, 那环境变量应该是已经配好了.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vim ~/.bashrc&lt;/code&gt;&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #658b00"&gt;export&lt;/span&gt; &lt;span style="color: #00688B"&gt;JAVA_HOME&lt;/span&gt;=/usr/java/jdk1.8.0_101
&lt;span style="color: #658b00"&gt;export&lt;/span&gt; &lt;span style="color: #00688B"&gt;HADOOP_HOME&lt;/span&gt;=/usr/smallcpp/hadoop-2.7.3
&lt;span style="color: #658b00"&gt;export&lt;/span&gt; &lt;span style="color: #00688B"&gt;PATH&lt;/span&gt;=&lt;span style="color: #00688B"&gt;$PATH&lt;/span&gt;:&lt;span style="color: #00688B"&gt;$JAVA_HOME&lt;/span&gt;/bin:&lt;span style="color: #00688B"&gt;$HADOOP_HOME&lt;/span&gt;/bin:&lt;span style="color: #00688B"&gt;$HADOOP_HOME&lt;/span&gt;/sbin
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行 &lt;code&gt;source ~/.bashrc&lt;/code&gt; 刷新环境变量.&lt;/p&gt;
&lt;h1 id="hadoop"&gt;Hadoop 类目录&lt;/h1&gt;
&lt;p&gt;这个类目录的作用是当运行 hadoop 或者 hdfs 的命令时, 命令的搜索目录.&lt;/p&gt;
&lt;p&gt;首先到 Hadoop 的根目录下创建一个新目录:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #658b00"&gt;cd&lt;/span&gt; /usr/smallcpp/hadoop-2.7.3/
mkdir myclass
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后 &lt;code&gt;vim hadoop-env.sh&lt;/code&gt; 设置 &lt;code&gt;HADOOP_CLASSPATH&lt;/code&gt;:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;# Extra Java CLASSPATH elements.  Automatically insert capacity-scheduler.&lt;/span&gt;
&lt;span style="color: #658b00"&gt;export&lt;/span&gt; &lt;span style="color: #00688B"&gt;HADOOP_CLASSPATH&lt;/span&gt;=/usr/smallcpp/hadoop-2.7.3/myclass

&lt;span style="color: #8B008B; font-weight: bold"&gt;for&lt;/span&gt; f &lt;span style="color: #8B008B; font-weight: bold"&gt;in&lt;/span&gt; &lt;span style="color: #00688B"&gt;$HADOOP_HOME&lt;/span&gt;/contrib/capacity-scheduler/*.jar; &lt;span style="color: #8B008B; font-weight: bold"&gt;do&lt;/span&gt;
  &lt;span style="color: #8B008B; font-weight: bold"&gt;if&lt;/span&gt; [ &lt;span style="color: #CD5555"&gt;"&lt;/span&gt;&lt;span style="color: #00688B"&gt;$HADOOP_CLASSPATH&lt;/span&gt;&lt;span style="color: #CD5555"&gt;"&lt;/span&gt; ]; &lt;span style="color: #8B008B; font-weight: bold"&gt;then&lt;/span&gt;
    &lt;span style="color: #658b00"&gt;export&lt;/span&gt; &lt;span style="color: #00688B"&gt;HADOOP_CLASSPATH&lt;/span&gt;=&lt;span style="color: #00688B"&gt;$HADOOP_CLASSPATH&lt;/span&gt;:&lt;span style="color: #00688B"&gt;$f&lt;/span&gt;
  &lt;span style="color: #8B008B; font-weight: bold"&gt;else&lt;/span&gt;
    &lt;span style="color: #658b00"&gt;export&lt;/span&gt; &lt;span style="color: #00688B"&gt;HADOOP_CLASSPATH&lt;/span&gt;=&lt;span style="color: #00688B"&gt;$f&lt;/span&gt;
  &lt;span style="color: #8B008B; font-weight: bold"&gt;fi&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样当执行 &lt;code&gt;hdfs FileSystemCat&lt;/code&gt; 的时候, 就会去 &lt;code&gt;/usr/smallcpp/hadoop-2.7.3/myclass&lt;/code&gt; 找我们写好的 &lt;code&gt;FileSystemCat&lt;/code&gt; 应用了.&lt;/p&gt;
&lt;h1 id="_2"&gt;编译源码&lt;/h1&gt;
&lt;p&gt;要将 Java 源码文件编译成 &lt;code&gt;.class&lt;/code&gt; 文件才能被 Hadoop 识别, 编译 Hdfs 应用需要导入 Hadoop 的 jar 包, 这些包位于以下目录:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;/usr/smallcpp/hadoop-2.7.1/share/hadoop/common&lt;/li&gt;
&lt;li&gt;/usr/smallcpp/hadoop-2.7.1/share/hadoop/common/lib&lt;/li&gt;
&lt;li&gt;/usr/smallcpp/hadoop-2.7.1/share/hadoop/hdfs&lt;/li&gt;
&lt;li&gt;/usr/smallcpp/hadoop-2.7.1/share/hadoop/hdfs/lib&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们这里的例子用到的是 &lt;code&gt;/usr/smallcpp/hadoop-2.7.3/share/hadoop/common/hadoop-common-2.7.3.jar&lt;/code&gt; 包, 执行 &lt;code&gt;javac&lt;/code&gt; 命令时用 &lt;code&gt;-cp&lt;/code&gt; 指定下就好.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;javac -cp /usr/smallcpp/hadoop-2.7.3/share/hadoop/common/hadoop-common-2.7.3.jar FileSystemCat.java
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后 &lt;code&gt;/usr/smallcpp/hadoop-2.7.3/myclass&lt;/code&gt; 下就多了个 &lt;code&gt;FileSystemCat.class&lt;/code&gt; 文件.&lt;/p&gt;
&lt;p&gt;这时执行 &lt;code&gt;hdfs FileSystemCat /xxx&lt;/code&gt; 就能查看到 &lt;code&gt;xxx&lt;/code&gt; 文件的内容啦, 类似 linux 的 &lt;code&gt;cat&lt;/code&gt; 命令.&lt;/p&gt;
&lt;h1 id="ant"&gt;ant&lt;/h1&gt;
&lt;p&gt;由于编译源码时需要指定 Hadoop 的 jar 包, 当引入的 jar 包多时, 这样就特别麻烦, 我们可以借用 ant 工具来编译源码, ant 可以在 &lt;code&gt;bulid.xml&lt;/code&gt; 中设定 jar 包的所在目录, 这样就比较方便了.&lt;/p&gt;
&lt;p&gt;这里仅作介绍, 因为我是使用 &lt;a href="http://www.smallcpp.cn/05-shi-yong-java-api-cao-zuo-hdfs.html#eclipse-hdfs"&gt;Eclipse&lt;/a&gt; 进行开发的, 导入 jar 包相对于说, 还是比较方便的.&lt;/p&gt;
&lt;h1 id="_3"&gt;其他例子&lt;/h1&gt;
&lt;h2 id="1"&gt;例 1&lt;/h2&gt;
&lt;p&gt;读入本地文件系统一个大约一百多字节的文本文件, 并将其第 101-120 字节的内容写入 HDFS 成为一个新文件.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;java.io.BufferedInputStream&lt;/span&gt;;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;java.io.FileInputStream&lt;/span&gt;;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;java.io.InputStream&lt;/span&gt;;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;java.io.OutputStream&lt;/span&gt;;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;java.net.URI&lt;/span&gt;;

&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;org.apache.hadoop.conf.Configuration&lt;/span&gt;;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;org.apache.hadoop.fs.FileSystem&lt;/span&gt;;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;org.apache.hadoop.fs.Path&lt;/span&gt;;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;org.apache.hadoop.io.IOUtils&lt;/span&gt;;


&lt;span style="color: #8B008B; font-weight: bold"&gt;public&lt;/span&gt; &lt;span style="color: #8B008B; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CopyLocalToHdfs&lt;/span&gt; {

    &lt;span style="color: #8B008B; font-weight: bold"&gt;public&lt;/span&gt; &lt;span style="color: #8B008B; font-weight: bold"&gt;static&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;void&lt;/span&gt; &lt;span style="color: #008b45"&gt;main&lt;/span&gt;(String[] args) &lt;span style="color: #8B008B; font-weight: bold"&gt;throws&lt;/span&gt; Exception {
        String local_uri = args[&lt;span style="color: #B452CD"&gt;0&lt;/span&gt;];
        String hdfs_uri = args[&lt;span style="color: #B452CD"&gt;1&lt;/span&gt;];
        InputStream in = &lt;span style="color: #8B008B; font-weight: bold"&gt;new&lt;/span&gt; BufferedInputStream(&lt;span style="color: #8B008B; font-weight: bold"&gt;new&lt;/span&gt; FileInputStream(local_uri));
        in.&lt;span style="color: #658b00"&gt;skip&lt;/span&gt;(&lt;span style="color: #B452CD"&gt;100&lt;/span&gt;);
        FileSystem fs = FileSystem.&lt;span style="color: #658b00"&gt;get&lt;/span&gt;(URI.&lt;span style="color: #658b00"&gt;create&lt;/span&gt;(hdfs_uri), &lt;span style="color: #8B008B; font-weight: bold"&gt;new&lt;/span&gt; Configuration(), &lt;span style="color: #CD5555"&gt;"hanxiao"&lt;/span&gt;);
        OutputStream out = fs.&lt;span style="color: #658b00"&gt;create&lt;/span&gt;(&lt;span style="color: #8B008B; font-weight: bold"&gt;new&lt;/span&gt; Path(hdfs_uri));
        IOUtils.&lt;span style="color: #658b00"&gt;copyBytes&lt;/span&gt;(in, out, (&lt;span style="color: #00688B; font-weight: bold"&gt;long&lt;/span&gt;)&lt;span style="color: #B452CD"&gt;20&lt;/span&gt;, &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;);
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="2"&gt;例 2&lt;/h2&gt;
&lt;p&gt;例 1 的反向操作, 读入 HDFS 文件系统一个大约一百多字节的文本文件, 并将其第 101-120 字节的内容写入本地文件系统成为一个新文件.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;java.io.BufferedOutputStream&lt;/span&gt;;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;java.io.FileOutputStream&lt;/span&gt;;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;java.io.InputStream&lt;/span&gt;;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;java.io.OutputStream&lt;/span&gt;;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;java.net.URI&lt;/span&gt;;

&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;org.apache.hadoop.conf.Configuration&lt;/span&gt;;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;org.apache.hadoop.fs.FileSystem&lt;/span&gt;;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;org.apache.hadoop.fs.Path&lt;/span&gt;;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;org.apache.hadoop.io.IOUtils&lt;/span&gt;;


&lt;span style="color: #8B008B; font-weight: bold"&gt;public&lt;/span&gt; &lt;span style="color: #8B008B; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CopyHdfsToLocal&lt;/span&gt; {

    &lt;span style="color: #8B008B; font-weight: bold"&gt;public&lt;/span&gt; &lt;span style="color: #8B008B; font-weight: bold"&gt;static&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;void&lt;/span&gt; &lt;span style="color: #008b45"&gt;main&lt;/span&gt;(String[] args) &lt;span style="color: #8B008B; font-weight: bold"&gt;throws&lt;/span&gt; Exception {
        String hdfs_uri = args[&lt;span style="color: #B452CD"&gt;0&lt;/span&gt;];
        String local_uri = args[&lt;span style="color: #B452CD"&gt;1&lt;/span&gt;];
        FileSystem fs = FileSystem.&lt;span style="color: #658b00"&gt;get&lt;/span&gt;(URI.&lt;span style="color: #658b00"&gt;create&lt;/span&gt;(hdfs_uri), &lt;span style="color: #8B008B; font-weight: bold"&gt;new&lt;/span&gt; Configuration(), &lt;span style="color: #CD5555"&gt;"hanxiao"&lt;/span&gt;);
        InputStream in = fs.&lt;span style="color: #658b00"&gt;open&lt;/span&gt;(&lt;span style="color: #8B008B; font-weight: bold"&gt;new&lt;/span&gt; Path(hdfs_uri));
        in.&lt;span style="color: #658b00"&gt;skip&lt;/span&gt;(&lt;span style="color: #B452CD"&gt;100&lt;/span&gt;);
        OutputStream out = &lt;span style="color: #8B008B; font-weight: bold"&gt;new&lt;/span&gt; BufferedOutputStream(&lt;span style="color: #8B008B; font-weight: bold"&gt;new&lt;/span&gt; FileOutputStream(local_uri));
        IOUtils.&lt;span style="color: #658b00"&gt;copyBytes&lt;/span&gt;(in, out, (&lt;span style="color: #00688B; font-weight: bold"&gt;long&lt;/span&gt;)&lt;span style="color: #B452CD"&gt;20&lt;/span&gt;, &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;);
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="eclipse-hdfs"&gt;使用 Eclipse 开发 Hdfs 应用&lt;/h1&gt;
&lt;p&gt;参考我的 Wiki: &lt;a href="http://wiki.smallcpp.cn/Hadoop/%E4%BD%BF%E7%94%A8%20Eclipse%20%E5%BC%80%E5%8F%91%20HDFS.html"&gt;使用 Eclipse 开发 HDFS&lt;/a&gt;&lt;/p&gt;
&lt;h1 id="hdfs"&gt;Hdfs 源码分析&lt;/h1&gt;
&lt;p&gt;参考 &lt;a href="http://blog.csdn.net/lipeng_bigdata/article/category/6049177"&gt;HDFS 2.6.0 源码分析&lt;/a&gt;&lt;/p&gt;</content><category term="大数据"></category></entry><entry><title>04. 使用 Shell 操作 HDFS</title><link href="http://www.smallcpp.cn/04-shi-yong-shell-cao-zuo-hdfs.html" rel="alternate"></link><published>2016-10-23T20:25:00+08:00</published><updated>2016-10-23T20:25:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-10-23:/04-shi-yong-shell-cao-zuo-hdfs.html</id><summary type="html">&lt;p&gt;使用 Shell 操作 HDFS&lt;/p&gt;</summary><content type="html">
&lt;h1 id="_1"&gt;基本用法&lt;/h1&gt;
&lt;p&gt;执行一个 HDFS 命令, 有下面两种写法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;hadoop 1.x &lt;code&gt;hadoop fs -???&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;hadoop 2.x &lt;code&gt;hdfs dfs -???&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;后面的 &lt;code&gt;???&lt;/code&gt; 是一个具体的文件系统命令, 和 Linux 的文件系统命令很相似, 如查看当前 HDFS 文件系统中的文件:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;HDFS dfs -ls hdfs://smallcpp01:9000/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里要注意下 HDFS 文件系统和本地文件系统的区别, 由于 HDFS 是分布式文件系统, 是通过网络共享, 因此需要个协议, 类似网络共享的 &lt;code&gt;http&lt;/code&gt;、&lt;code&gt;ftp&lt;/code&gt; 协议等, 这里就是 &lt;code&gt;HDFS&lt;/code&gt; 协议, 所以上面的 HDFS 由三部分组成:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;HDFS://&lt;/th&gt;
&lt;th&gt;smallcpp01:9000&lt;/th&gt;
&lt;th&gt;/&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;协议&lt;/td&gt;
&lt;td&gt;主机地址端口&lt;/td&gt;
&lt;td&gt;目录结构 (这里是根结点)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果在 &lt;code&gt;core-site.xml&lt;/code&gt; 里指定了 &lt;code&gt;defaultFS&lt;/code&gt;, 那上面地址中的 协议 和 主机地址端口 可以省略, 简写个目录结构就可以了:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;HDFS dfs -ls /
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果连目录结构都省略 &lt;code&gt;HDFS dfs -ls&lt;/code&gt;, 这样默认访问的是 &lt;code&gt;hdfs://smallcpp01:9000/user/&amp;lt;current user&amp;gt;&lt;/code&gt; 目录.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ls&lt;/code&gt; 命令的结果由 7 部分组成:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;-rw-r–r–&lt;/th&gt;
&lt;th&gt;2&lt;/th&gt;
&lt;th&gt;hanxiao&lt;/th&gt;
&lt;th&gt;supergroup&lt;/th&gt;
&lt;th&gt;59&lt;/th&gt;
&lt;th&gt;2016-10-16 21:30&lt;/th&gt;
&lt;th&gt;/words.txt&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;权限&lt;/td&gt;
&lt;td&gt;副本&lt;br/&gt;(如果是目录则为 - )&lt;/td&gt;
&lt;td&gt;创建者&lt;/td&gt;
&lt;td&gt;所在组&lt;/td&gt;
&lt;td&gt;大小&lt;/td&gt;
&lt;td&gt;最后访问时间&lt;/td&gt;
&lt;td&gt;文件路径&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;当前目录?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 HDFS 提供的命令中, 是没有当前目录的概念的, 更没有 &lt;code&gt;cd&lt;/code&gt; 命令.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据存在哪?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从 OS 的角度, 数据被放在 DataNode 的 &lt;code&gt;/tmp/dfs/data/current/&lt;/code&gt; 目录下, 当然从 OS 的角度, 是看不懂这里面的文件的, 打开后都是些二进制.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;帮助?&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;hdfs dfs -help
hdfs dfs -help 具体命令
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="_2"&gt;命令参考&lt;/h1&gt;
&lt;p&gt;更多命令参考: &lt;a href="http://pan.baidu.com/s/1kUXcdxl"&gt;hdfs 命令.doc&lt;/a&gt;&lt;/p&gt;</content><category term="大数据"></category></entry><entry><title>03. Hadoop 2.x 新特性</title><link href="http://www.smallcpp.cn/03-hadoop-2x-xin-te-xing.html" rel="alternate"></link><published>2016-10-23T19:21:00+08:00</published><updated>2016-10-23T19:21:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-10-23:/03-hadoop-2x-xin-te-xing.html</id><summary type="html">&lt;p&gt;Hadoop 2.x 新特性&lt;/p&gt;</summary><content type="html">
&lt;h1 id="hadoop-1x"&gt;Hadoop 1.x 问题&lt;/h1&gt;
&lt;p&gt;主要就是 NameNode 单点问题.&lt;/p&gt;
&lt;p&gt;Hadoop 1.x 中, 一个集群就只有一个 NameNode, 这种架构虽然实现简单, 但会产生&lt;strong&gt;单点&lt;/strong&gt;、&lt;strong&gt;内存&lt;/strong&gt;瓶颈、&lt;strong&gt;性能&lt;/strong&gt;
瓶颈等限制.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先&lt;/strong&gt;, 整个 Hadoop 集群的命名空间都归一个 NameNode 管理, 这样 HDFS 所能存储的文件数量会受到 NameNode 容量的限制;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其次&lt;/strong&gt;, 当集群进行复杂运算时, 也只有一个 NameNode 在运作, 集群的运算性能也会受到 NameNode 的限制.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后&lt;/strong&gt;, 虽然集群有 Second NameNode 作为辅助节点, 但并不会完成自动切换, 当 NameNode 宕掉时, 还是需要人工去处理.&lt;/p&gt;
&lt;p&gt;虽然仅仅在像 Yahoo 和 Facebook 返种规模的大公司才会面对这样的限制问题, 但在 Hadoop 2.x 中, 官方还是给出了解决方案.&lt;/p&gt;
&lt;h1 id="hadoop-2x"&gt;Hadoop 2.x 解决方案&lt;/h1&gt;
&lt;p&gt;Hadoop 2.x 提出了两个新特性用以解决以上问题:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HDFS 联邦&lt;/li&gt;
&lt;li&gt;HDFS HA&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Reference: &lt;a href="http://www.smallcpp.cn/10-2x-gao-ke-kao-ha-ji-federation-lian-meng.html"&gt;2.X 高可靠 HA 及 Federation (联盟)&lt;/a&gt;&lt;/p&gt;
&lt;h1 id="hdfs"&gt;HDFS 快照&lt;/h1&gt;
&lt;p&gt;在 2.x 终于实现了快照.&lt;/p&gt;
&lt;h2 id="_1"&gt;快照的作用是什么?&lt;/h2&gt;
&lt;p&gt;HDFS 2.x 中现在可以对目录创建 Snapshot, 创建之后不管后续目录发生什么变化, 都可以通过 snapshot 找回原来的文件和目录结构.&lt;/p&gt;
&lt;p&gt;为了启用这种功能, 首先需要启用目标目录的 snapshot 功能, 可以通过 &lt;code&gt;hdfs dfsadmin -allowSnapshot&lt;/code&gt; 命令来启用 snapshot 功能, 启用后, 并不会自动进行 snapshot 保存, 还需要先对现场手动创建一次 snapshot, 通过下面的命令来执行: &lt;code&gt;hdfs dfs -createSnapshot []&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;可以为相同的目录创建多个 snapshot, 不同的 snapshot 通过名字来区分, 默认是 &lt;code&gt;syyyyMMdd-HHmmss.SSS&lt;/code&gt;, 例如 &lt;code&gt;/storage/WALs/.snapshot/s20140515-084657.639&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="_2"&gt;实现原理&lt;/h2&gt;
&lt;p&gt;实现上是通过在每个目标节点下面创建 snapshot 节点, 后续任何子节点的变化都会同步记录到 snapshot 上. 例如删除子节点下面的文件, 并不是直接文件元信息以及数据删除, 而是将他们移动到 snapshot 下面. 这样后续还能够恢复回来.&lt;/p&gt;
&lt;p&gt;另外 snapshot 保存是一个完全的现场, 不仅是删除的文件还能找到, 新创建的文件也无法看到. 后一种效果的实现是通过在 snapshot 中记录哪些文件是新创建的, 查看列表的时候将这些文件排除在外.&lt;/p&gt;
&lt;p&gt;在 HDFS 中 INode 表示一个节点, 其中 INodeFile 表示文件, INodeDirectory 表示目录. INodeFileWithSnapshot 表示带有快照的文件, INodeDirectoryWithSnapshot 表示带有快照的目录, (INodeDirectorySnapshottable 表示可以创建快照的目录, INodeDirectoryWithSnapshot 不能创建新的快照, 只能将目录的变化记录到现有的快照里面) 相关的类结构如下:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/Hadoop新特性/快照1.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;图中红线表示的是关键类的引用关系, 其中最重要的是 DirectoryDiffList, 里面保存了一些快照和当前目录的差别. 每一个 DirectoryDiff 中包含快照以及儿子变化, 是实现快照功能的核心. ChilderenDiff 中 created list 保存的是从快照时间之后新创建的节点, deteled list 保存的新删除的节点. snapshot 中的 root 节点保存了 snapshot 的 name, 可以通过这个找到对应的快照.&lt;/p&gt;
&lt;h2 id="_3"&gt;例子分析&lt;/h2&gt;
&lt;p&gt;我们通过一个例子来分析整个 snapshot 的实现细节:&lt;/p&gt;
&lt;p&gt;1. 文件目录树如下图所示, 并且我们已经通过命令启动了 a 的 snapshot 功能, 结构如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/Hadoop新特性/快照2.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;图中 .snapshot 是虚拟节点, 保存了所有的 snapshot 列表, 其中 diff 中还保存当前节点下面的变化, 一个 snapshot 对应于一个 diff. 要注意的是 snapshot 中可以被多个目录的 diff 引用, 后续会进行说明.&lt;/p&gt;
&lt;p&gt;2. 当我们执行 createSnapshot 命令时, 结果如下:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/Hadoop新特性/快照3.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;3. 当删除文件 e 的时候, 不论是删除一个文件还是一个目录, 只要是直接子节点, 都会将节点转换为快照版本. 例如 e 会变成 INodeFileWithSnapshot, 在 a 的 DirectoryDiff 中 ChildDiff 中 deleted 列表中将会包含 e, 而在 a 的正常节点下会被删除. 目录节点的处理同样.&lt;/p&gt;
&lt;p&gt;4. 删除孙子节点是的情况&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/Hadoop新特性/快照4.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;处理这种节点的原则是: 先将孙子节点转变为 Snapshot 版本, 然后将父节点变为 snapshot 版本, 同时将孙子节点版本加入到直接父节点的 diff 列表中. 为了能够通过同一个 snapshot 找到当时的文件, 需要将新的 diff 指向到老的 snapshot 版本上. 图中 d 节点是 INodeDirectoryWithSnapshot (不是 INodeDiretorySnapshottable, 本身不允许在 d 上创建 snapshot).&lt;/p&gt;
&lt;h2 id="_4"&gt;快照命令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;设置一个目录为可快照:
    + &lt;code&gt;hdfs dfsadmin -allowSnapshot &amp;lt;path&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;取消目录可快照:
    + &lt;code&gt;hdfs dfsadmin -disallowSnapshot &amp;lt;path&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;生成快照:
    + &lt;code&gt;hdfs dfs -createSnapshot &amp;lt;path&amp;gt; [&amp;lt;snapshotName&amp;gt;]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删除快照:
    + &lt;code&gt;hdfs dfs -deleteSnapshot &amp;lt;path&amp;gt; &amp;lt;snapshotName&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;列出所有可快照目录:
    + &lt;code&gt;hdfs lsSnapshottableDir&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;比较快照之间的差异:
    + &lt;code&gt;hdfs snapshotDiff &amp;lt;path&amp;gt; &amp;lt;fromSnapshot&amp;gt; &amp;lt;toSnapshot&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/Hadoop新特性/快照.png"/&gt;&lt;/p&gt;
&lt;h2 id="refrences"&gt;Refrences&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.aboutyun.com/thread-14480-1-1.html"&gt;HDFS snapshot 占用空间吗&lt;/a&gt;&lt;br/&gt;
&lt;a href="http://www.aboutyun.com/thread-14495-1-1.html"&gt;HDFS Snapshot 原理&lt;/a&gt;&lt;br/&gt;
&lt;a href="http://blog.csdn.net/androidlushangderen/article/details/51282612"&gt;HDFS 快照管理&lt;/a&gt;&lt;/p&gt;</content><category term="大数据"></category></entry><entry><title>使用 Eclipse 开发 HDFS</title><link href="http://www.smallcpp.cn/shi-yong-eclipse-kai-fa-hdfs.html" rel="alternate"></link><published>2016-10-22T22:08:00+08:00</published><updated>2016-10-22T22:08:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-10-22:/shi-yong-eclipse-kai-fa-hdfs.html</id><summary type="html">&lt;p&gt;先在 windows 7 下搭建好 eclipse 项目环境, 参考 &lt;a href="http://www.smallcpp.cn/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/Eclipse%20%E9%85%8D%E7%BD%AE%20Java%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html"&gt;Eclipse 配置 Java 开发环境&lt;/a&gt;&lt;/p&gt;

&lt;h1 id="_1"&gt;导入依赖包&lt;/h1&gt;
&lt;p&gt;创建一个 Java 工程后, 在工程下新建个 lib 文件夹, 导入 hdfs 的相关 jar 包:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;/usr/smallcpp/hadoop-2.7.1/share/hadoop …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;先在 windows 7 下搭建好 eclipse 项目环境, 参考 &lt;a href="http://www.smallcpp.cn/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/Eclipse%20%E9%85%8D%E7%BD%AE%20Java%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html"&gt;Eclipse 配置 Java 开发环境&lt;/a&gt;&lt;/p&gt;

&lt;h1 id="_1"&gt;导入依赖包&lt;/h1&gt;
&lt;p&gt;创建一个 Java 工程后, 在工程下新建个 lib 文件夹, 导入 hdfs 的相关 jar 包:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;/usr/smallcpp/hadoop-2.7.1/share/hadoop/common&lt;/li&gt;
&lt;li&gt;/usr/smallcpp/hadoop-2.7.1/share/hadoop/common/lib&lt;/li&gt;
&lt;li&gt;/usr/smallcpp/hadoop-2.7.1/share/hadoop/hdfs&lt;/li&gt;
&lt;li&gt;/usr/smallcpp/hadoop-2.7.1/share/hadoop/hdfs/lib&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;测试 hdfs 导入这些目录下的 jar 就可以了…&lt;/p&gt;
&lt;p&gt;选中导入后所有的 jar 包, 右键 [构建路径] -&amp;gt; [添加到构建路径]&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i59.tinypic.com/2m43bex.jpg"/&gt;&lt;/p&gt;
&lt;h1 id="_2"&gt;关联源码&lt;/h1&gt;
&lt;p&gt;先去 &lt;a href="http://archive.apache.org/dist/"&gt;Hadoop&lt;/a&gt; 下载源码包:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/使用Eclipse开发HDFS/hdfssrc.png"/&gt;&lt;/p&gt;
&lt;p&gt;然后在 Eclipase 上按 &lt;code&gt;ctrl&lt;/code&gt; 追踪源码时, 就可以设置关联刚下载的 Hadoop 源码了.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/使用Eclipse开发HDFS/associatedsrc.png"/&gt;&lt;/p&gt;
&lt;h1 id="_3"&gt;关于权限&lt;/h1&gt;
&lt;p&gt;当我们远程上传文件时, 可能会报权限不足的错误, 此时有两种处理办法:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一种&lt;/strong&gt;, 是使用 &lt;code&gt;FileSystem&lt;/code&gt; 的另一个重载, 传递第三个参数来伪装成集群的 &lt;code&gt;super-user&lt;/code&gt;, 如:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;FileSystem fs = FileSystem.get(URI.create(uri), new Configuration(), "root");&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二种&lt;/strong&gt;, 是去 linux 里修改下 hdfs 的配置, 进入 sbin 目录, &lt;code&gt;vim hdfs-site.xml&lt;/code&gt;&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;property&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;dfs.permissions&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;value&amp;gt;&lt;/span&gt;false&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不管哪一种, 都不怎么靠谱, 确实在 Hadoop 1.x 时, 没有怎么考虑安全的问题, 因为 Hadoop 的应用场景是离线数据分析, 一般不对外网开放;&lt;/p&gt;
&lt;p&gt;不过在 Hadoop 2.x 中扩展了个 kerberos 项目用来控制 Hadoop 的权限, 如有必要可以再去研究.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;另外好像还有个 Apache ranger 项目, 也是一个 Hadoop 集群权限框架, 提供操作、监控、管理复杂的数据权限.&lt;/p&gt;
&lt;/blockquote&gt;</content><category term="大数据"></category></entry><entry><title>转.分布式文件系统命名空间解析</title><link href="http://www.smallcpp.cn/zhuan-fen-bu-shi-wen-jian-xi-tong-ming-ming-kong-jian-jie-xi.html" rel="alternate"></link><published>2016-10-22T22:08:00+08:00</published><updated>2016-10-22T22:08:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-10-22:/zhuan-fen-bu-shi-wen-jian-xi-tong-ming-ming-kong-jian-jie-xi.html</id><summary type="html">&lt;p&gt;近些年, 微软对其分布式文件系统 (Distributed File System, DFS) 做了很多改良, 其中的一项技术对文件系统资源提供了统一视图. DFS 重新定向了来自 UNC 途径的请求, 其中一个网络驱动映射到请求资源所在的网络共享. 这样的结果是你可以添加文件服务器到网络或者不用影响用户访问文件的方式就能强化现有的文件服务器.&lt;/p&gt;
&lt;p&gt;重定向请求到文件实际位置的 UNC 途径就是 DFS 命名空间. 本质上, DFS 命名空间是为用户呈现文件服务器资源集中化视图的统一命名空间. 一个 DFS 命名空间由很多部分组成.&lt;/p&gt;
&lt;h1 id="dfs"&gt;DFS 根&lt;/h1&gt;
&lt;p&gt;DFS 命名空间本质上是分等级的, 最顶端的是DFS根 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;近些年, 微软对其分布式文件系统 (Distributed File System, DFS) 做了很多改良, 其中的一项技术对文件系统资源提供了统一视图. DFS 重新定向了来自 UNC 途径的请求, 其中一个网络驱动映射到请求资源所在的网络共享. 这样的结果是你可以添加文件服务器到网络或者不用影响用户访问文件的方式就能强化现有的文件服务器.&lt;/p&gt;
&lt;p&gt;重定向请求到文件实际位置的 UNC 途径就是 DFS 命名空间. 本质上, DFS 命名空间是为用户呈现文件服务器资源集中化视图的统一命名空间. 一个 DFS 命名空间由很多部分组成.&lt;/p&gt;
&lt;h1 id="dfs"&gt;DFS 根&lt;/h1&gt;
&lt;p&gt;DFS 命名空间本质上是分等级的, 最顶端的是DFS根. 在实际运用中, 可以认为根和命名空间是一样的, 因为根常用来指代整个命名空间. DFS 根是一个共享文件, 它必须存在于 NTFS 卷中.&lt;/p&gt;
&lt;p&gt;DFS 根链接到一个或多个根目标, 而根目标则链接到一个文件服务器上的 UNC 共享. 一个 DFS 根可以链接的根目标数量由 DFS 根相关的命名空间类型决定. DFS 命名空间有两个类型: 独立命名空间和基于域的命名空间.&lt;/p&gt;
&lt;p&gt;独立命名空间存储他们在主机服务器注册表中的配置信息. 基于域的命名空间存储在活动目录数据库中的信息. 这个区别影响连接到 DFS 根的根目标数量. 独立 DFS 根只能包含一个单一根目标, 而基于域的 DFS 根只包含通过多个服务器分离的多个根目标.&lt;/p&gt;
&lt;p&gt;下图展示了一个基于域的 DFS 根. 很明显这是基于域的, 因为这个根的名字 &lt;code&gt;(\\lab.com\namespace)&lt;/code&gt; 反映了域的名字. 中心方格显示两个 UNC 途径, 并且两个途径都像根目标一样链接到 DFS 根.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/分布式文件系统命名空间解析/DFS根连接到一个或多个根目标.png"&gt;&lt;/p&gt;
&lt;h1 id="dfs_1"&gt;DFS 命名空间里的文件或链接&lt;/h1&gt;
&lt;p&gt;在分级中的下一个元素是文件或链接 (正如它有时候所指的) . 在 DFS 命名空间中的每个文件都映射到链接目标, 正如 DFS 根映射到根目标. 链接目标指向一个映射到物理文件夹的 UNC 共享.&lt;/p&gt;
&lt;p&gt;在下图中, 三个文件 (文件 1、文件 2 和文件 3) 都被定义在 DFS 根下 (注意, 我已经选了文件 1) . 控制台的中央窗口列出了映射到文件的链接目标.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/分布式文件系统命名空间解析/每个文件都映射到链接目标.png"&gt;&lt;/p&gt;
&lt;p&gt;如你所见, 这个链接目标不过是一个映射到共享文件的 UNC 途径. 另外要注意, 在控制台的中央窗口中, 为链接目标展示了各种各样的信息, 包括类型、途径和提交状态.&lt;/p&gt;
&lt;p&gt;由于一个文件可以和不同服务器上的多个链接目标连接, 所以提交状态存在. 这样做了之后, 你可以为链接目标创建一个复制组, 且复制组会保持多种文件内容与其它文件之间的同步. 下图展示的就是一个有多个链接目标的文件.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/分布式文件系统命名空间解析/多个链接目标.png"&gt;&lt;/p&gt;
&lt;p&gt;两个链接目标的提交状态都是有效的 (Enabled). 这意味着 DFS 可以向任意一个目标指定资源请求. 因此, 如果一个文件服务器必须离线维修, 这个服务器的提交状态就变成无效, 而 DFS 会停止向该服务器发送请求, 直到提交状态再次变为有效.&lt;/p&gt;
&lt;h1 id="ntfs-dfs"&gt;NTFS 级别的 DFS 命名空间&lt;/h1&gt;
&lt;p&gt;上述因素组成了 DFS 命名空间. 在下图中, 你可以看到 NTFS 级别的命名空间是什么样子的.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/分布式文件系统命名空间解析/驱动C盘上的DFS内容.png"&gt;&lt;/p&gt;
&lt;p&gt;注意名为 Dfsroots 的文件, 它下面的那个文件就叫 Namespace (命名空间). 当我创建根时 DFS 自动创建这些文件. Namespace 文件实际上是共享的, 但是文件系统隐藏了该共享.&lt;/p&gt;
&lt;p&gt;最后要注意, 在命名空间下面有到文件 1、文件 2 和文件 3 的快捷键. 这些都是在 DFS 管理控制台中指定的目标文件. 在图的底部是这三个文件夹的另一个列表, 它实际上是在驱动 C 盘上的共享文件. 我刚刚提到的快捷键映射到这些共享文件夹.&lt;/p&gt;</content><category term="大数据"></category></entry><entry><title>Eclipse 配置 Java 开发环境</title><link href="http://www.smallcpp.cn/eclipse-pei-zhi-java-kai-fa-huan-jing.html" rel="alternate"></link><published>2016-10-22T20:09:00+08:00</published><updated>2016-10-22T20:09:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-10-22:/eclipse-pei-zhi-java-kai-fa-huan-jing.html</id><summary type="html">
&lt;h1 id="java"&gt;Java 安装&lt;/h1&gt;
&lt;p&gt;访问 oracle 官网 : &lt;a href="http://www.oracle.com/index.html"&gt;http://www.oracle.com/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i65.tinypic.com/11ryjc5.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i64.tinypic.com/504f34.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i64.tinypic.com/2vcth8j.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;下载下来直接安装即可, 安装的时候, 不要勾选 &lt;strong&gt;公共 JRE&lt;/strong&gt;, 因为 JDK 中已包含一个专用的 JRE.
&lt;strong&gt;注意&lt;/strong&gt;: 路径中不要有中文或特殊符号、空格等.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i65.tinypic.com/14v1xxi.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;安装好 JDK 后, 在指定的安装目录里有很多的文件和文件夹, 其中 &lt;strong&gt;bin&lt;/strong&gt; 目录和 …&lt;/p&gt;</summary><content type="html">
&lt;h1 id="java"&gt;Java 安装&lt;/h1&gt;
&lt;p&gt;访问 oracle 官网 : &lt;a href="http://www.oracle.com/index.html"&gt;http://www.oracle.com/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i65.tinypic.com/11ryjc5.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i64.tinypic.com/504f34.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i64.tinypic.com/2vcth8j.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;下载下来直接安装即可, 安装的时候, 不要勾选 &lt;strong&gt;公共 JRE&lt;/strong&gt;, 因为 JDK 中已包含一个专用的 JRE.
&lt;strong&gt;注意&lt;/strong&gt;: 路径中不要有中文或特殊符号、空格等.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i65.tinypic.com/14v1xxi.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;安装好 JDK 后, 在指定的安装目录里有很多的文件和文件夹, 其中 &lt;strong&gt;bin&lt;/strong&gt; 目录和 &lt;strong&gt;lib&lt;/strong&gt; 目录需要额外注意下, bin 文件夹里保存的是 java 的可执行文件, 常用的是 &lt;code&gt;java.exe&lt;/code&gt; 和 &lt;code&gt;javac.exe&lt;/code&gt; (具体用处后面再说), lib 里保存的是 java 的类库, 和 C++ 开发中的 lib 文件差不多的意思.&lt;/p&gt;
&lt;p&gt;安装完后, 测试下是否安装成功.&lt;/p&gt;
&lt;p&gt;呼出 CMD 窗口, 执行 &lt;code&gt;javac&lt;/code&gt;, 会发现报错.&lt;/p&gt;
&lt;p&gt;这是因为, 在 DOS 中执行某程序, 如果执行的程序在&lt;strong&gt;当前目录&lt;/strong&gt;下不存在, 系统会在 &lt;strong&gt;Path 这个环境变量指定的目录&lt;/strong&gt;中查找, 如果还没找到, 就会错误提示 &lt;code&gt;Javac&lt;/code&gt; 不是内部或外部命令, 也不是可运行的程序或批处理文件, 所以, 要想运行 &lt;code&gt;Javac&lt;/code&gt;, 则必须 每次进入 JDK 安装路径 &lt;code&gt;\bin&lt;/code&gt; 或修改 &lt;code&gt;Path&lt;/code&gt; 环境变量, 为了一劳永逸,  我们来修改系统环境变量.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不仅 DOS 下是这样, winodws 下执行程序, 程序会先在当前目录下查找依赖文件, 如果没找到, 就去 path 指定的目录下查找.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id="_1"&gt;配置环境变量&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;JAVA_HOME&lt;/code&gt;: 配置 JDK 安装路径, 我这里是 &lt;code&gt;D:\jdk1.8.0_73&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PATH&lt;/code&gt;: 配置 JDK 命令文件路径 (bin目录), &lt;code&gt;%JAVA_HOME%\bin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CLASSPATH&lt;/code&gt;: 下面单独说明&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;CLASSPATH&lt;/code&gt; 之所以要单独拿出来讲, 是因为以后出现的莫名其妙的怪问题 80% 以上都可能是由于 &lt;code&gt;CLASSPATH&lt;/code&gt; 设置不对引起的, 所以要加倍小心才行.&lt;/p&gt;
&lt;p&gt;设置 &lt;code&gt;CLASSPATH&lt;/code&gt; 的目的, 在于告诉 Java 执行环境, 在哪些目录下可以找到所要执行的 Java 程序所需要的类或者包, 如果不设置 &lt;code&gt;CLASSPATH&lt;/code&gt;, 那么默认就会到当前工作目录寻找.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CLASSPATH=.;%java_home%\lib\tools.jar;%java_home%\lib\dt.jar;%java_home%\lib\rt.jar;%JAVA_HOME%\lib&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;下最前面的 &lt;code&gt;.;&lt;/code&gt; (句点分号), 这个是告诉 JDK, 搜索 CLASS 时先查找当前目录, 然后是 &lt;code&gt;tools.jar&lt;/code&gt;、&lt;code&gt;dt.jar&lt;/code&gt; 和 &lt;code&gt;rt.jar&lt;/code&gt; 三个 jar 包的路径, 最后是 &lt;code&gt;lib&lt;/code&gt; 目录的路径.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;除了配置环境变量外, 执行 java 或者 javac 命令时, 可以跟上 &lt;code&gt;-classpath&lt;/code&gt; 参数来直接指定类目录.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此时, 重启 DOS 窗口, 再次执行 &lt;code&gt;javac&lt;/code&gt; 命令, 就可以看到效果了.&lt;/p&gt;
&lt;h1 id="eclipse"&gt;Eclipse 安装&lt;/h1&gt;
&lt;p&gt;在官网上下载最新版本的 &lt;a href="http://www.eclipse.org/downloads/packages"&gt;Eclipse&lt;/a&gt; (我现在一般用 Mars 版本, 2016 新出的 Neno 感觉不怎么好用), 安装好后是英文版的, 需要手动下载语言包, Eclipse 有一个语言包项目, 叫 Eclipse Babel Project, 如果需要语言包, 可以联机从这儿下载.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.eclipse.org/babel/"&gt;http://www.eclipse.org/babel/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;找到下载页面后, 还要根据自己使用的 Eclipse 的版本来确定在哪下载.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i59.tinypic.com/2ibyxyx.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/Eclipse配置Java开发环境/eclipsev.png"/&gt;&lt;/p&gt;
&lt;p&gt;可以看到我的是 Mars 版本.&lt;/p&gt;
&lt;p&gt;点击第一张图上的 Mars, 跳转到语言包下载界面, 找到中文包, 下载, 解压, 覆盖即可.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i57.tinypic.com/fn8sg0.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;再次打开 Eclipse 就是中文的了.&lt;/p&gt;
&lt;h1 id="eclipse_1"&gt;Eclipse 配置&lt;/h1&gt;
&lt;h2 id="_2"&gt;设置字体&lt;/h2&gt;
&lt;p&gt;“窗口” -&amp;gt; “首选项”&lt;/p&gt;
&lt;p&gt;然后在左上角的过滤器中输入外观, 选择 “颜色和字体”, 在右边选择 “基本” -&amp;gt; “文本字体” -&amp;gt; “编辑”&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i67.tinypic.com/op8do8.jpg"/&gt;&lt;/p&gt;
&lt;h2 id="_3"&gt;自动提示&lt;/h2&gt;
&lt;p&gt;接下来, 设置下 eclipse 的自动提示
(你可以在任何时候 alt + / 来触发).
window –&amp;gt; Preferences –&amp;gt; Java –&amp;gt; Editor –&amp;gt; Content Assist:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i60.tinypic.com/1zoj2no.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;abcdefghijklmnopqrstuvwxyz.&lt;/strong&gt;(注意后面的点)&lt;/p&gt;
&lt;p&gt;这样改完后会有个问题, 就是当按下 “空格键”、”=” 时会上屏候选列表, 按习惯我们可改成 “Tab”、”Enter” 上屏.&lt;/p&gt;
&lt;p&gt;首先, 最好下载一个 Eclipse RCP 版本 (该版本修改源代码比较方便，能自动导入源代码):&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i66.tinypic.com/2aeytts.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;打开 window -&amp;gt; show view, 选择 Plug-ins (如果没有的话, 在 show view 的 other 里找找), 再找到 &lt;code&gt;org.eclipse.jface.text&lt;/code&gt;, 右键单击, 选择 import as -&amp;gt; Source Project, 导入完成后, 在 Eclipse 的 workspace 就可以看到这个 project 了.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i67.tinypic.com/ok94jt.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i67.tinypic.com/2nv79e9.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i63.tinypic.com/53nvrd.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;打开 &lt;code&gt;org.eclipse.jface.text.contentassist.CompletionProposalPopup&lt;/code&gt; 文件, 找到如下代码:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i67.tinypic.com/20rae14.jpg"/&gt;&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;if&lt;/span&gt; (contains(triggers, key)) {
                        e.&lt;span style="color: #658b00"&gt;doit&lt;/span&gt;= &lt;span style="color: #8B008B; font-weight: bold"&gt;false&lt;/span&gt;;
                        hide();
                        insertProposal(p, key, e.&lt;span style="color: #658b00"&gt;stateMask&lt;/span&gt;, fContentAssistSubjectControlAdapter.&lt;span style="color: #658b00"&gt;getSelectedRange&lt;/span&gt;().&lt;span style="color: #658b00"&gt;x&lt;/span&gt;);
                    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改之后的代码是:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;if&lt;/span&gt; (key != &lt;span style="color: #CD5555"&gt;'='&lt;/span&gt; &amp;amp;&amp;amp; key != &lt;span style="color: #B452CD"&gt;0x20&lt;/span&gt; &amp;amp;&amp;amp; key != &lt;span style="color: #CD5555"&gt;';'&lt;/span&gt; &amp;amp;&amp;amp; contains(triggers, key)) {
                        e.&lt;span style="color: #658b00"&gt;doit&lt;/span&gt;= &lt;span style="color: #8B008B; font-weight: bold"&gt;false&lt;/span&gt;;
                        hide();
                        insertProposal(p, key, e.&lt;span style="color: #658b00"&gt;stateMask&lt;/span&gt;, fContentAssistSubjectControlAdapter.&lt;span style="color: #658b00"&gt;getSelectedRange&lt;/span&gt;().&lt;span style="color: #658b00"&gt;x&lt;/span&gt;);
                    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果想要使用 “tab” 键上屏找到如下代码:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;case&lt;/span&gt; &lt;span style="color: #CD5555"&gt;'\t'&lt;/span&gt;:
e.&lt;span style="color: #658b00"&gt;doit&lt;/span&gt;= &lt;span style="color: #8B008B; font-weight: bold"&gt;false&lt;/span&gt;;
fProposalShell.&lt;span style="color: #658b00"&gt;setFocus&lt;/span&gt;();
&lt;span style="color: #8B008B; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #8B008B; font-weight: bold"&gt;false&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改之后的代码是:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;case&lt;/span&gt; &lt;span style="color: #CD5555"&gt;'\t'&lt;/span&gt;:
e.&lt;span style="color: #658b00"&gt;doit&lt;/span&gt;= &lt;span style="color: #8B008B; font-weight: bold"&gt;false&lt;/span&gt;;
insertSelectedProposalWithMask(e.&lt;span style="color: #658b00"&gt;stateMask&lt;/span&gt;);
&lt;span style="color: #8B008B; font-weight: bold"&gt;break&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改完成之后需要保存替换原来的 jar 文件:&lt;/p&gt;
&lt;p&gt;项目右键 -&amp;gt; export&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i67.tinypic.com/2pydoci.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;选择导出方式如下图:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i64.tinypic.com/2yynhid.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;点击 Next, 选择 Destination 选项卡, 选择 Directory, 选择一个要保存插件的目录, 然后 Finish.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i63.tinypic.com/2vacpe1.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;然后就会在所选的目录下产生一个新的 plugins 目录, 里面有一个 jar 文件, 用它替换掉 Eclipse/plugins 里面的 (注意版本号可能会不一样), 最后重新启动一下 Eclipse.&lt;/p&gt;
&lt;h2 id="_4"&gt;设置编码&lt;/h2&gt;
&lt;p&gt;统一设置为 &lt;strong&gt;utf-8&lt;/strong&gt; 编码, Window -&amp;gt; Preferences -&amp;gt; General -&amp;gt; Workspace -&amp;gt; Text file encoding -&amp;gt; Other -&amp;gt; UTF-8.&lt;/p&gt;
&lt;p&gt;统一设置为 &lt;strong&gt;utf-8&lt;/strong&gt; 编码, Window -&amp;gt; Preferences -&amp;gt; General -&amp;gt; Content Types, 在右面选择 “Text”, 在 default encoding 输入 “UTF-8”, 点 “update” 按钮更新.&lt;/p&gt;
&lt;h2 id="_5"&gt;导航器&lt;/h2&gt;
&lt;p&gt;类似 “资源管理器”, 它的视图和 “包资源管理器” 有点像, 因为有些文件或文件夹在 “包资源管理器” 看不到, 这时可以到 “导航器” 中查看.&lt;/p&gt;
&lt;p&gt;“窗口” -&amp;gt; “显示视图” -&amp;gt; “其他”, 在弹出窗中选择 “常规” -&amp;gt; “导航器”, 此时 “导航器” 就出现在 IDE 左侧的视图中了.&lt;/p&gt;
&lt;h2 id="_6"&gt;自动构建&lt;/h2&gt;
&lt;p&gt;eclipse 的 java 构建器包含了两种构建 java 程序的方法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自动构建&lt;/li&gt;
&lt;li&gt;手动构建&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中, 自动构建是 java 构建器默认采用的方式, 即当文件修改后保存或者对整个项目进行刷新时, java 构建器就会对其进行编译.&lt;/p&gt;
&lt;p&gt;这显然不是一种我希望的方式, 我希望是我点击 “Run” 或者 “Debug” 时 IDE 再去构建, 而不是保存一下文件就构建一下.&lt;/p&gt;
&lt;p&gt;关闭方法很简单, “项目” -&amp;gt; “自动构建”, 取消 “自动构建” 前面的选项即可.&lt;/p&gt;
&lt;h2 id="monokai"&gt;设置 Monokai 主题&lt;/h2&gt;
&lt;h3 id="_7"&gt;配置黑色框架&lt;/h3&gt;
&lt;p&gt;Window -&amp;gt; Preferences -&amp;gt; General -&amp;gt; Apperance 选择主题为 Dark, 确认.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i68.tinypic.com/30hnd45.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;完成之后确认, 颜色大概是这个样子:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i66.tinypic.com/jb74aw.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;这肯定不是我们想要的样子, 因为这个主题只是配置了框架的颜色，代码编辑区的样式还需要我们继续配置.&lt;/p&gt;
&lt;h3 id="_8"&gt;配置代码编辑区的样式&lt;/h3&gt;
&lt;p&gt;去 帮助 -&amp;gt; 安装新软件，按下 “添加站点进入”, 输入 &lt;code&gt;http://eclipse-color-theme.github.io/update&lt;/code&gt; 作为网址, 然后点击继续安装.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i64.tinypic.com/2u7c7ro.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;安装完成之后, Window -&amp;gt; Preferences -&amp;gt; General -&amp;gt; Appereance -&amp;gt; Color Theme 选择其中的样式.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i63.tinypic.com/20ppxrn.jpg"/&gt;&lt;/p&gt;
&lt;h1 id="eclipse_2"&gt;Eclipse 常用功能&lt;/h1&gt;
&lt;h2 id="_9"&gt;抽取函数&lt;/h2&gt;
&lt;p&gt;快捷键 &lt;code&gt;Shift + Alt + M&lt;/code&gt; 能将选中的代码块进行方法抽取.&lt;/p&gt;
&lt;p&gt;这是属于 &lt;strong&gt;重构&lt;/strong&gt; 功能的一部分, 可以点击选中的代码块, 选择 “重构” -&amp;gt; “抽取方法”&lt;/p&gt;
&lt;h2 id="hashcode-equasl"&gt;重写 hashCode() 和 equasl()&lt;/h2&gt;
&lt;p&gt;Eclipse 提供了快速重写 hashCode() 和 equasl() 方法的功能, 在 [编辑] – [源码] 里就能找到.&lt;/p&gt;
&lt;h2 id="gettersetter"&gt;自动添加 getter/setter&lt;/h2&gt;
&lt;p&gt;使用 Eclipse 还可以自动添加 getter/setter 方法, 步骤如下:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i60.tinypic.com/10mlulk.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i58.tinypic.com/2up68ev.jpg"/&gt;&lt;/p&gt;
&lt;h1 id="eclipse_3"&gt;Eclipse 常用快捷键&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Ctrl + 1 (快速修复)&lt;/li&gt;
&lt;li&gt;Ctrl + 鼠标, 跳转到鼠标点击处 api 的源码文件&lt;/li&gt;
&lt;li&gt;Ctrl + Shift + T 查找类文件 (包括源码文件)&lt;/li&gt;
&lt;li&gt;Ctrl + D (删除当前行)&lt;/li&gt;
&lt;li&gt;Ctrl + Alt + ↓ (复制当前行到下一行)&lt;/li&gt;
&lt;li&gt;Alt + / 或者说是 Ctrl + 空格 (由于后者与输入法的快捷键冲突, 所以, 我一般都用前者) 作用：快速插入&lt;/li&gt;
&lt;li&gt;Alt + Shift + R 重命名非常好用&lt;/li&gt;
&lt;li&gt;Ctrl + Q 定位到最后编辑的地方&lt;/li&gt;
&lt;li&gt;Ctrl + Shift + O (自动导入包)&lt;/li&gt;
&lt;li&gt;Ctrl + / 注释当前行,再按则取消注释&lt;/li&gt;
&lt;li&gt;ALT + F11 切换全屏模式&lt;/li&gt;
&lt;li&gt;Alt + Shift + Y 切换自动换行模式&lt;/li&gt;
&lt;/ol&gt;</content><category term="工具折腾"></category></entry><entry><title>Hadoop 集群添加新节点</title><link href="http://www.smallcpp.cn/hadoop-ji-qun-tian-jia-xin-jie-dian.html" rel="alternate"></link><published>2016-10-22T14:05:00+08:00</published><updated>2016-10-22T14:05:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-10-22:/hadoop-ji-qun-tian-jia-xin-jie-dian.html</id><summary type="html">&lt;p&gt;仅为&lt;strong&gt;实验&lt;/strong&gt;集群或者&lt;strong&gt;小型&lt;/strong&gt;集群的添加节点方法, 一般&lt;strong&gt;大型&lt;/strong&gt;的集群都有专门的运维.&lt;/p&gt;

&lt;h1 id="_1"&gt;安装系统&lt;/h1&gt;
&lt;p&gt;首先安装好系统, 配置好 IP、JDK 及 Hadoop, 参考 &lt;a href="http://www.smallcpp.cn/Hadoop/%E6%90%AD%E5%BB%BA%20Hadoop%20%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83.html"&gt;搭建 Hadoop 分布式实验环境&lt;/a&gt; 前三步.&lt;/p&gt;
&lt;h1 id="_2"&gt;设置域名解析&lt;/h1&gt;
&lt;p&gt;到 &lt;strong&gt;NameNode&lt;/strong&gt; 节点下, &lt;code&gt;cd /usr/smallcpp/hadoop-2.7.3 …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;仅为&lt;strong&gt;实验&lt;/strong&gt;集群或者&lt;strong&gt;小型&lt;/strong&gt;集群的添加节点方法, 一般&lt;strong&gt;大型&lt;/strong&gt;的集群都有专门的运维.&lt;/p&gt;

&lt;h1 id="_1"&gt;安装系统&lt;/h1&gt;
&lt;p&gt;首先安装好系统, 配置好 IP、JDK 及 Hadoop, 参考 &lt;a href="http://www.smallcpp.cn/Hadoop/%E6%90%AD%E5%BB%BA%20Hadoop%20%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83.html"&gt;搭建 Hadoop 分布式实验环境&lt;/a&gt; 前三步.&lt;/p&gt;
&lt;h1 id="_2"&gt;设置域名解析&lt;/h1&gt;
&lt;p&gt;到 &lt;strong&gt;NameNode&lt;/strong&gt; 节点下, &lt;code&gt;cd /usr/smallcpp/hadoop-2.7.3/etc/hadoop&lt;/code&gt; 进入 Hadoop 配置文件所在目录;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vim slaves&lt;/code&gt; 将新节点的域名添加进来;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo vim /etc/hosts&lt;/code&gt; 修改 [ip 域名] 对应表, 将新节点的 &lt;code&gt;IP 域名&lt;/code&gt; 添加进来, 然后将&lt;strong&gt;远程拷贝&lt;/strong&gt;到新节点中, 如我的新添加的节点主机名是 smallcpp04, 用户是 hanxiao:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;scp /etc/hosts hanxiao@smallcpp04:/home/hanxiao/.ssh/authorized_keys&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;同时也将 Hadoop 的配置目录拷贝过去:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;scp /usr/smallcpp/hadoop-2.7.3/etc/hadoop hanxiao@smallcpp04:/usr/smallcpp/hadoop-2.7.3/etc/hadoop&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;下面两个操作不知道是不是必须的, 待研究~&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更新当前集群的 DataNode 的 [ip 域名] 对应表&lt;/li&gt;
&lt;li&gt;更新当前集群的 DataNode 的 slaves 列表&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="ssh"&gt;配置 SSH&lt;/h1&gt;
&lt;p&gt;参考 &lt;a href="http://www.smallcpp.cn/Hadoop/%E6%90%AD%E5%BB%BA%20Hadoop%20%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83.html#52-smallcpp02-smallcpp03"&gt;搭建 Hadoop 分布式实验环境&lt;/a&gt; 第 5.2 步.&lt;/p&gt;
&lt;h1 id="_3"&gt;启动新节点&lt;/h1&gt;
&lt;p&gt;添加新节点&lt;strong&gt;不需要&lt;/strong&gt;重启集群, 新节点会向 NameNode 发送心跳及 blockreport, 集群就知道有新节点上线了, 所以按上面的操作配好后, 到新节点下执行以下操作即可.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;./start-dfs.sh
./start-yarn.sh
./mr-jobhistory-daemon.sh start historyserver
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;./start-all.sh
./mr-jobhistory-daemon.sh start historyserver
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行完毕后, 用 &lt;code&gt;jps&lt;/code&gt; 看下有没有下面这两个进程:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;DataNode
NodeManager
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="_4"&gt;负载均衡&lt;/h1&gt;
&lt;p&gt;该步骤可选, 数据负载均衡，目的是为了将其他节点的数据分担一些到新节点上来，比较消耗时间.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;./start-balancer.sh
&lt;/pre&gt;&lt;/div&gt;</content><category term="大数据"></category></entry><entry><title>Hadoop Logs 文件</title><link href="http://www.smallcpp.cn/hadoop-logs-wen-jian.html" rel="alternate"></link><published>2016-10-20T21:10:00+08:00</published><updated>2016-10-20T21:10:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-10-20:/hadoop-logs-wen-jian.html</id><summary type="html">&lt;p&gt;Hadoop 存在多种日志文件, 其中 &lt;strong&gt;Master&lt;/strong&gt; 上的日志文件记录全面信息, 包括 &lt;strong&gt;Slave&lt;/strong&gt; 上的 &lt;strong&gt;JobTracker&lt;/strong&gt; 与 &lt;strong&gt;DataNode&lt;/strong&gt; 也会将错误信息写到 &lt;strong&gt;Master&lt;/strong&gt; 中, 而 &lt;strong&gt;Slave&lt;/strong&gt; 中的日志主要记录完成的 &lt;strong&gt;Task&lt;/strong&gt; 任务信息.&lt;/p&gt;
&lt;p&gt;Hadoop Log 文件保存在 Hadoop 根目录下的 logs 目录里.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;hanxiao@smallcpp01:/usr/smallcpp …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;Hadoop 存在多种日志文件, 其中 &lt;strong&gt;Master&lt;/strong&gt; 上的日志文件记录全面信息, 包括 &lt;strong&gt;Slave&lt;/strong&gt; 上的 &lt;strong&gt;JobTracker&lt;/strong&gt; 与 &lt;strong&gt;DataNode&lt;/strong&gt; 也会将错误信息写到 &lt;strong&gt;Master&lt;/strong&gt; 中, 而 &lt;strong&gt;Slave&lt;/strong&gt; 中的日志主要记录完成的 &lt;strong&gt;Task&lt;/strong&gt; 任务信息.&lt;/p&gt;
&lt;p&gt;Hadoop Log 文件保存在 Hadoop 根目录下的 logs 目录里.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;hanxiao@smallcpp01:/usr/smallcpp/hadoop-2.7.3/logs$ ls -l
总用量 &lt;span style="color: #B452CD"&gt;452&lt;/span&gt;
-rw-rw-r-- &lt;span style="color: #B452CD"&gt;1&lt;/span&gt; hanxiao hanxiao &lt;span style="color: #B452CD"&gt;173292&lt;/span&gt; 10月 &lt;span style="color: #B452CD"&gt;17&lt;/span&gt; &lt;span style="color: #B452CD"&gt;01&lt;/span&gt;:22 hadoop-hanxiao-namenode-smallcpp01.log
-rw-rw-r-- &lt;span style="color: #B452CD"&gt;1&lt;/span&gt; hanxiao hanxiao   &lt;span style="color: #B452CD"&gt;5314&lt;/span&gt; 10月 &lt;span style="color: #B452CD"&gt;16&lt;/span&gt; &lt;span style="color: #B452CD"&gt;17&lt;/span&gt;:32 hadoop-hanxiao-namenode-smallcpp01.out
-rw-rw-r-- &lt;span style="color: #B452CD"&gt;1&lt;/span&gt; hanxiao hanxiao   &lt;span style="color: #B452CD"&gt;1030&lt;/span&gt; 10月 &lt;span style="color: #B452CD"&gt;16&lt;/span&gt; &lt;span style="color: #B452CD"&gt;17&lt;/span&gt;:27 hadoop-hanxiao-namenode-smallcpp01.out.1
-rw-rw-r-- &lt;span style="color: #B452CD"&gt;1&lt;/span&gt; hanxiao hanxiao   &lt;span style="color: #B452CD"&gt;1030&lt;/span&gt; 10月 &lt;span style="color: #B452CD"&gt;16&lt;/span&gt; &lt;span style="color: #B452CD"&gt;17&lt;/span&gt;:26 hadoop-hanxiao-namenode-smallcpp01.out.2
-rw-rw-r-- &lt;span style="color: #B452CD"&gt;1&lt;/span&gt; hanxiao hanxiao  &lt;span style="color: #B452CD"&gt;64382&lt;/span&gt; 10月 &lt;span style="color: #B452CD"&gt;17&lt;/span&gt; &lt;span style="color: #B452CD"&gt;01&lt;/span&gt;:22 hadoop-hanxiao-secondarynamenode-smallcpp01.log
-rw-rw-r-- &lt;span style="color: #B452CD"&gt;1&lt;/span&gt; hanxiao hanxiao   &lt;span style="color: #B452CD"&gt;1030&lt;/span&gt; 10月 &lt;span style="color: #B452CD"&gt;16&lt;/span&gt; &lt;span style="color: #B452CD"&gt;17&lt;/span&gt;:29 hadoop-hanxiao-secondarynamenode-smallcpp01.out
-rw-rw-r-- &lt;span style="color: #B452CD"&gt;1&lt;/span&gt; hanxiao hanxiao   &lt;span style="color: #B452CD"&gt;1030&lt;/span&gt; 10月 &lt;span style="color: #B452CD"&gt;16&lt;/span&gt; &lt;span style="color: #B452CD"&gt;17&lt;/span&gt;:27 hadoop-hanxiao-secondarynamenode-smallcpp01.out.1
-rw-rw-r-- &lt;span style="color: #B452CD"&gt;1&lt;/span&gt; hanxiao hanxiao  &lt;span style="color: #B452CD"&gt;40588&lt;/span&gt; 10月 &lt;span style="color: #B452CD"&gt;17&lt;/span&gt; &lt;span style="color: #B452CD"&gt;01&lt;/span&gt;:22 mapred-hanxiao-historyserver-smallcpp01.log
-rw-rw-r-- &lt;span style="color: #B452CD"&gt;1&lt;/span&gt; hanxiao hanxiao   &lt;span style="color: #B452CD"&gt;1852&lt;/span&gt; 10月 &lt;span style="color: #B452CD"&gt;16&lt;/span&gt; &lt;span style="color: #B452CD"&gt;20&lt;/span&gt;:27 mapred-hanxiao-historyserver-smallcpp01.out
-rw-rw-r-- &lt;span style="color: #B452CD"&gt;1&lt;/span&gt; hanxiao hanxiao      &lt;span style="color: #B452CD"&gt;0&lt;/span&gt; 10月 &lt;span style="color: #B452CD"&gt;16&lt;/span&gt; &lt;span style="color: #B452CD"&gt;17&lt;/span&gt;:26 SecurityAuth-hanxiao.audit
-rw-rw-r-- &lt;span style="color: #B452CD"&gt;1&lt;/span&gt; hanxiao hanxiao &lt;span style="color: #B452CD"&gt;132156&lt;/span&gt; 10月 &lt;span style="color: #B452CD"&gt;17&lt;/span&gt; &lt;span style="color: #B452CD"&gt;01&lt;/span&gt;:22 yarn-hanxiao-resourcemanager-smallcpp01.log
-rw-rw-r-- &lt;span style="color: #B452CD"&gt;1&lt;/span&gt; hanxiao hanxiao   &lt;span style="color: #B452CD"&gt;1899&lt;/span&gt; 10月 &lt;span style="color: #B452CD"&gt;16&lt;/span&gt; &lt;span style="color: #B452CD"&gt;17&lt;/span&gt;:29 yarn-hanxiao-resourcemanager-smallcpp01.out
-rw-rw-r-- &lt;span style="color: #B452CD"&gt;1&lt;/span&gt; hanxiao hanxiao   &lt;span style="color: #B452CD"&gt;1899&lt;/span&gt; 10月 &lt;span style="color: #B452CD"&gt;16&lt;/span&gt; &lt;span style="color: #B452CD"&gt;17&lt;/span&gt;:27 yarn-hanxiao-resourcemanager-smallcpp01.out.1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;log 文件的名称由几部分构造: &lt;strong&gt;组件&lt;/strong&gt; - &lt;strong&gt;当前用户&lt;/strong&gt; - &lt;strong&gt;节点&lt;/strong&gt; - &lt;strong&gt;主机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;*.log&lt;/code&gt; 是日志消息, 故障诊断的首要步骤即为检查该文件 (此日志文件最重要)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;*.out&lt;/code&gt; 是当前输出 (记录标准输出和标准错误).&lt;/p&gt;</content><category term="大数据"></category></entry><entry><title>02. HDFS 简介</title><link href="http://www.smallcpp.cn/02-hdfs-jian-jie.html" rel="alternate"></link><published>2016-10-20T20:52:00+08:00</published><updated>2016-10-20T20:52:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-10-20:/02-hdfs-jian-jie.html</id><summary type="html">&lt;p&gt;HDFS 简介&lt;/p&gt;</summary><content type="html">
&lt;h1 id="_1"&gt;分布式文件系统&lt;/h1&gt;
&lt;p&gt;HDFS 是一种分布式文件系统, 即 Hadoop Distributed File System (Hadoop 的分布式文件系统).&lt;/p&gt;
&lt;p&gt;常见的分布式文件系统有, GFS、HDFS、Lustre 、Ceph 、GridFS 、mogileFS、TFS、FastDFS等; 各自适用于不同的领域, 它们都不是系统级的分布式文件系统, 而是应用级的分布式文件存储服务.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是分布式文件系统?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据量越来越多, 在一个操作系统管辖的范围存不下了, 那么就分配到更多的操作系统管理的磁盘中, 但是不方便管理和维护, 因此迫切需要一种系统来管理多台机器上的文件, 这就是分布式文件管理系统.&lt;/p&gt;
&lt;p&gt;它是一种允许文件通过&lt;strong&gt;网络&lt;/strong&gt;在多台主机上&lt;strong&gt;分享&lt;/strong&gt;的文件系统, 可让多机器上的多用户分享文件和存储空间, 为进一步的大数据&lt;strong&gt;分析&lt;/strong&gt;提供数据支持.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通透性&lt;/strong&gt;: 让实际上是通过网络来访问文件的动作, 由程序与用户看来, 就像是访问本地的磁盘一般 (对比下共享文件的方式, 需要知道对方的 ip 地址才能访问).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;容错&lt;/strong&gt;: 自动数据冗余, 即使系统中有某些节点脱机, 整体来说系统仍然可以持续运作而不会有数据损失; 功能类似 Raid 自动备份功能, 在 &lt;code&gt;hdfs-site.xml&lt;/code&gt; 文件中会配置个 &lt;code&gt;dfs.replication&lt;/code&gt; 参数用来指定 Hadoop 集群的复制因子 (也就是一个文件会备份几份).&lt;/p&gt;
&lt;p&gt;分布式文件管理系统很多, HDFS 只是其中一种; 它是流式的数据访问, 也就是说批量读取而非随机读取, 所以它擅长的是 &lt;strong&gt;OLAP&lt;/strong&gt;, 而不是 &lt;strong&gt;OLTP&lt;/strong&gt;, 适用于&lt;strong&gt;一次写入多次查询&lt;/strong&gt;的情况, &lt;strong&gt;不支持&lt;/strong&gt;并发写情况, &lt;strong&gt;不合适&lt;/strong&gt;存储小文件.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一次写入&lt;/strong&gt;即写入后无法更新, 只能删除重写, 2.0 好像支持追加内容.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不支持并发写&lt;/strong&gt;并不是指不能同时存储多份文件, 而是指, 一份大文件被分成多个块时, 是一个块写满再写另一个块的, 不能同时写所有的块.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不合适存储小文件&lt;/strong&gt;, 因为 NameNode 将文件系统中的元数据存储在内存中, 因此, HDFS 所能存储的文件数量会受到 NameNode 内存的限制.&lt;/p&gt;
&lt;p&gt;下面是一张 HDFS 的简单示图, 参考下:&lt;/p&gt;
&lt;p&gt;&lt;img alt="HDFS" src="http://i61.tinypic.com/dwcpw9.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;当 &lt;strong&gt;Client&lt;/strong&gt; 需要存储一份文件的时候, 如 a.log (200M), Client 先和 HDFS 中的 &lt;strong&gt;NameNode&lt;/strong&gt; 取得联系, NameNode 从自己的集群中找到一个可以存储的 &lt;strong&gt;DataNode&lt;/strong&gt; 并告诉 Client, Client 开始向指定的 DataNode 存储数据.&lt;br/&gt;
存储数据的时候, 会根据文件的大小分块存储(2.0 默认 128M), 当存储完一个块后, DataNode 会检查 NameNode 中设置的副本数量, 如果不止一份的话, 当前 DataNode 就会水平传递 (pipline) 块给其他的 DataNode, 然后再申请另一个块, 继续存储剩余的文件内容…以此类推.&lt;/p&gt;
&lt;h1 id="hdfs"&gt;HDFS 的可靠性&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;冗余副本策略&lt;/strong&gt;
    + 数据会根据复制因子保存多份, 即使系统中有某些节点脱机, 整体来说系统仍然可以持续运作而不会有数据损失&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;机架感知&lt;/strong&gt;
    +  集群一般放在不同机架上, 副本保存在不同的机架上, 这样可以防止机架故障时丢失数据&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;心跳机制&lt;/strong&gt;
    + NameNode 周期性从 DataNode 接收心跳信号和块报告 (blockport) 以验证 DataNode 是否宕掉及数据块是否正常&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;安全模式&lt;/strong&gt;
    + 当集群的 DataNode 不满足复制因子数据时, 集群进入安全模式, 不允许使用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;校验和&lt;/strong&gt;
    + 在 DataNode 中, 除了保存数据块外, 还保存一份数据块的 &lt;code&gt;.mete&lt;/code&gt; 文件, 该文件保存正常情况下数据块的校验和, DataNode 通过验证当前数据块的校验和与 &lt;code&gt;.mete&lt;/code&gt; 中的是否相等来判断数据块是否正常&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;回收站&lt;/strong&gt;
    + 该功能默认关闭, 开启时, 当 HDFS 删除数据时, 不是直接删除, 而是放到回收站中, 避免误删&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;元数据保护&lt;/strong&gt;
    + 即 NameNode 中的元数据也可以配置成保存多份&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;快照机制&lt;/strong&gt;
    +  支持存储某个时间点的映像, 需要时, 可以使数据重迒返个时间点的状态&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="_2"&gt;体系结构&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;NameNode
    + 事务日志
    + 映像文件&lt;/li&gt;
&lt;li&gt;SecondaryNameNode&lt;/li&gt;
&lt;li&gt;DataNode&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="namenode"&gt;NameNode&lt;/h2&gt;
&lt;p&gt;NameNode 是管理节点, 维护集群的&lt;a href="http://wiki.smallcpp.cn/Hadoop/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90.html"&gt;命名空间&lt;/a&gt; (就是集群 HDFS 的目录结构), 包括文件目录树、文件/目录的元数据、每个文件对应的数据块列表, 以及接收用户的操作请求.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MetaData&lt;/strong&gt; (元数据)&lt;/p&gt;
&lt;p&gt;存储细节: 为了性能和安全兼具, Metadata 在 HDFS 中会存储&lt;strong&gt;两&lt;/strong&gt;份, 内存一份, 磁盘一份(镜像).&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;code&gt;/test/a.log&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;3&lt;/th&gt;
&lt;th&gt;&lt;code&gt;{blk_1, blk_2}&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;[{blk_1: [h0, h1, h3]}, {blk_2: [h0, h2, h4]}]&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;文件名&lt;/td&gt;
&lt;td&gt;副本数&lt;/td&gt;
&lt;td&gt;文件被分多少块&lt;/td&gt;
&lt;td&gt;每个块分别被保存在哪个 DataNode 上&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;HDFS 通过 CRC 校验块的完整性.&lt;/p&gt;
&lt;p&gt;Namenode 使用&lt;strong&gt;事务日志&lt;/strong&gt;记录 HDFS 元数据的变化, 使用&lt;strong&gt;映像文件&lt;/strong&gt;存储 MetaData.&lt;/p&gt;
&lt;p&gt;事务日志和映像文件保存在 &lt;code&gt;/tmp/dfs/name/current&lt;/code&gt; 目录下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;fsimage&lt;/strong&gt;: 元数据镜像文件, 存储某一时候 NameNode 的内存元数据信息&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;edits&lt;/strong&gt;: 操作日志文件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;fstime&lt;/strong&gt;: 保存最近一次 checkpoint 的时间 (还原点)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当有操作发生时, NameNode 首先向写操作日志到磁盘, 即向 &lt;strong&gt;edits&lt;/strong&gt; 文件中写日志, 成功返回后, 才会修改内存, 并且向客户端返回.&lt;/p&gt;
&lt;p&gt;Hadoop 会维护一个 &lt;strong&gt;fsimage&lt;/strong&gt; 文件, 也就是 NameNode 中 MetaData 的硬盘镜像, 但是 &lt;strong&gt;fsimage&lt;/strong&gt; 不会随时与 NameNode 内存中的 MetaData 保持一致, 而是每隔一段时间通过合并 &lt;strong&gt;edits&lt;/strong&gt; 文件来更新内容 (仅限 1.0 和 伪分布式, 2.0 集群是实时的), &lt;strong&gt;edits&lt;/strong&gt; 合并后就会进行一次清空. Secondary NameNode 就是用来合并 &lt;strong&gt;fsimage&lt;/strong&gt; 和 &lt;strong&gt;edits&lt;/strong&gt; 文件来更新 NameNode 的 MetaData 的.&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;/tmp/dfs/name/current&lt;/code&gt; 目录下, 除了那三个文件外, 还有个 &lt;strong&gt;VERSION&lt;/strong&gt; 文件:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;hanxiao@smallcpp01:/usr/smallcpp/hadoop-2.7.3/tmp/dfs/name/current$ cat VERSION
&lt;span style="color: #228B22"&gt;#Sun Oct 16 17:28:41 CST 2016&lt;/span&gt;
&lt;span style="color: #00688B"&gt;namespaceID&lt;/span&gt;=&lt;span style="color: #B452CD"&gt;1526300018&lt;/span&gt;
&lt;span style="color: #00688B"&gt;clusterID&lt;/span&gt;=CID-cc6f47f9-4021-4f9b-87a6-ad7ad82b7af7
&lt;span style="color: #00688B"&gt;cTime&lt;/span&gt;=&lt;span style="color: #B452CD"&gt;0&lt;/span&gt;
&lt;span style="color: #00688B"&gt;storageType&lt;/span&gt;=NAME_NODE
&lt;span style="color: #00688B"&gt;blockpoolID&lt;/span&gt;=BP-1803451175-192.168.142.155-1476610121875
&lt;span style="color: #00688B"&gt;layoutVersion&lt;/span&gt;=-63
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的数据是用来标识集群、节点唯一性的.&lt;/p&gt;
&lt;h2 id="secondary-namenode"&gt;Secondary NameNode&lt;/h2&gt;
&lt;p&gt;Secondary NameNode 的作用主要体现在 Hadoop 1.x 下,  Secondary NameNode 会按照配置的时间及大小定期合并 NameNode 节点上的 fsimage 和 edits, 这样做的目的包含三方面:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;edits 中可能包含一些文件的创建及删除的操作, 合并之后, 删除的文件就不存在了, 只保存了存在的文件, 删除的文件也就不会合并到 fsimage 中, 这样会节省空间&lt;/li&gt;
&lt;li&gt;NameNode 在每次重启时都会将 fsimage 和 edits 合并, 如果不在 Secondary NameNode 中定期合并, 在重启 NameNode 时会非常慢&lt;/li&gt;
&lt;li&gt;提供冷备份的功能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 Hadoop 2.X 中, 提供了 HA 解决方案 (高可用), 彻底解决了 NameNode 单点的问题, 也就不存在 Secondary NameNode, 引入了 Standby NameNode,可以顺利的将 Active NameNode 进行热备.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工作模式&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;从 NameNode 下载元数据信息 (&lt;strong&gt;fsimage&lt;/strong&gt;, &lt;strong&gt;edits&lt;/strong&gt;), 然后合并二者, 生成新的 &lt;strong&gt;fsimage&lt;/strong&gt;, 在本地保存一份后推送到 NameNode, 替换旧的 &lt;strong&gt;fsimage&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/Hdfs简介/SecondaryNameNode.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么时候同步?&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fs.checkpoint.period&lt;/code&gt; 指定两次 checkpoint 的最大时间间隔, 默认 3600 秒&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fs.checkpoint.size&lt;/code&gt; 规定 edits 的大小, 默认 64M&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="datanode"&gt;DataNode&lt;/h2&gt;
&lt;p&gt;真实文件数据存储服务&lt;/p&gt;
&lt;p&gt;文件块(block): 最基本存储单位, hp 1.0 默认 64M, hp 2.0 默认 128M, 从文件的 0 编号开始, 按指定大小, 顺序对文件进行划分并编号.&lt;/p&gt;
&lt;p&gt;HDFS 中, 如果一个文件小于一个数据块的大小 , 并不占用整个数据块 (这些文件最终被保存在 tmp/dfs/data/current/…/finalized/ 中).&lt;/p&gt;
&lt;p&gt;默认 3 个副本 (如果已存在一份存储好的文件(3个副本), 突然有一个小弟挂掉了, NameNode 会再安排另一个小弟重新备份这个文件, 这是基于心跳包机制的).&lt;/p&gt;
&lt;h2 id="block"&gt;读取数据流程 (以 block 为单位)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;客户端要访问 HDFS 中的一个文件&lt;/li&gt;
&lt;li&gt;首先从 NameNode 获得组成返个文件的数据块位置列表&lt;/li&gt;
&lt;li&gt;根据列表知道存储数据块的 DataNode&lt;/li&gt;
&lt;li&gt;访问 DataNode 获取数据&lt;/li&gt;
&lt;li&gt;NameNode 并不参不数据实际传输&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="block_1"&gt;写入数据流程 (以 block 为单位)&lt;/h2&gt;
&lt;p&gt;HDFS client 上传数据到 HDFS 时, 会首先在本地&lt;strong&gt;缓存&lt;/strong&gt;数据, 当数据达到一个 block 大小时, 请求 NameNode 分配一个 block. NameNode 就会从当前集群寻找一个空闲 block, 然后把 block 所在的 DataNode 的信息告诉 HDFS client. HDFS client 拿到信息后直接和 DataNode 通信, 把数据写到 DataNode 节点的一个 block 文件中 (在传输过程中, 以 Packet 为最小单位).&lt;/p&gt;
&lt;p&gt;由于 Hadoop 有副本机制, 例如三个, 所以 NameNode 会寻找三个空闲 block 组成 pipeline, 依次将目标数据块写入各个 DataNode, 建立多个副本, 待所以副本数据都上传完毕后, HDFS client 会继续下一个 block 的操作.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/Hdfs简介/hdfswriteflow.png"/&gt;&lt;/p&gt;</content><category term="大数据"></category></entry><entry><title>Sublime 常用插件与快捷键</title><link href="http://www.smallcpp.cn/sublime-chang-yong-cha-jian-yu-kuai-jie-jian.html" rel="alternate"></link><published>2016-10-19T13:27:00+08:00</published><updated>2016-10-19T13:27:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-10-19:/sublime-chang-yong-cha-jian-yu-kuai-jie-jian.html</id><summary type="html">
&lt;h1 id="_1"&gt;常用插件&lt;/h1&gt;
&lt;p&gt;有个老外推荐了他使用的一些包, 我觉得都很好, 这里也推荐一下 &lt;a href="https://johnblackbourn.com/my-st3-packages"&gt;传送门&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;我常用的大部分插件在之前的几篇 Wiki 都介绍配置过了.&lt;/p&gt;
&lt;p&gt;如果出现快捷键失灵, 那么可能是热键冲突引起的, 此时可以 &lt;code&gt;Ctrl + 反引号&lt;/code&gt; 打开日志控制台, 然后再按快捷键看看日志信息, 如果什么信息都没有, 说明快捷键失效了, 换一个快捷键再试试.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.smallcpp.cn/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/Sublime%20%E9%85%8D%E7%BD%AE%20Markdown%20%E5%86%99%E4%BD%9C%E7%8E%AF%E5%A2%83.html"&gt;Sublime 配置 Markdown 写作环境&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.smallcpp.cn/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/Sublime%20%E9%85%8D%E7%BD%AE%20Python%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html"&gt;Sublime 配置 Python 开发环境&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.smallcpp.cn/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/Sublime%20%E9%85%8D%E7%BD%AE%20Nodejs%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html"&gt;Sublime 配置 Nodejs 开发环境 …&lt;/a&gt;&lt;/p&gt;</summary><content type="html">
&lt;h1 id="_1"&gt;常用插件&lt;/h1&gt;
&lt;p&gt;有个老外推荐了他使用的一些包, 我觉得都很好, 这里也推荐一下 &lt;a href="https://johnblackbourn.com/my-st3-packages"&gt;传送门&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;我常用的大部分插件在之前的几篇 Wiki 都介绍配置过了.&lt;/p&gt;
&lt;p&gt;如果出现快捷键失灵, 那么可能是热键冲突引起的, 此时可以 &lt;code&gt;Ctrl + 反引号&lt;/code&gt; 打开日志控制台, 然后再按快捷键看看日志信息, 如果什么信息都没有, 说明快捷键失效了, 换一个快捷键再试试.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.smallcpp.cn/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/Sublime%20%E9%85%8D%E7%BD%AE%20Markdown%20%E5%86%99%E4%BD%9C%E7%8E%AF%E5%A2%83.html"&gt;Sublime 配置 Markdown 写作环境&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.smallcpp.cn/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/Sublime%20%E9%85%8D%E7%BD%AE%20Python%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html"&gt;Sublime 配置 Python 开发环境&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.smallcpp.cn/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/Sublime%20%E9%85%8D%E7%BD%AE%20Nodejs%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html"&gt;Sublime 配置 Nodejs 开发环境&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以下还有一些其他挺好用的插件也是我常用的.&lt;/p&gt;
&lt;h2 id="utf8"&gt;UTF8 转换(必备)&lt;/h2&gt;
&lt;p&gt;插件: &lt;a href="https://packagecontrol.io/packages/ConvertToUTF8"&gt;ConvertToUTF8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是必备插件, 没什么好说的, 安装就行了.&lt;/p&gt;
&lt;h2 id="_2"&gt;括号高亮&lt;/h2&gt;
&lt;p&gt;插件: &lt;a href="http://facelessuser.github.io/BracketHighlighter/"&gt;BracketHighlighter&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Bracket Highlighter matches a variety of brackets such as: [], (), {}, “”, ‘’, &lt;tag&gt;&lt;/tag&gt;, and even custom brackets.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;BracketHighlighter 插件为 Sublime Text 提供括号、引号这类高亮功能, 但安装此插件后, 默认没有高亮, 只有下划线表示, 而且还不是很醒目, 需要配置:&lt;/p&gt;
&lt;p&gt;Preferences -&amp;gt; package settings -&amp;gt; Bracket Highlighter -&amp;gt; Bracket Settings – User, 然后添加如下代码:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;{
    &lt;span style="color: #CD5555"&gt;"bracket_styles"&lt;/span&gt;: {
        &lt;span style="color: #CD5555"&gt;"default"&lt;/span&gt;: {
            &lt;span style="color: #CD5555"&gt;"icon"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"dot"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"color"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"brackethighlighter.default"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"style"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"highlight"&lt;/span&gt;
        },

        &lt;span style="color: #CD5555"&gt;"unmatched"&lt;/span&gt;: {
            &lt;span style="color: #CD5555"&gt;"icon"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"question"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"color"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"brackethighlighter.unmatched"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"style"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"highlight"&lt;/span&gt;
        },
        &lt;span style="color: #CD5555"&gt;"curly"&lt;/span&gt;: {
            &lt;span style="color: #CD5555"&gt;"icon"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"curly_bracket"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"color"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"brackethighlighter.curly"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"style"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"highlight"&lt;/span&gt;
        },
        &lt;span style="color: #CD5555"&gt;"round"&lt;/span&gt;: {
            &lt;span style="color: #CD5555"&gt;"icon"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"round_bracket"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"color"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"brackethighlighter.round"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"style"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"highlight"&lt;/span&gt;
        },
        &lt;span style="color: #CD5555"&gt;"square"&lt;/span&gt;: {
            &lt;span style="color: #CD5555"&gt;"icon"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"square_bracket"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"color"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"brackethighlighter.square"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"style"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"highlight"&lt;/span&gt;
        },
        &lt;span style="color: #CD5555"&gt;"angle"&lt;/span&gt;: {
            &lt;span style="color: #CD5555"&gt;"icon"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"angle_bracket"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"color"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"brackethighlighter.angle"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"style"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"highlight"&lt;/span&gt;
        },
        &lt;span style="color: #CD5555"&gt;"tag"&lt;/span&gt;: {
            &lt;span style="color: #CD5555"&gt;"icon"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"tag"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"color"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"brackethighlighter.tag"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"style"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"highlight"&lt;/span&gt;
        },
        &lt;span style="color: #CD5555"&gt;"single_quote"&lt;/span&gt;: {
            &lt;span style="color: #CD5555"&gt;"icon"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"single_quote"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"color"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"brackethighlighter.quote"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"style"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"highlight"&lt;/span&gt;
        },
        &lt;span style="color: #CD5555"&gt;"double_quote"&lt;/span&gt;: {
            &lt;span style="color: #CD5555"&gt;"icon"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"double_quote"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"color"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"brackethighlighter.quote"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"style"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"highlight"&lt;/span&gt;
        },
        &lt;span style="color: #CD5555"&gt;"regex"&lt;/span&gt;: {
            &lt;span style="color: #CD5555"&gt;"icon"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"regex"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"color"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"brackethighlighter.quote"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"style"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"outline"&lt;/span&gt;
        }
    }

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后还要针对你的 Sublime 主题进行设置, 如果使用的是默认的 Monokai 主题, 那么主题设置文件在:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到 Sublime text3 安装目录下的 Packages 中的 &lt;code&gt;Color Scheme – Default.sublime-package&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将其重命名为 &lt;code&gt;Color Scheme – Default.sublime-package.zip&lt;/code&gt;，解压找到 &lt;code&gt;Monokai.tmTheme&lt;/code&gt;, 拉出来&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Monokai.tmTheme&lt;/code&gt; 有一堆 &lt;code&gt;dict&lt;/code&gt; 标签 (注意是有 &lt;code&gt;key&lt;/code&gt; 子标签的那列 &lt;code&gt;dict&lt;/code&gt;), 在其同级下添加下面的代码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你像我一样, 使用的是 &lt;strong&gt;Monokai Extended&lt;/strong&gt; 主题扩展的话, 主题的设置文件在 &lt;code&gt;Data\Installed Packages\Monokai Extended.sublime-package&lt;/code&gt; 里.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;name&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;Bracket Default&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;scope&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;brackethighlighter.default&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;settings&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;foreground&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;#FFFFFF&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;background&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;#A6E22E&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;name&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;Bracket Unmatched&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;scope&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;brackethighlighter.unmatched&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;settings&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;foreground&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;#FFFFFF&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;background&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;#FF0000&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;name&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;Bracket Curly&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;scope&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;brackethighlighter.curly&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;settings&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;foreground&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;#FF00FF&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;name&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;Bracket Round&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;scope&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;brackethighlighter.round&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;settings&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;foreground&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;#E7FF04&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;name&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;Bracket Square&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;scope&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;brackethighlighter.square&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;settings&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;foreground&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;#FE4800&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;name&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;Bracket Angle&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;scope&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;brackethighlighter.angle&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;settings&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;foreground&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;#02F78E&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;name&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;Bracket Tag&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;scope&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;brackethighlighter.tag&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;settings&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;foreground&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;#FFFFFF&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;background&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;#0080FF&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;name&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;Bracket Quote&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;scope&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;brackethighlighter.quote&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;settings&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;foreground&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;#56FF00&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配好后的效果如下图:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/Sublime常用插件与快捷键/BracketHighlighter.png"/&gt;&lt;/p&gt;
&lt;h2 id="_3"&gt;代码提示、自动补全和代码跳转&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt;:
Forget about &lt;em&gt;SublimeCodeIntel&lt;/em&gt; and use the new &lt;a href="https://johnblackbourn.com/sublimecodeintel-st3"&gt;CodeComplice&lt;/a&gt; package instead.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;, 这类全局代码提示插件和那种单独语言的代码提示是相&lt;strong&gt;冲突&lt;/strong&gt;的, 如 &lt;strong&gt;Anaconda&lt;/strong&gt;、&lt;strong&gt;NodeJs&lt;/strong&gt; 等.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Sublime 默认是只提示当前文件, 这里的代码提示指的是全局代码提示.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;插件: &lt;a href="https://packagecontrol.io/packages/SublimeCodeIntel"&gt;SublimeCodeintel&lt;/a&gt; (已不推荐使用, 见上面的 &lt;strong&gt;Update&lt;/strong&gt;).&lt;/p&gt;
&lt;p&gt;该插件同时支持&lt;strong&gt;代码提示&lt;/strong&gt;、&lt;strong&gt;自动补全&lt;/strong&gt;和&lt;strong&gt;代码跳转&lt;/strong&gt;三个功能, 非常强大.&lt;/p&gt;
&lt;p&gt;另外, 还有一些插件具有单独的功能, 如 &lt;a href="https://packagecontrol.io/packages/All%20Autocomplete"&gt;All Autocomplete&lt;/a&gt; 支持全局代码提示, 而 &lt;a href="https://packagecontrol.io/packages/CTags"&gt;CTags&lt;/a&gt; 支持代码跳转;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当然&lt;/strong&gt;, 如果你的 SublimeCodeintel 能正常工作, 你是不需要 All Autocomplete 和 CTags 的.&lt;/p&gt;
&lt;p&gt;SublimeCodeintel 需要设置一下才能使用, 官网上说要配 &lt;code&gt;~/.codeintel/config&lt;/code&gt;, 经验证, 这是比较老的方式, 新的已经没有这个文件了 (坑爹啊, 为什么官网不更新!!), 新的配置说明可以参考: &lt;a href="https://packagecontrol.io/packages/CodeComplice"&gt;CodeComplice&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;首次使用需要配置用户设置后才生效, 选择 &lt;code&gt;Preferences -&amp;gt; Package Settings -&amp;gt; SublimeCodeIntel -&amp;gt; Setting Default&lt;/code&gt;，将其内容全部复制到 &lt;code&gt;Setting User&lt;/code&gt; 中;&lt;/p&gt;
&lt;p&gt;将 &lt;code&gt;JavaScript&lt;/code&gt; 为例, 将 &lt;code&gt;codeintel_language_settings&lt;/code&gt; 的 &lt;code&gt;JavaScript&lt;/code&gt; 改为下面这样:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #CD5555"&gt;"JavaScript"&lt;/span&gt;: {
    &lt;span style="color: #CD5555"&gt;"codeintel_scan_extra_dir"&lt;/span&gt;: [],
    &lt;span style="color: #CD5555"&gt;"codeintel_scan_exclude_dir"&lt;/span&gt;:[&lt;span style="color: #CD5555"&gt;"/build/"&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;"/min/"&lt;/span&gt;],
    &lt;span style="color: #CD5555"&gt;"codeintel_scan_files_in_project"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"codeintel_selected_catalogs"&lt;/span&gt;: [&lt;span style="color: #CD5555"&gt;"jQuery"&lt;/span&gt;]
},
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="_4"&gt;代码跳转&lt;/h2&gt;
&lt;p&gt;插件: &lt;a href="https://packagecontrol.io/packages/CTags"&gt;CTags&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由于 &lt;strong&gt;SublimeCodeintel&lt;/strong&gt; 会和其他的代码提示插件冲突, 所以有可能你不会用到 SublimeCodeintel, 这时就需要另一款代码跳转插件了, 那就是 CTags.&lt;/p&gt;
&lt;p&gt;CTags 插件借助于 tags 文件,  tags 文件能被编辑器或其它工具用来快速查找定位源代码中的符号 (tag/symbol), 如变量名, 函数名等.&lt;/p&gt;
&lt;p&gt;生成 tags 文件需要借助工具 &lt;a href="http://ctags.sourceforge.net/"&gt;Ctags&lt;/a&gt;, 它是用来遍历源代码文件生成 tags 文件的, 去官网下载对应的系统版本, 然后解压放到任意目录.&lt;/p&gt;
&lt;p&gt;然后还要在 Sublime 的 CTags 插件中配置 Ctags 工具的路径, 打开 CTags 设置文件 (从 Default 拷贝一份到 User), 找到其中的 &lt;code&gt;command&lt;/code&gt; 选项, 配上你的 Ctags 工具全路径, 如: &lt;code&gt;D:\\ctags58\\ctags.exe&lt;/code&gt; (exe 后缀可省略).&lt;/p&gt;
&lt;p&gt;还可以将 Ctags 工具路径加入系统的环境变量, 那就不需要配这个选项了.&lt;/p&gt;
&lt;p&gt;要使用时, 侧左栏的工程/项目目录上右键执行 &lt;code&gt;CTags: Rebuild Tags&lt;/code&gt; 菜单项, 然后就会发现工程/项目目录里多了两个文件 &lt;code&gt;.tags&lt;/code&gt; 和 &lt;code&gt;.tags_sorted_by_file&lt;/code&gt;, 此时, CTags 插件可以正常工作了; 选中一个函数, 右键打开 &lt;code&gt;Navigate to Definition&lt;/code&gt; 菜单项并执行, 就会发生跳转, 还可以跳回去.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;手动生成 tags 文件: 命令行下进入工程/项目目录, 执行 &lt;code&gt;ctags -R -f .tags&lt;/code&gt;, 这样会少生成 &lt;code&gt;.tags_sorted_by_file&lt;/code&gt; 文件, 但效果是一样的 . . .&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="_5"&gt;代码规范检查&lt;/h2&gt;
&lt;p&gt;插件: &lt;a href="http://www.sublimelinter.com/en/latest/"&gt;SublimeLinter&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SublimeLinter 支持全语言, 但不能单独使用, 需要额外下载插件包, 如:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SublimeLinter-csslint&lt;/li&gt;
&lt;li&gt;SublimeLinter-jshint&lt;/li&gt;
&lt;li&gt;SublimeLinter-contrib-htmlhint&lt;/li&gt;
&lt;li&gt;SublimeLinter-contrib-pylint&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同时系统中也需要安装对应的 lint, 如 &lt;code&gt;npm install -g jshint&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;如果只想使用某个单独语言的代码规范检查, 可以单独安装, 如在 &lt;a href="http://www.smallcpp.cn/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/Sublime%20%E9%85%8D%E7%BD%AE%20Python%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html"&gt;Sublime 配置 Python 开发环境&lt;/a&gt; 及 &lt;a href="http://www.smallcpp.cn/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/Sublime%20%E9%85%8D%E7%BD%AE%20Nodejs%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83.html"&gt;Sublime 配置 Nodejs 开发环境&lt;/a&gt; 中介绍过的 &lt;strong&gt;Pylint&lt;/strong&gt; 和 &lt;strong&gt;JSHint&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id="_6"&gt;符号对齐&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt;:
&lt;a href="https://github.com/randy3k/AlignTab"&gt;AlignTab&lt;/a&gt;: A much more powerful version of the &lt;em&gt;Alignment&lt;/em&gt; package. Supports regexes and table mode.&lt;/p&gt;
&lt;p&gt;AlignTab 预置了一些对齐符号, 如等号, 使用方法: 选中要对齐的代码块, 右键 -&amp;gt; &lt;code&gt;Align By&lt;/code&gt;, 选择按什么符号进行对齐.&lt;/p&gt;
&lt;p&gt;同时 AlignTab 还支持自定义符号对齐, 如 &lt;code&gt;+&lt;/code&gt; 号, 使用方法, 选中要对齐的代码块, &lt;code&gt;ctrl + shift + p&lt;/code&gt; 呼出命令栏, 输出 &lt;code&gt;Live&lt;/code&gt;, 选择弹出来的 &lt;code&gt;Aligntab: Live Preview Mode&lt;/code&gt;, 这是 AlignTab 的&lt;strong&gt;正则&lt;/strong&gt;模式, 选择后, Sublime 下方会出现正则输入栏, 在里面输入 ‘\+’ (因为 + 号是正则表达式, 所以要输入反斜杠转义), 就可以看到效果了.&lt;/p&gt;
&lt;p&gt;插件: &lt;a href="https://packagecontrol.io/packages/Alignment"&gt;Alignment&lt;/a&gt; (只支持等号对齐, 已不推荐使用, 见上面的 &lt;strong&gt;Update&lt;/strong&gt;).&lt;/p&gt;
&lt;p&gt;&lt;a href="https://my.oschina.net/shede333/blog/170536"&gt;Alignment 使用详解&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="htmlxml"&gt;HTML/XML 代码格式化&lt;/h2&gt;
&lt;p&gt;插件: &lt;a href="https://github.com/titoBouzout/Tag"&gt;Tag&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt;:
该插件可以考虑用下面的 &lt;strong&gt;HTML-CSS-JS Prettify&lt;/strong&gt; 替代.&lt;/p&gt;
&lt;p&gt;这个插件主要用来进行 HTML/XML 代码格式化, 我一般习惯使用和 JsFormat 相同的快捷键.&lt;/p&gt;
&lt;p&gt;插件设置 -&amp;gt; 按键绑定 - 用户, 添加一行:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;{
    &lt;span style="color: #CD5555"&gt;"keys"&lt;/span&gt;: [&lt;span style="color: #CD5555"&gt;"ctrl+k"&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;"ctrl+c"&lt;/span&gt;],
    &lt;span style="color: #CD5555"&gt;"command"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"tag_indent_document"&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"context"&lt;/span&gt;: [{
            &lt;span style="color: #CD5555"&gt;"key"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"selector"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"operator"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"equal"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"operand"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"text.html,text.htm,text.xml,text.xsl"&lt;/span&gt;
        }]
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="htmlcssjs"&gt;HTML/CSS/JS 格式化&lt;/h2&gt;
&lt;p&gt;插件: &lt;a href="https://github.com/titoBouzout/Tag"&gt;HTML-CSS-JS Prettify&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个插件同时支持 HTML、CSS 和 JS 的代码格式化, 我没使用过, 听说还行, 如果可以的话, 那么可以用来替换 &lt;strong&gt;Tab&lt;/strong&gt; 和 &lt;strong&gt;JsFormat&lt;/strong&gt; 这两个插件了.&lt;/p&gt;
&lt;p&gt;Refrences:
&lt;a href="http://www.tuicool.com/articles/jUjmIv6"&gt;Sublime Text2 格式化 HMTL/CSS/JS 插件 HTML-CSS-JS Prettify&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://segmentfault.com/a/1190000000666502"&gt;使用 Sublime Text 3 的 HTML-CSS-JS Prettify 插件格式化代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://frontenddev.org/article/sublime-does-text-three-plug-ins-html-and-css-js-prettify.html"&gt;sublime text 3 插件: HTML-CSS-JS Prettify&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="_7"&gt;快速注释&lt;/h2&gt;
&lt;p&gt;插件: &lt;a href="https://packagecontrol.io/packages/DocBlockr"&gt;Doc​Blockr&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个插件也不需要什么设置, 安装好即可用, 类似 vs 上 tab 键补全注释功能.&lt;/p&gt;
&lt;h2 id="_8"&gt;按模板快速新建文件&lt;/h2&gt;
&lt;p&gt;插件: &lt;a href="https://packagecontrol.io/packages/SublimeTmpl"&gt;SublimeTmpl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如其名, 无须多解释 . . .&lt;/p&gt;
&lt;h2 id="emmet"&gt;Emmet&lt;/h2&gt;
&lt;p&gt;插件: &lt;a href="https://sublime.wbond.net/packages/Emmet"&gt;Emmet&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;就是以前的 Zen Coding, 方便编写 HTML, 可说是前端必备, 打算单独弄篇 Wiki.&lt;/p&gt;
&lt;h2 id="_9"&gt;文件提示&lt;/h2&gt;
&lt;p&gt;插件: &lt;a href="https://packagecontrol.io/packages/AutoFileName"&gt;Auto​File​Name&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个插件也是前端用的多, 例如写 CSS 的时候, 如 &lt;code&gt;background:url(../img/njpg.png) no-repeat;&lt;/code&gt;, 当写到 &lt;code&gt;../img/&lt;/code&gt; 时插件就被提示这个目录下有哪些文件.&lt;/p&gt;
&lt;h2 id="jquery"&gt;jQuery 语法提示&lt;/h2&gt;
&lt;p&gt;插件: &lt;a href="https://packagecontrol.io/packages/jQuery"&gt;jQuery&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;让 Sublime Text3 支持 jQuery 语法提示, 这个插件不需要设置, 安装后即能使用.&lt;/p&gt;
&lt;h2 id="html5"&gt;HTML5 语法提示&lt;/h2&gt;
&lt;p&gt;插件: &lt;a href="https://packagecontrol.io/packages/HTML5"&gt;HTML5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;让 Sublime Text3 支持 HTML5 语法提示, 这个插件不需要设置, 安装后即能使用.&lt;/p&gt;
&lt;h2 id="sass"&gt;Sass 语法提示&lt;/h2&gt;
&lt;p&gt;插件: &lt;a href="https://sublime.wbond.net/packages/Sass"&gt;Sass&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;让 Sublime Text3 支持 Sass 语法提示, 这个插件不需要设置, 安装后即能使用.&lt;/p&gt;
&lt;h1 id="_10"&gt;常用快捷键&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + Shift + P&lt;/td&gt;
&lt;td&gt;打开命令面板&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + P&lt;/td&gt;
&lt;td&gt;搜索项目中的文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + G&lt;/td&gt;
&lt;td&gt;跳转到第几行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + R&lt;/td&gt;
&lt;td&gt;跳转到 method&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + W&lt;/td&gt;
&lt;td&gt;关闭当前打开文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + D&lt;/td&gt;
&lt;td&gt;选择单词, 重复可增加选择下一个相同的单词&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Alt + F3&lt;/td&gt;
&lt;td&gt;选择所有相同的单词&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + L&lt;/td&gt;
&lt;td&gt;选择行, 重复可依次增加选择下一行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + Shift + W&lt;/td&gt;
&lt;td&gt;关闭所有打开文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + Shift + V&lt;/td&gt;
&lt;td&gt;粘贴并格式化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + Shift + L&lt;/td&gt;
&lt;td&gt;先选中多行, 再按下快捷键, 会在每行行尾插入光标, 即可同时编辑这些行.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + Shift + Enter&lt;/td&gt;
&lt;td&gt;在当前行前插入新行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + Shift + D&lt;/td&gt;
&lt;td&gt;复制整行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + X&lt;/td&gt;
&lt;td&gt;删除当前行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + M&lt;/td&gt;
&lt;td&gt;跳转到对应括号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + U&lt;/td&gt;
&lt;td&gt;软撤销, 撤销光标位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + J&lt;/td&gt;
&lt;td&gt;选择标签内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + F&lt;/td&gt;
&lt;td&gt;查找内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + Shift + F&lt;/td&gt;
&lt;td&gt;查找并替换&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + H&lt;/td&gt;
&lt;td&gt;替换&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + N&lt;/td&gt;
&lt;td&gt;新建窗口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + K + B&lt;/td&gt;
&lt;td&gt;开关侧栏&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + Shift + M&lt;/td&gt;
&lt;td&gt;选中当前括号内容, 重复可选着括号本身&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + F2&lt;/td&gt;
&lt;td&gt;设置/删除标记&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + /&lt;/td&gt;
&lt;td&gt;注释当前行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + Shift + /&lt;/td&gt;
&lt;td&gt;当前位置插入注释&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + Alt + /&lt;/td&gt;
&lt;td&gt;块注释, 并 Focus 到首行, 写注释说明用的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + Shift + A&lt;/td&gt;
&lt;td&gt;(HTML) 选择当前标签前后, 修改标签用的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;F11&lt;/td&gt;
&lt;td&gt;全屏&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Shift + F11&lt;/td&gt;
&lt;td&gt;全屏免打扰模式, 只编辑当前文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Alt + F3&lt;/td&gt;
&lt;td&gt;选择所有相同的词&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Alt + .&lt;/td&gt;
&lt;td&gt;闭合标签&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Alt + Shift + W&lt;/td&gt;
&lt;td&gt;使用标签包裹一行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Alt + Shift + 数字&lt;/td&gt;
&lt;td&gt;分屏显示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Alt + 数字&lt;/td&gt;
&lt;td&gt;切换打开第N个文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Shift + 右键拖动&lt;/td&gt;
&lt;td&gt;光标多行拖动 (和鼠标中键同样功能)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;鼠标的前进后退键&lt;/td&gt;
&lt;td&gt;切换 Tab 文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;按 Ctrl, 依次点击或选取&lt;/td&gt;
&lt;td&gt;编辑的多个位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;按 Ctrl + Shift + 上下键,&lt;/td&gt;
&lt;td&gt;替换行&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id="_11"&gt;全部快捷键&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;选择类&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + D&lt;/td&gt;
&lt;td&gt;选中光标所占的文本, 继续操作则会选中下一个相同的文本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Alt + F3&lt;/td&gt;
&lt;td&gt;选中文本按下快捷键, 即可一次性选择全部的相同文本进行同时编辑.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;举个栗子: 快速选中并更改所有相同的变量名、函数名等.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + L&lt;/td&gt;
&lt;td&gt;选中整行, 继续操作则继续选择下一行, 效果和 Shift + ↓ 效果一样.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + Shift + L&lt;/td&gt;
&lt;td&gt;先选中多行, 再按下快捷键, 会在每行行尾插入光标, 即可同时编辑这些行.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + Shift + M&lt;/td&gt;
&lt;td&gt;选择括号内的内容 (继续选择父括号).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;举个栗子: 快速选中删除函数中的代码, 重写函数体代码或重写括号内里的内容.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + M&lt;/td&gt;
&lt;td&gt;光标移动至括号内结束或开始的位置.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + Enter&lt;/td&gt;
&lt;td&gt;在下一行插入新行. 即使光标不在行尾, 也能快速向下插入一行.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + Shift + Enter&lt;/td&gt;
&lt;td&gt;在上一行插入新行. 即使光标不在行首, 也能快速向上插入一行.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + Shift + [&lt;/td&gt;
&lt;td&gt;选中代码, 按下快捷键, 折叠代码.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + Shift + ]&lt;/td&gt;
&lt;td&gt;选中代码, 按下快捷键, 展开代码.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + K + 0&lt;/td&gt;
&lt;td&gt;展开所有折叠代码.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + ←&lt;/td&gt;
&lt;td&gt;向左单位性地移动光标, 快速移动光标.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + →&lt;/td&gt;
&lt;td&gt;向右单位性地移动光标, 快速移动光标.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;shift + ↑&lt;/td&gt;
&lt;td&gt;向上选中多行.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;shift + ↓&lt;/td&gt;
&lt;td&gt;向下选中多行.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Shift + ←&lt;/td&gt;
&lt;td&gt;向左选中文本.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Shift + →&lt;/td&gt;
&lt;td&gt;向右选中文本.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + Shift + ←&lt;/td&gt;
&lt;td&gt;向左单位性地选中文本.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + Shift + →&lt;/td&gt;
&lt;td&gt;向右单位性地选中文本.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + Shift + ↑&lt;/td&gt;
&lt;td&gt;将光标所在行和上一行代码互换（将光标所在行插入到上一行之前).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + Shift + ↓&lt;/td&gt;
&lt;td&gt;将光标所在行和下一行代码互换（将光标所在行插入到下一行之后).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + Alt + ↑&lt;/td&gt;
&lt;td&gt;向上添加多行光标, 可同时编辑多行.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + Alt + ↓&lt;/td&gt;
&lt;td&gt;向下添加多行光标, 可同时编辑多行.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;编辑类&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + J&lt;/td&gt;
&lt;td&gt;合并选中的多行代码为一行. 例如将多行格式的 CSS 属性合并为一行.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + Shift + D&lt;/td&gt;
&lt;td&gt;复制光标所在整行, 插入到下一行.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Tab&lt;/td&gt;
&lt;td&gt;向右缩进.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Shift + Tab&lt;/td&gt;
&lt;td&gt;向左缩进.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + K + K&lt;/td&gt;
&lt;td&gt;从光标处开始删除代码至行尾.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + Shift + K&lt;/td&gt;
&lt;td&gt;删除整行.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + /&lt;/td&gt;
&lt;td&gt;注释单行.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + Shift + /&lt;/td&gt;
&lt;td&gt;注释多行.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + K + U&lt;/td&gt;
&lt;td&gt;转换大写.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + K + L&lt;/td&gt;
&lt;td&gt;转换小写.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + Z&lt;/td&gt;
&lt;td&gt;撤销.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + Y&lt;/td&gt;
&lt;td&gt;恢复撤销.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + U&lt;/td&gt;
&lt;td&gt;软撤销, 感觉和 Ctrl + Z 一样.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + F2&lt;/td&gt;
&lt;td&gt;设置书签&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + T&lt;/td&gt;
&lt;td&gt;左右字母互换.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;F6&lt;/td&gt;
&lt;td&gt;单词检测拼写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;搜索类&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + Shift + P&lt;/td&gt;
&lt;td&gt;打开 sublime 命令框工具栏.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + F&lt;/td&gt;
&lt;td&gt;打开底部搜索框, 查找关键字.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + shift + F&lt;/td&gt;
&lt;td&gt;在文件夹内查找, 允许在多个文件夹进行查找.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + P&lt;/td&gt;
&lt;td&gt;打开搜索框. 举个栗子:&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;1、输入当前项目中的文件名, 快速搜索文件;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;2、输入 @ 和关键字, 查找文件中函数名;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;3、输入 : 和数字, 跳转到文件中该行代码;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;4、输入 # 和关键字, 查找变量名.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + G&lt;/td&gt;
&lt;td&gt;打开搜索框, 自动带 :, 输入数字跳转到该行代码.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + R&lt;/td&gt;
&lt;td&gt;打开搜索框, 自动带 @, 输入关键字, 查找文件中的函数名.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + :&lt;/td&gt;
&lt;td&gt;打开搜索框, 自动带 #, 输入关键字, 查找文件中的变量名、属性名等.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Esc&lt;/td&gt;
&lt;td&gt;退出光标多行选择, 退出搜索框, 命令框等.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;显示类&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + Tab&lt;/td&gt;
&lt;td&gt;按文件浏览过的顺序, 切换当前窗口的标签页.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + PageDown&lt;/td&gt;
&lt;td&gt;向左切换当前窗口的标签页.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + PageUp&lt;/td&gt;
&lt;td&gt;向右切换当前窗口的标签页.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Alt + Shift + 1&lt;/td&gt;
&lt;td&gt;窗口分屏, 恢复默认 1 屏（非小键盘的数字)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Alt + Shift + 2&lt;/td&gt;
&lt;td&gt;左右分屏 - 2 列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Alt + Shift + 3&lt;/td&gt;
&lt;td&gt;左右分屏 - 3 列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Alt + Shift + 4&lt;/td&gt;
&lt;td&gt;左右分屏 - 4 列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Alt + Shift + 5&lt;/td&gt;
&lt;td&gt;等分 4 屏&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Alt + Shift + 8&lt;/td&gt;
&lt;td&gt;垂直分屏 - 2 屏&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Alt + Shift + 9&lt;/td&gt;
&lt;td&gt;垂直分屏 - 3 屏&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl + K + B&lt;/td&gt;
&lt;td&gt;开启/关闭侧边栏.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;F11&lt;/td&gt;
&lt;td&gt;全屏模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Shift + F11&lt;/td&gt;
&lt;td&gt;免打扰模式&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content><category term="工具折腾"></category></entry><entry><title>Sublime 配置 Nodejs 开发环境</title><link href="http://www.smallcpp.cn/sublime-pei-zhi-nodejs-kai-fa-huan-jing.html" rel="alternate"></link><published>2016-10-18T22:19:00+08:00</published><updated>2016-10-18T22:19:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-10-18:/sublime-pei-zhi-nodejs-kai-fa-huan-jing.html</id><summary type="html">
&lt;h1 id="_1"&gt;语法提示&lt;/h1&gt;
&lt;p&gt;使用插件: &lt;strong&gt;SublimeText-Nodejs&lt;/strong&gt; 插件（&lt;a href="https://github.com/tanepiper/SublimeText-Nodejs"&gt;Github&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;, 这个插件不要用 Sublime 的 Package Control 来安装, Package Control 安装的会没有配置文件导致设置不了插件 . . .&lt;/p&gt;
&lt;p&gt;直接在 Github 上下载包下来, 解压重命名为 &lt;strong&gt;Nodejs&lt;/strong&gt;, 然后放到 Sublime 的 &lt;strong&gt;Packages&lt;/strong&gt; 目录下 (首选项 -&amp;gt; 浏览插件);&lt;/p&gt;
&lt;p&gt;打开 Nodejs 下面的 …&lt;/p&gt;</summary><content type="html">
&lt;h1 id="_1"&gt;语法提示&lt;/h1&gt;
&lt;p&gt;使用插件: &lt;strong&gt;SublimeText-Nodejs&lt;/strong&gt; 插件（&lt;a href="https://github.com/tanepiper/SublimeText-Nodejs"&gt;Github&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;, 这个插件不要用 Sublime 的 Package Control 来安装, Package Control 安装的会没有配置文件导致设置不了插件 . . .&lt;/p&gt;
&lt;p&gt;直接在 Github 上下载包下来, 解压重命名为 &lt;strong&gt;Nodejs&lt;/strong&gt;, 然后放到 Sublime 的 &lt;strong&gt;Packages&lt;/strong&gt; 目录下 (首选项 -&amp;gt; 浏览插件);&lt;/p&gt;
&lt;p&gt;打开 Nodejs 下面的 &lt;code&gt;Nodejs.sublime-settings&lt;/code&gt;, 修改里面的 &lt;code&gt;node_command&lt;/code&gt; 和  &lt;code&gt;npm_command&lt;/code&gt;, 如下:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;{
  &lt;span style="color: #228B22"&gt;// save before running commands&lt;/span&gt;
  &lt;span style="color: #CD5555"&gt;"save_first"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;,
  &lt;span style="color: #228B22"&gt;// if present, use this command instead of plain "node"&lt;/span&gt;
  &lt;span style="color: #228B22"&gt;// e.g. "/usr/bin/node" or "C:\bin\node.exe"&lt;/span&gt;
  &lt;span style="color: #CD5555"&gt;"node_command"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"E:\\nodejs\\node.exe"&lt;/span&gt;,
  &lt;span style="color: #228B22"&gt;// Same for NPM command&lt;/span&gt;
  &lt;span style="color: #CD5555"&gt;"npm_command"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"E:\\nodejs\\npm.cmd"&lt;/span&gt;,
  &lt;span style="color: #228B22"&gt;// as 'NODE_PATH' environment variable for node runtime&lt;/span&gt;
  &lt;span style="color: #CD5555"&gt;"node_path"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;false&lt;/span&gt;,

  &lt;span style="color: #CD5555"&gt;"expert_mode"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;false&lt;/span&gt;,

  &lt;span style="color: #CD5555"&gt;"ouput_to_new_tab"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;false&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再打开 &lt;code&gt;Nodejs.sublime-build&lt;/code&gt;, 修改里面的 &lt;code&gt;encoding&lt;/code&gt; 和  &lt;code&gt;windows cmd&lt;/code&gt;, 如下:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;{
  &lt;span style="color: #CD5555"&gt;"cmd"&lt;/span&gt;: [&lt;span style="color: #CD5555"&gt;"node"&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;"$file"&lt;/span&gt;],
  &lt;span style="color: #CD5555"&gt;"file_regex"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"^[ ]*File \"(...*?)\", line ([0-9]*)"&lt;/span&gt;,
  &lt;span style="color: #CD5555"&gt;"selector"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"source.js"&lt;/span&gt;,
  &lt;span style="color: #CD5555"&gt;"shell"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;,
  &lt;span style="color: #CD5555"&gt;"encoding"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"utf8"&lt;/span&gt;,
  &lt;span style="color: #CD5555"&gt;"windows"&lt;/span&gt;:
    {
        &lt;span style="color: #CD5555"&gt;"cmd"&lt;/span&gt;: [&lt;span style="color: #CD5555"&gt;"taskkill"&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;"/F"&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;"/IM"&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;"node.exe"&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;"&amp;amp;"&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;"node"&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;"$file"&lt;/span&gt;]
    },
  &lt;span style="color: #CD5555"&gt;"linux"&lt;/span&gt;:
    {
        &lt;span style="color: #CD5555"&gt;"cmd"&lt;/span&gt;: [&lt;span style="color: #CD5555"&gt;"killall node; node"&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;"$file"&lt;/span&gt;]
    },
    &lt;span style="color: #CD5555"&gt;"osx"&lt;/span&gt;:
    {
    &lt;span style="color: #CD5555"&gt;"cmd"&lt;/span&gt;: [&lt;span style="color: #CD5555"&gt;"killall node; node $file"&lt;/span&gt;]
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置好后, 打开一个 js 文件使用 &lt;code&gt;ctrl + b&lt;/code&gt; 就能调用 node.js 来运行脚本了.&lt;/p&gt;
&lt;h1 id="_2"&gt;代码检查&lt;/h1&gt;
&lt;p&gt;插件: JSHint&lt;/p&gt;
&lt;p&gt;这个可以通过 Package Control 安装, 选择插件时, 有两个, 一个是 JSHint, 还有一个是 JSHint Gutter, 推荐使用 JSHint Gutter, 这个版本较新, 可以配置很多另一个 JSHint 没有的功能.&lt;/p&gt;
&lt;p&gt;插件设置 -&amp;gt; JSHint Gutter -&amp;gt; Set Plugin Options, 这里面主要配置 node.js 的路径和 &lt;code&gt;lint_on_save&lt;/code&gt; (保存时检查, 很好用的功能).&lt;/p&gt;
&lt;p&gt;插件设置 -&amp;gt; JSHint Gutter -&amp;gt; Set Linting Preferences, 这里对 JSHint 的规则做配置, 我这里配好一份, 可参考:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;{
  &lt;span style="color: #228B22"&gt;// The plugin looks for a .jshintrc file in the same directory as the source&lt;/span&gt;
  &lt;span style="color: #228B22"&gt;// file you're prettifying (or any directory above if it doesn't exist, or in&lt;/span&gt;
  &lt;span style="color: #228B22"&gt;// your home folder if everything else fails) and uses those options along&lt;/span&gt;
  &lt;span style="color: #228B22"&gt;// the default ones.&lt;/span&gt;

  &lt;span style="color: #228B22"&gt;// Details: https://github.com/victorporof/Sublime-JSHint#using-your-own-jshintrc-options&lt;/span&gt;
  &lt;span style="color: #228B22"&gt;// Example: https://github.com/jshint/jshint/blob/master/examples/.jshintrc&lt;/span&gt;
  &lt;span style="color: #228B22"&gt;// Documentation: http://www.jshint.com/docs/options/&lt;/span&gt;
  &lt;span style="color: #CD5555"&gt;"globals"&lt;/span&gt;: {
    &lt;span style="color: #CD5555"&gt;"console"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;
  },  &lt;span style="color: #228B22"&gt;// 指定没有正式定义的全局变量的白名单&lt;/span&gt;
  &lt;span style="color: #CD5555"&gt;"browser"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;,  &lt;span style="color: #228B22"&gt;// true: 暴露浏览器属性的全局变量, 列如 window, document&lt;/span&gt;
  &lt;span style="color: #CD5555"&gt;"esnext"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;,  &lt;span style="color: #228B22"&gt;// true: 允许 ECMAScript 6 规约, 目前 ES6 的特性不是所有的浏览器都支持&lt;/span&gt;
  &lt;span style="color: #CD5555"&gt;"unused"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;,  &lt;span style="color: #228B22"&gt;// true: 表示禁止变量已经声明, 但却不使用&lt;/span&gt;
  &lt;span style="color: #CD5555"&gt;"undef"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;,  &lt;span style="color: #228B22"&gt;// true: 表示所有的局部变量都必须先声明再使用&lt;/span&gt;
  &lt;span style="color: #CD5555"&gt;"noempty"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;,  &lt;span style="color: #228B22"&gt;// true: 表示禁止出现空的代码块 `{ }`&lt;/span&gt;
  &lt;span style="color: #CD5555"&gt;"noarg"&lt;/span&gt; : &lt;span style="color: #8B008B; font-weight: bold"&gt;false&lt;/span&gt;,  &lt;span style="color: #228B22"&gt;// true: 表示禁止使用 `arguments.caller` 和 `arguments.callee`&lt;/span&gt;
  &lt;span style="color: #CD5555"&gt;"immed "&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;,  &lt;span style="color: #228B22"&gt;// true: 立即执行函数必须用括号包起来 `(function () { } ());`&lt;/span&gt;
  &lt;span style="color: #CD5555"&gt;"eqeqeq"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;false&lt;/span&gt;,  &lt;span style="color: #228B22"&gt;// true: 表示判断相等时, 必须使用 ===&lt;/span&gt;
  &lt;span style="color: #CD5555"&gt;"strict"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"global"&lt;/span&gt;  &lt;span style="color: #228B22"&gt;// global: 全局强制使用 ES5 的严格模式 (在每个文件开头 "use strict";), Strict Mode 是对 JS 用法的一些限制, 过滤掉了容易出错的特性和不容易优化的特性&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后, 要使用 JSHint 插件, 还需要你的系统安装了 JSHint 包, 可用 npm 直接安装, 网络不好的使用国内镜像安装:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;npm --registry https://registry.npm.taobao.org install jshint&lt;/code&gt;&lt;/p&gt;
&lt;h1 id="_3"&gt;格式化代码&lt;/h1&gt;
&lt;p&gt;插件: JsFormat&lt;/p&gt;
&lt;p&gt;这个没什么好说的, 默认快捷键: &lt;code&gt;ctrl + alt + f&lt;/code&gt;, 我习惯改成 &lt;code&gt;ctrl + k + c&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;插件设置 -&amp;gt; JsFormat -&amp;gt; Key Bindings - Default, 改成:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;[
    {
        &lt;span style="color: #CD5555"&gt;"keys"&lt;/span&gt;: [&lt;span style="color: #CD5555"&gt;"ctrl+k"&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;"ctrl+c"&lt;/span&gt;], &lt;span style="color: #CD5555"&gt;"command"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"js_format"&lt;/span&gt;,
        &lt;span style="color: #CD5555"&gt;"context"&lt;/span&gt;: [{&lt;span style="color: #CD5555"&gt;"key"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"selector"&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;"operator"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"equal"&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;"operand"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"source.js,source.json"&lt;/span&gt;}]
    }
]
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="_4"&gt;代码调试&lt;/h1&gt;
&lt;p&gt;参考另篇 wiki: &lt;a href="http://www.smallcpp.cn/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/NodeJs%20%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7.html#node-inspector"&gt;NodeJs 调试技巧&lt;/a&gt;&lt;/p&gt;
&lt;h1 id="_5"&gt;代码高亮&lt;/h1&gt;
&lt;p&gt;Sublime 自带了 JS 的高亮, 但有个插件叫 JavaScriptNext, 它对 JS 的渲染更好看些, 可以尝试使用.&lt;/p&gt;</content><category term="工具折腾"></category></entry><entry><title>01. Hadoop 初识</title><link href="http://www.smallcpp.cn/01-hadoop-chu-shi.html" rel="alternate"></link><published>2016-10-16T23:32:00+08:00</published><updated>2016-10-16T23:32:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-10-16:/01-hadoop-chu-shi.html</id><summary type="html">&lt;p&gt;Hadoop 初识&lt;/p&gt;</summary><content type="html">
&lt;h1 id="1"&gt;1. 预备&lt;/h1&gt;
&lt;p&gt;使用 Hadoop 需要具体一些预备知识: Linux 和 Java;&lt;/p&gt;
&lt;p&gt;Linux 可以去看看《鸟哥的私房菜》, Java 不需要太过深入, 看看张孝祥的 《Java 就业培训》就好了.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OLTP&lt;/strong&gt;: 联机事务处理, 是传统的关系型数据库的主要应用, 主要是基本的、日常的事务处理, 例如银行交易.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OLAP&lt;/strong&gt;: 联机分析处理, 是数据仓库系统的主要应用, 支持复杂的分析操作, 侧重决策支持, 并且提供直观易懂的查询结果.&lt;/p&gt;
&lt;p&gt;Hadoop 是一个由 Apache 基金会所开发的&lt;strong&gt;分布式系统基础架构&lt;/strong&gt;, 由一套&lt;em&gt;分布式文件系统&lt;/em&gt;和一套&lt;em&gt;计算框架&lt;/em&gt;构成, 它是一套&lt;strong&gt;生态圈&lt;/strong&gt;, 而不是一个数据库应用.&lt;/p&gt;
&lt;p&gt;Hadoop 做的是&lt;strong&gt;离线数据&lt;/strong&gt;分析 (OLAP), 例如像淘宝数据魔方那样统计历史数据; 也正如此 Hadoop 使用的 HDFS 文件系统是个&lt;strong&gt;半只读&lt;/strong&gt;系统, 只支持增加, 不支持修改, 因为历史数据产生了就是产生了, 不需要被修改; 但也有特殊情况存在, 所以 Hadoop 推出了 &lt;strong&gt;HBase&lt;/strong&gt; 这个子项目.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;去 IEO&lt;/strong&gt;: 它是阿里巴巴造出的概念, 其本意是, 在阿里巴巴的 IT 架构中, 去掉 IBM 的小型机、Oracle 数据库、EMC 存储设备, 代之以自己在开源软件基础上开发的系统;&lt;/p&gt;
&lt;p&gt;使用 Hadoop 也推崇这个概念, 毕竟 IEO 价格昂贵, 而 Hadoop 可以运行在廉价的 PC 机上.&lt;/p&gt;
&lt;p&gt;Hadoop 生产环境选型:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/Hadoop初识/集群选择.png"/&gt;&lt;/p&gt;
&lt;p&gt;Hadoop 的大多思想都来源于 Google;&lt;/p&gt;
&lt;p&gt;Google 技术有三宝: &lt;strong&gt;GFS&lt;/strong&gt;、&lt;strong&gt;MapReduce&lt;/strong&gt; 和 &lt;strong&gt;BigTable&lt;/strong&gt;! HDFS 的灵感就来自 GFS, 而 HBase 的灵感就是 BigTable, 当然也少不了 MapReduce.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.jobbole.com/71431/"&gt;Page Rank – 给每个网页评分&lt;/a&gt;, 曾是 Google 发家致富的法宝, 是一套非常复杂的算法, 当 Google 收集的网页数量变得非常巨大后, 单台的服务器已经无法完成这个算法的运算, 于是 Google 推出了 &lt;strong&gt;Map-Reduce&lt;/strong&gt; 的方法, 这套方法的中心思想就按某个依据将巨大/复杂的任务拆分、映射到多个服务器进行分布式计算, 最终将各个服务器的运算结果进行汇总.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/hguisu/article/details/7962350"&gt;倒排索引 – 解决全文搜索的问题&lt;/a&gt;&lt;/p&gt;
&lt;h1 id="2"&gt;2. 实验环境&lt;/h1&gt;
&lt;p&gt;2.1. 条件允许, 可以搞台服务器, 装上 &lt;strong&gt;ESXI&lt;/strong&gt;, 虚拟出几个服务器, 再通过 VMware Client 对其进行管理.&lt;/p&gt;
&lt;p&gt;2.2. 如果条件不允许, 可以在本机上用 VMware Workstation (或者 Virtualbox), 推荐虚拟出 3 台服务器, 一台用作 NameNode, 另两台用作 DataNode.&lt;/p&gt;
&lt;p&gt;2.3. 还可以在 Windows 上用 &lt;strong&gt;cygwin&lt;/strong&gt; 虚拟出类 UNIX 环境, 不过不推荐这样做…&lt;/p&gt;
&lt;p&gt;我们使用 2.2 来进行实验, 参考我的一篇 wiki: &lt;a href="http://wiki.smallcpp.cn/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/%E6%90%AD%E5%BB%BA%20Hadoop%20%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83.html"&gt;搭建 Hadoop 分布式实验环境&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果使用 2.2 的话, 要去主板的 BIOS 中开启 VT 功能, 能很大的提高虚拟机性能.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id="3-hadoop"&gt;3. Hadoop 生态圈&lt;/h1&gt;
&lt;p&gt;这里仅介绍下几个重要的 Hadoop 子项目;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Pig, 一种脚本语言, 目的是为了简化 MR 的编写&lt;/li&gt;
&lt;li&gt;Hive, 提供一种类 SQL 语句来操作 MR, 也是为了简化 MR 的编写&lt;/li&gt;
&lt;li&gt;HBase, 这是一个真实的 NoSQL 数据库, 它是为了解决 Hadoop 半只读的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;像 Pig 和 Hive 都是为了增强 Hadoop 的 OLAP 能力, 而 HBase 是为了增强 Hadoop 的 OLTP 能力.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以上仅为我个人理解, 现在对 Hadoop 接触不深, 可能理解有误, 以后再改进.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id="4-hadoop"&gt;4. Hadoop 进程&lt;/h1&gt;
&lt;p&gt;当 Hadoop 集群跑起来后, 它们产生一些守护进程 (就像在 Windows 系统下的服务一样), Hadoop 是 Java 开发的, 所以这些进程都是 Java 进程, 可以通过 &lt;code&gt;JPS&lt;/code&gt; 查看.&lt;/p&gt;
&lt;p&gt;Hadoop 集群逻辑上分为两个节点: &lt;strong&gt;主节点 (Master)&lt;/strong&gt;和&lt;strong&gt;从节点 (Slave)&lt;/strong&gt;;&lt;/p&gt;
&lt;p&gt;Master 节点为运行着 &lt;strong&gt;NameNode&lt;/strong&gt;、&lt;strong&gt;Secondary NameNode&lt;/strong&gt; 及 &lt;strong&gt;JobTracker&lt;/strong&gt; (&lt;strong&gt;ResourceManager&lt;/strong&gt;) 节点的统称.&lt;/p&gt;
&lt;p&gt;Slave 节点为运行着 &lt;strong&gt;DataNode&lt;/strong&gt; 及 &lt;strong&gt;TaskTracker&lt;/strong&gt; (&lt;strong&gt;NodeManager&lt;/strong&gt;) 节点的统称.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/Hadoop初识/Hadoop集群.png"/&gt;&lt;/p&gt;
&lt;p&gt;以下先简单介绍, 有个印象, 后续还会单独进行讲解.&lt;/p&gt;
&lt;h2 id="41-namenode"&gt;4.1 NameNode&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HDFS 的守护程序 (总控), 保存 Hadoop 集群的元数据.&lt;/li&gt;
&lt;li&gt;记录文件是怎么分块保存的.&lt;/li&gt;
&lt;li&gt;对内存和 I/O 进行集中管理.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总之就是一个 “老大” 的角色, 在 Hadoop 1.x 中, NameNode 是&lt;strong&gt;单点&lt;/strong&gt;的, 也就是说故障后则整个集群崩溃, 就算有 Secondary NameNode 做为替补, 但也要人工操作, 不能自动替换 (听说在 Hadoop 2.x 中已经支持自动切换了, 暂时没接触过, 还不敢确定).&lt;/p&gt;
&lt;h2 id="42-secondary-namenode"&gt;4.2 Secondary NameNode&lt;/h2&gt;
&lt;p&gt;就是个 NameNode 的辅助程序, 或者说替补程序, 保存着 NameNode 元数据的快照, 当 NameNode 故障时, 可以用 Secondary NameNode 进行备用.&lt;/p&gt;
&lt;h2 id="43-datenode"&gt;4.3 DateNode&lt;/h2&gt;
&lt;p&gt;数据节点守护程序, 简单的说就是 HDFS 保存数据的地方.&lt;/p&gt;
&lt;h2 id="44-jobtracker"&gt;4.4 JobTracker&lt;/h2&gt;
&lt;p&gt;位于 Master 上, 是MR 作业主处理程序, 负责拆分、映射作业到 TaskTracker.&lt;/p&gt;
&lt;p&gt;同 NameNode 一样, 它也是个&lt;strong&gt;单点&lt;/strong&gt;进程.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;仅为 Hadoop 1.x 上的概念, Hadoop 2.x 上用 ResourceManager 替代了.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="45-tasktracker"&gt;4.5 TaskTracker&lt;/h2&gt;
&lt;p&gt;位于 Slave 节点上, 管理各自的 Task.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;仅为 Hadoop 1.x 上的概念, Hadoop 2.x 上用 NodeManager 替代了.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id="5-cdh"&gt;5. CDH&lt;/h1&gt;
&lt;p&gt;Hadoop 是一套开源框架, 许多公司都推出了各自版本的 Hadoop, 也有一些公司则围绕 Hadoop 开发产品; 在 Hadoop 生态体系中, 规模最大、知名度最高的公司则是 Cloudera (简称 CDH), 类似 Ubuntu 和 Linux 的关系.&lt;/p&gt;
&lt;p&gt;后续会对 CDH 进行单独的介绍, 这里仅为了解下是什么就可以了.&lt;/p&gt;</content><category term="大数据"></category></entry><entry><title>搭建 Hadoop 分布式实验环境</title><link href="http://www.smallcpp.cn/da-jian-hadoop-fen-bu-shi-shi-yan-huan-jing.html" rel="alternate"></link><published>2016-10-16T11:42:00+08:00</published><updated>2016-10-16T11:42:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-10-16:/da-jian-hadoop-fen-bu-shi-shi-yan-huan-jing.html</id><summary type="html">&lt;p&gt;&lt;strong&gt;实验最终成品&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;宿主机: win7 64位, 16G&lt;/li&gt;
&lt;li&gt;虚拟化工具: VMware Workstation&lt;/li&gt;
&lt;li&gt;虚拟机系统: Ubuntu 32位, 1.5G, 20G, NAT&lt;/li&gt;
&lt;li&gt;主机名: smallcpp01 (NameNode), smallcpp02 (Datanode), smallcpp03 (Datanode)&lt;/li&gt;
&lt;li&gt;Java 版本: jdk-8u101-linux-i586&lt;/li&gt;
&lt;li&gt;Hadoop 版本: hadoop-2.7.3 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;&lt;strong&gt;实验最终成品&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;宿主机: win7 64位, 16G&lt;/li&gt;
&lt;li&gt;虚拟化工具: VMware Workstation&lt;/li&gt;
&lt;li&gt;虚拟机系统: Ubuntu 32位, 1.5G, 20G, NAT&lt;/li&gt;
&lt;li&gt;主机名: smallcpp01 (NameNode), smallcpp02 (Datanode), smallcpp03 (Datanode)&lt;/li&gt;
&lt;li&gt;Java 版本: jdk-8u101-linux-i586&lt;/li&gt;
&lt;li&gt;Hadoop 版本: hadoop-2.7.3&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于虚拟机的网络模式解释下, 推荐的是使用&lt;strong&gt;桥接&lt;/strong&gt;模式, 因为桥接模式可以让虚拟机和宿主机处于同一网段, 而 &lt;strong&gt;NAT&lt;/strong&gt; 模式则是虚拟机单独分配一个网段;
然而我实验时发现&lt;strong&gt;桥接&lt;/strong&gt;模式虚拟机能 ping 通局域网内所有其他 ip 及外网 ip, 但就是不能和宿主机互 ping, 搞了好久没搞定, 万般无奈选择了 &lt;strong&gt;NAT&lt;/strong&gt; 模式.&lt;/p&gt;
&lt;p&gt;虚拟机的安装参考另一篇 wiki: &lt;a href="http://www.smallcpp.cn/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/VMware%20%E5%AE%89%E8%A3%85%20Ubuntu.html"&gt;使用 VMware 安装 Ubuntu  、VM Tools 和 Fcitx 输入法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装好后虚拟机后, 开始搭建 Hadoop 分布式实验环境.&lt;/p&gt;

&lt;h1 id="1-iphosts-iptables"&gt;1. 固定 IP、主机名、Hosts 和 iptables&lt;/h1&gt;
&lt;h2 id="ip"&gt;固定 IP&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;sudo vim /etc/network/interfaces&lt;/strong&gt;, 编辑 interfaces 文件, 这是 Ubuntu 网上配置文件.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;auto lo
iface lo inet loopback

auto eth0
iface eth0 inet static
address 192.168.31.200
netmask 255.255.255.0
gateway 192.168.31.2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;初始文件只有前面两行, 后面的是要添加的内容.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第 &lt;strong&gt;1&lt;/strong&gt; 行跟第 &lt;strong&gt;4&lt;/strong&gt; 行说明 &lt;code&gt;lo&lt;/code&gt; 接口跟 &lt;code&gt;eth0&lt;/code&gt; 接口会在系统启动时被自动配置;&lt;/li&gt;
&lt;li&gt;第 &lt;strong&gt;2&lt;/strong&gt; 行将 &lt;code&gt;lo&lt;/code&gt; 接口设置为一个本地回环 (loopback) 地址;&lt;/li&gt;
&lt;li&gt;第 &lt;strong&gt;5&lt;/strong&gt; 行指出 &lt;code&gt;eth0&lt;/code&gt; 接口具有一个静态的 (static) IP 配置;&lt;/li&gt;
&lt;li&gt;第 &lt;strong&gt;6&lt;/strong&gt; 行-第 &lt;strong&gt;8&lt;/strong&gt; 行分别设置 &lt;code&gt;eth0&lt;/code&gt; 接口的 ip、掩码和网关.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是需要注意, 并不所有的都是 &lt;code&gt;eth0&lt;/code&gt;, 采用的 Ubuntu 版本不同, 也有可能是其他的接口, 如 &lt;code&gt;ens32&lt;/code&gt;; 可以先使用 &lt;code&gt;ifconfig&lt;/code&gt; 看下系统使用的是哪个接口.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/搭建Hadoop分布式实验环境/ifconfig.png"/&gt;&lt;/p&gt;
&lt;p&gt;另外就是 &lt;strong&gt;gateway&lt;/strong&gt; (网关), 虚拟机的网关可以通过虚拟网络编辑器查看.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/搭建Hadoop分布式实验环境/虚拟网络编辑器.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/搭建Hadoop分布式实验环境/NAT.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/搭建Hadoop分布式实验环境/gateway.png"/&gt;&lt;/p&gt;
&lt;p&gt;所以上面的第八行的 &lt;strong&gt;gateway&lt;/strong&gt; 要填: &lt;code&gt;192.168.142.2&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="dns"&gt;DNS&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;sudo vim /etc/resolv.conf&lt;/strong&gt;, 编辑 DNS 解析文件.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;nameserver 8.8.8.8
nameserver 8.8.4.4
nameserver 192.168.31.2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第 3 行填 &lt;strong&gt;gateway&lt;/strong&gt; (网关) ip;&lt;/p&gt;
&lt;p&gt;改完上面, 如果重启的话, DNS 还是会变为原来的样子;&lt;/p&gt;
&lt;p&gt;网上给出的方法是执行 &lt;code&gt;sudo vim /etc/resolvconf/resolv.conf.d/base&lt;/code&gt; 输入和 DNS 解析文件相同的内容.&lt;/p&gt;
&lt;p&gt;实际操作后重启发现好像并没生效, 又找到了另一个方法, 执行 &lt;code&gt;sudo vim /etc/resolvconf/resolv.conf.d/tail&lt;/code&gt; 输入和 DNS 解析文件相同的内容.&lt;/p&gt;
&lt;p&gt;最后, 通过 &lt;code&gt;sudo resolvconf -u&lt;/code&gt; 刷新 &lt;strong&gt;resolv.conf&lt;/strong&gt; 文件, 再用 &lt;code&gt;sudo /etc/init.d/networking restart&lt;/code&gt; 重启网络.&lt;/p&gt;
&lt;h2 id="hosts"&gt;Hosts&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;sudo vim /etc/hostname&lt;/code&gt; 修改主机名为 smallcpp01 (另外两台分别用 smallcpp02 和 smallcpp03).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo vim /etc/hosts&lt;/code&gt; 修改 [ip 域名] 对应表.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;127.0.0.1       localhost
192.168.31.200  smallcpp01
192.168.31.201  smallcpp02
192.168.31.201  smallcpp03
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="_1"&gt;关闭防火墙&lt;/h2&gt;
&lt;p&gt;iptables 是 linux 下一个简单实用的防火墙组件.&lt;/p&gt;
&lt;p&gt;先用 &lt;code&gt;sudo ufw status&lt;/code&gt; 查看防火墙状态, 如果是启用的, 就用 &lt;code&gt;sudo ufw disable&lt;/code&gt; 关闭它.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Ubuntu 默认不安装 selinux&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;都设置好后, &lt;code&gt;reboot&lt;/code&gt; 重启系统, &lt;code&gt;ifconfig&lt;/code&gt; 查看 ip 是否变为我们设置的, &lt;code&gt;hostname&lt;/code&gt; 查看主机名.&lt;/p&gt;
&lt;h1 id="2-jdk"&gt;2. 安装 JDK&lt;/h1&gt;
&lt;h2 id="21"&gt;2.1&lt;/h2&gt;
&lt;p&gt;访问 oracle 官网: &lt;a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html"&gt;http://www.oracle.com/technetwork/java/javase/downloads/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我这里选择的是最新的 &lt;code&gt;jdk-8u101-linux-i586&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;下载好后, 弄到 Ubuntu 里解压, 然后在 &lt;code&gt;usr&lt;/code&gt; 目录下新建一个 &lt;code&gt;java&lt;/code&gt; 目录, 把解压好的文件复制进去.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;sudo mkdir /usr/java
sudo mv 桌面/jdk1.8.0_101/ /usr/java/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者可以先 &lt;code&gt;sudo mkdir /usr/java&lt;/code&gt; 创建好目录, 再用 &lt;code&gt;sudo tar -zxvf jdk-8u101-linux-i586.tar.gz -C /usr/java&lt;/code&gt; (-z 处理 gzip, x 解压, v 显示详情, f 解压哪个文件) 直接解压到 &lt;code&gt;/usr/java&lt;/code&gt; 下.&lt;/p&gt;
&lt;h2 id="22"&gt;2.2&lt;/h2&gt;
&lt;p&gt;修改环境变量.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vim ~/.bashrc&lt;/code&gt; 打开 VIM 编辑器后, 翻到最后一行, 在后面添加:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;export JAVA_HOME=/usr/java/jdk1.8.0_101
export PATH=$PATH:$JAVA_HOME/bin
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意, “=” 左右两边不能有空格; 最后刷新下文件.&lt;/p&gt;
&lt;h2 id="23"&gt;2.3&lt;/h2&gt;
&lt;p&gt;刷新环境变量.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;source ~/.bashrc
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时, 不管在哪个目录输入 &lt;code&gt;java -version&lt;/code&gt; 都可以找到执行文件.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/搭建Hadoop分布式实验环境/javaversion.png"/&gt;&lt;/p&gt;
&lt;h1 id="3-hadoop"&gt;3. 安装 Hadoop&lt;/h1&gt;
&lt;h2 id="31"&gt;3.1&lt;/h2&gt;
&lt;p&gt;访问: &lt;a href="http://archive.apache.org/dist/"&gt;http://archive.apache.org/dist/&lt;/a&gt;, apache 的所有项目都在这里.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i61.tinypic.com/29ustjt.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i60.tinypic.com/33xy72x.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i58.tinypic.com/2nuon4o.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/搭建Hadoop分布式实验环境/hadoopdown.png"/&gt;&lt;/p&gt;
&lt;p&gt;下载完成后, 拖到 Ubuntu 桌面.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo mkdir /usr/smallcpp&lt;/code&gt; 创建一个文件夹.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cd ~/桌面&lt;/code&gt;, 进入桌面目录.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo tar -zxvf hadoop-2.7.3.tar.gz -C /usr/smallcpp&lt;/code&gt; (-z 处理 gzip, x 解压, v 显示详情, f 解压哪个文件)&lt;/p&gt;
&lt;p&gt;为避免权限问题, 可将 &lt;code&gt;/usr/smallcpp/hadoop-2.7.3/&lt;/code&gt; 目录权限改为 &lt;strong&gt;777&lt;/strong&gt;: &lt;code&gt;sudo chmod -R 777 /usr/smallcpp/hadoop-2.7.3/&lt;/code&gt;&lt;/p&gt;
&lt;h2 id="32"&gt;3.2&lt;/h2&gt;
&lt;p&gt;修改环境变量.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vim ~/.bashrc&lt;/code&gt;&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;export JAVA_HOME=/usr/java/jdk1.8.0_101
export HADOOP_HOME=/usr/smallcpp/hadoop-2.7.3
export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="33"&gt;3.3&lt;/h2&gt;
&lt;p&gt;刷新环境变量.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;source ~/.bashrc&lt;/code&gt; 退回根目录, 测试下 hadoop 命令: &lt;code&gt;hadoop version&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/搭建Hadoop分布式实验环境/hadoopversion.png"/&gt;&lt;/p&gt;
&lt;h1 id="4-hadoop"&gt;4. 配置 Hadoop&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;cd /usr/smallcpp/hadoop-2.7.3/etc/hadoop&lt;/code&gt; 进入 Hadoop 配置文件所在目录.&lt;/p&gt;
&lt;h2 id="41-vim-hadoop-envsh"&gt;4.1. vim hadoop-env.sh&lt;/h2&gt;
&lt;p&gt;定位到 26 行左右, 找到&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;export JAVA_HOME=${JAVA_HOME}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;改成:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;export JAVA_HOME=/usr/java/jdk1.8.0_101 (可以在 vim 的命令模式下, 通过 echo $JAVA_HOME 查看路径)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="42-vim-core-sitexml"&gt;4.2. vim core-site.xml&lt;/h2&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;property&amp;gt;&lt;/span&gt;
        &lt;span style="color: #228B22"&gt;&amp;lt;!--用来指定 HDFS 的老大(NameNode)的地址--&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;fs.defaultFS&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
                &lt;span style="color: #228B22"&gt;&amp;lt;!--smallcpp01 是这台主机名, 要在 hosts 里设置了映射才可以, 不然只能写 ip--&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;value&amp;gt;&lt;/span&gt;hdfs://smallcpp01:9000&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;

        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;property&amp;gt;&lt;/span&gt;
        &lt;span style="color: #228B22"&gt;&amp;lt;!--用来指定 hadoop 运行时产生文件的存放目录--&amp;gt;&lt;/span&gt;
        &lt;span style="color: #228B22"&gt;&amp;lt;!--默认为系统目录, 重启会被清空, 导致重启 hadoop 不能用--&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;hadoop.tmp.dir&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;value&amp;gt;&lt;/span&gt;/usr/smallcpp/hadoop-2.7.3/tmp&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="43-vim-hdfs-sitexml"&gt;4.3. vim hdfs-site.xml&lt;/h2&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;property&amp;gt;&lt;/span&gt;
        &lt;span style="color: #228B22"&gt;&amp;lt;!--指定 HDFS 保存数据的副本个数, 一般最大为 3 就差不多了--&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;dfs.replication&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;value&amp;gt;&lt;/span&gt;2&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;property&amp;gt;&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;&amp;lt;!--指定元数据保存目录--&amp;gt;&lt;/span&gt;
             &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;dfs.namenode.name.dir&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
             &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;value&amp;gt;&lt;/span&gt;/usr/smallcpp/hadoop-2.7.3/tmp/dfs/name&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;property&amp;gt;&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;&amp;lt;!--指定 HDFS 保存数据目录--&amp;gt;&lt;/span&gt;
             &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;dfs.datanode.data.dir&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
             &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;value&amp;gt;&lt;/span&gt;/usr/smallcpp/hadoop-2.7.3/tmp/dfs/data&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们这里有 smallcpp02 和 smallcpp03 两台数据节点, 所以 &lt;code&gt;dfs.replication&lt;/code&gt; 为 2, 如果是伪分布式系统的话, 这里改为 1 就可以了.&lt;/p&gt;
&lt;h2 id="44-vim-yarn-envsh"&gt;4.4. vim yarn-env.sh&lt;/h2&gt;
&lt;p&gt;定位到 23 行左右, 找到 JAVA_HOME, 改为 &lt;code&gt;export JAVA_HOME=/usr/java/jdk1.8.0_101&lt;/code&gt;&lt;/p&gt;
&lt;h2 id="45-vim-yarn-sitexml"&gt;4.5. vim yarn-site.xml&lt;/h2&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;property&amp;gt;&lt;/span&gt;
            &lt;span style="color: #228B22"&gt;&amp;lt;!--NodeManager 获取数据的方式是shuffle--&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;yarn.nodemanager.aux-services&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;value&amp;gt;&lt;/span&gt;mapreduce_shuffle&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;property&amp;gt;&lt;/span&gt;
            &lt;span style="color: #228B22"&gt;&amp;lt;!--指定 YARN 的老大(ResourceManager 它负责资源的调度、分配)的地址--&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;yarn.resourcemanager.hostname&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;value&amp;gt;&lt;/span&gt;smallcpp01&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="46-mapred-sitexml"&gt;4.6. mapred-site.xml&lt;/h2&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;cp mapred-site.xml.template mapred-site.xml
vim mapred-site.xml
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;property&amp;gt;&lt;/span&gt;
        &lt;span style="color: #228B22"&gt;&amp;lt;!--告诉 Hadoop MR 要运行在 yarn 上--&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;mapreduce.framework.name&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;value&amp;gt;&lt;/span&gt;yarn&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;property&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;mapreduce.jobhistory.address&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;value&amp;gt;&lt;/span&gt;smallcpp01:10020&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;property&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;name&amp;gt;&lt;/span&gt;mapreduce.jobhistory.webapp.address&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;value&amp;gt;&lt;/span&gt;smallcpp01:19888&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="47-vim-slaves"&gt;4.7. vim slaves&lt;/h2&gt;
&lt;p&gt;如果是伪分布式环境, 不需要配这个环节.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vim slaves&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;打开后去掉第一行的 localhost, 将数据节点的域名添加进来&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;smallcpp02
smallcpp03
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;, 数据节点的域名要在 Hosts 文件中解析了才行!&lt;/p&gt;
&lt;h2 id="48"&gt;4.8. 克隆虚拟机&lt;/h2&gt;
&lt;p&gt;关闭当前虚拟机后, 从当前虚拟机上克隆两份.&lt;/p&gt;
&lt;p&gt;修改克隆出来的虚拟机的&lt;strong&gt;固定 IP&lt;strong&gt;&lt;em&gt;*、主机名&lt;/em&gt;* 和 &lt;/strong&gt;Hosts&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo vim /etc/network/interfaces&lt;/code&gt; 修改固定 IP&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo vim /etc/hostname&lt;/code&gt; 修改主机名.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo vim /etc/hosts&lt;/code&gt; 修改 [ip 域名] 对应表.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;127.0.0.1       localhost
192.168.31.200  smallcpp01
192.168.31.201  smallcpp02
192.168.31.202  smallcpp03
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配好后重启, 在三台虚拟机间互 Ping 测试下.&lt;/p&gt;
&lt;h1 id="5-ssh"&gt;5. 配置 SSH 免密码登录&lt;/h1&gt;
&lt;p&gt;Ubuntu 默认并没有安装 &lt;strong&gt;ssh&lt;/strong&gt; 服务, 需要自己手动安装 &lt;strong&gt;openssh-server&lt;/strong&gt;, 可以通过 &lt;code&gt;ssh localhost&lt;/code&gt; 判断是否安装 ssh 服务; 如果没有安装则通过 &lt;code&gt;sudo apt-get install openssh-server&lt;/code&gt; 安装即可.&lt;/p&gt;
&lt;h2 id="51-smallcpp01"&gt;5.1. 配置 smallcpp01&lt;/h2&gt;
&lt;p&gt;在 smallcpp01 上安装好 &lt;strong&gt;ssh&lt;/strong&gt; 服务后.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cd ~&lt;/code&gt; 进入根目录&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ls -la&lt;/code&gt; 查看下当前目录文件, 可以看到有个隐藏的 &lt;code&gt;.ssh&lt;/code&gt; 文件夹 (如果没有自己新建个)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cd .ssh/&lt;/code&gt; 进入 &lt;code&gt;.ssh&lt;/code&gt; 目录, &lt;code&gt;ls&lt;/code&gt; 一下, 看看该目录下有没有 &lt;code&gt;id_rsa&lt;/code&gt;、&lt;code&gt;id_rsa.pub&lt;/code&gt; 两个文件, 如果没有, 就用 &lt;code&gt;ssh-keygen -t rsa&lt;/code&gt; 生成一对 (一路回车就好).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cp id_rsa.pub authorized_keys&lt;/code&gt;&lt;/p&gt;
&lt;h2 id="52-smallcpp02-smallcpp03"&gt;5.2. 配置 smallcpp02 和 smallcpp03&lt;/h2&gt;
&lt;p&gt;首先也是先安装好 &lt;strong&gt;ssh&lt;/strong&gt; 服务生成一对 &lt;code&gt;id_rsa&lt;/code&gt;、&lt;code&gt;id_rsa.pub&lt;/code&gt; 文件;&lt;/p&gt;
&lt;p&gt;然后&lt;strong&gt;不要&lt;/strong&gt;执行 &lt;code&gt;cp id_rsa.pub authorized_keys&lt;/code&gt;, 而是执行 &lt;code&gt;ssh-copy-id -i ~/.ssh/id_rsa.pub hanxiao@smallcpp01&lt;/code&gt; 将公钥追加到 &lt;strong&gt;smallcpp01&lt;/strong&gt; 的 &lt;strong&gt;authorized_keys&lt;/strong&gt; 中.&lt;/p&gt;
&lt;p&gt;操作好后到 smallcpp01 中 &lt;code&gt;vim authorized_keys&lt;/code&gt; 可以看到里面已经多出了 smallcpp02 和 smallcpp03 的公钥了.&lt;/p&gt;
&lt;p&gt;最后将 &lt;strong&gt;authorized_keys&lt;/strong&gt; 远程拷贝到 smallcpp02 和 smallcpp03 中.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;scp authorized_keys hanxiao@smallcpp02:/home/hanxiao/.ssh/authorized_keys
scp authorized_keys hanxiao@smallcpp03:/home/hanxiao/.ssh/authorized_keys
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="6"&gt;6. 启动集群&lt;/h1&gt;
&lt;p&gt;首次启动需要先在 NameNode 节点 (smallcpp01) 执行 NameNode 的格式化:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;hdfs namenode -format       # 首次运行需要执行初始化，之后不需要
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;格式化成功后就可以通过以下命令启动集群了:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;./start-dfs.sh
./start-yarn.sh
./mr-jobhistory-daemon.sh start historyserver
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;./start-all.sh
./mr-jobhistory-daemon.sh start historyserver
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;集群成功启动后可以在终端用 &lt;code&gt;JPS&lt;/code&gt; 查看当前有哪些 Java 进程, NameNode 节点上应该有以下进程:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;NameNode
SecondaryNameNode
ResourceManager
JobHistoryServer
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而 DataNode 上应该有以下进程:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;DataNode
NodeManager
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;停止集群命令如下:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;stop-yarn.sh
stop-dfs.sh
mr-jobhistory-daemon.sh stop historyserver
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;stop-all.sh
mr-jobhistory-daemon.sh stop historyserver
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还可以通过 &lt;code&gt;hdfs dfsadmin -report&lt;/code&gt; 来查看所有 DataNode 的信息.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/搭建Hadoop分布式实验环境/dfsadmin.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Live datanodes&lt;/strong&gt; 表示当前集群有几个 DataNode 在运行.&lt;/p&gt;
&lt;h1 id="7"&gt;7. 测试集群&lt;/h1&gt;
&lt;p&gt;集群启动成功后会提供 Web 界面来管理集群.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://smallcpp01:50070"&gt;smallcpp01:50070&lt;/a&gt; -- hdfs 管理界面&lt;/li&gt;
&lt;li&gt;&lt;a href="http://smallcpp01:8088"&gt;smallcpp01:8088&lt;/a&gt; -- yarn 管理界面&lt;/li&gt;
&lt;li&gt;&lt;a href="http://smallcpp01:19888"&gt;smallcpp01:19888&lt;/a&gt; -- jobhistory 管理界面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;hdfs 管理界面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i61.tinypic.com/10fcr2s.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;hadoop fs -ls /
hdfs://smallcpp01:9000&lt;/p&gt;
&lt;h2 id="71"&gt;7.1. 上传文件&lt;/h2&gt;
&lt;p&gt;在 smallcpp01 (不一定是 smallcpp01, 可以集群中的任意一台进行测试) 的桌面上准备了一份大文件, 如 &lt;code&gt;ubuntu-16.04-desktop-amd64.iso&lt;/code&gt;, 现在把它上传到 Hadoop 的 HDFS 文件系统上去.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hadoop fs -put /home/hanxiao/桌面/ubuntu-16.04-desktop-amd64.iso hdfs://smallcpp01:9000/ubuntu-amd64.iso&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;上传文件到 &lt;code&gt;hdfs://smallcpp01:9000/&lt;/code&gt; 并命名为 &lt;code&gt;ubuntu-amd64.iso&lt;/code&gt;; 同样功能的命令除了 &lt;code&gt;put&lt;/code&gt; 还有 &lt;code&gt;copyFromLocal&lt;/code&gt; (过时).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hdfs://smallcpp01:9000/&lt;/code&gt; 表示的是 HDFS 的&lt;strong&gt;根目录&lt;/strong&gt;, 可以简写成 &lt;code&gt;/&lt;/code&gt;, 如上面的上传文件命令可以写成这样:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hadoop fs -put /home/hanxiao/桌面/ubuntu-16.04-desktop-amd64.iso /ubuntu-amd64.iso&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Hadoop 的 &lt;strong&gt;HDFS&lt;/strong&gt; 系统使用起来就像是 Linux 的文件系统, 如 &lt;code&gt;hadoop fs -ls /&lt;/code&gt; 查看的就是 HDFS 根目录下的列表, 切不要将它们混淆了, HDFS 的根目录可不在 Linux 的根目录 (&lt;code&gt;/&lt;/code&gt;) 下, 是两套完全不同的体系.&lt;/p&gt;
&lt;p&gt;上传完毕后可以在 Web 界面的文件管理模块可以看到变化:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/搭建Hadoop分布式实验环境/hadoopfile.png"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/搭建Hadoop分布式实验环境/hadoopinfo.png"/&gt;&lt;/p&gt;
&lt;h2 id="72"&gt;7.2. 下载文件&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;hadoop fs -get /ubuntu-amd64.iso /home/hanxiao/桌面/ubuntu-amd64.iso&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;下载文件到 Linux 系统.&lt;/p&gt;
&lt;p&gt;执行命令的时候, 可能会出现提示: &lt;code&gt;WARN hdfs.DFSClient: DFSInputStream has been closed already&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;不用管它, apache 也给出了说明:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i61.tinypic.com/344ql4k.jpg"/&gt;&lt;/p&gt;
&lt;h2 id="73-mr"&gt;7.3. 测试 MR 作业&lt;/h2&gt;
&lt;p&gt;MR 使用 Java 进行开发, Hadoop 预置了一些测试 MR 作业 (就是一些 jar 包), 它们在: &lt;code&gt;/usr/smallcpp/hadoop-2.7.3/share/hadoop/mapreduce&lt;/code&gt; 目录下.&lt;/p&gt;
&lt;p&gt;创建一个文件 &lt;code&gt;vim words.txt&lt;/code&gt;, 输入内容:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;hello tom
hello jerry
hello kitty
hello world
hello hanxiao
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所有的 MR 都是执行在 &lt;strong&gt;hdfs&lt;/strong&gt; 上的, 所以要先上传文件: &lt;code&gt;hadoop fs -put words.txt /words.txt&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/usr/smallcpp/hadoop-2.7.3/share/hadoop/mapreduce&lt;/code&gt; 目录下有个 &lt;code&gt;hadoop-mapreduce-examples-2.7.3.jar&lt;/code&gt;, 里面有个 &lt;code&gt;wordcount&lt;/code&gt; 方法, 可以用来统计单词个数.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;cd /usr/smallcpp/hadoop-2.7.3/share/hadoop/mapreduce
hadoop jar hadoop-mapreduce-examples-2.7.3.jar wordcount /words.txt /result
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个参数是待统计文件, 第二个参数是保存结果的目录.&lt;/p&gt;
&lt;p&gt;执行完毕后, 查看下 hdfs 系统: &lt;code&gt;hadoop fs -ls /&lt;/code&gt;&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;Found 4 items
drwxr-xr-x   - hanxiao supergroup          0 2016-10-16 21:33 /result
drwxrwx---   - hanxiao supergroup          0 2016-10-16 20:27 /tmp
-rw-r--r--   2 hanxiao supergroup 1485881344 2016-10-16 21:01 /ubuntu-amd64.iso
-rw-r--r--   2 hanxiao supergroup         59 2016-10-16 21:30 /words.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;/result&lt;/code&gt; 就是刚生成的结果目录, 用 &lt;code&gt;hadoop fs -ls /result&lt;/code&gt; 查看下里面的内容:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;Found 2 items
-rw-r--r--   2 hanxiao supergroup          0 2016-10-16 21:36 /result/_SUCCESS
-rw-r--r--   2 hanxiao supergroup         47 2016-10-16 21:36 /result/part-r-00000
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 &lt;code&gt;_SUCCESS&lt;/code&gt; 表示 MR 作业执行成功, &lt;code&gt;part-r-00000&lt;/code&gt; 为结果文件, 用 &lt;code&gt;hadoop fs -cat /result/part-r-00000&lt;/code&gt; 查看下:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;hello   5
jerry   1
kitty   1
hanxiao  1
tom     1
world   1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然也可以直接通过 Web 查看.&lt;/p&gt;
&lt;h1 id="references"&gt;References&lt;/h1&gt;
&lt;p&gt;&lt;a href="http://www.powerxing.com/install-hadoop/"&gt;Hadoop 安装教程_单机/伪分布式配置_Hadoop2.6.0/Ubuntu14.04&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.powerxing.com/install-hadoop-cluster/"&gt;Hadoop 集群安装配置教程_Hadoop2.6.0/Ubuntu14.04&lt;/a&gt;&lt;/p&gt;</content><category term="大数据"></category></entry><entry><title>VMware 安装 Ubuntu</title><link href="http://www.smallcpp.cn/vmware-an-zhuang-ubuntu.html" rel="alternate"></link><published>2016-10-16T03:04:00+08:00</published><updated>2016-10-16T03:04:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-10-16:/vmware-an-zhuang-ubuntu.html</id><summary type="html">
&lt;h1 id="_1"&gt;安装系统&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;宿主机: win7 64位, 16G&lt;/li&gt;
&lt;li&gt;虚拟机系统: Ubuntu 32位&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;1. 创建新的虚拟机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i59.tinypic.com/2jff68n.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 使用自定义模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i60.tinypic.com/315ohh1.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 下一步直到选择安装源&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i58.tinypic.com/33vp5af.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 选择操作系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i62.tinypic.com/2lw6dz9.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 设置虚拟机名称及安装路径&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i61.tinypic.com/t6e0c2.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6. 设置处理器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i60.tinypic.com/16gg5co.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7. 设置内存, 对于测试环境的 Linux (32 位) 来说, &lt;code&gt;1G&lt;/code&gt; 足够 (条件允许可以设置大一点 …&lt;/strong&gt;&lt;/p&gt;</summary><content type="html">
&lt;h1 id="_1"&gt;安装系统&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;宿主机: win7 64位, 16G&lt;/li&gt;
&lt;li&gt;虚拟机系统: Ubuntu 32位&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;1. 创建新的虚拟机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i59.tinypic.com/2jff68n.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 使用自定义模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i60.tinypic.com/315ohh1.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 下一步直到选择安装源&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i58.tinypic.com/33vp5af.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 选择操作系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i62.tinypic.com/2lw6dz9.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 设置虚拟机名称及安装路径&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i61.tinypic.com/t6e0c2.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6. 设置处理器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i60.tinypic.com/16gg5co.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7. 设置内存, 对于测试环境的 Linux (32 位) 来说, &lt;code&gt;1G&lt;/code&gt; 足够 (条件允许可以设置大一点).&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i58.tinypic.com/16c2e6u.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8. 设置网络类型, 如果使用有线上网, 推荐 &lt;code&gt;NAT&lt;/code&gt;, 如果是无线的话, 推荐使用桥接.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i58.tinypic.com/2d0ayw4.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;9. 下面三步直接默认的就可以了.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i58.tinypic.com/34xjr52.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i57.tinypic.com/2rn7zeu.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i62.tinypic.com/5ufhnp.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;10. 设置磁盘, 使用默认的 &lt;code&gt;20G&lt;/code&gt; 足够了, 下面选择第一个单选框.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i60.tinypic.com/2w20m6q.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;11. 设置磁盘文件及完成创建, 都默认就可以了.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i58.tinypic.com/ol15l.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i60.tinypic.com/msit82.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;12. 点击编辑虚拟机设置.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i61.tinypic.com/2i7tvnb.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;13. 设置光盘镜像后点击确定.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i57.tinypic.com/33m7i3q.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;14. 点击开启此虚拟机.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i60.tinypic.com/5xsfgo.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;15. 等待虚拟机启动, 直到设置语言, 选择语言后点击安装 Ubuntu.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i62.tinypic.com/nc1209.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;16. 对于我们编程或测试来说下面两个不必要勾选, 直接点继续.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i60.tinypic.com/ergcxx.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;17. 选择最后一项, 我们将自定义分区设置.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i62.tinypic.com/2u6pbbd.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;18. 现在开始利用上一篇学到的东西开始定义我们的分区.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;18.1. 选中 &lt;code&gt;/dev/sda&lt;/code&gt; 后点击新建分区表…此时会弹出一个对话框, 直接确定就可以了.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i61.tinypic.com/1zlqiwg.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;18.2. 选中新出现的空闲, 再点击左下方的 &lt;code&gt;+&lt;/code&gt;.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i60.tinypic.com/j5e5xc.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;18.3. 下图中的 “主分区”，”空间起始位置”， “Ext4 …” 均为默认, 不需要修改; 大小设置为 &lt;code&gt;10240 MB = 10G&lt;/code&gt;; 最后的 “挂载点” 下拉列表中, 选中 “/”, 点 “确定”.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i62.tinypic.com/muv1nb.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;18.4. 同 &lt;code&gt;18.2&lt;/code&gt; 中一样&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i57.tinypic.com/2uy0v3t.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;18.5. 大小选为 &lt;code&gt;1024 MB = 1G&lt;/code&gt;, 用于下拉框选择交换空间 (即 swap). 这里我们没有用上一篇说过的 &lt;code&gt;2 倍&lt;/code&gt;, 因为是虚拟机测试环境, 所以选 &lt;code&gt;1G&lt;/code&gt; 就可以了.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i57.tinypic.com/20k4rr9.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;18.6. 同 18.2 中一样&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i61.tinypic.com/ivjml5.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;18.7. 大小设为 &lt;code&gt;200 MB&lt;/code&gt;, 挂载点选为 &lt;code&gt;/boot&lt;/code&gt;.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i62.tinypic.com/2ef25pi.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;18.8. 同 18.2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i62.tinypic.com/24e6vs7.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;18.9. 挂载点选为 &lt;code&gt;/home&lt;/code&gt;, 其它默认就可以了.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i60.tinypic.com/2chkjlu.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;18.10. 此时你的设置应该如下, 点现在安装即可.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i59.tinypic.com/2usfjw0.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;19. 下面的步骤默认就可以了, 不过要注意的是要记得设置的账号和密码.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i57.tinypic.com/9v89k4.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i57.tinypic.com/6gy1r7.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i59.tinypic.com/aljcaq.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i61.tinypic.com/23u6jpy.jpg"/&gt;&lt;/p&gt;
&lt;h1 id="vm-tools"&gt;安装 VM Tools&lt;/h1&gt;
&lt;p&gt;全部安装完成以后, 我们还需要安装 &lt;strong&gt;VM Tools&lt;/strong&gt; 来提高虚拟机使用性.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 先关闭虚拟机, 将 CD 设置成使用物理驱动器. 再启动虚拟机, 进入安装好的 Ubuntu 系统后, 选择虚拟机菜单栏 -- 安装 VMware tools.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i61.tinypic.com/29fw7tg.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i60.tinypic.com/2vxo9x0.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 在 Ubuntu 系统中弹出的 VMware tools 窗口中找到 &lt;code&gt;VMwaretools-9.6.0-1294478.tar.gz&lt;/code&gt; 复制到桌面.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i60.tinypic.com/25gdlia.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 复制完之后, 右键左侧栏的文件夹图标 -- 退出, 这时应该返回到桌面界面了. 在桌面上的 &lt;code&gt;VMwaretools-9.6.0-1294478.tar.gz&lt;/code&gt; 右击 提取到此处.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i60.tinypic.com/2vwfbzo.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 此时桌面就多了一个 &lt;code&gt;vmware-tools-distrib&lt;/code&gt; 的文件夹, 按 &lt;code&gt;CTRL+ALT+T&lt;/code&gt; 呼出终端. 为了以后方便, 此时可以在左侧栏的终端图标上右键 -- 锁定到启动器.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i60.tinypic.com/a0h0so.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 在弹出的终端窗里输入 &lt;code&gt;sudo su&lt;/code&gt; 进入 “超级用户”模式, 此时它会要求输入密码, 输入即可, 要注意, 在终端输入密码是不会显示的, 输完后直接确定就可以了.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i62.tinypic.com/21oo66b.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6. 输入 &lt;code&gt;ls&lt;/code&gt; 命令列出文件夹里的文件, 然后进入 使用 &lt;code&gt;cd&lt;/code&gt; 桌面 命令进入桌面文件夹.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i61.tinypic.com/jgtq9t.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7. 输入 &lt;code&gt;ls&lt;/code&gt; 命令列出桌面上的文件, 然后进入 使用 &lt;code&gt;cd&lt;/code&gt; 命令进入刚才解压出来的文件夹.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(小技巧, 因为 &lt;code&gt;vmware-tools-distrib&lt;/code&gt; 名字很长, 可以输入名字的几个字母后按 &lt;code&gt;tab&lt;/code&gt; 键, 终端会自动补全; 当然也可以在 &lt;code&gt;ls&lt;/code&gt; 显示出来的结果上直接复制然后粘贴.)&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i57.tinypic.com/20ayo0l.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8. 进入 &lt;code&gt;vmware-tools-distrib&lt;/code&gt; 后, 使用 &lt;code&gt;sudo ./ vmware-install.pl&lt;/code&gt; 命令安装 VM Tools. 然后一堆的 &lt;code&gt;enter&lt;/code&gt;、 &lt;code&gt;y&lt;/code&gt;、 &lt;code&gt;n&lt;/code&gt; 要按.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i58.tinypic.com/5uo8dl.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;安装完后要重启才能生效, 不过我们先别急着重启, Ubuntu 自带的 &lt;strong&gt;iBus&lt;/strong&gt; 输入法太难用了, &lt;strong&gt;Fcitx&lt;/strong&gt; 才是当之无愧的最好的中文输入法 (框架). 现在我们来安装它.&lt;/p&gt;
&lt;h1 id="fcitx"&gt;安装 Fcitx&lt;/h1&gt;
&lt;p&gt;Ubuntu 16 后已自带 Fcitx, 但是没有&lt;strong&gt;五笔&lt;/strong&gt;, 需要额外执行 &lt;code&gt;sudo apt-get install fcitx-table-wubi&lt;/code&gt; 安装下就行了.&lt;/p&gt;
&lt;p&gt;Ubuntu 16 以前参考下面的步骤.&lt;/p&gt;
&lt;p&gt;在终端输入 &lt;code&gt;sudo apt-get install fcitx-table-wbpy&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i62.tinypic.com/zisi6h.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;安装完成之后, 输入 &lt;code&gt;reboot&lt;/code&gt; 重启系统.&lt;/p&gt;
&lt;p&gt;重启系统过后, 首先拖动虚拟机大小看看屏幕能不能自适应, 如果可以的话说明 &lt;strong&gt;VM Tools&lt;/strong&gt; 安装好了.&lt;/p&gt;
&lt;p&gt;接下来看看刚安装好的输入法.&lt;/p&gt;
&lt;p&gt;首先打开语言设置.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i58.tinypic.com/2m7vo.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;在 &lt;em&gt;键盘输入方式系统&lt;/em&gt; 处可以看到已经变成 &lt;strong&gt;fcitx&lt;/strong&gt; 了, 如果不是的话, 手动选择下再重启.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i60.tinypic.com/wsv1pd.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;此时, 你的系统应该有双拼、拼音、五笔拼音等乱七八糟的输入法. 如果只需要一个五笔拼音就够了, 可以从 Ubuntu 右上角顶栏的小键盘图标中打开配置，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i59.tinypic.com/11ljxie.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;然后在桌面新建一个文本文档测试下新输入法, 是不是感觉棒棒哒..&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i62.tinypic.com/349citu.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;Ubuntu 还有很多不错的软件工具可以使用, 可以到 &lt;a href="http://wiki.ubuntu.org.cn/Qref/Apps"&gt;http://wiki.ubuntu.org.cn/Qref/Apps&lt;/a&gt; 自己找~&lt;/p&gt;
&lt;p&gt;看到合适的心仪的工具后, 直接点右侧的安装就可以了(当然这必须在 Ubuntu 里的浏览器上操作, 在 Windows 下可不行).&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i60.tinypic.com/10n85s9.jpg"/&gt;&lt;/p&gt;</content><category term="工具折腾"></category></entry><entry><title>vector、deque、list 三者的区别</title><link href="http://www.smallcpp.cn/vector-deque-list-san-zhe-de-qu-bie.html" rel="alternate"></link><published>2016-10-10T14:37:00+08:00</published><updated>2016-10-10T14:37:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-10-10:/vector-deque-list-san-zhe-de-qu-bie.html</id><summary type="html">
&lt;p&gt;stl 提供了三个最基本的容器: vector, list, deque.&lt;/p&gt;
&lt;h1 id="vector"&gt;vector&lt;/h1&gt;
&lt;p&gt;vector 为存储的对象分配一块连续的地址空间, 因此对 vector 中的元素随机访问效率很高.&lt;/p&gt;
&lt;p&gt;在 vecotor 中插入或者删除某个元素, 需要将现有元素进行复制, 移动. 如果 vector 中存储的对象很大, 或者构造函数复杂, 则在对现有元素进行拷贝时开销较大, 因为拷贝对象要调用拷贝构造函数. 对于简单的小对象, vector 的效率优于 list.&lt;/p&gt;
&lt;p&gt;vector 在每次扩张容量的时候, 将容量扩展 2 …&lt;/p&gt;</summary><content type="html">
&lt;p&gt;stl 提供了三个最基本的容器: vector, list, deque.&lt;/p&gt;
&lt;h1 id="vector"&gt;vector&lt;/h1&gt;
&lt;p&gt;vector 为存储的对象分配一块连续的地址空间, 因此对 vector 中的元素随机访问效率很高.&lt;/p&gt;
&lt;p&gt;在 vecotor 中插入或者删除某个元素, 需要将现有元素进行复制, 移动. 如果 vector 中存储的对象很大, 或者构造函数复杂, 则在对现有元素进行拷贝时开销较大, 因为拷贝对象要调用拷贝构造函数. 对于简单的小对象, vector 的效率优于 list.&lt;/p&gt;
&lt;p&gt;vector 在每次扩张容量的时候, 将容量扩展 2 倍, 这样对于小对象来说, 效率是很高的.&lt;/p&gt;
&lt;h1 id="list"&gt;list&lt;/h1&gt;
&lt;p&gt;list 就是数据结构中的双向链表 (根据 sgi stl 源代码), 因此它的内存空间可以是不连续的, 通过指针来进行数据的访问, 这个特点使得它的随即存取变的非常&lt;strong&gt;没有&lt;/strong&gt;效率, 因此它
没有提供 &lt;code&gt;[ ]&lt;/code&gt; 操作符的重载; 但由于链表的特点, 它可以以很好的效率支持任意地方的删除和插入.&lt;/p&gt;
&lt;p&gt;就 Vector 和 List 而言:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vector&lt;/code&gt; 适用: 对象数量变化少, 简单对象, 随机访问元素频繁&lt;/li&gt;
&lt;li&gt;&lt;code&gt;list&lt;/code&gt; 适用: 对象数量变化大, 对象复杂, 插入和删除频繁&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="deque"&gt;deque&lt;/h1&gt;
&lt;p&gt;deque 是一个双向队列, 它的具体实现不太清楚, 但知道它具有以下两个特点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它支持 &lt;code&gt;[ ]&lt;/code&gt; 操作符, 也就是支持随即存取, 并且和 vector 的效率相差无几&lt;/li&gt;
&lt;li&gt;它支持在两端的操作: &lt;code&gt;push_back&lt;/code&gt;, &lt;code&gt;push_front&lt;/code&gt;, &lt;code&gt;pop_back&lt;/code&gt;, &lt;code&gt;pop_front&lt;/code&gt; 等, 并且在两端操作上与 list 的效率也差不多.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此在实际使用时, 如何选择这三个容器中哪一个, 应根据你的需要而定, 一般应遵循下面的原则:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果你需要高效的随即存取, 而不在乎插入和删除的效率, 使用 vector&lt;/li&gt;
&lt;li&gt;如果你需要大量的插入和删除, 而不关心随即存取, 则应使用 list&lt;/li&gt;
&lt;li&gt;如果你需要随即存取, 而且关心两端数据的插入和删除, 则应使用 deque&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="_1"&gt;总结&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;vector 表示一段连续的内存区域, 每个元素被顺序存储在这段内存中, 对 vector 的随机访问效率很高, 但对非末尾元素的插入和删除则效率非常低.&lt;/li&gt;
&lt;li&gt;deque 也表示一段连续的内存区域, 但与 vector 不同的是它支持高效地在其首部插入和删除元素, 它通过两级数组结构来实现, 一级表示实际的容器, 第二级指向容器的首和尾.&lt;/li&gt;
&lt;li&gt;list 表示非连续的内存区域并通过一对指向首尾元素的指针双向链接起来, 插入删除效率高, 随机访问效率低.&lt;/li&gt;
&lt;/ul&gt;</content><category term="软件工程"></category></entry><entry><title>程序员的碎片知识管理</title><link href="http://www.smallcpp.cn/cheng-xu-yuan-de-sui-pian-zhi-shi-guan-li.html" rel="alternate"></link><published>2016-08-24T19:22:00+08:00</published><updated>2016-08-24T19:22:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-08-24:/cheng-xu-yuan-de-sui-pian-zhi-shi-guan-li.html</id><summary type="html">&lt;p&gt;面对信息量爆炸的时代, 做为一名程序员, 如何才能在诸多知识碎片中逆水行舟?&lt;/p&gt;</summary><content type="html">
&lt;h1 id="_1"&gt;一个悲惨的故事&lt;/h1&gt;
&lt;p&gt;公司里每天大量的邮件资讯, 手机里新闻客户端每天的资讯推送, 微信群里每天收到同事、朋友、家人分享的文章, 这么多的文章资讯哪里有时间消化完? 绝大多数人都对资讯的过载束手无策, 然后就选择浅阅读, 或者直接无视.&lt;/p&gt;
&lt;p&gt;在很久很久以前, 有一个程序猿, 他也遇到了这个问题, 于是每次他收到或者看到感兴趣的文章时就把它收集到笔记类软件中 (比如为知), 不感兴趣的文章则过滤掉;&lt;/p&gt;
&lt;p&gt;因为收集起来的文章仅仅是主题比较有兴趣而已, 文章的质量往往良莠不齐, 当他有时间了就会去笔记中”去粗存精”, 然后有一天, 他发现本来应该保存重要信息的笔记软件, 被一堆从来没有读过的文章塞满, 不但浪费珍贵的空间, 检索起来还会出来好多不相干的结果干扰, 所以, 他觉悟了. . .&lt;/p&gt;
&lt;p&gt;随着长时间的摸索改善, 现在他的碎片化知识收集流程是这样的:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i65.tinypic.com/jgt6o2.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;首先看一下他使用到的工具有哪些:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Inoreader (代替 Google Reader)&lt;/li&gt;
&lt;li&gt;IFTTT&lt;/li&gt;
&lt;li&gt;Diigo&lt;/li&gt;
&lt;li&gt;Pocket&lt;/li&gt;
&lt;li&gt;Wunderlist (中文名奇妙清单)&lt;/li&gt;
&lt;li&gt;wiki/blog&lt;/li&gt;
&lt;li&gt;为知笔记&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="inoreader"&gt;Inoreader&lt;/h1&gt;
&lt;p&gt;在线 RSS 评阅应用 (界面可设中文), RSS 的最大特点就是更新速度快, 它适合不做过多思考地对大量信息进行&lt;strong&gt;扫描式阅读&lt;/strong&gt;, 但并不适合对经过筛选留下来的有价值的信息进行更进一步理解.&lt;/p&gt;
&lt;p&gt;同时 RSS 也基本不具备对信息的整理和收集功能, 顶多就是加个星标, 如果连星标也不加, 过个两三天这条订阅基本就永远消失在数字洪流中了.&lt;/p&gt;
&lt;p&gt;对于 RSS 中稍微有点价值的、觉得日后可能会派上用场的内容, 一般会打个 “topocket” 标签, 配合 &lt;strong&gt;IFTTT&lt;/strong&gt; 向 &lt;strong&gt;Pocket&lt;/strong&gt; 发送文章, 然后定期到 Pocket 中进行简单的整理.&lt;/p&gt;
&lt;h1 id="pocket"&gt;Pocket&lt;/h1&gt;
&lt;p&gt;一款&lt;strong&gt;稍后阅读&lt;/strong&gt;应用, 它不是信息源, 是信息的中转站. 它似于信息消化系统中的”胃”，信息资讯进入到这里被临时储存、简单消化之后, 才进入后面的”保存”和”内化”过程.&lt;/p&gt;
&lt;p&gt;当通过 Inoreader 订阅了感兴趣的内容, 或者在微信及其它地方看到感兴趣的内容, 通过 IFTTT 或者手动将其添加到 Pocket;&lt;/p&gt;
&lt;p&gt;“在我们整理已收集的知识时, 无法拥有刚获得知识的新鲜感, 行动力会异常的脆弱, &lt;strong&gt;稍后阅读&lt;/strong&gt;常常会变成&lt;strong&gt;再也不读&lt;/strong&gt;”, 所以就需要某种提醒机制, 例如 &lt;strong&gt;Wunderlist&lt;/strong&gt; (奇妙清单) . . .&lt;/p&gt;
&lt;p&gt;另外, 要学会去&lt;strong&gt;设计框架&lt;/strong&gt;, 然后针对性的往里面塞东西, 例如闲逛时突然看到某种感兴趣的话题, 那就应该设计这个话题的框架, 但有可能现在还不想深入理解, 或者没时间深入了解, 就应该把它记在 &lt;strong&gt;Wunderlist&lt;/strong&gt; 中, 提示自己想要学习某类知识. ———— 也就是说从传统的来源导向型, 转变到&lt;strong&gt;目标导向&lt;/strong&gt;型 (即有目标的搜索相关知识).&lt;/p&gt;
&lt;h1 id="wikiblog"&gt;Wiki/Blog/为知&lt;/h1&gt;
&lt;p&gt;到这里, 就是我们最终碎片知识的旅途终点, 简简单单收录起来的文章始终是别人的, 只有经过自己转化、整理后才能真正形成自己的知识库.&lt;/p&gt;
&lt;p&gt;我觉得…一个程序猿, 理应有自己的 &lt;a href="http://www.smallcpp.cn/"&gt;Wiki/Blog&lt;/a&gt; 吧…&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;wiki/blog&lt;/strong&gt;: 存储技术类的知识 (至于为什么要分 wiki 和 blog? 参考 &lt;a href="http://blog.xiaohansong.com/2016/01/16/kownledge-Management/"&gt;程序员的知识管理&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;为知&lt;/strong&gt;: 存储行业、娱乐、生活等其它类知识&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;PS, 最新调整 -&amp;gt; &lt;a href="http://www.smallcpp.cn/qian-yi-onenote-shuo-ming.html"&gt;传送门, 迁移 OneNote 说明&lt;/a&gt;&lt;/p&gt;
&lt;h1 id="diigo"&gt;Diigo&lt;/h1&gt;
&lt;p&gt;上面没提到 &lt;strong&gt;Diigo&lt;/strong&gt;, 这是一款社区化的书签应用, 遇到感兴趣的贴吧、论坛、空间、社区等就收藏起来, 别问我为什么不用浏览器自带的书签功能, 我也不知道, 去用用 Diigo, 我相信你也会爱上它的…&lt;/p&gt;</content><category term="杂项"></category></entry><entry><title>玩转奇妙清单</title><link href="http://www.smallcpp.cn/wan-zhuan-qi-miao-qing-dan.html" rel="alternate"></link><published>2016-08-19T13:56:00+08:00</published><updated>2016-08-19T13:56:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-08-19:/wan-zhuan-qi-miao-qing-dan.html</id><summary type="html">&lt;p&gt;转自&lt;a href="http://sspai.com/tag/%E5%A5%87%E5%A6%99%E6%B8%85%E5%8D%95"&gt;少数派&lt;/a&gt;&lt;/p&gt;

&lt;h1 id="_1"&gt;添加待办事项&lt;/h1&gt;
&lt;p&gt;除了进入奇妙清单应用添加添加待办事项外, 这里列举了一些其他方法.&lt;/p&gt;
&lt;h2 id="_2"&gt;邮件添加&lt;/h2&gt;
&lt;p&gt;只需要用登录奇妙清单的邮箱账号作为&lt;strong&gt;发信人&lt;/strong&gt;, 向 &lt;code&gt;me@wunderlist.com&lt;/code&gt; 发送邮件, 就可以生成一条待办事项, 具体规则:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;邮件的标题会成为待办事项的名称&lt;/li&gt;
&lt;li&gt;邮件的正文内容会成为待办事项的备注&lt;/li&gt;
&lt;li&gt;所有生成的待办事项都被存放在&lt;code&gt;收件箱&lt;/code&gt;中&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_3"&gt;收件箱&lt;/h2&gt;
&lt;p&gt;奇妙清单上有一项默认的清单&lt;code&gt;收件箱&lt;/code&gt;, 这是一个随时储存灵感、临时想到的待办的地方, 一定要随时 check.&lt;/p&gt;
&lt;p&gt;通过邮件添加的待办事项也会放在&lt;code&gt;收件箱&lt;/code&gt;中 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;转自&lt;a href="http://sspai.com/tag/%E5%A5%87%E5%A6%99%E6%B8%85%E5%8D%95"&gt;少数派&lt;/a&gt;&lt;/p&gt;

&lt;h1 id="_1"&gt;添加待办事项&lt;/h1&gt;
&lt;p&gt;除了进入奇妙清单应用添加添加待办事项外, 这里列举了一些其他方法.&lt;/p&gt;
&lt;h2 id="_2"&gt;邮件添加&lt;/h2&gt;
&lt;p&gt;只需要用登录奇妙清单的邮箱账号作为&lt;strong&gt;发信人&lt;/strong&gt;, 向 &lt;code&gt;me@wunderlist.com&lt;/code&gt; 发送邮件, 就可以生成一条待办事项, 具体规则:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;邮件的标题会成为待办事项的名称&lt;/li&gt;
&lt;li&gt;邮件的正文内容会成为待办事项的备注&lt;/li&gt;
&lt;li&gt;所有生成的待办事项都被存放在&lt;code&gt;收件箱&lt;/code&gt;中&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_3"&gt;收件箱&lt;/h2&gt;
&lt;p&gt;奇妙清单上有一项默认的清单&lt;code&gt;收件箱&lt;/code&gt;, 这是一个随时储存灵感、临时想到的待办的地方, 一定要随时 check.&lt;/p&gt;
&lt;p&gt;通过邮件添加的待办事项也会放在&lt;code&gt;收件箱&lt;/code&gt;中.&lt;/p&gt;
&lt;h2 id="chrome"&gt;Chrome 添加&lt;/h2&gt;
&lt;h3 id="_4"&gt;在新标签页添加&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://chrome.google.com/webstore/detail/wunderlist-new-tab/fgikemaeelgbhjnhnnahcpkjpafaeion"&gt;Chrome 的新标签页扩展&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装了这个扩展之后, 任何时候有新的想法或事项需要记录, 只需要打开新标签页, 就可以直接添加和查看待办事项, 连背景都是和你的奇妙清单中同步的.&lt;/p&gt;
&lt;p&gt;目前, 扩展还比较简单, 仅仅只能选择将待办事项添加到哪个清单中, 以及查看清单中的所有待办事项, 暂时还不支持针对单项任务的截止日期、提醒等属性修改.&lt;/p&gt;
&lt;h3 id="_5"&gt;浏览网页添加&lt;/h3&gt;
&lt;p&gt;只需要为浏览器安装&lt;a href="https://chrome.google.com/webstore/detail/add-to-wunderlist/dmnddeddcgdllibmaodanoonljfdmooc?hl=en"&gt;&lt;code&gt;Add to Wunderlist&lt;/code&gt;&lt;/a&gt;的插件扩展, 就可以随时把任何网页收藏到自己的清单中, 并且可以智能识别 IMDB、Youtube、ebay、亚马逊等网页结构, 更智能的, 你甚至可以选中网页上的某一内容链接, 奇妙清单会自动将其作为事项的备注.&lt;/p&gt;
&lt;p&gt;用浏览器查看邮件时, &lt;code&gt;Add to Wunderlist&lt;/code&gt;也非常实用. 如果一封邮件需要标记为待办, 你可以直接存到奇妙清单中, 会自动根据邮件的标题和内容生成待办事项.&lt;/p&gt;
&lt;h2 id="android"&gt;Android 添加&lt;/h2&gt;
&lt;p&gt;奇妙清单有 Android 版本的 APP, 除了直接进入应用添加待办事项外还提供了桌面小插件, 不用进入 App, 直接在桌面上也可以创建新的待办事项, 而且还支持直接设定所属清单, 截止日期和提醒时间.&lt;/p&gt;
&lt;h1 id="_6"&gt;标签管理&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;奇妙清单&lt;/code&gt;还支持标签功能, 只要在待办事项中的名称中, 以&lt;code&gt;#+名称&lt;/code&gt;的方式, 就可以创建给待办事项加上标签.&lt;/p&gt;
&lt;p&gt;那么, 什么时候需要使用标签呢？&lt;/p&gt;
&lt;p&gt;其实, 一个标签也完成可以作为一个清单存在. 然而, 如果创建了过多的清单, 也会影响使用效率, 因此建议大家可以在同一个清单中管理一类事情, 但通过标签去&lt;strong&gt;细分&lt;/strong&gt;这些事情的属性.&lt;/p&gt;
&lt;p&gt;举例来说, 在&lt;code&gt;工作&lt;/code&gt;清单中, 主要存放着所有的&lt;code&gt;bug&lt;/code&gt;和&lt;code&gt;优化&lt;/code&gt;, 这时候就可以通过标签的形式来管理.&lt;/p&gt;
&lt;p&gt;在添加新的待办事项时, 你可以点击键盘上侧的&lt;code&gt;#&lt;/code&gt;号键, 这时就会出现已有的标签列表可以选择.&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;奇妙清单&lt;/code&gt;的搜索功能中, 只需要输入标签, 就可以过渡出所有带有这些标签的待办事项, 而在网页版中更加简单, 你只需要点击任何一个事项名称中的标签, 就可以进入到标签视图查看该标签下的所有事项.&lt;/p&gt;
&lt;p&gt;总之, 在你想要细分或者拆分某个大类别的清单前, 总是先思考一下, 如果用&lt;code&gt;标签&lt;/code&gt;, 会不会是更好的解决方案.&lt;/p&gt;
&lt;h1 id="_7"&gt;智能清单&lt;/h1&gt;
&lt;p&gt;在&lt;code&gt;奇妙清单&lt;/code&gt;中, 默认提供了:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全部&lt;/li&gt;
&lt;li&gt;已完成&lt;/li&gt;
&lt;li&gt;本周&lt;/li&gt;
&lt;li&gt;今天&lt;/li&gt;
&lt;li&gt;星标任务&lt;/li&gt;
&lt;li&gt;分配给我&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这六个智能清单, 它们会根据任务的属性来聚合显示不同的待办事项.&lt;/p&gt;
&lt;p&gt;然而, 如果它们全部显示, 不仅占位置, 还占用了你多余的注意力. &lt;code&gt;奇妙清单&lt;/code&gt;显然考虑到了这一点, 因此&lt;code&gt;智能清单&lt;/code&gt;的显示一共有三个选项:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可见: 该智能清单会一直显示&lt;/li&gt;
&lt;li&gt;隐藏: 该智能清单会一直不显示&lt;/li&gt;
&lt;li&gt;自动: 该智能清单仅在其中有内容时才显示&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样, 你可以根据自己的需要, 来让自己的清单更整洁. 在这里, 建议大家:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将&lt;code&gt;全部&lt;/code&gt;、&lt;code&gt;已完成&lt;/code&gt;设为隐藏, 因为事项多的时候, 基本不会用到这两个清单&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;星标任务&lt;/code&gt;设为可见, 你时刻需要关注最重要的事情&lt;/li&gt;
&lt;li&gt;将其它的设为自动, 例如&lt;code&gt;今天&lt;/code&gt;, 如果完成了今天所有的事情, 就可以不再显示&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="http://i64.tinypic.com/2lsxw7l.jpg"/&gt;&lt;/p&gt;
&lt;h1 id="_8"&gt;排序规则&lt;/h1&gt;
&lt;p&gt;在&lt;code&gt;设置&lt;/code&gt;中, 当你标记一个事项为&lt;code&gt;星标任务&lt;/code&gt;时, 它可以保持在原位置不动, 或移动到清单的最上方.&lt;/p&gt;
&lt;p&gt;每添加一个新任务时, 你可以选择它们是在&lt;code&gt;清单顶部&lt;/code&gt;或&lt;code&gt;清单底部&lt;/code&gt;, 同时, 应用角标也可以在&lt;code&gt;截止/逾期的任务&lt;/code&gt;、&lt;code&gt;通知&lt;/code&gt;、&lt;code&gt;未读对话&lt;/code&gt;和&lt;code&gt;禁用&lt;/code&gt;中选择.&lt;/p&gt;
&lt;p&gt;根据使用经验, 推荐大家设置为:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;星标任务: 移到顶部, 这样整个清单中最重要的事情一目了然&lt;/li&gt;
&lt;li&gt;添加任务: 清单顶部, 当事情较多时, 把新添加的任务放在顶部, 可以方便编辑修改, 另一方面, 一般来说新添加的事情也需要优先关注&lt;/li&gt;
&lt;li&gt;应用角标: 截止/逾期的任务, 不用进入 App 也可以快速知道今天有多少事情需要处理. 当然, 如果你和整个团队都频繁地使用&lt;code&gt;奇妙清单&lt;/code&gt;来互相留言、分配任务, 设置为&lt;code&gt;通知&lt;/code&gt;也非常有用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="http://i64.tinypic.com/9tekoy.jpg"/&gt;&lt;/p&gt;
&lt;h1 id="_9"&gt;仪式养成&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;仪式 Ritual&lt;/code&gt;实际上是 GTD 中的一个概念, 简单来说, 就是将自己在&lt;strong&gt;一定周期内&lt;/strong&gt;需要&lt;strong&gt;重复&lt;/strong&gt;的事项, 通过某个工具来提醒自己, 不断地强化行为, 从而养成相应的习惯.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;奇妙清单&lt;/code&gt;当然也可以帮助你完成这个目标, 首先, 你可以根据自己的需要, 新建如下清单:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;每日仪式&lt;/code&gt;: 每天都要重复完成的事情, 如早起锻炼、阅读、学习某项技能等, 你也可以进一步细分为&lt;code&gt;晨间仪式&lt;/code&gt;和&lt;code&gt;晚间仪式&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;每周仪式&lt;/code&gt;: 每周都要重复完成的事情, 如周末健身, 看望长辈, 记录周记等&lt;/li&gt;
&lt;li&gt;&lt;code&gt;每月仪式&lt;/code&gt;: 每月都要重复完成的事情, 如信用卡还款, 整理收藏夹等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在每个事项中都有三个属性:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;到期日&lt;/strong&gt;: 这个事项最迟完成的时间. 你必须设置一个到期日后, 才可以设置重复周期. 如果是每日仪式, 不妨就设定在今天, 同样的道理, 其它仪式可以设定在本周末或本月末&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重复&lt;/strong&gt;: 事项重复出现的周期, 按天、按周、按月、按年, 接下来也会有更多自定义选项, 如按工作日. 一旦设立后, 当完成某一事项时, 它会重复出现在清单中, 并且到期日自动更新为&lt;code&gt;上一个到期日 + 重复周期&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提醒&lt;/strong&gt;: 你可以设置在某天的具体几点几分提醒你, 以督促自己更好地执行和完成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要&lt;strong&gt;注意&lt;/strong&gt;的是, 你必须先勾选完成某个事项后, 才会触发其重复机制. 举例来说, 在&lt;code&gt;每月仪式&lt;/code&gt;清单中有本月 16 号&lt;code&gt;信用卡还款&lt;/code&gt;的事项, 你只有勾选完成后, 它才会自动生成下个月 16 号的还款事项, 否则, 即使到了下个月 16 号, 也不会有任何提醒.&lt;/p&gt;
&lt;h1 id="_10"&gt;删除清单&lt;/h1&gt;
&lt;p&gt;当删除一个清单时, 这个清单下的所有历史记录都会被删除…也就是说, 一旦删除清单, 就再也找不到以前完成的事项.&lt;/p&gt;
&lt;p&gt;所以我们可以创建一个&lt;code&gt;归档&lt;/code&gt;文件夹去保存所有已完成的清单, 这样就不怕丢失历史记录了.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i66.tinypic.com/2cz4rhx.jpg"/&gt;&lt;/p&gt;
&lt;h1 id="_11"&gt;恢复清单&lt;/h1&gt;
&lt;p&gt;在上一节 &lt;code&gt;删除清单&lt;/code&gt; 中我们使用&lt;code&gt;归档&lt;/code&gt;文件夹去保存所有已完成的清单, 但如果意外删除了清单怎么办?&lt;/p&gt;
&lt;p&gt;访问 &lt;a href="https://www.wunderlist.com/restore"&gt;https://www.wunderlist.com/restore&lt;/a&gt; 便可以轻松恢复 30 天以内被删除的清单.&lt;/p&gt;
&lt;h1 id="_12"&gt;智能到期日&lt;/h1&gt;
&lt;p&gt;在创建任务的时候, 一般很自然地会在心里带著到期日, 任务可能是 &lt;code&gt;明天 提交报告&lt;/code&gt; 或 &lt;code&gt;三天后 给客户发建议书&lt;/code&gt; 或是 &lt;code&gt;下周 订位子吃晚饭&lt;/code&gt;, 为了更自然有序地帮您抓好任务和到期日, 奇妙清单开通了智能到期日功能.&lt;/p&gt;
&lt;p&gt;智能到期日的操作非常简单：在您创建任务的时候它会自动识别与日期相关的词组如 &lt;code&gt;今天&lt;/code&gt;, &lt;code&gt;周一&lt;/code&gt;, &lt;code&gt;下周&lt;/code&gt;等, 并自动生成任务到期日.&lt;/p&gt;
&lt;p&gt;此功能目前支持奇妙清单&lt;strong&gt;网页&lt;/strong&gt;、&lt;strong&gt;Windows 7&lt;/strong&gt; 和 &lt;strong&gt;Chrome&lt;/strong&gt; 版, 后续将支持更多平台.&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;设置&lt;/code&gt; 里面可以对智能到期日功能进行配置:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i68.tinypic.com/2vlljdv.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;第二个选项&lt;code&gt;移除任务中智能到期日的文本&lt;/code&gt;的意思是指, 当启用了这个功能时, 会自动把任务名中 &lt;code&gt;今天&lt;/code&gt;, &lt;code&gt;周一&lt;/code&gt;, &lt;code&gt;下周&lt;/code&gt; 这类词删除掉.&lt;/p&gt;</content><category term="工具折腾"></category></entry><entry><title>GenShi Templates</title><link href="http://www.smallcpp.cn/genshi-templates.html" rel="alternate"></link><published>2016-08-19T12:56:00+08:00</published><updated>2016-08-19T12:56:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-08-19:/genshi-templates.html</id><summary type="html">
&lt;h1 id="genshi-xml-template-language"&gt;Genshi XML Template Language&lt;/h1&gt;
&lt;p&gt;Genshi provides a XML-based template language that is heavily inspired by Kid, which in turn was inspired by a number of existing template languages, namely XSLT …&lt;/p&gt;</summary><content type="html">
&lt;h1 id="genshi-xml-template-language"&gt;Genshi XML Template Language&lt;/h1&gt;
&lt;p&gt;Genshi provides a XML-based template language that is heavily inspired by Kid, which in turn was inspired by a number of existing template languages, namely XSLT, TAL, and PHP.&lt;/p&gt;
&lt;p&gt;This document describes the template language and will be most useful as reference to those developing Genshi XML templates. Templates are XML files of some kind (such as XHTML) that include processing directives (elements or attributes identified by a separate namespace) that affect how the template is rendered, and template expressions that are dynamically substituted by variable data.&lt;/p&gt;
&lt;p&gt;See Genshi Templating Basics for general information on embedding Python code in templates.&lt;/p&gt;
&lt;h1 id="1-template-directives"&gt;1 Template Directives&lt;/h1&gt;
&lt;p&gt;Directives are elements and/or attributes in the template that are identified by the namespace http://genshi.edgewall.org/. They can affect how the template is rendered in a number of ways: Genshi provides directives for conditionals and looping, among others.&lt;/p&gt;
&lt;p&gt;To use directives in a template, the namespace must be declared, which is usually done on the root element:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;html&lt;/span&gt; &lt;span style="color: #658b00"&gt;xmlns&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"http://www.w3.org/1999/xhtml"&lt;/span&gt;
      &lt;span style="color: #658b00"&gt;xmlns:py&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"http://genshi.edgewall.org/"&lt;/span&gt;
      &lt;span style="color: #658b00"&gt;lang&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"en"&lt;/span&gt;&amp;gt;
  ...
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;html&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this example, the default namespace is set to the XHTML namespace, and the namespace for Genshi directives is bound to the prefix “py”.&lt;/p&gt;
&lt;p&gt;All directives can be applied as attributes, and some can also be used as elements. The if directives for conditionals, for example, can be used in both ways:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;html&lt;/span&gt; &lt;span style="color: #658b00"&gt;xmlns&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"http://www.w3.org/1999/xhtml"&lt;/span&gt;
      &lt;span style="color: #658b00"&gt;xmlns:py&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"http://genshi.edgewall.org/"&lt;/span&gt;
      &lt;span style="color: #658b00"&gt;lang&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"en"&lt;/span&gt;&amp;gt;
  ...
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt; &lt;span style="color: #658b00"&gt;py:if&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"foo"&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;p&lt;/span&gt;&amp;gt;Bar&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;p&lt;/span&gt;&amp;gt;
  &amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
  ...
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;html&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is basically equivalent to the following:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;html&lt;/span&gt; &lt;span style="color: #658b00"&gt;xmlns&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"http://www.w3.org/1999/xhtml"&lt;/span&gt;
      &lt;span style="color: #658b00"&gt;xmlns:py&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"http://genshi.edgewall.org/"&lt;/span&gt;
      &lt;span style="color: #658b00"&gt;lang&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"en"&lt;/span&gt;&amp;gt;
  ...
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;py:if&lt;/span&gt; &lt;span style="color: #658b00"&gt;test&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"foo"&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
      &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;p&lt;/span&gt;&amp;gt;Bar&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;p&lt;/span&gt;&amp;gt;
    &amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
  &amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;py:if&lt;/span&gt;&amp;gt;
  ...
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;html&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The rationale behind the second form is that directives do not always map naturally to elements in the template. In such cases, the py:strip directive can be used to strip off the unwanted element, or the directive can simply be used as an element.&lt;/p&gt;
&lt;h2 id="11-conditional-sections"&gt;1.1 Conditional Sections&lt;/h2&gt;
&lt;h3 id="111-pyif"&gt;1.1.1 py:if&lt;/h3&gt;
&lt;p&gt;The element and its content is only rendered if the expression evaluates to a truth value:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;b&lt;/span&gt; &lt;span style="color: #658b00"&gt;py:if&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"foo"&lt;/span&gt;&amp;gt;${bar}&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;b&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Given the data foo=True and bar=’Hello’ in the template context, this would produce:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;b&lt;/span&gt;&amp;gt;Hello&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;b&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But setting foo=False would result in the following output:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This directive can also be used as an element:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;py:if&lt;/span&gt; &lt;span style="color: #658b00"&gt;test&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"foo"&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;b&lt;/span&gt;&amp;gt;${bar}&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;b&lt;/span&gt;&amp;gt;
  &amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;py:if&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="112-pychoose"&gt;1.1.2 py:choose&lt;/h3&gt;
&lt;p&gt;The py:choose directive, in combination with the directives py:when and py:otherwise provides advanced conditional processing for rendering one of several alternatives. The first matching py:when branch is rendered, or, if no py:when branch matches, the py:otherwise branch is rendered.&lt;/p&gt;
&lt;p&gt;If the py:choose directive is empty the nested py:when directives will be tested for truth:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt; &lt;span style="color: #658b00"&gt;py:choose&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;""&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;span&lt;/span&gt; &lt;span style="color: #658b00"&gt;py:when&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"0 == 1"&lt;/span&gt;&amp;gt;0&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;span&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;span&lt;/span&gt; &lt;span style="color: #658b00"&gt;py:when&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"1 == 1"&lt;/span&gt;&amp;gt;1&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;span&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;span&lt;/span&gt; &lt;span style="color: #658b00"&gt;py:otherwise&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;""&lt;/span&gt;&amp;gt;2&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;span&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This would produce the following output:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;span&lt;/span&gt;&amp;gt;1&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;span&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If the py:choose directive contains an expression the nested py:when directives will be tested for equality to the parent py:choose value:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt; &lt;span style="color: #658b00"&gt;py:choose&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"1"&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;span&lt;/span&gt; &lt;span style="color: #658b00"&gt;py:when&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"0"&lt;/span&gt;&amp;gt;0&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;span&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;span&lt;/span&gt; &lt;span style="color: #658b00"&gt;py:when&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"1"&lt;/span&gt;&amp;gt;1&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;span&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;span&lt;/span&gt; &lt;span style="color: #658b00"&gt;py:otherwise&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;""&lt;/span&gt;&amp;gt;2&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;span&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This would produce the following output:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;span&lt;/span&gt;&amp;gt;1&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;span&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;These directives can also be used as elements:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;py:choose&lt;/span&gt; &lt;span style="color: #658b00"&gt;test&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"1"&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;py:when&lt;/span&gt; &lt;span style="color: #658b00"&gt;test&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"0"&lt;/span&gt;&amp;gt;0&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;py:when&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;py:when&lt;/span&gt; &lt;span style="color: #658b00"&gt;test&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"1"&lt;/span&gt;&amp;gt;1&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;py:when&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;py:otherwise&lt;/span&gt;&amp;gt;2&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;py:otherwise&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;py:choose&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="12-looping"&gt;1.2 Looping&lt;/h2&gt;
&lt;h3 id="121-pyfor"&gt;1.2.1 py:for&lt;/h3&gt;
&lt;p&gt;The element is repeated for every item in an iterable:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;ul&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;li&lt;/span&gt; &lt;span style="color: #658b00"&gt;py:for&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"item in items"&lt;/span&gt;&amp;gt;${item}&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;li&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;ul&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Given items=[1, 2, 3] in the context data, this would produce:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;ul&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;li&lt;/span&gt;&amp;gt;1&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;li&lt;/span&gt;&amp;gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;li&lt;/span&gt;&amp;gt;2&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;li&lt;/span&gt;&amp;gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;li&lt;/span&gt;&amp;gt;3&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;li&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;ul&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This directive can also be used as an element:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;ul&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;py:for&lt;/span&gt; &lt;span style="color: #658b00"&gt;each&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"item in items"&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;li&lt;/span&gt;&amp;gt;${item}&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;li&lt;/span&gt;&amp;gt;
  &amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;py:for&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;ul&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="13-snippet-reuse"&gt;1.3 Snippet Reuse&lt;/h2&gt;
&lt;h3 id="131-pydef"&gt;1.3.1 py:def&lt;/h3&gt;
&lt;p&gt;The py:def directive can be used to create macros, i.e. snippets of template code that have a name and optionally some parameters, and that can be inserted in other places:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;p&lt;/span&gt; &lt;span style="color: #658b00"&gt;py:def&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"greeting(name)"&lt;/span&gt; &lt;span style="color: #658b00"&gt;class&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"greeting"&lt;/span&gt;&amp;gt;
    Hello, ${name}!
  &amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;p&lt;/span&gt;&amp;gt;
  ${greeting('world')}
  ${greeting('everyone else')}
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The above would be rendered to:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;p&lt;/span&gt; &lt;span style="color: #658b00"&gt;class&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"greeting"&lt;/span&gt;&amp;gt;
    Hello, world!
  &amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;p&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;p&lt;/span&gt; &lt;span style="color: #658b00"&gt;class&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"greeting"&lt;/span&gt;&amp;gt;
    Hello, everyone else!
  &amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;p&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If a macro doesn’t require parameters, it can be defined without the parenthesis. For example:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;p&lt;/span&gt; &lt;span style="color: #658b00"&gt;py:def&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"greeting"&lt;/span&gt; &lt;span style="color: #658b00"&gt;class&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"greeting"&lt;/span&gt;&amp;gt;
    Hello, world!
  &amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;p&lt;/span&gt;&amp;gt;
  ${greeting()}
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The above would be rendered to:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;p&lt;/span&gt; &lt;span style="color: #658b00"&gt;class&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"greeting"&lt;/span&gt;&amp;gt;
    Hello, world!
  &amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;p&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This directive can also be used as an element:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;py:def&lt;/span&gt; &lt;span style="color: #658b00"&gt;function&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"greeting(name)"&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;p&lt;/span&gt; &lt;span style="color: #658b00"&gt;class&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"greeting"&lt;/span&gt;&amp;gt;Hello, ${name}!&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;p&lt;/span&gt;&amp;gt;
  &amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;py:def&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="132-pymatch"&gt;1.3.2 py:match&lt;/h3&gt;
&lt;p&gt;This directive defines a match template: given an XPath expression, it replaces any element in the template that matches the expression with its own content.&lt;/p&gt;
&lt;p&gt;For example, the match template defined in the following template matches any element with the tag name “greeting”:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;span&lt;/span&gt; &lt;span style="color: #658b00"&gt;py:match&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"greeting"&lt;/span&gt;&amp;gt;
    Hello ${select('@name')}
  &amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;span&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;greeting&lt;/span&gt; &lt;span style="color: #658b00"&gt;name&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"Dude"&lt;/span&gt; /&amp;gt;
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This would result in the following output:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;span&lt;/span&gt;&amp;gt;
    Hello Dude
  &amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;span&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Inside the body of a py:match directive, the select(path) function is made available so that parts or all of the original element can be incorporated in the output of the match template. See Using XPath for more information about this function.&lt;/p&gt;
&lt;p&gt;Match templates are applied both to the original markup as well to the generated markup. The order in which they are applied depends on the order they are declared in the template source: a match template defined after another match template is applied to the output generated by the first match template. The match templates basically form a pipeline.&lt;/p&gt;
&lt;p&gt;This directive can also be used as an element:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;py:match&lt;/span&gt; &lt;span style="color: #658b00"&gt;path&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"greeting"&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;span&lt;/span&gt;&amp;gt;Hello ${select('@name')}&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;span&lt;/span&gt;&amp;gt;
  &amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;py:match&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;greeting&lt;/span&gt; &lt;span style="color: #658b00"&gt;name&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"Dude"&lt;/span&gt; /&amp;gt;
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When used this way, the py:match directive can also be annotated with a couple of optimization hints. For example, the following informs the matching engine that the match should only be applied once:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;py:match&lt;/span&gt; &lt;span style="color: #658b00"&gt;path&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"body"&lt;/span&gt; &lt;span style="color: #658b00"&gt;once&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"true"&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;body&lt;/span&gt; &lt;span style="color: #658b00"&gt;py:attrs&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"select('@*')"&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt; &lt;span style="color: #658b00"&gt;id&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"header"&lt;/span&gt;&amp;gt;...&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
    ${select("*|text()")}
    &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt; &lt;span style="color: #658b00"&gt;id&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"footer"&lt;/span&gt;&amp;gt;...&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
  &amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;body&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;py:match&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The following optimization hints are recognized:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Attribute&lt;/th&gt;
&lt;th&gt;Default&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;buffer&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;td&gt;Whether the matched content should be buffered in memory. Buffering can improve performance a bit at the cost of needing more memory during rendering. Buffering is ‘’required’‘ for match templates that contain more than one invocation of the select() function. If there is only one call, and the matched content can potentially be very long, consider disabling buffering to avoid excessive memory use.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;once&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;td&gt;Whether the engine should stop looking for more matching elements after the first match. Use this on match templates that match elements that can only occur once in the stream, such as the &lt;head&gt; or &lt;body&gt; elements in an HTML template, or elements with a specific ID.&lt;/body&gt;&lt;/head&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;recursive&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;td&gt;Whether the match template should be applied to its own output. Note that once implies non-recursive behavior, so this attribute only needs to be set for match templates that don’t also have once set.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Note&lt;/p&gt;
&lt;p&gt;The py:match optimization hints were added in the 0.5 release. In earlier versions, the attributes have no effect.&lt;/p&gt;
&lt;h2 id="14-variable-binding"&gt;1.4 Variable Binding&lt;/h2&gt;
&lt;h3 id="141-pywith"&gt;1.4.1 py:with&lt;/h3&gt;
&lt;p&gt;The py:with directive lets you assign expressions to variables, which can be used to make expressions inside the directive less verbose and more efficient. For example, if you need use the expression author.posts more than once, and that actually results in a database query, assigning the results to a variable using this directive would probably help.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;span&lt;/span&gt; &lt;span style="color: #658b00"&gt;py:with&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"y=7; z=x+10"&lt;/span&gt;&amp;gt;$x $y $z&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;span&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Given x=42 in the context data, this would produce:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;span&lt;/span&gt;&amp;gt;42 7 52&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;span&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This directive can also be used as an element:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;py:with&lt;/span&gt; &lt;span style="color: #658b00"&gt;vars&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"y=7; z=x+10"&lt;/span&gt;&amp;gt;$x $y $z&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;py:with&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that if a variable of the same name already existed outside of the scope of the py:with directive, it will not be overwritten. Instead, it will have the same value it had prior to the py:with assignment. Effectively, this means that variables are immutable in Genshi.&lt;/p&gt;
&lt;h2 id="15-structure-manipulation"&gt;1.5 Structure Manipulation&lt;/h2&gt;
&lt;h3 id="151-pyattrs"&gt;1.5.1 py:attrs&lt;/h3&gt;
&lt;p&gt;This directive adds, modifies or removes attributes from the element:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;ul&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;li&lt;/span&gt; &lt;span style="color: #658b00"&gt;py:attrs&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"foo"&lt;/span&gt;&amp;gt;Bar&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;li&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;ul&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Given foo={‘class’: ‘collapse’} in the template context, this would produce:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;ul&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;li&lt;/span&gt; &lt;span style="color: #658b00"&gt;class&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"collapse"&lt;/span&gt;&amp;gt;Bar&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;li&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;ul&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Attributes with the value None are omitted, so given foo={‘class’: None} in the context for the same template this would produce:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;ul&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;li&lt;/span&gt;&amp;gt;Bar&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;li&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;ul&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This directive can only be used as an attribute.&lt;/p&gt;
&lt;h3 id="152-pycontent"&gt;1.5.2   py:content&lt;/h3&gt;
&lt;p&gt;This directive replaces any nested content with the result of evaluating the expression:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;ul&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;li&lt;/span&gt; &lt;span style="color: #658b00"&gt;py:content&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"bar"&lt;/span&gt;&amp;gt;Hello&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;li&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;ul&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Given bar=’Bye’ in the context data, this would produce:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;ul&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;li&lt;/span&gt;&amp;gt;Bye&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;li&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;ul&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This directive can only be used as an attribute.&lt;/p&gt;
&lt;h3 id="153-pyreplace"&gt;1.5.3 py:replace&lt;/h3&gt;
&lt;p&gt;This directive replaces the element itself with the result of evaluating the expression:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;span&lt;/span&gt; &lt;span style="color: #658b00"&gt;py:replace&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"bar"&lt;/span&gt;&amp;gt;Hello&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;span&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Given bar=’Bye’ in the context data, this would produce:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
  Bye
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This directive can also be used as an element (since version 0.5):&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;py:replace&lt;/span&gt; &lt;span style="color: #658b00"&gt;value&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"title"&lt;/span&gt;&amp;gt;Placeholder&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;py:replace&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="154-pystrip"&gt;1.5.4 py:strip&lt;/h3&gt;
&lt;p&gt;This directive conditionally strips the top-level element from the output. When the value of the py:strip attribute evaluates to True, the element is stripped from the output:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt; &lt;span style="color: #658b00"&gt;py:strip&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"True"&lt;/span&gt;&amp;gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;b&lt;/span&gt;&amp;gt;foo&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;b&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This would be rendered as:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;b&lt;/span&gt;&amp;gt;foo&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;b&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As a shorthand, if the value of the py:strip attribute is empty, that has the same effect as using a truth value (i.e. the element is stripped).&lt;/p&gt;
&lt;h2 id="16-processing-order"&gt;1.6 Processing Order&lt;/h2&gt;
&lt;p&gt;It is possible to attach multiple directives to a single element, although not all combinations make sense. When multiple directives are encountered, they are processed in the following order:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;py:def&lt;/li&gt;
&lt;li&gt;py:match&lt;/li&gt;
&lt;li&gt;py:when&lt;/li&gt;
&lt;li&gt;py:otherwise&lt;/li&gt;
&lt;li&gt;py:for&lt;/li&gt;
&lt;li&gt;py:if&lt;/li&gt;
&lt;li&gt;py:choose&lt;/li&gt;
&lt;li&gt;py:with&lt;/li&gt;
&lt;li&gt;py:replace&lt;/li&gt;
&lt;li&gt;py:content&lt;/li&gt;
&lt;li&gt;py:attrs&lt;/li&gt;
&lt;li&gt;py:strip&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="2-includes"&gt;2 Includes&lt;/h1&gt;
&lt;p&gt;To reuse common snippets of template code, you can include other files using XInclude.&lt;/p&gt;
&lt;p&gt;For this, you need to declare the XInclude namespace (commonly bound to the prefix “xi”) and use the &lt;xi:include&gt; element where you want the external file to be pulled in:&lt;/xi:include&gt;&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;html&lt;/span&gt; &lt;span style="color: #658b00"&gt;xmlns&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"http://www.w3.org/1999/xhtml"&lt;/span&gt;
      &lt;span style="color: #658b00"&gt;xmlns:py&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"http://genshi.edgewall.org/"&lt;/span&gt;
      &lt;span style="color: #658b00"&gt;xmlns:xi&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"http://www.w3.org/2001/XInclude"&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;xi:include&lt;/span&gt; &lt;span style="color: #658b00"&gt;href&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"base.html"&lt;/span&gt; /&amp;gt;
  ...
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;html&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Include paths are relative to the filename of the template currently being processed. So if the example above was in the file “myapp/index.html” (relative to the template search path), the XInclude processor would look for the included file at “myapp/base.html”. You can also use Unix-style relative paths, for example “../base.html” to look in the parent directory.&lt;/p&gt;
&lt;p&gt;Any content included this way is inserted into the generated output instead of the &lt;xi:include&gt; element. The included template sees the same context data. Match templates and macros in the included template are also available to the including template after the point it was included.&lt;/xi:include&gt;&lt;/p&gt;
&lt;p&gt;By default, an error will be raised if an included file is not found. If that’s not what you want, you can specify fallback content that should be used if the include fails. For example, to to make the include above fail silently, you’d write:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;xi:include href="base.html"&amp;gt;&amp;lt;xi:fallback /&amp;gt;&amp;lt;/xi:include&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;See the XInclude specification for more about fallback content. Note though that Genshi currently only supports a small subset of XInclude.&lt;/p&gt;
&lt;h2 id="21-dynamic-includes"&gt;2.1 Dynamic Includes&lt;/h2&gt;
&lt;p&gt;Incudes in Genshi are fully dynamic: Just like normal attributes, the href attribute accepts expressions, and directives can be used on the &lt;xi:include&gt;&lt;/xi:include&gt; element just as on any other element, meaning you can do things like conditional includes:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;xi:include&lt;/span&gt; &lt;span style="color: #658b00"&gt;href&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"${name}.html"&lt;/span&gt; &lt;span style="color: #658b00"&gt;py:if&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"not in_popup"&lt;/span&gt;
            &lt;span style="color: #658b00"&gt;py:for&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"name in ('foo', 'bar', 'baz')"&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="22-including-text-templates"&gt;2.2 Including Text Templates&lt;/h2&gt;
&lt;p&gt;The parse attribute of the &lt;xi:include&gt; element can be used to specify whether the included template is an XML template or a text template (using the new syntax added in Genshi 0.5):&lt;/xi:include&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;xi:include href="myscript.js" parse="text" /&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This example would load the myscript.js file as a NewTextTemplate. See text templates for details on the syntax of text templates.&lt;/p&gt;
&lt;h1 id="3-comments"&gt;3 Comments&lt;/h1&gt;
&lt;p&gt;Normal XML/HTML comment syntax can be used in templates:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;!-- this is a comment --&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;However, such comments get passed through the processing pipeline and are by default included in the final output. If that’s not desired, prefix the comment text with an exclamation mark:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;!-- !this is a comment too, but one that will be stripped from the output --&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Note that it does not matter whether there’s whitespace before or after the exclamation mark, so the above could also be written as follows:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;!--! this is a comment too, but one that will be stripped from the output --&amp;gt;&lt;/code&gt;&lt;/p&gt;</content><category term="软件工程"></category></entry><entry><title>使用 Chrome 调试 XPath</title><link href="http://www.smallcpp.cn/shi-yong-chrome-diao-shi-xpath.html" rel="alternate"></link><published>2016-08-16T16:00:00+08:00</published><updated>2016-08-16T16:00:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-08-16:/shi-yong-chrome-diao-shi-xpath.html</id><content type="html">
&lt;blockquote&gt;
&lt;p&gt;需要注意, 有时获取出来并测试成功的 XPath 用 xlml 来实现的话有可能获取不到, 那时就要手动分析了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id="xpath"&gt;获取 XPath&lt;/h1&gt;
&lt;p&gt;&lt;img alt="" src="http://i67.tinypic.com/fbffnn.jpg"/&gt;&lt;/p&gt;
&lt;h1 id="xpath_1"&gt;测试 XPath&lt;/h1&gt;
&lt;p&gt;在 console 中用 &lt;code&gt;$x(' . . . ')&lt;/code&gt; 来测试 XPath&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i66.tinypic.com/29wswaa.jpg"/&gt;&lt;/p&gt;</content><category term="工具折腾"></category></entry><entry><title>JVisualVM JConsole</title><link href="http://www.smallcpp.cn/jvisualvm-jconsole.html" rel="alternate"></link><published>2016-08-11T10:19:00+08:00</published><updated>2016-08-11T10:19:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-08-11:/jvisualvm-jconsole.html</id><summary type="html">&lt;h1 id="jvisualvm"&gt;JVisualVM&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;JConsole: Java 性能分析器, 用于连接正在运行的 JVM, 不过此 JVM 需要使用可管理的模式启动 (在启动时设置 &lt;code&gt;com.sun.management.jmxremote&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;JVisualVM: 升级版的 JConsole, 可以监控线程, 内存情况, 查看方法的 CPU 时间和内存中的对象, 已被 GC 的对象, 反向查看分配的堆栈&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Visual GC&lt;/strong&gt; 插件: 监控垃圾回收器 …&lt;/p&gt;</summary><content type="html">&lt;h1 id="jvisualvm"&gt;JVisualVM&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;JConsole: Java 性能分析器, 用于连接正在运行的 JVM, 不过此 JVM 需要使用可管理的模式启动 (在启动时设置 &lt;code&gt;com.sun.management.jmxremote&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;JVisualVM: 升级版的 JConsole, 可以监控线程, 内存情况, 查看方法的 CPU 时间和内存中的对象, 已被 GC 的对象, 反向查看分配的堆栈&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Visual GC&lt;/strong&gt; 插件: 监控垃圾回收器&lt;/p&gt;
&lt;p&gt;安装:&lt;/p&gt;
&lt;p&gt;工具 --&gt; 插件 --&gt; 可用插件 --&gt; 选中 visual gc --&gt; 安装&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i67.tinypic.com/2iuuvdg.jpg"&gt;&lt;/p&gt;
&lt;p&gt;具体关于 JVM 内存结构参考:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/autofei/article/details/7456213"&gt;Java 的内存结构 (Memory Structure) 和垃圾收集 (Garbage Collection) 图解&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://blog.sina.com.cn/s/blog_68158ebf0100wp83.html"&gt;我对 Java 内存的认识&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://blog.chinaunix.net/xmlrpc.php?r=blog/article&amp;amp;uid=29632145&amp;amp;id=4616836"&gt;JVM 内存区域划分 Eden Space、Survivor Space、Tenured Gen，Perm Gen 解释&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</content><category term="工具折腾"></category></entry><entry><title>JDBC 为什么用 Class.forName 加载驱动</title><link href="http://www.smallcpp.cn/jdbc-wei-shi-yao-yong-classforname-jia-zai-qu-dong.html" rel="alternate"></link><published>2016-08-02T16:55:00+08:00</published><updated>2016-08-02T16:55:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-08-02:/jdbc-wei-shi-yao-yong-classforname-jia-zai-qu-dong.html</id><summary type="html">
&lt;p&gt;JDBC 中注册驱动为什么使用 &lt;code&gt;Class.forName("com.mysql.jdbc.Driver")&lt;/code&gt; 而不使用 &lt;code&gt;new com.mysql.jdbc.Driver()&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;其原因有二.&lt;/p&gt;
&lt;h3 id="_1"&gt;原因一&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;new&lt;/code&gt; 一个类需要 &lt;code&gt;import&lt;/code&gt; 它的包, 而各大数据库提供的驱动不一样, 使用 &lt;code&gt;new&lt;/code&gt; 的方式就十分依赖 &lt;code&gt;import&lt;/code&gt; 驱动的 jar 包, 这样一旦换了数据库驱动, 还要修改 …&lt;/p&gt;</summary><content type="html">
&lt;p&gt;JDBC 中注册驱动为什么使用 &lt;code&gt;Class.forName("com.mysql.jdbc.Driver")&lt;/code&gt; 而不使用 &lt;code&gt;new com.mysql.jdbc.Driver()&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;其原因有二.&lt;/p&gt;
&lt;h3 id="_1"&gt;原因一&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;new&lt;/code&gt; 一个类需要 &lt;code&gt;import&lt;/code&gt; 它的包, 而各大数据库提供的驱动不一样, 使用 &lt;code&gt;new&lt;/code&gt; 的方式就十分依赖 &lt;code&gt;import&lt;/code&gt; 驱动的 jar 包, 这样一旦换了数据库驱动, 还要修改 &lt;code&gt;import&lt;/code&gt; 语句, 而使用 &lt;code&gt;Class.forName("com.mysql.jdbc.Driver")&lt;/code&gt; 的话, 可以把 “com.mysql.jdbc.Driver” 写入配置文件, 这样换数据库驱动的话, 只要修改配置文件就行了.&lt;/p&gt;
&lt;h3 id="_2"&gt;原因二&lt;/h3&gt;
&lt;p&gt;首先, JDBC 规范要求各厂商必须在&lt;strong&gt;静态代码块&lt;/strong&gt;中将自己 (Driver) 使用 &lt;code&gt;DriverManager.registerDriver&lt;/code&gt; 方法注册到 &lt;code&gt;DriverManager&lt;/code&gt; 中去, 最终使用 &lt;code&gt;DriverManager&lt;/code&gt; 来操作数据库, 如下图.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i67.tinypic.com/10fw3no.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;根据 Java 类加载规则, 一个 java 文件从被加载到被卸载这个生命过程, 总共要经历5个阶段:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;装载&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;链接&lt;/strong&gt;
    + 验证
    + 准备
    + 解析&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始化&lt;/strong&gt; (对类的静态变量, 静态代码块执行初始化操作)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用&lt;/strong&gt; (即实例化)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;卸载&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;关于类的加载参考 blog: &lt;a href="http://blog.smallcpp.cn/018-dai-ma-kuai-he-lei-jia-zai.html"&gt;018、代码块和类加载&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;类的加载指的是 &lt;strong&gt;装载&lt;/strong&gt; -&amp;gt; &lt;strong&gt;链接&lt;/strong&gt; -&amp;gt; &lt;strong&gt;初始化&lt;/strong&gt; 这&lt;strong&gt;三&lt;/strong&gt;个阶段, 而使用 &lt;code&gt;Class.forName()&lt;/code&gt; 方法就是完成类的加载、执行 Driver 中的静态代码块.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;new&lt;/code&gt; 语法实际是和 &lt;code&gt;Class.forName().newInstances()&lt;/code&gt; 差不多的, 是 &lt;strong&gt;装载&lt;/strong&gt; -&amp;gt; &lt;strong&gt;链接&lt;/strong&gt; -&amp;gt; &lt;strong&gt;初始化&lt;/strong&gt; -&amp;gt; &lt;strong&gt;使用&lt;/strong&gt; 这&lt;strong&gt;四&lt;/strong&gt;个阶段, 也就是获取一个实例对象, 但我们只需要加载类、注册好驱动就可以了, 并不需要实例化它 (因为并不使用 &lt;code&gt;Driver&lt;/code&gt; 的实例对象操作数据库, 而是使用 &lt;code&gt;DriverManager&lt;/code&gt;).&lt;/p&gt;</content><category term="软件工程"></category></entry><entry><title>事务隔离级别</title><link href="http://www.smallcpp.cn/shi-wu-ge-chi-ji-bie.html" rel="alternate"></link><published>2016-08-01T17:22:00+08:00</published><updated>2016-08-01T17:22:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-08-01:/shi-wu-ge-chi-ji-bie.html</id><summary type="html">
&lt;h1 id="_1"&gt;事务并发引起的问题&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;脏读&lt;/strong&gt; (Drity Read): 某个事务已更新一份数据, 另一个事务在此时读取了同一份数据, 由于某些原因, 前一个 RollBack 了操作, 则后一个事务所读取的数据就会是不正确的.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不可重复读&lt;/strong&gt; (Non-repeatable read): 在一个事务的两次查询之中数据不一致, 这可能是两次查询过程中间被另一个事务&lt;strong&gt;更新&lt;/strong&gt;了原有的数据.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;幻读&lt;/strong&gt; (Phantom Read): 和不可重复读很像, 在一个事务的两次查询中数据笔数不一致, 这可能是两次查询过程中间被一个事务&lt;strong&gt;插入&lt;/strong&gt;了新的数据.&lt;/p&gt;
&lt;h1 id="_2"&gt;隔离级别&lt;/h1&gt;
&lt;p&gt;为了解决上面事务并发引起的问题, 数据库的事务系统一般提供了隔离级别的设定:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读未提交 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">
&lt;h1 id="_1"&gt;事务并发引起的问题&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;脏读&lt;/strong&gt; (Drity Read): 某个事务已更新一份数据, 另一个事务在此时读取了同一份数据, 由于某些原因, 前一个 RollBack 了操作, 则后一个事务所读取的数据就会是不正确的.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不可重复读&lt;/strong&gt; (Non-repeatable read): 在一个事务的两次查询之中数据不一致, 这可能是两次查询过程中间被另一个事务&lt;strong&gt;更新&lt;/strong&gt;了原有的数据.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;幻读&lt;/strong&gt; (Phantom Read): 和不可重复读很像, 在一个事务的两次查询中数据笔数不一致, 这可能是两次查询过程中间被一个事务&lt;strong&gt;插入&lt;/strong&gt;了新的数据.&lt;/p&gt;
&lt;h1 id="_2"&gt;隔离级别&lt;/h1&gt;
&lt;p&gt;为了解决上面事务并发引起的问题, 数据库的事务系统一般提供了隔离级别的设定:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读未提交 Read Uncommitted, 对应值为 &lt;code&gt;1&lt;/code&gt;, 最低级别, 会导致脏读、不可重复读、幻读&lt;/li&gt;
&lt;li&gt;读已提交 Read Committed, 设置为 &lt;code&gt;2&lt;/code&gt;, 避免脏读&lt;/li&gt;
&lt;li&gt;可重复读 Repeatable Read, 设置为 &lt;code&gt;4&lt;/code&gt;, 避免脏读、不可重复读&lt;/li&gt;
&lt;li&gt;可串行化 Serializable, 设置为 &lt;code&gt;8&lt;/code&gt;, 最高级别, 所谓串行化, 就是完全避免了并发, 脏读、不可重复读、幻读都不会发生&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MySQL 默认是 4&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为数据库对隔离级别的实现有所差别, 貌似 MySQL 设置成 4 时也能避免幻读.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="" src="http://i64.tinypic.com/2a7twk8.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;查看隔离级别:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;select&lt;/span&gt; @@&lt;span style="color: #8B008B; font-weight: bold"&gt;global&lt;/span&gt;.tx_isolation;    &lt;span style="color: #228B22"&gt;-- 全局隔离级别&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;select&lt;/span&gt; @@&lt;span style="color: #8B008B; font-weight: bold"&gt;session&lt;/span&gt;.tx_isolation;   &lt;span style="color: #228B22"&gt;-- 当前会话的隔离级别&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置隔离级别 (谁读设置谁):&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;SET&lt;/span&gt; [&lt;span style="color: #8B008B; font-weight: bold"&gt;GLOBAL&lt;/span&gt; | &lt;span style="color: #8B008B; font-weight: bold"&gt;SESSION&lt;/span&gt;] &lt;span style="color: #8B008B; font-weight: bold"&gt;TRANSACTION&lt;/span&gt; &lt;span style="color: #8B008B; font-weight: bold"&gt;ISOLATION&lt;/span&gt; &lt;span style="color: #8B008B; font-weight: bold"&gt;LEVEL&lt;/span&gt; &lt;span style="color: #a61717; background-color: #e3d2d2"&gt;{&lt;/span&gt; &lt;span style="color: #8B008B; font-weight: bold"&gt;READ&lt;/span&gt; &lt;span style="color: #8B008B; font-weight: bold"&gt;UNCOMMITTED&lt;/span&gt; | &lt;span style="color: #8B008B; font-weight: bold"&gt;READ&lt;/span&gt; &lt;span style="color: #8B008B; font-weight: bold"&gt;COMMITTED&lt;/span&gt; | &lt;span style="color: #8B008B; font-weight: bold"&gt;REPEATABLE&lt;/span&gt; &lt;span style="color: #8B008B; font-weight: bold"&gt;READ&lt;/span&gt; | &lt;span style="color: #8B008B; font-weight: bold"&gt;SERIALIZABLE&lt;/span&gt; &lt;span style="color: #a61717; background-color: #e3d2d2"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</content><category term="数据库"></category></entry><entry><title>mysql transaction 与 autocommit</title><link href="http://www.smallcpp.cn/mysql-transaction-yu-autocommit.html" rel="alternate"></link><published>2016-08-01T15:42:00+08:00</published><updated>2016-08-01T15:42:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-08-01:/mysql-transaction-yu-autocommit.html</id><summary type="html">&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;在默认的情况下, MySQL 从自动提交 (autocommit) 模式运行, 这种模式会在每条语句执行完毕后把它作出的修改立刻提交给数据库并使之永久化. 事实上, 这相当于把每一条语句都&lt;strong&gt;隐含&lt;/strong&gt;地当做一个&lt;strong&gt;事务&lt;/strong&gt;来执行.&lt;/p&gt;
&lt;p&gt;如果你想明确地执行事务, 需要&lt;strong&gt;禁用&lt;/strong&gt;自动提交模式并告诉 MySQL 你想让它在何时提交或回滚有关的修改.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;禁用&lt;/strong&gt;自动提交模式有两种方式:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一种&lt;/strong&gt;是直接设置 &lt;code&gt;autocommit&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt;, 此时, 在提交或回滚前的所有 sql 语句都会当成同一个事务来处理;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另一种 …&lt;/strong&gt;&lt;/p&gt;</summary><content type="html">&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;在默认的情况下, MySQL 从自动提交 (autocommit) 模式运行, 这种模式会在每条语句执行完毕后把它作出的修改立刻提交给数据库并使之永久化. 事实上, 这相当于把每一条语句都&lt;strong&gt;隐含&lt;/strong&gt;地当做一个&lt;strong&gt;事务&lt;/strong&gt;来执行.&lt;/p&gt;
&lt;p&gt;如果你想明确地执行事务, 需要&lt;strong&gt;禁用&lt;/strong&gt;自动提交模式并告诉 MySQL 你想让它在何时提交或回滚有关的修改.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;禁用&lt;/strong&gt;自动提交模式有两种方式:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一种&lt;/strong&gt;是直接设置 &lt;code&gt;autocommit&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt;, 此时, 在提交或回滚前的所有 sql 语句都会当成同一个事务来处理;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另一种&lt;/strong&gt;常用的办法是发出一条 &lt;code&gt;START TRANSACTION&lt;/code&gt; (或 BEGIN) 语句临时&lt;strong&gt;挂起&lt;/strong&gt;自动提交模式, 在事务被提交或回滚之后, 该模式将恢复到开始本次事务的 &lt;code&gt;START TRANSACTION&lt;/code&gt; 语句被执行之前的状态. (如果自动提交模式原来是激活的, 结束事务将回到自动提交模式; 如果它原来是禁用的, 结束当前事务将&lt;strong&gt;自动&lt;/strong&gt;开始下一个事务.)&lt;/p&gt;</content><category term="数据库"></category></entry><entry><title>三层架构与 MVC</title><link href="http://www.smallcpp.cn/san-ceng-jia-gou-yu-mvc.html" rel="alternate"></link><published>2016-07-29T11:24:00+08:00</published><updated>2016-07-29T11:24:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-07-29:/san-ceng-jia-gou-yu-mvc.html</id><summary type="html">
&lt;p&gt;近来对架构这块又有了新认识, MVC 也好, 三层也罢, 都是结构性模式, 由于结构化, 而可能忽视了行为事件, 这类的架构大多是一种 “失血”、”贫血” 模式 (这段话不理解先看完下面的分析, 再看下最后的&lt;a href="http://www.smallcpp.cn/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E4%B8%8E%20MVC.html#_3"&gt;小结&lt;/a&gt;, 然后回过头来理解这段话).&lt;/p&gt;
&lt;p&gt;现在, 我更推荐&lt;a href="http://www.smallcpp.cn/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/DDD%20%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%85%AD%E8%BE%B9%E5%BD%A2%E6%9E%B6%E6%9E%84.html"&gt;领域驱动设计配合六边形架构&lt;/a&gt; (领域驱动设计继承了职责驱动设计, 或者可以说是职责驱动设计的进化).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;推荐本书: &lt;a href="https://share.weiyun.com/ffebfff0ea72831e6d0a96905f359d06"&gt;UML 和模式应用&lt;/a&gt;, 这本书介绍了对象职责的分配原则&lt;/p&gt;
&lt;p&gt;参考资料:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.jdon.com/38045"&gt;对象的责任与职责&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.jdon.com/37976"&gt;DCI 架构是什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.jdon.com/38071"&gt;如何从职责和协作中发现丰富对象？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.jdon.com/38448"&gt;MVC …&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;</summary><content type="html">
&lt;p&gt;近来对架构这块又有了新认识, MVC 也好, 三层也罢, 都是结构性模式, 由于结构化, 而可能忽视了行为事件, 这类的架构大多是一种 “失血”、”贫血” 模式 (这段话不理解先看完下面的分析, 再看下最后的&lt;a href="http://www.smallcpp.cn/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E4%B8%8E%20MVC.html#_3"&gt;小结&lt;/a&gt;, 然后回过头来理解这段话).&lt;/p&gt;
&lt;p&gt;现在, 我更推荐&lt;a href="http://www.smallcpp.cn/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/DDD%20%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%85%AD%E8%BE%B9%E5%BD%A2%E6%9E%B6%E6%9E%84.html"&gt;领域驱动设计配合六边形架构&lt;/a&gt; (领域驱动设计继承了职责驱动设计, 或者可以说是职责驱动设计的进化).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;推荐本书: &lt;a href="https://share.weiyun.com/ffebfff0ea72831e6d0a96905f359d06"&gt;UML 和模式应用&lt;/a&gt;, 这本书介绍了对象职责的分配原则&lt;/p&gt;
&lt;p&gt;参考资料:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.jdon.com/38045"&gt;对象的责任与职责&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.jdon.com/37976"&gt;DCI 架构是什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.jdon.com/38071"&gt;如何从职责和协作中发现丰富对象？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.jdon.com/38448"&gt;MVC 模式已死&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://kb.cnblogs.com/page/117717/"&gt;分享我对领域驱动设计 (DDD) 的学习成果&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.cnblogs.com/tsoukw/archive/2007/09/28/908983.html"&gt;别在领域模型迷失了自己&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="_1"&gt;三层&lt;/h3&gt;
&lt;p&gt;三层是从整个应用程序架构的角度来分的三层 (如果程序需要, 还可以分多层).&lt;/p&gt;
&lt;p&gt;三层是为了解决整个应用程序中各个业务操作过程中不同阶段的代码封装的问题, 为了使程序员更加专注的处理某阶段的业务逻辑.&lt;/p&gt;
&lt;p&gt;比如将数据库操作代码封装到一层中, 提供一些方法根据参数直接返回用户需要的相应数据, 这样在处理具体的业务逻辑的时候, 就不用关心数据的存储问题了.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三层架构是界面层 (UI) 业务逻辑层 (BLL) 和数据访问层 (DAL) 构成的.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id="mvc"&gt;MVC&lt;/h3&gt;
&lt;p&gt;MVC 是在应用程序 (BS结构) 的视图层划分出来的不同功能的几个模块.&lt;/p&gt;
&lt;p&gt;MVC 主要是为了解决应用程序用户界面的样式替换问题, 把展示数据的 HTML 页面尽可能的和业务代码分离.&lt;/p&gt;
&lt;p&gt;MVC 把纯净的界面展示逻辑 (用户界面) 独立到一些文件中 (Views), 把一些和用户交互的程序逻辑 (Controller) 单独放在一些文件中, 在 Views 和 Controller 中传递数据使用一些专门封装数据的实体对象, 这些对象, 统称为 Models.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MVC是模型层 (M) 界面层 (View) 和控制层 (Controller) 构成的.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id="_2"&gt;区别及联系&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;三层架构是界面层 (UI) 业务逻辑层 (BLL) 和数据访问层 (DAL) 构成的.&lt;/p&gt;
&lt;p&gt;MVC是模型层 (M) 界面层 (View) 和控制层 (Controller) 构成的.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而且他们之间其实并不对应, 如果硬要给他们对应的话, 那么三层架构中的UI对应MVC中的 view (jsp) , 都是用于显示以及获取界面的数据; 三层架构中的 BLL 层和 DAL 层对应 MVC 中的 Model (javabean) 层, 都是用于处理上层传递来的数据以及从数据库获取的数据的; MVC 中的 Controller (Servlet) 最多算是三层架构中的 UI 的一部分, 也就我们常说的是 Servlet.&lt;/p&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i65.tinypic.com/2af0nyd.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;然而, 从更高层面看, 其实三层架构和MVC还是一个东西~&lt;/p&gt;
&lt;p&gt;我们所看到的不一样只是表面上的不一样, 核心的东西是一致的, 那么什么是核心？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答曰&lt;/strong&gt;：分层, 解耦!&lt;/p&gt;
&lt;p&gt;如果从解耦的角度来看三层架构和MVC其实他们是一致的, 只不过划分的方法不一样罢了, 就像上面的图所示. 从这一点说他们可以说是一个东西, 这就相当于我们看到馒头和面条一样, 表面上看他们不一样 (注意仅仅是表面) 但是他们核心是一致的, 都是面做的……&lt;/p&gt;
&lt;h3 id="_3"&gt;小结&lt;/h3&gt;
&lt;p&gt;三层也好, MVC 也罢, 从我的感觉上, 都是对设计模式中六大设计原则的具现形式.&lt;/p&gt;
&lt;p&gt;比如在三层中, 将数据库操作代码封装到一层中, 提供一些方法根据参数直接返回用户需要的相应数据, 这不就是&lt;strong&gt;单一原则&lt;/strong&gt;的体现吗?&lt;/p&gt;
&lt;p&gt;只要依照设计原则去开发程序, 不管什么模型, 都能开发出好的程序, 现在网上不流传一篇文章吗 &lt;strong&gt;&amp;lt;&amp;lt;别学框架, 学架构&amp;gt;&amp;gt;&lt;/strong&gt;, 是的, 架构, 这种核心的东西才是值得去探讨的....&lt;/p&gt;
&lt;p&gt;但是, 这两个架构都是&lt;strong&gt;更高层次&lt;/strong&gt;的抽象, 是结构性的架构, 整个过程是”死”的, 不会去指导具体类的设计, 也不会去指导职责的划分, 这将导致逻辑控制层臃肿, 产生很多超大的“业务逻辑”类, 最终出现&lt;a href="http://www.smallcpp.cn/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E4%B8%8E%20MVC.html"&gt;开篇&lt;/a&gt;的问题, 不方便维护, 不方便扩展.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.smallcpp.cn/ddd-ling-yu-qu-dong-she-ji-yu-liu-bian-xing-jia-gou.html"&gt;DDD (领域驱动设计) 配合六边形架构&lt;/a&gt;是更好的替代架构 (领域驱动设计继承了职责驱动设计, 或者可以说是职责驱动设计的进化), 应用场景更广, 扩展更简单.&lt;/p&gt;</content><category term="软件工程"></category></entry><entry><title>WRUP 实践</title><link href="http://www.smallcpp.cn/wrup-shi-jian.html" rel="alternate"></link><published>2016-07-29T11:18:00+08:00</published><updated>2016-07-29T11:18:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-07-29:/wrup-shi-jian.html</id><summary type="html">
&lt;h1 id="rup"&gt;RUP 软件工程管理概述&lt;/h1&gt;
&lt;h2 id="_1"&gt;软件工程模型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;瀑布式开发&lt;/li&gt;
&lt;li&gt;迭代式开发&lt;/li&gt;
&lt;li&gt;敏捷开发模型&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_2"&gt;瀑布式开发&lt;/h3&gt;
&lt;p&gt;传统的瀑布式开发, 也就是从需求到设计, 从设计到编码, 从编码到测试, 从测试到提交, 大概这样的流程;&lt;/p&gt;
&lt;p&gt;它要求每一个开发阶段都要做到最好, 特别是前期阶段, 设计的越完美, 提交后的成本损失就越少. 以前很多从事的外包项目就是这样的流程.&lt;/p&gt;
&lt;p&gt;但是这里面有个问题, 就是开发途中发现之前的需求不合格、需要重新设计等问题, 都要留到下一个版本的开发中了.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i63.tinypic.com/29f9e87.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;所以, 瀑布式开发的过程中是比较机械化的, 按流程走下来, 要求每一个流程都要按规范走完.&lt;/p&gt;
&lt;p&gt;当然它也有好处的, 从开发者的角度上说, 当你进入开发阶段时, 项目的文档是非常详细的 …&lt;/p&gt;</summary><content type="html">
&lt;h1 id="rup"&gt;RUP 软件工程管理概述&lt;/h1&gt;
&lt;h2 id="_1"&gt;软件工程模型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;瀑布式开发&lt;/li&gt;
&lt;li&gt;迭代式开发&lt;/li&gt;
&lt;li&gt;敏捷开发模型&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_2"&gt;瀑布式开发&lt;/h3&gt;
&lt;p&gt;传统的瀑布式开发, 也就是从需求到设计, 从设计到编码, 从编码到测试, 从测试到提交, 大概这样的流程;&lt;/p&gt;
&lt;p&gt;它要求每一个开发阶段都要做到最好, 特别是前期阶段, 设计的越完美, 提交后的成本损失就越少. 以前很多从事的外包项目就是这样的流程.&lt;/p&gt;
&lt;p&gt;但是这里面有个问题, 就是开发途中发现之前的需求不合格、需要重新设计等问题, 都要留到下一个版本的开发中了.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i63.tinypic.com/29f9e87.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;所以, 瀑布式开发的过程中是比较机械化的, 按流程走下来, 要求每一个流程都要按规范走完.&lt;/p&gt;
&lt;p&gt;当然它也有好处的, 从开发者的角度上说, 当你进入开发阶段时, 项目的文档是非常详细的, 像每个按钮点击后, 前台发生什么变化, 后台又怎么处理, 都详细的描述, 开发者只需编码就可以了…&lt;/p&gt;
&lt;h3 id="_3"&gt;迭代式开发&lt;/h3&gt;
&lt;p&gt;迭代式开发适合在一些需求信息不明确的项目中, 它不要求每一个阶段的任务做的都是最完美的, 而是明明知道还有很多不足的地方, 但先可以不去完善它, 而是把主要功能先搭建起来, 以最短的时间, 最少的损失先完成一个”不完美的成果物”直至提交.&lt;/p&gt;
&lt;p&gt;这样在开发过程中遇到需求的变化时, 所带来的影响要比瀑布式开发小.&lt;/p&gt;
&lt;p&gt;然后再通过客户或用户的反馈信息, 在这个”不完美的成果物”上逐步进行完善.&lt;/p&gt;
&lt;p&gt;而现在的很多项目中, 需求在项目进行中变化的事儿经常见, 所以显得迭代式开发的优势较瀑布式开发更明显一些.&lt;/p&gt;
&lt;p&gt;目前迭代式开发里面比较出名就是 &lt;strong&gt;RUP&lt;/strong&gt;, 称为统一过程.&lt;/p&gt;
&lt;h3 id="_4"&gt;敏捷开发模型&lt;/h3&gt;
&lt;p&gt;在迭代式开发时, 遇到比较小的项目, 就有人思考, 能不能”反应”更迅速一点, 文档再少一点, 迭代周期更减少一点…&lt;/p&gt;
&lt;p&gt;于是敏捷开发模型就应运而生了, 可以说, 它是在迭代式开发的基础上”进化”而来, 是一种极限迭代, 比较出名的有下面两种开发模型:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;XP, Extreme Programming (极限编程)&lt;/li&gt;
&lt;li&gt;Scrum, Scrum 的英文意思是橄榄球运动的一个专业术语, 表示”争球”的动作, 把一个开发流程的名字取名为 Scrum, 我想它的意思是开发团队在开发一个项目时, 大家像打橄榄球一样迅速、富有战斗激情、人人你争我抢地完成它.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;这两个我们后面的笔记会详细介绍.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="rup_1"&gt;RUP 软件工程&lt;/h2&gt;
&lt;h3 id="rup_2"&gt;RUP 初窥&lt;/h3&gt;
&lt;p&gt;RUP (统一过程) 是一种以用例驱动、以体系结构为核心、迭代及增量的软件过程模型, 由 UML 方法和工具支持, 广泛应用于各类面向对象项目.&lt;/p&gt;
&lt;p&gt;如下就是一个标准的 RUP 软件工程图 (图&lt;strong&gt;左上角&lt;/strong&gt;为原点):&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i66.tinypic.com/bhg0th.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;纵轴&lt;/strong&gt; 表示了工作流程的静态结构, 共 9 个工作流程, 前 6 个流程就是一个正常的&lt;strong&gt;软件的生命周期&lt;/strong&gt;, 称为核心流程, 后面的 3 个流程是辅助流程, 将贯穿项目始终, 也称为支持流程, 像搭建版本控制系统、搭建问题追踪系统、管理开发日志等, 都是属于这个流程.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;横轴&lt;/strong&gt; 代表了制定开发过程的时间, 显示 RUP 的动态特征, 通过迭代式软件开发的周期、阶段、迭代和里程碑等动态信息表示, 它将纵轴上的每个工作流程都划分为 4 个阶段, 每个阶段以一个主要里程碑结束, 所以本质上说每个阶段都是两个里程碑之间的时间跨度.&lt;/p&gt;
&lt;h3 id="rup-4"&gt;RUP 4 阶段&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;初始阶段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;初始阶段的目标是为系统建立商业案例并确定项目的边界.&lt;/p&gt;
&lt;p&gt;为了达到该目的必须识别所有与系统交互的外部实体, 在较高层次上定义交互的特性.&lt;/p&gt;
&lt;p&gt;本阶段具有非常重要的意义, 在这个阶段中所关注的是整个项目进行中的业务和需求方面的主要风险.&lt;/p&gt;
&lt;p&gt;对于建立在原有系统基础上的开发项目来讲, 初始阶段可能很短.&lt;/p&gt;
&lt;p&gt;初始阶段结束时是第一个重要的&lt;strong&gt;里程碑&lt;/strong&gt;: 生命周期目标 (Lifecycle Objective) 里程碑.&lt;/p&gt;
&lt;p&gt;生命周期目标里程碑评价项目基本的生存能力.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;细化阶段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;细化阶段的目标是分析问题领域, 建立健全的体系结构基础, 编制项目计划, 淘汰项目中最高风险的元素.&lt;/p&gt;
&lt;p&gt;为了达到该目的, 必须在理解整个系统的基础上, 对体系结构作出决策, 包括其范围、主要功能和诸如性能等非功能需求.&lt;/p&gt;
&lt;p&gt;同时为项目建立支持环境, 包括创建开发案例, 创建模板、准则并准备工具.&lt;/p&gt;
&lt;p&gt;细化阶段结束时第二个重要的&lt;strong&gt;里程碑&lt;/strong&gt;: 生命周期结构 (Lifecycle Architecture) 里程碑.&lt;/p&gt;
&lt;p&gt;生命周期结构里程碑为系统的结构建立了管理基准并使项目小组能够在构建阶段中进行衡量.&lt;/p&gt;
&lt;p&gt;此刻, 要检验详细的系统目标和范围、结构的选择以及主要风险的解决方案.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;构造阶段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在构建阶段, 所有剩余的构件和应用程序功能被开发并集成为产品, 所有的功能被详细测试.&lt;/p&gt;
&lt;p&gt;从某种意义上说, 构建阶段是一个制造过程, 其重点放在管理资源及控制运作以优化成本、进度和质量.&lt;/p&gt;
&lt;p&gt;构建阶段结束时是第三个重要的&lt;strong&gt;里程碑&lt;/strong&gt;: 初始功能 (Initial Operational) 里程碑.&lt;/p&gt;
&lt;p&gt;初始功能里程碑决定了产品是否可以在测试环境中进行部署.&lt;/p&gt;
&lt;p&gt;此刻, 要确定软件、环境、用户是否可以开始系统的运作.&lt;/p&gt;
&lt;p&gt;此时的产品版本也常被称为 “beta” 版.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;交付阶段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;交付阶段的重点是确保软件对最终用户是可用的.&lt;/p&gt;
&lt;p&gt;交付阶段可以跨越几次迭代, 包括为发布做准备的产品测试, 基于用户反馈的少量的调整.&lt;/p&gt;
&lt;p&gt;在生命周期的这一点上, 用户反馈应主要集中在产品调整, 设置、安装和可用性问题, 所有主要的结构问题应该已经在项目生命周期的早期阶段解决了.&lt;/p&gt;
&lt;p&gt;在交付阶段的终点是第四个&lt;strong&gt;里程碑&lt;/strong&gt;: 产品发布 (Product Release) 里程碑.&lt;/p&gt;
&lt;p&gt;此时, 要确定目标是否实现, 是否应该开始另一个开发周期.&lt;/p&gt;
&lt;p&gt;在一些情况下这个里程碑可能与下一个周期的初始阶段的结束重合.&lt;/p&gt;
&lt;h3 id="rup_3"&gt;RUP 周期&lt;/h3&gt;
&lt;p&gt;RUP 模型采用迭代开发, 通过多次迭代执行开发工作流, 逐步确定&lt;strong&gt;一部分&lt;/strong&gt;需求分析和风险, 在设计、实现并确认这部分后, 再去做&lt;strong&gt;下一部分&lt;/strong&gt;的需求分析、设计、实现和确认工作, 依次进行下去, 直到整个项目完成, 这样能够在逐步集成中更好的理解需求, 构建一个健壮的体系结构.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i66.tinypic.com/21bswhz.jpg"/&gt;&lt;/p&gt;
&lt;h3 id="_5"&gt;软件生命周期&lt;/h3&gt;
&lt;p&gt;1、&lt;strong&gt;问题的定义及规划&lt;/strong&gt; (上图中叫业务建模)&lt;/p&gt;
&lt;p&gt;此阶段是软件开发方与需求方共同讨论, 主要确定软件的开发目标及其可行性.&lt;/p&gt;
&lt;p&gt;2、&lt;strong&gt;需求分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在确定软件开发可行的情况下, 对软件需要实现的各个功能进行详细分析. 需求分析阶段是一个很重要的阶段, 这一阶段做得好, 将为整个软件开发项目的成功打下良好的基础”唯一不变的是变化本身”, 同样需求也是在整个软件开发过程中不断变化和深入的, 因此我们必须制定需求变更计划来应付这种变化, 以保护整个项目的顺利进行.&lt;/p&gt;
&lt;p&gt;3、&lt;strong&gt;软件设计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此阶段主要根据需求分析的结果, 对整个软件系统进行设计, 如系统框架设计, 数据库设计等等. 软件设计一般分为总体设计和详细设计. 好的软件设计将为软件程序编写打下良好的基础.&lt;/p&gt;
&lt;p&gt;4、&lt;strong&gt;程序编码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此阶段是将软件设计的结果转换成计算机可运行的程序代码. 在程序编码中必须要制定统一, 符合标准的编写规范. 以保证程序的可读性, 易维护性, 提高程序的运行效率.&lt;/p&gt;
&lt;p&gt;5、&lt;strong&gt;软件测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在软件设计完成后要经过严密的测试, 以发现软件在整个设计过程中存在的问题并加以纠正. 整个测试过程分单元测试、组装测试以及系统测试三个阶段进行. 测试的方法主要有白盒测试和黑盒测试两种. 在测试过程中需要建立详细的测试计划并严格按照测试计划进行测试, 以减少测试的随意性.&lt;/p&gt;
&lt;p&gt;6、&lt;strong&gt;运行维护&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;软件维护是软件生命周期中持续时间最长的阶段. 在软件开发完成并投入使用后, 由于多方面的原因, 软件不能继续适应用户的要求. 要延续软件的使用寿命, 就必须对软件进行维护. 软件的维护包括纠错性维护和改进性维护两个方面.&lt;/p&gt;
&lt;h3 id="rup_4"&gt;RUP 中的核心流程&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;业务建模工作流&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;产生五个工作产品, 即商业逻辑建模 (USE CASE)(ROSE)、业务需求说明书 (MS WORD)、专业词汇表 (英汉对照) (MS WORD)、风险说明 (MS WORD)、复审说明书.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需求工作流&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了确保开发人员构建正确的系统, 要了解目标组织的结构及机制;&lt;/p&gt;
&lt;p&gt;要明确目标组织中当前存在的问题并确定改进的可能性;&lt;/p&gt;
&lt;p&gt;确保客户、最终用户和开发人员就目标组织达成共识;&lt;/p&gt;
&lt;p&gt;导出支持目标组织所需的系统需求, 建立系统需求模型: 用例图.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析设计工作流&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将系统需求转换为未来系统的设计, 逐步开放强壮的系统架构, 使设计适合于实施环境, 为提高性能而进行设计;&lt;/p&gt;
&lt;p&gt;根据需求工作流中的用例图建立分析模型: 时序图等.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实施工作流&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要定义代码结构, 以构件的方式实施类和对象, 对已开发的构件按类和单元来测试, 并且将结果集成到可执行的系统中;&lt;/p&gt;
&lt;p&gt;建立开发模型: 类图、状态图等.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试工作流&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对各个类进行单元测试, 测试工作流包括核实对象之间的交互, 核实软件的所有构件是否正确集成, 核实所有需求是否已经正确实施, 确定缺陷, 确保在部署软件之前将风险降到最低.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;部署工作流&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目的是成功的生成版本并将软件分发给最终用户, 部署工作流描述了那些与确保软件产品对最终用户具有可用性相关的活动, 包括: 软件打包、生成软件本身以外的产品、安装软件、为用户提供帮助, 在有些情况下, 还可能包括计划和进行 beta 测试版、移植现有的软件和数据以及正式验收.&lt;/p&gt;
&lt;h3 id="rup_5"&gt;RUP 中的支持工作流&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;团队架构&lt;/li&gt;
&lt;li&gt;里程碑计划&lt;/li&gt;
&lt;li&gt;每日站会&lt;/li&gt;
&lt;li&gt;持续构建 (CI)&lt;/li&gt;
&lt;li&gt;问题追踪&lt;/li&gt;
&lt;li&gt;自动化部署&lt;/li&gt;
&lt;li&gt;版本控制&lt;/li&gt;
&lt;li&gt;文档控制&lt;/li&gt;
&lt;li&gt;需求变更控制&lt;/li&gt;
&lt;li&gt;资源变更控制&lt;/li&gt;
&lt;li&gt;问题、知识管理 (wiki)&lt;/li&gt;
&lt;li&gt;工具、资源共享&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="wrup"&gt;WRUP 最佳实践模型&lt;/h1&gt;
&lt;p&gt;WRUP 由麦子学院的 Sandy 老师从 RUP 的基础上进化而来, 主要是增加了 TDD 驱动开发 (测试驱动开发).&lt;/p&gt;
&lt;h2 id="_6"&gt;原则特征&lt;/h2&gt;
&lt;p&gt;本模型描述了 WRUP 最佳实践方式, 它本身也是一套经过部署、验证有效的商业化软件开发方法.&lt;/p&gt;
&lt;p&gt;之所以称为 “最佳实践”, 不仅仅是因为他们具有可以量化的价值, 并且被许多成功的机构、成功的项目所运用, 并且是在 Sundy 的十年开发生涯中不断积累的结果.&lt;/p&gt;
&lt;p&gt;为了使整个团队有效的利用最佳实践模型, 我们为每个团队成员提供了必要准则、工具和模板, 并且明确指出其原则特征:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;迭代的开发软件&lt;/li&gt;
&lt;li&gt;开发与质量控制 (TDD) 双线并行&lt;/li&gt;
&lt;li&gt;量化可追溯的需求管理&lt;/li&gt;
&lt;li&gt;标准且可视化的软件建模&lt;/li&gt;
&lt;li&gt;验证每一个步骤&lt;/li&gt;
&lt;li&gt;控制变更&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_7"&gt;核心流程&lt;/h2&gt;
&lt;p&gt;WRUP 提出了 W 双线生产模型, 如下图:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i63.tinypic.com/213p6wj.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;即: 开发与质量控制 (TDD) 双线并行.&lt;/p&gt;
&lt;p&gt;由 W 模型图可知, 项目生产过程包括两个主要过程: 开发 和 质量控制.&lt;/p&gt;
&lt;p&gt;二者之间是相互独立又是息息相关密不可分的, 例如开发过程的需求分析完成后, 质量控制过程也可以完成验收测试设计.&lt;/p&gt;
&lt;p&gt;质量控制过程又隐含着对开发阶段的审核, 开发过程大部分的审核皆由质量控制部门来实现.&lt;/p&gt;
&lt;p&gt;W 模型对上一节学到的 RUP 图形 &lt;strong&gt;Y&lt;/strong&gt; 轴进行了拆分和细化:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i66.tinypic.com/bhg0th.jpg"/&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;RUP&lt;/th&gt;
&lt;th&gt;WRUP&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;业务建模&lt;/td&gt;
&lt;td&gt;项目评估&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;需求&lt;/td&gt;
&lt;td&gt;需求分析&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;分析设计&lt;/td&gt;
&lt;td&gt;概要设计&lt;br/&gt;详细设计&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;实施&lt;/td&gt;
&lt;td&gt;编码&lt;br/&gt;单元验证&lt;br/&gt;集成构建&lt;br/&gt;系统构建&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;测试&lt;/td&gt;
&lt;td&gt;质量控制过程&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;部署&lt;/td&gt;
&lt;td&gt;项目交付&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可以看到, 关键就是把测试移到专门的质量控制过程, 由质量控制部门来实现, 并贯穿始终, 这个应该可以认为是 TDD 驱动开发 (测试驱动开发) 的变种.&lt;/p&gt;
&lt;h4 id="_8"&gt;项目评估&lt;/h4&gt;
&lt;p&gt;项目评估阶段的目标是: 评估项目的级别、风险、项目需要投入的资源, 并且出可行性方案.&lt;/p&gt;
&lt;p&gt;本阶段是非常重要的阶段, 是项目的基石, 若项目评估未通过, 则直接不再继续下面的步骤, 并且反馈给相关人; 若项目评估通过, 则需要确立项目级别、项目组织结构、项目从属事项等.&lt;/p&gt;
&lt;p&gt;这个阶段关注的是项目中进行工程的业务和需求方面的主要风险, 对于建立在原有系统上的开发项目来说, 项目评估阶段的时间可能很短.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本阶段的主要目标如下&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;明确客户各个阶段使用目标以及软件基本架构&lt;/li&gt;
&lt;li&gt;估计出潜在风险&lt;/li&gt;
&lt;li&gt;评估项目使用的人力，财力，物力等资源&lt;/li&gt;
&lt;li&gt;对整个项目做最初的项目成本及日程估计&lt;/li&gt;
&lt;li&gt;确立软件项目立项是否可行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;这个阶段的产出是&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目评估表&lt;/li&gt;
&lt;li&gt;项目立项书 (若通过评估)，包括业务上下文，验收规范，成本预计等&lt;/li&gt;
&lt;li&gt;原始核心需求文档 (客户提供)&lt;/li&gt;
&lt;li&gt;项目计划 V1 (概要)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;阶段结束是一个里程碑标准&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;就是否参与这个项目已经定论&lt;/li&gt;
&lt;li&gt;项目级别已经定论&lt;/li&gt;
&lt;li&gt;项目投入资源以及主要风险承担者已经定论&lt;/li&gt;
&lt;li&gt;风险承担者就范围定义，成本/日程估计达成共识&lt;/li&gt;
&lt;li&gt;项目开发环境搭建完成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果无法通过这些里程碑, 则项目可以被取消或者仔细地重新考虑.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阶段评审的工作和需要达到的状态列表&lt;/strong&gt;:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;产品&lt;/th&gt;
&lt;th&gt;责任人&lt;/th&gt;
&lt;th&gt;应该达到的状态&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;项目评估表&lt;/td&gt;
&lt;td&gt;PS (Project Senate)&lt;/td&gt;
&lt;td&gt;完成&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;项目立项书&lt;/td&gt;
&lt;td&gt;PM (Project Manager)&lt;/td&gt;
&lt;td&gt;完成&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;概要原始需求书&lt;/td&gt;
&lt;td&gt;PM&lt;/td&gt;
&lt;td&gt;具备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;项目计划 V1 (包含项目开发计划，项目测试计划)&lt;/td&gt;
&lt;td&gt;PM / PDM / PTM&lt;/td&gt;
&lt;td&gt;完成项目计划的第一个版本, 也就是概要版本, 不细化到具体的人员分配和具体功能细节.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;开发服务器及开发环境&lt;/td&gt;
&lt;td&gt;SE (Support Engineer)&lt;/td&gt;
&lt;td&gt;完成或者确立&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;项目管理服务器及管理环境&lt;/td&gt;
&lt;td&gt;SE (Support Engineer)&lt;/td&gt;
&lt;td&gt;完成或者确立&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;项目仓库框架&lt;/td&gt;
&lt;td&gt;SE (Support Engineer)&lt;/td&gt;
&lt;td&gt;完成&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;责任人确立&lt;/td&gt;
&lt;td&gt;PS (Project Senate)&lt;/td&gt;
&lt;td&gt;确立项目经理, 开发经理, 测试经理以及项目外的干系人 (客户方代表) 选.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;用户接口原型 (可选)&lt;/td&gt;
&lt;td&gt;UID (UI Designer)&lt;/td&gt;
&lt;td&gt;主要是界面原型&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="_9"&gt;需求分析&lt;/h4&gt;
&lt;p&gt;项目需求分析需要达到的目标是明确分析客户的需求, 并且量化成需求分析设计文档, 以达到确立商业用例及系统边界的目的.&lt;/p&gt;
&lt;p&gt;为了达到该目的, 必须对系统具有 “英里宽和英寸深” 的现象, 体系结构的决策必须在理解整个系统的基础上作出: 它的范围、主要功能和性能等非功能性需求.&lt;/p&gt;
&lt;p&gt;项目需求分析阶段是项目成功细化的关键保障, 我们对需求的确立也是我们后面阶段工作的前提保障, 常用的一句话: “正确的需求才有正确的软件”.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本阶段需要达到的目标&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;置顶而下明确客户系统模块划分&lt;/li&gt;
&lt;li&gt;明确 80% 客户系统的商业用例&lt;/li&gt;
&lt;li&gt;明确角色分配以及流程走向&lt;/li&gt;
&lt;li&gt;使用UML用例量化需求，完成需求报告&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;这个阶段的产出&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;蓝图文档: 核心项目需求、关键特色、主要约束的总体蓝图&lt;/li&gt;
&lt;li&gt;原始用例模型&lt;/li&gt;
&lt;li&gt;原始项目术语表&lt;/li&gt;
&lt;li&gt;原始商业案例, 包括业务的上下文、验收规范、成本预计&lt;/li&gt;
&lt;li&gt;原始的风险评估&lt;/li&gt;
&lt;li&gt;一个或多个原型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;阶段结束是一个里程碑标准&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;风险承担者就范围定义, 成本/日程估计达成共识&lt;/li&gt;
&lt;li&gt;以客观的主要用例证实对需求的理解&lt;/li&gt;
&lt;li&gt;成本/日程、优先级、风险和开发过程的可信度&lt;/li&gt;
&lt;li&gt;被开发体系结构原型的深度和广度&lt;/li&gt;
&lt;li&gt;实际开支与计划开支的比较&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果无法通过这些里程碑, 则项目可能被取消或者仔细地重新考虑.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阶段评审工作需要达到的状态列表&lt;/strong&gt;:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;产品&lt;/th&gt;
&lt;th&gt;责任人&lt;/th&gt;
&lt;th&gt;应该达到的状态&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;需求分析图 UML&lt;/td&gt;
&lt;td&gt;PDA (Project Demand Analyst)&lt;/td&gt;
&lt;td&gt;完成&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UI 原型&lt;/td&gt;
&lt;td&gt;UID (UI Designer)&lt;/td&gt;
&lt;td&gt;模型覆盖率 100%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;需求分析报告 (可选)&lt;/td&gt;
&lt;td&gt;PDA Leader&lt;/td&gt;
&lt;td&gt;具备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;项目计划 V2 (需求阶段的详细计划及执行情况)&lt;/td&gt;
&lt;td&gt;PDA&lt;/td&gt;
&lt;td&gt;细化到需求阶段的每日工作量和人员分配&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;客户沟通记录及确认签字&lt;/td&gt;
&lt;td&gt;PDA, Customer&lt;/td&gt;
&lt;td&gt;每次沟通的记录表以及客户签字确认&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="_10"&gt;概要设计&lt;/h4&gt;
&lt;p&gt;项目概要设计阶段主要是指根据业务用例和用户需求所做的架构设计, 我们也称之为系统设计.&lt;/p&gt;
&lt;p&gt;这部分即包括设计的描述 (画出设计图), 也包括设计的实现 (编码实现), 概要设计也是项目的骨架搭建, 关注与接口与接口之间的端对端关系.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;概要设计需要达到的目标&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完成概要设计图&lt;/li&gt;
&lt;li&gt;明确模块以及模块之间的接口定义&lt;/li&gt;
&lt;li&gt;覆盖原型的所有主要功能模块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;产出&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;概要设计图&lt;/li&gt;
&lt;li&gt;概要设计书 (可选)&lt;/li&gt;
&lt;li&gt;项目框架代码, 接口定义代码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;里程碑&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;风险承担者对目前的项目框架方案达成一致&lt;/li&gt;
&lt;li&gt;架构设计基本完成&lt;/li&gt;
&lt;li&gt;模块与接口设计完成&lt;/li&gt;
&lt;li&gt;需求不断迭代确立&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;阶段评审工作所需要达到的状态列表&lt;/strong&gt;:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;产品&lt;/th&gt;
&lt;th&gt;责任人&lt;/th&gt;
&lt;th&gt;应该达到的状态&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;概要设计图 UML&lt;/td&gt;
&lt;td&gt;AD (Architecture Designer)&lt;/td&gt;
&lt;td&gt;完成&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;概要设计书&lt;/td&gt;
&lt;td&gt;(可选)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DBMS 实现&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;项目计划 V3 (架构设计阶段)&lt;/td&gt;
&lt;td&gt;PDA&lt;/td&gt;
&lt;td&gt;细化到概要设计阶段的每日工作量和人员分配&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;概要设计评估表&lt;/td&gt;
&lt;td&gt;PS&lt;/td&gt;
&lt;td&gt;通过&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;概要设计代码实现&lt;/td&gt;
&lt;td&gt;AD&lt;/td&gt;
&lt;td&gt;实现代码结构&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="_11"&gt;详细设计&lt;/h4&gt;
&lt;p&gt;详细设计主要是为了对各个功能模块和各个子系统进行细节&lt;strong&gt;白盒设计&lt;/strong&gt;, 如果说概要设计是采用&lt;strong&gt;黑盒&lt;/strong&gt;的分析方式, 则详细设计就要关注流程、路径和逻辑, 属于白盒的范畴.&lt;/p&gt;
&lt;p&gt;详细设计要完成对各个功能的函数级别的设计, 但无需完成具体代码.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;详细设计需要达到的目标&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;详细设计需要达到的目标&lt;/li&gt;
&lt;li&gt;完成详细设计UML&lt;/li&gt;
&lt;li&gt;实现详细设计的代码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;产出&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;详细设计图UML&lt;/li&gt;
&lt;li&gt;详细设计书&lt;/li&gt;
&lt;li&gt;详细的模块级别源代码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;阶段评审工作所需要达到的状态列表&lt;/strong&gt;:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;产品&lt;/th&gt;
&lt;th&gt;责任人&lt;/th&gt;
&lt;th&gt;应该达到的状态&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;各模块详细设计图 UML&lt;/td&gt;
&lt;td&gt;MD (Model Designer)&lt;/td&gt;
&lt;td&gt;完成数量不定的各个模块详细设计&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;详细设计书 (可选)&lt;/td&gt;
&lt;td&gt;MD&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DBMS实现&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;项目计划 V4 (详细设计阶段)&lt;/td&gt;
&lt;td&gt;PDA&lt;/td&gt;
&lt;td&gt;细化到概要设计阶段的每日工作量和人员分配&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;详细设计评估表&lt;/td&gt;
&lt;td&gt;PS&lt;/td&gt;
&lt;td&gt;通过&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;详细设计代码实现&lt;/td&gt;
&lt;td&gt;MD&lt;/td&gt;
&lt;td&gt;实现代码结构&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;关于概要设计和详细设计可参考我另一篇隙 &amp;lt;&amp;lt;12、WRUP 最佳案例&amp;gt;&amp;gt; 中的 [Design 设计目录]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="_12"&gt;编码实现&lt;/h4&gt;
&lt;p&gt;编码实现是工程的最下层细化阶段, 其目的就是根据架构设计和详细设计实现和完成每个函数、每个类、每个模块、每个子系统、最终构成我们整个源代码部分.&lt;/p&gt;
&lt;p&gt;这个阶段, 所有剩余的构件和应用程序功能被开发并集成为产品, 所有的功能被详尽的单元测试.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编码实现的目标&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据设计完成具体函数的编写工作&lt;/li&gt;
&lt;li&gt;所有的功能代码被单元测试&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;产出&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发日志&lt;/li&gt;
&lt;li&gt;源代码及相关文件&lt;/li&gt;
&lt;li&gt;单元测试源代码文件&lt;/li&gt;
&lt;li&gt;Code Review 报告&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;阶段评审工作需要达到的状态列表&lt;/strong&gt;:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;产品&lt;/th&gt;
&lt;th&gt;责任人&lt;/th&gt;
&lt;th&gt;应该达到的状态&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;开发日志&lt;/td&gt;
&lt;td&gt;持续填写&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;原地吗及相关文件&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;单元测试源代码&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CodeReview&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="_13"&gt;单元验证&lt;/h4&gt;
&lt;p&gt;单元验证的目的是保证我们每个 Unit 编码的健壮性, 我们要求手动编码的单元验证函数覆盖率在 100%, 流程分支覆盖率在 80% 以上, 条件分支覆盖在 80% 以上, 边界值以及等价类覆盖在 50% 以上.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单元验证实现的目标&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据完成的功能函数进行单元测试，验证健全性&lt;/li&gt;
&lt;li&gt;对完成代码进行边界值验证，分支验证，等价类验证以及常规验证&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;产出&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单元测试代码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;阶段评审工作需要达到的状态列表&lt;/strong&gt;:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;产品&lt;/th&gt;
&lt;th&gt;责任人&lt;/th&gt;
&lt;th&gt;应该达到的状态&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;单元测试源代码&lt;/td&gt;
&lt;td&gt;Developer&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;单元测试结果报告&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="_14"&gt;集成构建&lt;/h4&gt;
&lt;p&gt;集成构建主要是指非表现层的各个模块之间, 各个层次之间的接口组合.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;集成构建实现的目标&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;除了界面层的最后搭建之外, 其余层次之间的接口组合要完成&lt;/li&gt;
&lt;li&gt;通过质量控制组的测试&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;产出&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集成构建进度表&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;阶段评审工作需要达到的状态列表&lt;/strong&gt;:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;产品&lt;/th&gt;
&lt;th&gt;责任人&lt;/th&gt;
&lt;th&gt;应该达到的状态&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;集成构建进度表&lt;/td&gt;
&lt;td&gt;Developer&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;集成构建覆盖表&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;集成构建评估表&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="_15"&gt;系统构建&lt;/h4&gt;
&lt;p&gt;系统构建首先是要对表现层与集成构建结果进行对接;&lt;/p&gt;
&lt;p&gt;其次, 系统构建要与非业务功能模块进行对接.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;系统构建实现的目标&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完成系统的整体构建, 达到内部测试的要求&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;产出&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完整的系统产品&lt;/li&gt;
&lt;li&gt;系统构建的进度表&lt;/li&gt;
&lt;li&gt;系统构建覆盖表&lt;/li&gt;
&lt;li&gt;系统构建评估表&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;阶段评审工作需要达到的状态列表&lt;/strong&gt;:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;产品&lt;/th&gt;
&lt;th&gt;责任人&lt;/th&gt;
&lt;th&gt;应该达到的状态&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;系统构建进度表&lt;/td&gt;
&lt;td&gt;Developer&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;完整的系统产品&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;系统构建覆盖表&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;系统构建评估表&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="_16"&gt;项目交付&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;阶段评审工作需要达到的状态列表&lt;/strong&gt;:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;产品&lt;/th&gt;
&lt;th&gt;责任人&lt;/th&gt;
&lt;th&gt;应该达到的状态&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;项目验收检查表&lt;/td&gt;
&lt;td&gt;Developer&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;项目竣工表&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;项目用户手册&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;项目内侧报告&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="_17"&gt;静态结构&lt;/h2&gt;
&lt;p&gt;开发流程定义了 &lt;strong&gt;谁&lt;/strong&gt;? &lt;strong&gt;何时&lt;/strong&gt;? &lt;strong&gt;如何&lt;/strong&gt;? &lt;strong&gt;做某事&lt;/strong&gt;? 四种主要的建模元素来表达.&lt;/p&gt;
&lt;h4 id="_18"&gt;角色&lt;/h4&gt;
&lt;p&gt;角色及职能如下, 注意, 这只是职能描述, 在多数情况下, 有些角色可以忽略, 有些可以一人兼任多职.&lt;/p&gt;
&lt;h6 id="pm"&gt;PM (项目经理)&lt;/h6&gt;
&lt;p&gt;工作职能描述:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;项目及产品研发管理,对项目成败直接负责.&lt;/li&gt;
&lt;li&gt;项目用人建议及学生的挑选.&lt;/li&gt;
&lt;li&gt;项目参与人员的培养和训练.&lt;/li&gt;
&lt;li&gt;与外包客户的沟通,包括售前,售后 .&lt;/li&gt;
&lt;li&gt;参与售前项目需求工作&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;担任此角色能力界定:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;3年以上的相关软件开发经验&lt;/li&gt;
&lt;li&gt;熟悉相关项目语言&lt;/li&gt;
&lt;li&gt;带领过8人以上团队开发过成熟商业项目,有成功案例.&lt;/li&gt;
&lt;/ol&gt;
&lt;h6 id="pdm"&gt;PDM (项目开发经理)&lt;/h6&gt;
&lt;p&gt;工作职能描述:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;项目及产品开发管理,主要管理项目中的开发团队 .直接对项目经理负责.&lt;/li&gt;
&lt;li&gt;积极接受培养及自我培养 . 负责对各个小组的组长直接管理 .&lt;/li&gt;
&lt;li&gt;制定产品开发计划,把握产品开发进度.&lt;/li&gt;
&lt;li&gt;协调与测试团队的合作,紧密的与测试经理配合.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;担任此角色能力界定:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;2 年以上相关软件开发经验.&lt;/li&gt;
&lt;li&gt;熟悉相关项目语言&lt;/li&gt;
&lt;li&gt;能独立完成同类项目.&lt;/li&gt;
&lt;li&gt;具有多个商业项目开发成功案例&lt;/li&gt;
&lt;/ol&gt;
&lt;h6 id="ptm"&gt;PTM (项目测试经理)&lt;/h6&gt;
&lt;p&gt;工作职能描述:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;项目及产品测试管理,主要管理项目中的测试团队 ,直接对项目经理负责&lt;/li&gt;
&lt;li&gt;积极接受培养及自我培养,负责对各个测试小组的组长直接管理&lt;/li&gt;
&lt;li&gt;制定产品测试计划,带领测试团队完成测试任务.把握产品测试计划&lt;/li&gt;
&lt;li&gt;监控产品开发进度,监控开发团队开发质量&lt;/li&gt;
&lt;li&gt;协调与开发团队的合作,紧密把握开发团队质量及进度&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;担任此角色能力界定:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;2年以上相关软件开发及软件测试经验.&lt;/li&gt;
&lt;li&gt;熟悉相关项目语言&lt;/li&gt;
&lt;li&gt;能独立完成同类项目.&lt;/li&gt;
&lt;li&gt;具有多个商业项目开发及测试成功案例&lt;/li&gt;
&lt;li&gt;熟悉软件测试各个流程&lt;/li&gt;
&lt;li&gt;具备一定的技术管理能力&lt;/li&gt;
&lt;/ol&gt;
&lt;h6 id="se"&gt;SE (支持工程师)&lt;/h6&gt;
&lt;p&gt;工作职能描述:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;开发服务器及开发环境平台搭建&lt;/li&gt;
&lt;li&gt;项目管理服务器及管理环境搭建&lt;/li&gt;
&lt;li&gt;项目仓库构建&lt;/li&gt;
&lt;li&gt;进行每日构建&lt;/li&gt;
&lt;li&gt;项目中相关文档的收集,整理及汇总&lt;/li&gt;
&lt;li&gt;进行项目配置管理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;担任此角色能力界定:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;熟悉各类服务器系统,Windows , Linux ,Unix&lt;/li&gt;
&lt;li&gt;熟悉各操作系统上开发环境的搭建&lt;/li&gt;
&lt;li&gt;熟悉网络基础&lt;/li&gt;
&lt;li&gt;熟练掌握各版本控制系统的管理&lt;/li&gt;
&lt;li&gt;系统的学习过软件配置管理内容.&lt;/li&gt;
&lt;li&gt;熟练搭建各类应用服务器,Web服务器&lt;/li&gt;
&lt;li&gt;具有软件开发能力,能进行每日构建工作&lt;/li&gt;
&lt;/ol&gt;
&lt;h6 id="ued"&gt;UED (用户体验设计师)&lt;/h6&gt;
&lt;p&gt;工作职能描述:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据用户体验设计软件布局,美化等工作&lt;/li&gt;
&lt;li&gt;根据需求原型文档,做出美化后的软件界面效果图.&lt;/li&gt;
&lt;li&gt;参与到需求过程中,设计用户体验&lt;/li&gt;
&lt;li&gt;根据设计的效果图,发布成静态网页,并且提供切好的素材(包括Logo,按钮等)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;担任此角色能力界定:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;具有较强的客户沟通能力&lt;/li&gt;
&lt;li&gt;具有较强的美术功底及审美能力&lt;/li&gt;
&lt;li&gt;具有软件界面设计经验&lt;/li&gt;
&lt;li&gt;熟练掌握各类设计工具(PS,Dreamwaver,Corldraw等)&lt;/li&gt;
&lt;li&gt;具有强烈的改善客户体验意识&lt;/li&gt;
&lt;/ol&gt;
&lt;h6 id="uie"&gt;UIE (用户接口工程师,前端工程师)&lt;/h6&gt;
&lt;p&gt;工作职能描述:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据UED提供的效果图及素材,规划整体页面设计 .&lt;/li&gt;
&lt;li&gt;编写DIV+CSS的界面实现&lt;/li&gt;
&lt;li&gt;公用界面组件的编写和规划&lt;/li&gt;
&lt;li&gt;Masterpage公用模板的编写及规划&lt;/li&gt;
&lt;li&gt;公用界面客户端脚本库的编写&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;担任此角色能力界定:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;身后的网页制作功底&lt;/li&gt;
&lt;li&gt;对Photoshop,Fireworks等工具基本掌握&lt;/li&gt;
&lt;li&gt;熟练编写DIV+CSS的页面布局方式&lt;/li&gt;
&lt;li&gt;熟练编写Javascript等客户端脚本&lt;/li&gt;
&lt;li&gt;熟悉项目相关语言及开发工具,有一定的后端代码编写能力&lt;/li&gt;
&lt;/ol&gt;
&lt;h6 id="pda"&gt;PDA (项目需求分析师)&lt;/h6&gt;
&lt;p&gt;工作职能描述:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;项目需求阶段进行需求分析的主要人员&lt;/li&gt;
&lt;li&gt;与项目经理,UED一起参与项目的需求阶段&lt;/li&gt;
&lt;li&gt;负责需求阶段素材及资料的收集整理&lt;/li&gt;
&lt;li&gt;负责需求阶段与客户确认工作&lt;/li&gt;
&lt;li&gt;完成功能规格说明书的编写&lt;/li&gt;
&lt;li&gt;配合UED完成界面原型的设计和实现&lt;/li&gt;
&lt;li&gt;负责需求分析报告的编写&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;担任此角色能力界定:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;较强的沟通能力及逻辑思维&lt;/li&gt;
&lt;li&gt;熟练使用Rose等UML建模工具&lt;/li&gt;
&lt;li&gt;熟练使用Office等各类制图,成文工具&lt;/li&gt;
&lt;li&gt;有较强的方案文字功底&lt;/li&gt;
&lt;li&gt;系统的学习和研究过软件需求分析过程与技能 .&lt;/li&gt;
&lt;li&gt;有较强的自我学习能力&lt;/li&gt;
&lt;/ol&gt;
&lt;h6 id="ad"&gt;AD (架构设计师)&lt;/h6&gt;
&lt;p&gt;工作职能描述:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;项目及产品的架构设计&lt;/li&gt;
&lt;li&gt;完成项目概要设计&lt;/li&gt;
&lt;li&gt;完成项目概要设计相关文档&lt;/li&gt;
&lt;li&gt;制定各类继承接口&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;担任此角色能力界定:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;3个以上项目的架构设计经验&lt;/li&gt;
&lt;li&gt;熟悉软件开发各类模式,并且善于总结模式&lt;/li&gt;
&lt;li&gt;熟练使用UML工具&lt;/li&gt;
&lt;li&gt;熟悉项目开发语言及工具&lt;/li&gt;
&lt;li&gt;具有较强的编程功底&lt;/li&gt;
&lt;/ol&gt;
&lt;h6 id="md"&gt;MD (模块设计师)&lt;/h6&gt;
&lt;p&gt;工作职能描述:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据概要设计,完成分配的模块的详细设计&lt;/li&gt;
&lt;li&gt;详细设计文档的实现&lt;/li&gt;
&lt;li&gt;详细设计代码的实现&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;担任此角色能力界定:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;熟练使用UML工具&lt;/li&gt;
&lt;li&gt;熟悉项目开发语言及工具&lt;/li&gt;
&lt;li&gt;具有较强的编程功底&lt;/li&gt;
&lt;/ol&gt;
&lt;h6 id="de"&gt;DE (开发工程师)&lt;/h6&gt;
&lt;p&gt;工作职能描述:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据详细设计进行编码实现&lt;/li&gt;
&lt;li&gt;完成自己模块的单元测试&lt;/li&gt;
&lt;li&gt;填写开发日志&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;担任此角色能力界定:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;熟悉项目开发语言及工具&lt;/li&gt;
&lt;li&gt;能正面压力工作&lt;/li&gt;
&lt;li&gt;不排斥加班&lt;/li&gt;
&lt;li&gt;熟练使用UML及版本控制工具&lt;/li&gt;
&lt;/ol&gt;
&lt;h6 id="te"&gt;TE (测试工程师)&lt;/h6&gt;
&lt;p&gt;工作职能描述:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据开发工程师提交代码进行各阶段测试&lt;/li&gt;
&lt;li&gt;设计测试用例&lt;/li&gt;
&lt;li&gt;执行测试工作&lt;/li&gt;
&lt;li&gt;填写Buglist .&lt;/li&gt;
&lt;li&gt;填写测试日志&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;担任此角色能力界定:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;熟悉项目开发语言及工具&lt;/li&gt;
&lt;li&gt;能正面压力工作&lt;/li&gt;
&lt;li&gt;不排斥加班&lt;/li&gt;
&lt;li&gt;熟练使用UML及版本控制工具&lt;/li&gt;
&lt;li&gt;熟悉测试理论&lt;/li&gt;
&lt;li&gt;熟练编写测试用力&lt;/li&gt;
&lt;li&gt;熟练使用各类测试工具(loadrunner等)&lt;/li&gt;
&lt;/ol&gt;
&lt;h6 id="dg"&gt;DG (开发组长)&lt;/h6&gt;
&lt;p&gt;工作职能描述:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;管理7人以内的开发工程师&lt;/li&gt;
&lt;li&gt;指定短期目标点&lt;/li&gt;
&lt;li&gt;抓小组成员执行力,监督小组开发工作&lt;/li&gt;
&lt;li&gt;也是一名开发工程师,参与开发&lt;/li&gt;
&lt;li&gt;制定小组开发计划&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;担任此角色能力界定:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;熟悉项目开发语言及工具&lt;/li&gt;
&lt;li&gt;能正面压力工作&lt;/li&gt;
&lt;li&gt;不排斥加班&lt;/li&gt;
&lt;li&gt;熟练使用UML及版本控制工具&lt;/li&gt;
&lt;li&gt;具有较强的责任心&lt;/li&gt;
&lt;li&gt;具有一定的组织能力&lt;/li&gt;
&lt;/ol&gt;
&lt;h6 id="tg"&gt;TG (测试组长)&lt;/h6&gt;
&lt;p&gt;工作职能描述:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;管理7人以内的测试工程师&lt;/li&gt;
&lt;li&gt;指定短期目标点&lt;/li&gt;
&lt;li&gt;抓小组成员执行力,监督小组测试工作&lt;/li&gt;
&lt;li&gt;也是一名测试工程师,参与测试&lt;/li&gt;
&lt;li&gt;制定小组测试计划&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;担任此角色能力界定:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;熟悉项目开发语言及工具&lt;/li&gt;
&lt;li&gt;能正面压力工作&lt;/li&gt;
&lt;li&gt;不排斥加班&lt;/li&gt;
&lt;li&gt;熟练使用UML及版本控制工具&lt;/li&gt;
&lt;li&gt;熟悉测试理论&lt;/li&gt;
&lt;li&gt;熟练编写测试用力&lt;/li&gt;
&lt;li&gt;熟练使用各类测试工具(loadrunner等)&lt;/li&gt;
&lt;li&gt;具有较强的责任心&lt;/li&gt;
&lt;li&gt;具有一定的组织能力&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="sandy"&gt;Sandy 未写完, 只有这么多…&lt;/h2&gt;
&lt;p&gt;其实总结起来的话, 也就几点:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;业务建模&lt;/strong&gt;, 一般就是客户、市场等前线人员出具的 &lt;strong&gt;word 文档&lt;/strong&gt;…&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需求阶段&lt;/strong&gt;, 以用例驱动, 也就是根据业务建模的 word 文档建立&lt;strong&gt;用例图&lt;/strong&gt;及&lt;strong&gt;原型图&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设计阶段&lt;/strong&gt;, 以类驱动, 根据需求阶段的产物建立&lt;strong&gt;时序图&lt;/strong&gt;、&lt;strong&gt;类图&lt;/strong&gt;、&lt;strong&gt;状态图&lt;/strong&gt;等.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开发阶段&lt;/strong&gt;, 就是根据设计阶段的产物去具体实现了.&lt;/p&gt;
&lt;p&gt;当然, 现在大部分开发会把 &lt;strong&gt;设计阶段&lt;/strong&gt; 和 &lt;strong&gt;开发阶段&lt;/strong&gt; 结合, 一边开发开边设计 (重构).&lt;/p&gt;
&lt;p&gt;测试、部署、交付就没什么可说的了…&lt;/p&gt;
&lt;h1 id="wrup_1"&gt;WRUP 最佳案例&lt;/h1&gt;
&lt;p&gt;Sandy 共享了一份项目案例, 我放到了我的&lt;a href="http://share.weiyun.com/5aa283a41c6887a9ee974995d3f9a499"&gt;微云&lt;/a&gt;上.&lt;/p&gt;
&lt;h2 id="_19"&gt;项目结构&lt;/h2&gt;
&lt;p&gt;首先, Sandy 推荐的项目结构如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i63.tinypic.com/aabv2f.jpg"/&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;工程根目录&lt;/strong&gt;
    + &lt;strong&gt;Design&lt;/strong&gt;: 设计目录
        * 数据库建模、系统设计 (系统设计分为概要设计和详细设计, 说明比较长, 这里说不清, 下面单独说 &lt;a href="#design"&gt;Design 设计目录&lt;/a&gt;)
    + &lt;strong&gt;Help&lt;/strong&gt;: 使用帮助目录
        * 使用培训、帮助文档等等
    + &lt;strong&gt;Logs&lt;/strong&gt;: 日志目录
        * 构建日志、个人日志等等
    + &lt;strong&gt;Planning&lt;/strong&gt;: 计划目录
        * 会议记录、邮件沟通记录、周报 (针对整个项目的周报, 非个人)、个人日计划等等
    + &lt;strong&gt;Publish&lt;/strong&gt;: 发布目录
        * 安装包、安装必读、客户验收文档等等
    + &lt;strong&gt;Requirement&lt;/strong&gt;: 需求目录
        * 需求说明书、词汇对照表、风险说明、用例图、UI 原型、需求变更等等
    + &lt;strong&gt;Source&lt;/strong&gt;: 源码目录
    + &lt;strong&gt;Study&lt;/strong&gt;: 学习目录
        * 开发新项目, 或多或少都会学习到新的知识, 参考新的源码, 这些项目的参考、学习文件都放在这
    + &lt;strong&gt;Test&lt;/strong&gt;: 测试目录
        * Bug List 管理、测试报告 (测试用例) 等
    + &lt;strong&gt;Readme.txt&lt;/strong&gt;: 工程说明
        * 这份源码是用来做什么的
        * 如何去使用
        * 项目中重要的文件和子目录的结构信息
        * 每个目录都可以有个 Readme, 用来对当前目录的子目录做解释&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上仅为 Sandy 推荐的结构, 实际可按照需要进行&lt;strong&gt;调整&lt;/strong&gt;, 例如:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Help&lt;/strong&gt; (使用帮助目录) 可以归纳到 &lt;strong&gt;Publish&lt;/strong&gt; (发布目录) 里&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Logs&lt;/strong&gt;  (日志目录) 可以归纳到 &lt;strong&gt;Planning&lt;/strong&gt; (计划目录) 里, 特别像&lt;em&gt;个人日志&lt;/em&gt;和&lt;em&gt;个人日计划&lt;/em&gt;完全可以结合, 每天早上先写好昨天的日志, 然后安排好今天的计划&lt;/li&gt;
&lt;li&gt;上面列出来的产出 (各种文档、报告) 不是必须的, 根据需要补充, 例如 &lt;strong&gt;Test&lt;/strong&gt; (测试目录) 里的 Bug List, 如果你采用 Redmine 或者 Bugzilla 等问题追踪系统, 完全可以去除 Bug List&lt;/li&gt;
&lt;li&gt;如果你有完善的版本控制体系, 要求每天写提交日志, 那么&lt;strong&gt;个人日志&lt;/strong&gt;也可以考虑省略, 演变成&lt;strong&gt;个人周报&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="design"&gt;Design 设计目录&lt;/h3&gt;
&lt;p&gt;参考文章:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.tuicool.com/articles/FVFFniy"&gt;UML在项目实施中的使用心得(概要设计阶段)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.tuicool.com/articles/ArYzM3V"&gt;UML在项目实施中的使用心得(详细设计阶段)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上面两篇文章大概总结为:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;概要设计&lt;/strong&gt;阶段使用 &lt;strong&gt;Deployment&lt;/strong&gt; 图、&lt;strong&gt;Component&lt;/strong&gt; 图、&lt;strong&gt;Sequence&lt;/strong&gt; 图、&lt;strong&gt;StateMachine&lt;/strong&gt; 图、&lt;strong&gt;Activity&lt;/strong&gt; 图描述清楚技术架构、部署方式、内外接口、主要流程和数据库结构等等;&lt;/p&gt;
&lt;p&gt;而在&lt;strong&gt;详细设计&lt;/strong&gt;阶段使用 &lt;strong&gt;Class&lt;/strong&gt; 图、&lt;strong&gt;Sequence&lt;/strong&gt; 图、&lt;strong&gt;StateMachine&lt;/strong&gt; 图、&lt;strong&gt;Activity&lt;/strong&gt; 图与代码设计相结合, 描述实际代码中方法、属性间的关系及协作流程, 甚至需要伪代码.&lt;/p&gt;
&lt;p&gt;可以看出来:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;概要设计&lt;/strong&gt;是黑盒设计, 体现的是各模块间的关系&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;详细设计&lt;/strong&gt;是白盒设计, 体现代码中类、实例、方法、属性间的关系&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一些人以为 UML 建模一上来就要画许多很精细的图, 这是&lt;strong&gt;误解&lt;/strong&gt; !!&lt;/p&gt;
&lt;p&gt;如今敏捷开发一般&lt;strong&gt;不&lt;/strong&gt;推荐&lt;strong&gt;详细设计&lt;/strong&gt;, 将系统设计、概要设计、详细设计合并为&lt;strong&gt;架构&lt;/strong&gt; (Architecture) 设计, 对系统和架构作出一种初步、稳定的分解，是常见的一种敏捷开发、敏捷建模实践;&lt;/p&gt;
&lt;p&gt;而且程序猿个个都有极强的创造精神, 有相当一部分不大喜欢别人把详细设计做的太细, 以便发挥下自己的创造力 (初级设计能力);&lt;/p&gt;
&lt;p&gt;不过仁者见仁, 智者见智, 因为一个初级的程序猿如果先是看别人的设计, 然后再开始自己的设计, 也许学习曲线就不会那么陡峭, 日子也会过的舒服一点儿也未可知.&lt;/p&gt;
&lt;p&gt;所以说, 如果一个团队里的新手较多, 还是推荐使用&lt;strong&gt;详细设计&lt;/strong&gt;的, 否则不推荐使用.&lt;/p&gt;
&lt;h2 id="_20"&gt;需求分析&lt;/h2&gt;
&lt;h3 id="_21"&gt;项目评估阶段&lt;/h3&gt;
&lt;p&gt;项目评估是做需求分析的首要条件, 当接到一个需求, 我们要先对这个需求做下评估, 确定能不能做, 如果能做的话, 才会去做需求分析.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目的设想和业务案例参考&lt;/li&gt;
&lt;li&gt;是否可行&lt;/li&gt;
&lt;li&gt;粗略估计成本&lt;/li&gt;
&lt;li&gt;能获取到的支持&lt;/li&gt;
&lt;li&gt;......&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个阶段一般是很快速的, 最短可能就是一次项目可行性研讨会…&lt;/p&gt;
&lt;p&gt;产出:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;评估报告&lt;/li&gt;
&lt;li&gt;立项&lt;/li&gt;
&lt;li&gt;资源计划&lt;/li&gt;
&lt;li&gt;技术难点重点&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_22"&gt;需求分析阶段&lt;/h3&gt;
&lt;h5 id="_23"&gt;需求阶段步骤&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;第一次需求及设计 (评估及非功能)&lt;/li&gt;
&lt;li&gt;第二次需求及设计 (领域边界, 即系统可能包含哪些模块, 子系统)&lt;/li&gt;
&lt;li&gt;第三次需求及设计 (功能)&lt;/li&gt;
&lt;li&gt;第四次需求及设计 (界面)&lt;/li&gt;
&lt;li&gt;不断迭代&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上是细分后的情况, 大部分情况下, 可以只有 &lt;strong&gt;功能&lt;/strong&gt; 和 &lt;strong&gt;界面&lt;/strong&gt;.&lt;/p&gt;
&lt;h5 id="_24"&gt;迭代式需求&lt;/h5&gt;
&lt;p&gt;&lt;img alt="" src="http://i66.tinypic.com/bhg0th.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;我们依照 RUP 流程, 先启 -&amp;gt; 精化 -&amp;gt; 构建 -&amp;gt; 产品化 的 4 个阶段, 总结出需求的四要素及五原则:&lt;/p&gt;
&lt;p&gt;四要素:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;环境和前提 (给谁用, 用多久, 用在什么地方, 需不需要暴露接口等等)&lt;/li&gt;
&lt;li&gt;R (静态), 系统、子系统、模块、子模块 (用例图中的 &lt;strong&gt;Package&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;P (动态), 即上一步的静态结构的动态行为, 与上一步结合就形成了完整的&lt;strong&gt;用例图&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;界面原型, 可用工具有 Visio、Axure、Mockups、Blend 等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;五原则:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;沟通、建模、成文&lt;/li&gt;
&lt;li&gt;文不如表、表不如图&lt;/li&gt;
&lt;li&gt;至顶而下, 逐层细分&lt;/li&gt;
&lt;li&gt;业务 = (R &amp;amp; P)&lt;/li&gt;
&lt;li&gt;拥抱变化, 不断重构&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="_25"&gt;三轴线&lt;/h5&gt;
&lt;p&gt;三轴线框架: X 横向功能需求, Y 纵向功能需求, Z非功能需求&lt;/p&gt;
&lt;p&gt;X 轴是贯穿整个系统模块的, 是被依赖的功能模块, 比如权限系统&lt;/p&gt;
&lt;p&gt;Y 轴是相对独立的功能需求, 例如菜单的顶层结构, 互不影响, 可以算是单独的功能性需求, 它不依赖别的模块&lt;/p&gt;
&lt;p&gt;Z 轴是我们的非功能模块, 比如安全性, 健壮性, 美观性等等, 包括我们的日志系统, 也是非功能性需求&lt;/p&gt;
&lt;h5 id="_26"&gt;需求成文&lt;/h5&gt;
&lt;p&gt;在开发者角度, UML 就是文档、是”文”.&lt;/p&gt;
&lt;p&gt;但是最终你还是要给客户、给老板需求报告, 虽说 “文不如表、表不如图”, 但他们看不懂 UML 图, 这时就需要把 UML 图转成 Word 文档了…&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;, 这里的需求文档, 不是客户给的原始需求文档, 而你根据 UML 转化而来的文档, 是要提供给客户、老板的, 所以在大纲上, 也是遵循需求 4 要素, 简单的说, 就是用 word 文档解释 UML.&lt;/p&gt;
&lt;h2 id="_27"&gt;系统设计&lt;/h2&gt;
&lt;h3 id="_28"&gt;什么是系统设计&lt;/h3&gt;
&lt;p&gt;到了这一步, 说明你最起码已经迭代过一轮需求分析了, 而系统设计, 就是根据需求分析阶段的产出 (即系统模块、功能要求等), 设计出一个符合 &lt;strong&gt;GRASP&lt;/strong&gt; &amp;amp; &lt;strong&gt;SOLID&lt;/strong&gt; 的软件架构 (什么是 GRASP &amp;amp; SOLID, 后面再介绍).&lt;/p&gt;
&lt;p&gt;这个阶段的任务是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设计软件系统的模块层次结构&lt;/li&gt;
&lt;li&gt;设计数据库的结构&lt;/li&gt;
&lt;li&gt;设计模块的控制流程&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个阶段又分两个步骤: &lt;strong&gt;概要设计&lt;/strong&gt;和&lt;strong&gt;详细设计&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;概要设计是&lt;strong&gt;黑盒&lt;/strong&gt;设计, 解决软件系统的模块划分和模块的层次机构以及数据库设计, 详细设计是&lt;strong&gt;白盒&lt;/strong&gt;设计, 解决每个模块的控制流程, 内部算法和数据结构的设计.&lt;/p&gt;
&lt;p&gt;现在有些敏捷开发思想, 不推荐使用&lt;em&gt;详细设计&lt;/em&gt;, 将系统设计阶段统称为&lt;strong&gt;架构设计&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;也就是说, 这个阶段的任务从上面的三条, 变为两条 (即不进行详细设计, 不涉及具体算法、流程):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设计软件系统的模块层次结构&lt;/li&gt;
&lt;li&gt;设计数据库的结构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外要注意, 在需求阶段, 我们用用例图中的&lt;strong&gt;Package&lt;/strong&gt;来表达系统、子系统、模块、子模块间的关系, 但这和系统设计阶段的模块层次&lt;strong&gt;不是&lt;/strong&gt;一一对应的, 确切的说需求阶段的模块划分表达的是更上层的东西, 即功能模块的划分, 而系统设计阶段的模块划分则是从软件工程角度出发, 应该按 GRASP &amp;amp; SOLID, 是两种完全不同的概念.&lt;/p&gt;
&lt;h3 id="grasp-solid"&gt;GRASP &amp;amp; SOLID&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;SOLID&lt;/strong&gt;, 这是描述设计原则的一个专业术语, 由我们可爱的代码整洁之道传教者鲍勃 (罗伯特C. 马丁) 大叔提出, 是一组用于指导我们如何写出”好代码”的原则.&lt;/p&gt;
&lt;p&gt;SOLID 的解释为:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Single responsibility principle (单一职责原则)&lt;/li&gt;
&lt;li&gt;Open/closed principle (打开/关闭原则)&lt;/li&gt;
&lt;li&gt;Liskov substitution principle (里氏替换原则)&lt;/li&gt;
&lt;li&gt;Interface segregation principle (接口隔离原则)&lt;/li&gt;
&lt;li&gt;Dependency inversion principle (依赖倒置原则)&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;关于这几个原则的定义, 参考我另一篇笔记: &lt;a href="http://blog.smallcpp.cn/6-cliu-da-she-ji-yuan-ze.html"&gt;六大设计原则&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;GRASP&lt;/strong&gt;, 全称为General Responsibility Assignment Software Pattern, 即&lt;strong&gt;通用职责分配软件模式&lt;/strong&gt;, 它由《UML 和模式应用》 (Applying UML and Patterns) 一书作者 Craig Larman 提出.&lt;/p&gt;
&lt;p&gt;GRASP 是对象职责分配的基本原则, 其核心思想是&lt;strong&gt;职责分配&lt;/strong&gt; (Responsibility Assignment), 用职责设计对象 (Designing Objects with Responsibilities).&lt;/p&gt;
&lt;p&gt;GRASP 包括以下内容:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Information Expert (信息专家模式)&lt;/li&gt;
&lt;li&gt;Creator (创造者模式)&lt;/li&gt;
&lt;li&gt;Controller (控制器模式)&lt;/li&gt;
&lt;li&gt;Low Coupling (低耦合模式)&lt;/li&gt;
&lt;li&gt;High Cohesion (高内聚模式)&lt;/li&gt;
&lt;li&gt;Polymorphism (多态模式)&lt;/li&gt;
&lt;li&gt;Pure Fabrication (纯虚构模式)&lt;/li&gt;
&lt;li&gt;Indirection (中介模式)&lt;/li&gt;
&lt;li&gt;Protected Variations (受保护变化模式)&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;关于这几个模式的定义, 参考我另一篇笔记: &lt;a href="http://blog.smallcpp.cn/3-cshe-ji-mo-shi-yu-grasp.html"&gt;设计模式与 GRASP&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;GRASP 与 SOLID 是有相通的地方的:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Information Expert 与 Single responsibility principle&lt;/li&gt;
&lt;li&gt;Protected Variations 与 Open/closed principle&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;GRASP &amp;amp; SOLID 是 GOF (二十三种设计模式) 的基础, GOF 只是在某些情景下对 GRASP &amp;amp; SOLID 的具体实践.&lt;/p&gt;
&lt;p&gt;GRASP 以&lt;strong&gt;职责驱动设计&lt;/strong&gt;, 什么是职责呢?&lt;/p&gt;
&lt;p&gt;简单地说, 一个类或构件的职责包括两个方面: 一个是&lt;strong&gt;知道&lt;/strong&gt;的事, 对于一个类来说就是他的属性; 一个是&lt;strong&gt;能做&lt;/strong&gt;的事, 对于一个类来说就是他的方法.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“知道”职责 —— 表示这个类, 它”知道”些什么
    + 了解私有封装数据
    + 了解关联的对象
    + 了解能够派生或计算的事物&lt;/li&gt;
&lt;li&gt;“行为”职责 —— 表示这类类, 它可以”做”什么
    + 完成对象初始化
    + 执行一些控制行为&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;职责的分配可使用&lt;strong&gt;时序图&lt;/strong&gt;或&lt;strong&gt;协作图&lt;/strong&gt;来表达, 面向对象设计过程就是将责任分配给类的过程.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例子:&lt;/strong&gt; 在一个销售软件中存在一个交费行为, 此时, 就可将交费识别为一个”行为”职责.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“行为”职责表示交费的行为, 需要创建一个付款记录的对象 Payment&lt;/li&gt;
&lt;li&gt;“知道”职责必须知道付款记录类 Payment，知道如何记录及计算 Payment 类中的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="http://i67.tinypic.com/nmxmyp.jpg"/&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发现具有交费行为的对象 Sale&lt;/li&gt;
&lt;li&gt;发现了该类还关联另一个类对象 Payment&lt;/li&gt;
&lt;/ul&gt;</content><category term="软件工程"></category></entry><entry><title>使用 StarUML 绘制 UML</title><link href="http://www.smallcpp.cn/shi-yong-staruml-hui-zhi-uml.html" rel="alternate"></link><published>2016-07-29T11:07:00+08:00</published><updated>2016-07-29T11:07:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-07-29:/shi-yong-staruml-hui-zhi-uml.html</id><summary type="html">
&lt;h1 id="uml-staruml"&gt;UML 架构及 StarUML&lt;/h1&gt;
&lt;h2 id="uml"&gt;UML 架构&lt;/h2&gt;
&lt;p&gt;UML 图形分类:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象图
    + 类图
    + 组件图
    + 部署图&lt;/li&gt;
&lt;li&gt;交互图
    + 用例图
    + 时序图
    + 协作图
    + 活动图&lt;/li&gt;
&lt;li&gt;状态图
    + 状态图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="http://www.ibm.com/developerworks/cn/rational/r-uml/"&gt;参考文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里重点学习 &lt;strong&gt;用例图、时序图 和 类图&lt;/strong&gt; 三张图.&lt;/p&gt;
&lt;h2 id="staruml"&gt;StarUML&lt;/h2&gt;
&lt;p&gt;StarUML 5.0 貌似是最后一个免费版本 …&lt;/p&gt;</summary><content type="html">
&lt;h1 id="uml-staruml"&gt;UML 架构及 StarUML&lt;/h1&gt;
&lt;h2 id="uml"&gt;UML 架构&lt;/h2&gt;
&lt;p&gt;UML 图形分类:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象图
    + 类图
    + 组件图
    + 部署图&lt;/li&gt;
&lt;li&gt;交互图
    + 用例图
    + 时序图
    + 协作图
    + 活动图&lt;/li&gt;
&lt;li&gt;状态图
    + 状态图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="http://www.ibm.com/developerworks/cn/rational/r-uml/"&gt;参考文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里重点学习 &lt;strong&gt;用例图、时序图 和 类图&lt;/strong&gt; 三张图.&lt;/p&gt;
&lt;h2 id="staruml"&gt;StarUML&lt;/h2&gt;
&lt;p&gt;StarUML 5.0 貌似是最后一个免费版本…&lt;/p&gt;
&lt;p&gt;安装好后运行, 会让选一个 approach (入口), 直接点 Cancel 就好, 会以默认的视图打开 StarUML.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i66.tinypic.com/dde2rr.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;也可以选择 Rational, 这种 approach 用的也比较多.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i65.tinypic.com/260psvn.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i64.tinypic.com/14t6iyh.jpg"/&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;用例视图&lt;/strong&gt;(Use Case View), 包含系统中所有的参与者、用例和用例图, Use Case View 在系统中可以看成是一个独立的实现, 它侧重用高级别的视图表明系统做什么, 而不用考虑具体的实现&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;逻辑视图&lt;/strong&gt;(Logical View), 重点描述在系统中如何实现用例, 它提供系统各模块的详细视图, 并描述这些模块之间的关系, Logical View 包含对一些类图、时序图和状态图, 通过这些具体的元素, 开发者可以对系统构建具体的设计&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;组件视图&lt;/strong&gt;(Component View), 包含的信息有代码库、可执行文件、运行时库，还有在模型中的其他组件, 一个组件就是一个物理的编码模块&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;发布视图&lt;/strong&gt;(Deployment View), 关于系统的物理发布, 它不同于系统的逻辑架构&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="uml_1"&gt;UML 用例图&lt;/h1&gt;
&lt;p&gt;用例, 是帮助角色确定&lt;strong&gt;系统使用情况&lt;/strong&gt;的 UML 组件&lt;/p&gt;
&lt;p&gt;用例组, 是从用户角度出发对&lt;strong&gt;如何使用系统的描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用例图, 用图形的方式来描述情景, 主要用来描述 “&lt;strong&gt;用户&lt;/strong&gt;、&lt;strong&gt;需求&lt;/strong&gt;、&lt;strong&gt;系统功能单元&lt;/strong&gt;” 之间的关系, 它展示了一个外部用户能够观察到的系统功能模型, 也就是说, 它应该是从&lt;strong&gt;用户&lt;/strong&gt;的角度来描述系统, 而非开发者.&lt;/p&gt;
&lt;h2 id="_1"&gt;用例卡片&lt;/h2&gt;
&lt;p&gt;在用例图出现之前, 当需要去客户那讨论某些功能的需求时, 常常会带上一堆的 “卡片”, 每张卡片上都是一张&lt;strong&gt;用例表单&lt;/strong&gt;, 讨论过程中按照客户的要求填写这个表单, 等讨论结束, 就按这个表单的内容进行开发, 这个记录了需求表单的卡片, 就叫它 “&lt;strong&gt;用例卡片&lt;/strong&gt;”, 下面是一个&lt;strong&gt;登录功能&lt;/strong&gt;的用例卡片.&lt;/p&gt;
&lt;p&gt;&lt;img alt="用例图" src="http://i63.tinypic.com/2u53yvb.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;通过这张卡片, 可以总结出一些&lt;strong&gt;用例要素&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参与者
    + 包括使用者、系统用户和其它交互的系统&lt;/li&gt;
&lt;li&gt;前置条件&lt;/li&gt;
&lt;li&gt;场景中的步骤
    + 事件流&lt;/li&gt;
&lt;li&gt;后置条件&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="staruml_1"&gt;StarUML 用例图&lt;/h2&gt;
&lt;p&gt;打开 StarUML, 选择 &lt;strong&gt;Rational Approach&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;StarUML 界面右侧的 &lt;strong&gt;Model Explorer&lt;/strong&gt; 中 &amp;lt;&amp;lt;&lt;strong&gt;use case view&lt;/strong&gt;&amp;gt;&amp;gt; 就是用例图 view, 我们要添加用例图, 就要在这个 view 下添加.&lt;/p&gt;
&lt;p&gt;&amp;lt;&amp;lt;&lt;strong&gt;use case view&lt;/strong&gt;&amp;gt;&amp;gt; 自带了一个 &lt;strong&gt;Main&lt;/strong&gt; 用例图, 点击下 &amp;lt;&amp;lt;&lt;strong&gt;use case view&lt;/strong&gt;&amp;gt;&amp;gt; 下的 Main, 在StarUML 界面左侧, 就打开了用例图工具栏.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i66.tinypic.com/9uwxo1.jpg"/&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;StarUML&lt;/th&gt;
&lt;th&gt;翻译&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Package&lt;/td&gt;
&lt;td&gt;包&lt;/td&gt;
&lt;td&gt;分类、模块、子模块&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;类比文件夹的功能&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UseCase&lt;/td&gt;
&lt;td&gt;用例&lt;/td&gt;
&lt;td&gt;描述一个用户的具体动作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;要求是&lt;strong&gt;动宾短语&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Actor&lt;/td&gt;
&lt;td&gt;角色&lt;/td&gt;
&lt;td&gt;执行者&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;包括用户、后台系统员或者其他系统&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Association&lt;/td&gt;
&lt;td&gt;关联&lt;/td&gt;
&lt;td&gt;表示参与者与用例之间可以通信&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DirecteAssociation&lt;/td&gt;
&lt;td&gt;定向关联&lt;/td&gt;
&lt;td&gt;也表示参与者与用例之间可以通信, 但是用箭头表示通信方向&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;箭头&lt;/strong&gt;指向消息接收方&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Generalization&lt;/td&gt;
&lt;td&gt;泛化&lt;/td&gt;
&lt;td&gt;继承关系&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;子用例和父用例相似, 但表现出更特别的行为&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;子用例将继承父用例的所有结构、行为和关系&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;箭头&lt;/strong&gt;指向父用例&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Dependency&lt;/td&gt;
&lt;td&gt;依赖&lt;/td&gt;
&lt;td&gt;源用例依赖于目标用例&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;如冰箱依赖插头, 去食堂吃饭依赖于有餐卡&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;箭头&lt;/strong&gt;指向目标用例&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Include&lt;/td&gt;
&lt;td&gt;包含&lt;/td&gt;
&lt;td&gt;用来把一个较复杂用例所表示的功能进行分解&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;包含属于依赖的一种&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;箭头&lt;/strong&gt;指向分解出来的子用例&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Extend&lt;/td&gt;
&lt;td&gt;扩展&lt;/td&gt;
&lt;td&gt;指用例功能的延伸&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;相当于在&lt;strong&gt;一定条件下&lt;/strong&gt;为基础用例提供一个附加功能&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;如, 只有在书籍丢失用例成立的情况下才会触发补偿用例&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;箭头&lt;/strong&gt;指向基础用例&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;System Boundary&lt;/td&gt;
&lt;td&gt;系统边界&lt;/td&gt;
&lt;td&gt;用来把一些联系紧密的用例包含起来&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;一般认为被包含的用例共同完成某一功能&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;而边界外的用例则与这个功能无关&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Extend (扩展) 图样示例:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i63.tinypic.com/bdn036.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;只有当 “&lt;strong&gt;失书&lt;/strong&gt;” 的扩展点发生后, 才会触发补偿的用例.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;小技巧:&lt;/p&gt;
&lt;p&gt;当发现线条不规整时, 可选中该线条, 按 &lt;strong&gt;Ctrl + L&lt;/strong&gt; 来自动规整.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于每个图样, 可以在 StarUML &lt;strong&gt;右下方&lt;/strong&gt;设置其属性:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i67.tinypic.com/2le6rnp.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;对于用例图来说, 我们只关心它的 Name 和 Stereotype 属性, 后面的 Visibility、IsAbstract、Attributes、Operations 在画类图的时候才会有所体现.&lt;/p&gt;
&lt;p&gt;当然你也可以在 &amp;lt;&amp;lt;&lt;strong&gt;use case view&lt;/strong&gt;&amp;gt;&amp;gt; 上右键选择新添加用例图:&lt;/p&gt;
&lt;p&gt;&amp;lt;&amp;lt;&lt;strong&gt;use case view&lt;/strong&gt;&amp;gt;&amp;gt; --&amp;gt; Add Diagram --&amp;gt; Use Case Diagram&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i66.tinypic.com/2zp5n6h.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;在 StarUML 左侧, 除了 UseCase 的工具栏外, 还有一个&lt;strong&gt;注释&lt;/strong&gt;工具栏 (Annotation), 这个工具栏是所有 UML 图形通用的:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;StarUML&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Text&lt;/td&gt;
&lt;td&gt;文本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Note&lt;/td&gt;
&lt;td&gt;注释&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NoteLink&lt;/td&gt;
&lt;td&gt;注释连接线&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Rectangle&lt;/td&gt;
&lt;td&gt;矩形&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Elipse&lt;/td&gt;
&lt;td&gt;椭圆&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Rounded Rectangle&lt;/td&gt;
&lt;td&gt;圆角矩形&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这里我们常用的是 &lt;strong&gt;Note&lt;/strong&gt; 和 &lt;strong&gt;NoteLink&lt;/strong&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;小技巧:&lt;/p&gt;
&lt;p&gt;当使用图形时, 可以在工具栏上设置图形的层次.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i63.tinypic.com/ipbcd1.jpg"/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;关于删除&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你在 StarUML 画布上拖入某个图样, 那么直接在画布上删除仅仅是在画布上删除它, 它还是在右边的 Model Explorer 中, 必须要在 Model Explorer 中删除才是真的删除, 或者在画布上 Ctrl + Del 删除.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于用例图设计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通常情况下, 一个系统可能会被我们分为几个&lt;strong&gt;模块&lt;/strong&gt;, 每个模块都完成独立的功能, 我们把这些模块用 &lt;strong&gt;Package&lt;/strong&gt; 表示, 在 &lt;strong&gt;Main&lt;/strong&gt; 视图下列出大纲, 然后在每个 &lt;strong&gt;Package&lt;/strong&gt; 下画各自的 &lt;strong&gt;UseCase&lt;/strong&gt;, 如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i67.tinypic.com/2moa45i.jpg"/&gt;&lt;/p&gt;
&lt;h1 id="uml_2"&gt;UML 状态图&lt;/h1&gt;
&lt;h2 id="_2"&gt;状态图概述&lt;/h2&gt;
&lt;p&gt;状态图是一种”开关”, 描述的是&lt;strong&gt;状态变化&lt;/strong&gt;的图形, 即&lt;strong&gt;一个&lt;/strong&gt;对象&lt;strong&gt;状态&lt;/strong&gt;与&lt;strong&gt;状态的转变&lt;/strong&gt;, 并且给出了状态变化的&lt;strong&gt;起点&lt;/strong&gt;和&lt;strong&gt;终点&lt;/strong&gt;, 类比&lt;strong&gt;流程图&lt;/strong&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;使用场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;需要描述一个对象的状态跟踪的时候, 比如一个表单在不同环节审批的状态&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 StarUML 中新建状态图:&lt;/p&gt;
&lt;p&gt;打开 StarUML, 选择 &lt;strong&gt;Rational Approach&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&amp;lt;&amp;lt;&lt;strong&gt;Logical View&lt;/strong&gt;&amp;gt;&amp;gt; --&amp;gt; Add Diagram --&amp;gt; Statechart Diagram&lt;/p&gt;
&lt;p&gt;界面左边就出现了 Statechart 工具栏.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;StarUML&lt;/th&gt;
&lt;th&gt;翻译&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;State&lt;/td&gt;
&lt;td&gt;状态节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SubmachineState&lt;/td&gt;
&lt;td&gt;状态子节点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;InitialState&lt;/td&gt;
&lt;td&gt;初始状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FinalState&lt;/td&gt;
&lt;td&gt;结束状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JunctionPoint&lt;/td&gt;
&lt;td&gt;交汇点(两条状态传递线交汇处)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ChoicePoint&lt;/td&gt;
&lt;td&gt;选择点(又叫进入节点)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ShallowHistory&lt;/td&gt;
&lt;td&gt;浅层历史状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DeepHistory&lt;/td&gt;
&lt;td&gt;深层历史状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Synchronization&lt;/td&gt;
&lt;td&gt;同步&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Flow Final&lt;/td&gt;
&lt;td&gt;对象流程结束(退出节点)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Transition&lt;/td&gt;
&lt;td&gt;状态传递&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SelfTransition&lt;/td&gt;
&lt;td&gt;自我状态传递&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="_3"&gt;核心要素&lt;/h2&gt;
&lt;p&gt;对于状态图来说, 最为&lt;strong&gt;核心&lt;/strong&gt;的元素无外乎是两个:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个是用圆角矩形表示的状态(State)&lt;/li&gt;
&lt;li&gt;一个则是在状态之间的、包含一些文字描述的有向箭头线(Transition), 这些箭头线称为状态传递&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="http://i63.tinypic.com/29z3ifl.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i67.tinypic.com/2rcy7v6.jpg"/&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源状态: 即受转换影响的状态&lt;/li&gt;
&lt;li&gt;目标状态: 当转换完成后对象的状态&lt;/li&gt;
&lt;li&gt;触发事件: 用来为转换定义一个事件, 包括调用、改变、信号、时间四类事件&lt;/li&gt;
&lt;li&gt;监护条件: 布尔表达式, 决定是否激活转换&lt;/li&gt;
&lt;li&gt;动作: 转换激活时的操作&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_4"&gt;状态动作&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;状态节点有三个内部动作&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EntryActiors, 进入状态时触发的动作&lt;/li&gt;
&lt;li&gt;DoActions, 状态中执行的动作&lt;/li&gt;
&lt;li&gt;ExitActions, 退出状态时触发的动作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然, 这三个事件都不是必须的, 根据需求来填写.&lt;/p&gt;
&lt;p&gt;例如在上例中, 对象状态转移后的动作(&lt;strong&gt;烧水&lt;/strong&gt;), 是显示在箭头线上, 也可以定义&lt;strong&gt;进入动作&lt;/strong&gt;(EntryActions)来描述转换激活时的操作&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i64.tinypic.com/fuuwb4.jpg"/&gt;&lt;/p&gt;
&lt;h2 id="_5"&gt;复合状态&lt;/h2&gt;
&lt;p&gt;另外, 在某些时候, 还可以使用&lt;strong&gt;复合状态&lt;/strong&gt;, 它表示在某一状态中, 还维护着其它的状态.&lt;/p&gt;
&lt;p&gt;如, 在电脑运行的时候, 还会维护一个待机的状态.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i68.tinypic.com/34qmj9v.jpg"/&gt;&lt;/p&gt;
&lt;h2 id="_6"&gt;退出/进入节点&lt;/h2&gt;
&lt;p&gt;上面的图中, 除了用到了&lt;strong&gt;复合状态&lt;/strong&gt;外, 还使用了&lt;strong&gt;退出节点&lt;/strong&gt;(Flow Final), 它表示状态可以有多个退出事件, 如&lt;strong&gt;上图&lt;/strong&gt;中的 &lt;em&gt;长按电源键&lt;/em&gt; 或者 &lt;em&gt;断电&lt;/em&gt;, 都会触发 running 状态的退出.&lt;/p&gt;
&lt;p&gt;除了&lt;strong&gt;退出节点&lt;/strong&gt;(Flow Final)外, 还有个 &lt;strong&gt;ChoicePoint&lt;/strong&gt;(选择节点, 又叫进入节点), 它表示一个状态有多个进入事件, 就不放图举例了.&lt;/p&gt;
&lt;h2 id="_7"&gt;子节点&lt;/h2&gt;
&lt;p&gt;再来看看 &lt;strong&gt;SubmachineState&lt;/strong&gt;(状态子节点), 它所以表示的是该状态是另一个状态(称之为母状态)的子状态, 母状态中以&lt;strong&gt;引用&lt;/strong&gt;的方式把一个已经存在的状态作为自己子状态, 在母状态机中子机状态作为一个子状态, 但它自身仍是一个&lt;strong&gt;完整的状态&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i65.tinypic.com/14tylx3.jpg"/&gt;&lt;/p&gt;
&lt;h2 id="_8"&gt;历史状态&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;ShallowHistory&lt;/strong&gt;(历史状态), 为一个状态提供了一种在退出状态时记忆当前活动所处的子状态, 并能够返回到该子状态的机制.&lt;/p&gt;
&lt;p&gt;例如下图, 当发生暂停时, 记住播放状态, 当继续播放时就直接进入播放状态.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i63.tinypic.com/15wjlmh.jpg"/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;StarUML 中有 &lt;strong&gt;ShallowHistory&lt;/strong&gt; 和 &lt;strong&gt;DeepHistory&lt;/strong&gt;, 但在大多情况下是随便用哪个, 并没有做太多要求, 只要表达清楚这里是一个”历史”就可以了.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="_9"&gt;同步&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Synchronization&lt;/strong&gt; 又分两种, 分叉与汇合.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分叉: 指将一个转换分成两个或多个转换, 用来描述需要&lt;strong&gt;并发&lt;/strong&gt;的状态&lt;/li&gt;
&lt;li&gt;汇合: 指将从并发状态来的转换合并形成一个转换, 用来描述多个并发状态的控制&lt;strong&gt;同步&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="http://i68.tinypic.com/2aafsxy.jpg"/&gt;&lt;/p&gt;
&lt;h1 id="uml_3"&gt;UML 时序图&lt;/h1&gt;
&lt;h2 id="_10"&gt;时序图概述&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;何谓时序图&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;简单的说, 就是描述一个时间段内不同对象之间的业务情况(时间顺序).&lt;/p&gt;
&lt;p&gt;时序图的重点在&lt;strong&gt;消息时序&lt;/strong&gt;上, 也就是说, 描述&lt;strong&gt;消息&lt;/strong&gt;是如何在对象间发送和接收的, 表示了对象之间传递消息的时间顺序.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时序图与用例图&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;时序图表示了&lt;strong&gt;系统&lt;/strong&gt;与&lt;strong&gt;参与者&lt;/strong&gt;互动执行某一个&lt;strong&gt;用例&lt;/strong&gt;期间, 系统内部对象间的协作情况.&lt;/p&gt;
&lt;p&gt;对于程序设计来说, 一个用例就对应一个时序图, 时序图是对系统的内部行为进行描述, 用于用例分析和设计阶段.&lt;/p&gt;
&lt;p&gt;在项目的需求阶段, 架构师会根据把&lt;strong&gt;用例图&lt;/strong&gt;细化为一个或者更多的时序图.&lt;/p&gt;
&lt;p&gt;虽然在开发者看来, 时序图描述的是模块(类)间的交互, 然而, 现在时序图也常常被&lt;strong&gt;业务人员&lt;/strong&gt;用来描述业务的流程.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在 StarUML 中新建时序图&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;打开 StarUML, 选择 &lt;strong&gt;Rational Approach&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&amp;lt;&amp;lt;&lt;strong&gt;Logical View&lt;/strong&gt;&amp;gt;&amp;gt; --&amp;gt; Add Diagram --&amp;gt; Sequence Diagram&lt;/p&gt;
&lt;p&gt;界面左边就出现了 Sequence 工具栏.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;StarUML&lt;/th&gt;
&lt;th&gt;翻译&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Object&lt;/td&gt;
&lt;td&gt;对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Stimulus&lt;/td&gt;
&lt;td&gt;消息传递&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SelfStimulus&lt;/td&gt;
&lt;td&gt;自我消息传递&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Combined Fragment&lt;/td&gt;
&lt;td&gt;组合碎片&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Interaction Operand&lt;/td&gt;
&lt;td&gt;交互操作域&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Frame&lt;/td&gt;
&lt;td&gt;框架&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="object"&gt;Object&lt;/h2&gt;
&lt;p&gt;时序图中 Object 的命令遵循下面的格式:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;实体名 : 类名
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大部分情况下, 我们可能只关心&lt;strong&gt;类名&lt;/strong&gt;, 所以可以简写成 &lt;strong&gt;: 类名&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id="lifeline-focus-of-control"&gt;Lifeline 与 Focus of Control&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;生命线&lt;/strong&gt;在时序图中表示为从对象图标向下延伸的一条&lt;strong&gt;虚线&lt;/strong&gt;, 表示对象存在的时间.&lt;/p&gt;
&lt;p&gt;而&lt;strong&gt;控制焦点&lt;/strong&gt;是&lt;strong&gt;生命线&lt;/strong&gt;中表示时间段的符号, 在这个时间段内对象将执行相应的操作, 用小矩形表示.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i63.tinypic.com/2lxi9s1.jpg"/&gt;&lt;/p&gt;
&lt;h2 id="stimulus"&gt;Stimulus&lt;/h2&gt;
&lt;h3 id="_11"&gt;消息类型&lt;/h3&gt;
&lt;p&gt;消息一般分为&lt;strong&gt;同步消息&lt;/strong&gt;(Synchronous Message), &lt;strong&gt;异步消息&lt;/strong&gt;(Asynchronous Message)和&lt;strong&gt;返回消息&lt;/strong&gt;(Return Message).&lt;/p&gt;
&lt;p&gt;如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i66.tinypic.com/euh6hi.jpg"/&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步消息: 消息的发送者把控制传递给消息的接收者, 然后停止活动, 等待消息的接收者放弃或者返回控制&lt;/li&gt;
&lt;li&gt;异步消息: 消息发送者通过消息把信号传递给消息的接收者, 然后继续自己的活动, 不等待接受者返回消息或者控制&lt;/li&gt;
&lt;li&gt;返回消息: 返回消息表示从过程调用返回&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于 StarUML 而言, 同步消息的 Stimulus 为 &lt;strong&gt;Call&lt;/strong&gt;, 异步消息的 Stimulus 为 &lt;strong&gt;Send&lt;/strong&gt;, 返回消息的 Stimulus 为 &lt;strong&gt;Return&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i68.tinypic.com/fc06mw.jpg"/&gt;&lt;/p&gt;
&lt;h3 id="_12"&gt;消息约束&lt;/h3&gt;
&lt;p&gt;当为对象的交互建模时, 有时候必须满足一个条件消息才会传递给对象.&lt;/p&gt;
&lt;p&gt;为了在一个序列图上画一个约束, 你把约束元件放在约束的消息线上, 消息名字之前.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i64.tinypic.com/14e9vo6.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;注意 Stimulus 上的 &lt;strong&gt;[restraint == true]&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id="combined-fragment"&gt;Combined Fragment&lt;/h2&gt;
&lt;p&gt;Combined Fragment 用来描述一批 Stimulus 的约束, 如上面 &lt;strong&gt;消息约束&lt;/strong&gt; 中的 &lt;strong&gt;[restraint == true]&lt;/strong&gt;, 如果想要其对多条 Stimulus 生效, 就可以使用 Combined Fragment.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i68.tinypic.com/b7kubs.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;只有当 restraint == true 时, Combined Fragment 里的 Stimulus 才会被触发.&lt;/p&gt;
&lt;p&gt;Combined Fragment 左上角的 &lt;strong&gt;opt&lt;/strong&gt; 表示选择约束, 除了 opt 外, 还有 &lt;strong&gt;loop&lt;/strong&gt;(循环), 甚至还支持 &lt;strong&gt;if else&lt;/strong&gt; 结构(&lt;strong&gt;alt&lt;/strong&gt;).&lt;/p&gt;
&lt;p&gt;不过要使用 &lt;strong&gt;alt&lt;/strong&gt;, 就要配合 &lt;strong&gt;Interaction Operand&lt;/strong&gt; 了, 把 &lt;strong&gt;Interaction Operand&lt;/strong&gt; 拖放到 Combined Fragment 里就可以对 Combined Fragment 进行拆分了, 效果如下:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i66.tinypic.com/2w7pto8.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;如果 restraint == true, 则执行 call_1(), 否则执行 call_2().&lt;/p&gt;
&lt;h1 id="uml_4"&gt;UML 协作图、活动图&lt;/h1&gt;
&lt;h2 id="_13"&gt;协作图&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;协作图&lt;/strong&gt; 与 &lt;strong&gt;时序图&lt;/strong&gt; 是可以互转的, 只不过一个重点表达时序的先后关系, 一个重点表达对象间交互关系.&lt;/p&gt;
&lt;p&gt;通常 &lt;strong&gt;时序图&lt;/strong&gt; 用的更多, 而&lt;strong&gt;协作图&lt;/strong&gt;的主要作用是显示某个组件/对象是否有过多的交互, 是否应该继续分拆, 它可以当作&lt;strong&gt;时序图&lt;/strong&gt;的辅助形式.&lt;/p&gt;
&lt;h2 id="_14"&gt;活动图&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;活动图&lt;/strong&gt; 就是最早就接触过的 &lt;strong&gt;流程图&lt;/strong&gt;, 至少在画法上, 活动图和流程图很相似, 但 UML 活动图是面向对象, 表示的是对象间的流程.&lt;/p&gt;
&lt;p&gt;从存在意义上说, &lt;strong&gt;活动图&lt;/strong&gt;和&lt;strong&gt;时序图&lt;/strong&gt;一样, 都是对&lt;strong&gt;用例图&lt;/strong&gt;的再分析, 不同的是, &lt;strong&gt;时序图&lt;/strong&gt;是从计算机角度出发, 而&lt;strong&gt;活动图&lt;/strong&gt;是从用户角度出发, 因此, 对于我们开发者来说, 活动图在表示上”&lt;strong&gt;不够技术性&lt;/strong&gt;”, 但对业务人员来说, 往往能够更快速地理解它们.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;根据我的经验&lt;/strong&gt;, 当我们拿到用例图后, 可以先用时序图来尝试, 当发现用时序图不怎么好实现时, 再转向使用活动图, 毕竟有些复杂的交互, 用计算机的角度并不一定能描述清楚.&lt;/p&gt;
&lt;h2 id="_15"&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;协作图&lt;/strong&gt; 与 &lt;strong&gt;活动图&lt;/strong&gt; 两张图不做太多要求, 知道下就好.&lt;/p&gt;
&lt;h1 id="uml_5"&gt;UML 类图&lt;/h1&gt;
&lt;h2 id="_16"&gt;类图概述&lt;/h2&gt;
&lt;p&gt;类图, 豪不夸张的说, 是 UML 里最复杂的图了…&lt;/p&gt;
&lt;p&gt;类图在需求阶段和设计阶段具有不同的含义, 参考我之前的一篇笔记: &lt;a href="http://www.smallcpp.cn/15-c-zheng-que-bian-xi-lei-tu-de-liang-chong-cun-zai-xing-shi-zhuan.html"&gt;正确辨析类图的两种存在形式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于我们开发者来说, 我觉得重点还是在设计阶段的类图.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在 StarUML 中新建类图&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;打开 StarUML, 选择 &lt;strong&gt;Rational Approach&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&amp;lt;&amp;lt;&lt;strong&gt;Logical View&lt;/strong&gt;&amp;gt;&amp;gt; --&amp;gt; Add Diagram --&amp;gt; Class Diagram&lt;/p&gt;
&lt;p&gt;界面左边就出现了 Class 工具栏.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;StarUML&lt;/th&gt;
&lt;th&gt;翻译&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Subsystem&lt;/td&gt;
&lt;td&gt;子系统&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Package&lt;/td&gt;
&lt;td&gt;包&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Class&lt;/td&gt;
&lt;td&gt;类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Interface&lt;/td&gt;
&lt;td&gt;接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Enumeration&lt;/td&gt;
&lt;td&gt;枚举&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Signal&lt;/td&gt;
&lt;td&gt;信号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Exception&lt;/td&gt;
&lt;td&gt;异常&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Port&lt;/td&gt;
&lt;td&gt;端口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Part&lt;/td&gt;
&lt;td&gt;局部&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Association&lt;/td&gt;
&lt;td&gt;关联&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DirectedAssociation&lt;/td&gt;
&lt;td&gt;定向关联&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Aggregation&lt;/td&gt;
&lt;td&gt;聚合&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Composition&lt;/td&gt;
&lt;td&gt;组合&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Generalization&lt;/td&gt;
&lt;td&gt;泛化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Dependency&lt;/td&gt;
&lt;td&gt;依赖&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Realization&lt;/td&gt;
&lt;td&gt;实现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AssociationClass&lt;/td&gt;
&lt;td&gt;关系类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Connector&lt;/td&gt;
&lt;td&gt;连接&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Object&lt;/td&gt;
&lt;td&gt;对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Link&lt;/td&gt;
&lt;td&gt;链接&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id="uml_6"&gt;UML 部署图&lt;/h1&gt;
&lt;p&gt;是用来建模系统的物理部署, 例如计算机和设备, 以及它们之间是如何连接的, 部署图的使用者是开发人员、系统集成人员和测试人员.&lt;/p&gt;
&lt;p&gt;如果含有依赖关系的构件实例放置在不同节点上, 部署视图可以展示出执行过程中的瓶颈.&lt;/p&gt;
&lt;h1 id="uml_7"&gt;UML 组件图&lt;/h1&gt;
&lt;p&gt;描述代码构件的物理结构以及各种组件之间的依赖关系, 在组件图中, 组件可以是一个文件、产品、可执行文件或脚本等.&lt;/p&gt;
&lt;p&gt;在 UML 2 中, 组件被认为是独立的, 在一个系统或子系统中的封装单位, 提供一个或多个接口.&lt;/p&gt;
&lt;p&gt;虽然 UML 2 规范没有严格地声明它, 但组件是呈现事物的更大的设计单元, 这些事物一般将使用可更换的组件来实现.&lt;/p&gt;
&lt;p&gt;主要思想是, 你能容易地在你的设计中重用或替换一个不同的组件实现, 因为一个组件封装了行为, 实现了特定接口.&lt;/p&gt;
&lt;p&gt;在这里, 初学者很容易将组件图和类图搞混, 那么&lt;strong&gt;组件图和类图&lt;/strong&gt;的区别如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类表示的是逻辑的抽象, 构件是存在于计算机中的物理抽象, 组件是可部署的, 而类不行&lt;/li&gt;
&lt;li&gt;组件表示的是物理模块, 类是逻辑模块, 组件是由一组类协作而成的&lt;/li&gt;
&lt;li&gt;类可以直接拥有操作和属性, 组件仅拥有可以通过其接口访问的操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="http://i68.tinypic.com/1zpidfd.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.ibm.com/developerworks/cn/rational/rationaledge/content/feb05/bell/bell.html"&gt;参考文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;部署图和组件图:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;部署图表现组件实例, 偏向于描述组件在节点中运行时的状态, 描述了组件运行的环境&lt;/li&gt;
&lt;li&gt;组件图表现组件类型的定义, 偏向于描述构件之间相互依赖支持的基本关系&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先有部署图还是组件图?
依照 top down 原则, 所以是从部署图到构件图, 实际上也应该如此, 因为我们在需求确定后, 一般就会确定大体的技术架构、程序模块划分, 而此时一般系统集成的工作也要相应的启动: 要买主机、网络设备;
所以要提供给系统集成人员相应的资料, 那么就需要先把部署图做出来, 然后再细化构件图.&lt;/p&gt;</content><category term="软件工程"></category></entry><entry><title>事务与锁</title><link href="http://www.smallcpp.cn/shi-wu-yu-suo.html" rel="alternate"></link><published>2016-07-28T17:48:00+08:00</published><updated>2016-07-28T17:48:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-07-28:/shi-wu-yu-suo.html</id><summary type="html">&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;事务与锁是不同的, &lt;strong&gt;事务&lt;/strong&gt;具有 &lt;code&gt;ACID&lt;/code&gt; (原子性、一致性、&lt;strong&gt;隔离性&lt;/strong&gt;和持久性), 而&lt;strong&gt;锁&lt;/strong&gt;是用于解决其中&lt;strong&gt;隔离性&lt;/strong&gt;的一种机制.&lt;/p&gt;
&lt;p&gt;事务的隔离级别通过锁的机制来实现.&lt;/p&gt;
&lt;p&gt;隔离级别, 一般有四种:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读未提交 Read uncommitted&lt;/li&gt;
&lt;li&gt;读已提交 Read committed&lt;/li&gt;
&lt;li&gt;可重复读 Repeatable read&lt;/li&gt;
&lt;li&gt;可串行化 Serializable&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;关于隔离级别的说明参考另一篇 wiki: &lt;a href="http://www.smallcpp.cn/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.html"&gt;事务的隔离级别 …&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;</summary><content type="html">&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;事务与锁是不同的, &lt;strong&gt;事务&lt;/strong&gt;具有 &lt;code&gt;ACID&lt;/code&gt; (原子性、一致性、&lt;strong&gt;隔离性&lt;/strong&gt;和持久性), 而&lt;strong&gt;锁&lt;/strong&gt;是用于解决其中&lt;strong&gt;隔离性&lt;/strong&gt;的一种机制.&lt;/p&gt;
&lt;p&gt;事务的隔离级别通过锁的机制来实现.&lt;/p&gt;
&lt;p&gt;隔离级别, 一般有四种:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读未提交 Read uncommitted&lt;/li&gt;
&lt;li&gt;读已提交 Read committed&lt;/li&gt;
&lt;li&gt;可重复读 Repeatable read&lt;/li&gt;
&lt;li&gt;可串行化 Serializable&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;关于隔离级别的说明参考另一篇 wiki: &lt;a href="http://www.smallcpp.cn/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.html"&gt;事务的隔离级别&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对用户来说, 只有当事务隔离级别无法解决一些并发问题和需求时, 才有必要在语句中手动设置锁.&lt;/p&gt;
&lt;p&gt;不适当的设置锁, 可能会导致严重的阻塞和死锁.&lt;/p&gt;
&lt;p&gt;建议, 只有在完全了解锁机制的情况下, 才可以在语句中手动设置锁, 否则应该使用事务隔离级别.&lt;/p&gt;</content><category term="数据库"></category></entry><entry><title>悲观锁与乐观锁</title><link href="http://www.smallcpp.cn/bei-guan-suo-yu-le-guan-suo.html" rel="alternate"></link><published>2016-07-28T17:46:00+08:00</published><updated>2016-07-28T17:46:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-07-28:/bei-guan-suo-yu-le-guan-suo.html</id><summary type="html">&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;悲观锁&lt;/strong&gt; (Pessimistic Lock), 顾名思义, 就是很悲观, 每次去拿数据的时候都认为别人会修改, 所以每次在拿数据的时候都会上锁, 这样别人想拿这个数据就会 block 直到它拿到锁.&lt;/p&gt;
&lt;p&gt;传统的关系型数据库里边就用到了很多这种锁机制, 比如行锁, 表锁等, 都是在做操作之前先上锁.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;乐观锁&lt;/strong&gt; (Optimistic Lock), 顾名思义, 就是很乐观, 每次去拿数据的时候都认为别人不会修改, 所以不会上锁, 但是在更新的时候会判断一下在此期间别人有没有去更新这个数据, 可以使用版本号等机制.&lt;/p&gt;
&lt;p&gt;乐观锁适用于多读的应用类型, 这样可以提高吞吐量, 像数据库如果提供类似于 write_condition 机制的其实都是提供的乐观锁.&lt;/p&gt;
&lt;p&gt;两种锁各有优缺点, 不可认为一种好于另一种 …&lt;/p&gt;</summary><content type="html">&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;悲观锁&lt;/strong&gt; (Pessimistic Lock), 顾名思义, 就是很悲观, 每次去拿数据的时候都认为别人会修改, 所以每次在拿数据的时候都会上锁, 这样别人想拿这个数据就会 block 直到它拿到锁.&lt;/p&gt;
&lt;p&gt;传统的关系型数据库里边就用到了很多这种锁机制, 比如行锁, 表锁等, 都是在做操作之前先上锁.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;乐观锁&lt;/strong&gt; (Optimistic Lock), 顾名思义, 就是很乐观, 每次去拿数据的时候都认为别人不会修改, 所以不会上锁, 但是在更新的时候会判断一下在此期间别人有没有去更新这个数据, 可以使用版本号等机制.&lt;/p&gt;
&lt;p&gt;乐观锁适用于多读的应用类型, 这样可以提高吞吐量, 像数据库如果提供类似于 write_condition 机制的其实都是提供的乐观锁.&lt;/p&gt;
&lt;p&gt;两种锁各有优缺点, 不可认为一种好于另一种, 像乐观锁适用于写比较少的情况下, 即冲突真的很少发生的时候, 这样可以省去了锁的开销, 加大了系统的整个吞吐量.&lt;/p&gt;
&lt;p&gt;但如果经常产生冲突, 上层应用会不断的进行 retry, 这样反倒是降低了性能, 所以这种情况下用悲观锁就比较合适.&lt;/p&gt;</content><category term="数据库"></category></entry><entry><title>读锁与写锁</title><link href="http://www.smallcpp.cn/du-suo-yu-xie-suo.html" rel="alternate"></link><published>2016-07-28T17:37:00+08:00</published><updated>2016-07-28T17:37:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-07-28:/du-suo-yu-xie-suo.html</id><content type="html">
&lt;h1 id="_1"&gt;读锁&lt;/h1&gt;
&lt;p&gt;读锁的意义在于,  当前线程告诉别人: “我要读东西啦, 你们先不要改数据, 免得我读到错的数据.”&lt;/p&gt;
&lt;p&gt;由于可见, 对数据加读锁后, 其他线程还能读 (因为大家都是读的话, 就不会产生正在读的过程中数据被修改的问题), 但是不允许对加锁的数据进行写入…&lt;/p&gt;
&lt;h1 id="_2"&gt;写锁&lt;/h1&gt;
&lt;p&gt;写锁呢, 就是告诉别人: “我要修改数据了, 修改后才是正常的数据, 你们要等我修改完再读.”&lt;/p&gt;
&lt;p&gt;所以, 加数据加写锁后, 其他线程即不能读也不能写…&lt;/p&gt;</content><category term="软件工程"></category></entry><entry><title>字符编码</title><link href="http://www.smallcpp.cn/zi-fu-bian-ma.html" rel="alternate"></link><published>2016-07-28T17:19:00+08:00</published><updated>2016-07-28T17:19:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-07-28:/zi-fu-bian-ma.html</id><summary type="html">
&lt;h1 id="_1"&gt;编码/解码&lt;/h1&gt;
&lt;p&gt;任何数据在内存中都是以二进制的形式保存, 也就是说一个文本文件, 不管你看到的是中文还是英文或者是法文, 它在内存也都是一串二进制数据 (或者说是一串字节数组), 那么当用一个文本浏览器打开一个文本文件时, 该文本浏览器就会拿它读出来的字节数组去 “查字典”, 然后将查到的结果展现出来.&lt;/p&gt;
&lt;p&gt;这个 “查字典” 的动作就被称之为&lt;strong&gt;解码&lt;/strong&gt;, 当然我们不叫它 “查字典”, 而叫它查码表, 常见的码表有 ASCII、ISO-8859-1、GB2312、GBK、UTF-8、UTF-16 等.&lt;/p&gt;
&lt;p&gt;(解码, 解码, 可以理解成&lt;strong&gt;破解密码 …&lt;/strong&gt;&lt;/p&gt;</summary><content type="html">
&lt;h1 id="_1"&gt;编码/解码&lt;/h1&gt;
&lt;p&gt;任何数据在内存中都是以二进制的形式保存, 也就是说一个文本文件, 不管你看到的是中文还是英文或者是法文, 它在内存也都是一串二进制数据 (或者说是一串字节数组), 那么当用一个文本浏览器打开一个文本文件时, 该文本浏览器就会拿它读出来的字节数组去 “查字典”, 然后将查到的结果展现出来.&lt;/p&gt;
&lt;p&gt;这个 “查字典” 的动作就被称之为&lt;strong&gt;解码&lt;/strong&gt;, 当然我们不叫它 “查字典”, 而叫它查码表, 常见的码表有 ASCII、ISO-8859-1、GB2312、GBK、UTF-8、UTF-16 等.&lt;/p&gt;
&lt;p&gt;(解码, 解码, 可以理解成&lt;strong&gt;破解密码&lt;/strong&gt;, 二进制数据相当于密码, 人眼不可识别, 你需要把这串密码破解出来才能知道它是什么内容, 所以叫解码).&lt;/p&gt;
&lt;p&gt;相对的, 将可识别的文字转换成字节数组的过程就称之为&lt;strong&gt;编码&lt;/strong&gt;, 根据使用的码表不同, 同样的文字会被编码成不同的字节数组.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i64.tinypic.com/2012gz5.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么, 什么样才叫人眼可识别呢?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;就像中国人有汉语, 英国人有英语, 日本人有日语, 计算机也有自己的”语言”, 那就是 Unicode.&lt;/p&gt;
&lt;p&gt;来看下 Unicode 字符集的定义:&lt;/p&gt;
&lt;p&gt;Unicode (统一码、万国码、单一码) 是一种在计算机上使用的字符集, 它为每种语言中的每个字符设定了统一并且唯一的二进制编码, 以满足跨语言、跨平台进行文本转换、处理的要求;&lt;/p&gt;
&lt;p&gt;1990 年开始研发, 1994 年正式公布, 随着计算机工作能力的增强, Unicode 也在面世以来的十多年里得到普及.&lt;/p&gt;
&lt;p&gt;所以, &lt;strong&gt;编码&lt;/strong&gt;就是将 Unicode “加密” 成字节数组, &lt;strong&gt;解码&lt;/strong&gt;就是将字节数组 “破解” 成 Unicode.&lt;/p&gt;</content><category term="软件工程"></category></entry><entry><title>打磨 gem</title><link href="http://www.smallcpp.cn/da-mo-gem.html" rel="alternate"></link><published>2016-05-28T22:56:00+08:00</published><updated>2016-05-28T22:56:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-05-28:/da-mo-gem.html</id><summary type="html">
&lt;h1 id="_1"&gt;打磨&lt;/h1&gt;
&lt;p&gt;由于 GFW 的原因, 直接使用 gem 会报错: &lt;code&gt;Errno::ECONNRESET: Connection reset by peer - SSL_connect (https://api.rubygems.org&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;更改 gem 的源为国内的映像就好了:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;gem sources --remove https://rubygems.org/

gem sources -a …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">
&lt;h1 id="_1"&gt;打磨&lt;/h1&gt;
&lt;p&gt;由于 GFW 的原因, 直接使用 gem 会报错: &lt;code&gt;Errno::ECONNRESET: Connection reset by peer - SSL_connect (https://api.rubygems.org&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;更改 gem 的源为国内的映像就好了:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;gem sources --remove https://rubygems.org/

gem sources -a https://ruby.taobao.org/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看下当前源:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;$ gem sources -l
*** CURRENT SOURCES ***

https://ruby.taobao.org
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一定要&lt;strong&gt;确保&lt;/strong&gt;只有 &lt;code&gt;ruby.taobao.org&lt;/code&gt;&lt;/p&gt;
&lt;h1 id="_2"&gt;注意事项&lt;/h1&gt;
&lt;p&gt;gem 的配置是区分 sudo 和普通用户命令的…&lt;/p&gt;
&lt;p&gt;也就是说, 如果你用上面的方法打磨后, 如果使用 &lt;code&gt;sudo gem sources -l&lt;/code&gt; 会发现还是以前的 &lt;code&gt;https://rubygems.org/&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;所以用 sudo 再执行次上面的配置:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;sudo gem sources --remove https://rubygems.org/

sudo gem sources -a http://ruby.taobao.org/

sudo gem sources -l

*** CURRENT SOURCES ***

http://ruby.taobao.org
&lt;/pre&gt;&lt;/div&gt;</content><category term="工具折腾"></category></entry><entry><title>Ubuntu 升级 Ruby 版本</title><link href="http://www.smallcpp.cn/ubuntu-sheng-ji-ruby-ban-ben.html" rel="alternate"></link><published>2016-05-28T21:47:00+08:00</published><updated>2016-05-28T21:47:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-05-28:/ubuntu-sheng-ji-ruby-ban-ben.html</id><summary type="html">
&lt;h1 id="rvm-ruby"&gt;使用 rvm 管理 ruby 版本&lt;/h1&gt;
&lt;p&gt;这是推荐的方式, 但是由于 GFW 的原因, rvm 不一定安装成功, 如果不成功则参考下面的从源码安装.&lt;/p&gt;
&lt;p&gt;Reference: &lt;a href="http://blog.csdn.net/abbuggy/article/details/8170899"&gt;在ubuntu中安装及使用rvm管理ruby版本&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="_1"&gt;准备工作&lt;/h2&gt;
&lt;p&gt;后面需要使用 &lt;strong&gt;curl&lt;/strong&gt;, 用 &lt;strong&gt;dpkg -s curl&lt;/strong&gt; 命令检查一下系统中有没有安装&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;abbuggy@abbuggy-ubuntu:~$ dpkg -s curl
Package: curl
Status …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">
&lt;h1 id="rvm-ruby"&gt;使用 rvm 管理 ruby 版本&lt;/h1&gt;
&lt;p&gt;这是推荐的方式, 但是由于 GFW 的原因, rvm 不一定安装成功, 如果不成功则参考下面的从源码安装.&lt;/p&gt;
&lt;p&gt;Reference: &lt;a href="http://blog.csdn.net/abbuggy/article/details/8170899"&gt;在ubuntu中安装及使用rvm管理ruby版本&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="_1"&gt;准备工作&lt;/h2&gt;
&lt;p&gt;后面需要使用 &lt;strong&gt;curl&lt;/strong&gt;, 用 &lt;strong&gt;dpkg -s curl&lt;/strong&gt; 命令检查一下系统中有没有安装&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;abbuggy@abbuggy-ubuntu:~$ dpkg -s curl
Package: curl
Status: install ok installed
Priority: optional
Section: web
Installed-Size: 338
Maintainer: Ubuntu Developers &amp;lt;ubuntu-devel-discuss@lists.ubuntu.com&amp;gt;
Architecture: i386
Version: 7.22.0-3ubuntu4
Replaces: curl-ssl
Provides: curl-ssl
Depends: libc6 (&amp;gt;= 2.7), libcurl3 (&amp;gt;= 7.16.2-1), zlib1g (&amp;gt;= 1:1.1.4)
Description: Get a file from an HTTP, HTTPS or FTP server
 curl is a client to get files from servers using any of the supported
 protocols. The command is designed to work without user interaction
 or any kind of interactivity.
 .
 curl offers a busload of useful tricks like proxy support, user
 authentication, FTP upload, HTTP post, file transfer resume and more.
Homepage: http://curl.haxx.se
Original-Maintainer: Ramakrishnan Muthukrishnan &amp;lt;rkrishnan@debian.org&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的说明我是已经安装过了的, 如果没有安装应该是类似如下的回显:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;abbuggy@abbuggy-ubuntu:~$ dpkg -s curl
系统没有安装软件包 curl, 因而没有相关的信息.
使用 dpkg --info (= dpkg-deb --info) 来检测打包好的文件,
还可以通过 dpkg --contents (= dpkg-deb --contents) 来列出它们的内容.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么安装就行了 &lt;code&gt;sudo apt-get install curl&lt;/code&gt;&lt;/p&gt;
&lt;h2 id="rvm"&gt;安装 rvm&lt;/h2&gt;
&lt;p&gt;用 rvm 官方推荐的方式安装 &lt;code&gt;curl -L get.rvm.io | bash -s stable&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;回显提示我们, RVM 被安装在 &lt;code&gt;$HOME/.vrm&lt;/code&gt; 中, 并且需要在终端中加载脚本 &lt;code&gt;$HOME/.rvm/scripts/rvm&lt;/code&gt;&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;abbuggy@abbuggy-ubuntu:~$ curl -L get.rvm.io | bash -s stable
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   185  100   185    0     0    144      0  0:00:01  0:00:01 --:--:--   906
100 10235  100 10235    0     0   3929      0  0:00:02  0:00:02 --:--:-- 10888
Downloading RVM from wayneeseguin branch stable
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   131  100   131    0     0     62      0  0:00:02  0:00:02 --:--:--   143
100 1124k  100 1124k    0     0   127k      0  0:00:08  0:00:08 --:--:--  269k

Installing RVM to /home/abbuggy/.rvm/
    RVM PATH line found in /home/abbuggy/.bashrc /home/abbuggy/.zshrc.
    RVM sourcing line found in /home/abbuggy/.bash_profile /home/abbuggy/.zprofile.

# RVM:  Shell scripts enabling management of multiple ruby environments.
# RTFM: https://rvm.io/
# HELP: http://webchat.freenode.net/?channels=rvm (#rvm on irc.freenode.net)
# Cheatsheet: http://cheat.errtheblog.com/s/rvm/
# Screencast: http://screencasts.org/episodes/how-to-use-rvm

# In case of any issues read output of 'rvm requirements' and/or 'rvm notes'

Installation of RVM in /home/abbuggy/.rvm/ is almost complete:

  * To start using RVM you need to run `source /home/abbuggy/.rvm/scripts/rvm`
    in all your open shell windows, in rare cases you need to reopen all shell windows.

# abbuggy,
#
#   Thank you for using RVM!
#   I sincerely hope that RVM helps to make your life easier and more enjoyable!!!
#
# ~Wayne
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;应该请把这句话加在 &lt;code&gt;$HOME/.bash_profile&lt;/code&gt; 文件中, 以便在开启一个终端会话时候加载 RVM:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;[[ -s "$HOME/.rvm/scripts/rvm" ]] &amp;amp;&amp;amp; . "$HOME/.rvm/scripts/rvm" # This loads RVM into a shell session.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果对 shell 不熟悉, 这里简单解释一下这是干什么用的:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[[condition]]&lt;/code&gt; 两层的方括号中间括着条件返回条件是不是真, -s 是判断给定的文件是否存在的命令.&lt;/p&gt;
&lt;p&gt;这样一来, 不就是在 &lt;code&gt;[[ -s "$HOME/.vrm/scripts/vrm"]]&lt;/code&gt; 判断刚才安装的 RVM 是否存在吗?&lt;/p&gt;
&lt;p&gt;接下来的&amp;amp;&amp;amp;符号是&lt;strong&gt;“短路的与”&lt;/strong&gt;, 当前面的条件是真的时候, 执行后面的语句, 返回这两个语句是不是全是真.&lt;/p&gt;
&lt;p&gt;在这里, 利用了”短路”特性, 也就是说当 RVM 已经安装的话, 执行后面的 &lt;code&gt;$HOME/.rvm/scripts/rvm&lt;/code&gt; 命令.&lt;/p&gt;
&lt;p&gt;这条命令和 &lt;code&gt;source "$HOME/.rvm/scripts/rvm"&lt;/code&gt; 是一个意思: 加载 rvm 的启动脚本.&lt;/p&gt;
&lt;p&gt;现在, 通过修改 &lt;code&gt;.bash_profile&lt;/code&gt; 增加的内容需要重新打开终端窗口时加载, 或者另一个是在当前窗口执行一遍 &lt;code&gt;$HOME/.rvm/scripts/rvm&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="rvm_1"&gt;使用 RVM&lt;/h2&gt;
&lt;p&gt;察看 RVM 的版本&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;rvm -v

rvm 1.16.20 (stable) by Wayne E. Seguin &amp;lt;wayneeseguin@gmail.com&amp;gt;, Michal Papis &amp;lt;mpapis@gmail.com&amp;gt; [https://rvm.io/]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后通过 &lt;code&gt;rvm requirements&lt;/code&gt; 命令, 可以察看安装各版本时候的前提条件, 其中现在这句是需要关注的, 这是安装依赖的第三方包, 没有这个安装不成功岂不是很悲剧?&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;Additional Dependencies:
# For Ruby / Ruby HEAD (MRI, Rubinius, &amp;amp; REE), install the following:
  ruby: /usr/bin/apt-get install build-essential openssl libreadline6 libreadline6-dev curl git-core zlib1g zlib1g-dev libssl-dev libyaml-dev libsqlite3-dev sqlite3 libxml2-dev libxslt-dev autoconf libc6-dev ncurses-dev automake libtool bison subversion pkg-config
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样一来, 安装 ruby 的准备工作就完成了, 察看当前 RVM中 已经安装的 ruby 版本, 现在应该还没有.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;rvm list

rvm rubies

# No rvm rubies installed yet. Try 'rvm help install'.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;察看 RVM 可供安装的 ruby 版本:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;rvm list known
# MRI Rubies

[ruby-]1.8.6[-p420]
[ruby-]1.8.7-p370
[ruby-]1.8.7[-p371]
[ruby-]1.9.1[-p431]
[ruby-]1.9.2-p180
[ruby-]1.9.2-p290
[ruby-]1.9.2-p318
[ruby-]1.9.2[-p320]
[ruby-]1.9.2-head
[ruby-]1.9.3-preview1
[ruby-]1.9.3-rc1
[ruby-]1.9.3-p0
[ruby-]1.9.3-p125
[ruby-]1.9.3-p194
[ruby-]1.9.3-p286
[ruby-]1.9.3-[p327]
[ruby-]1.9.3-head
[ruby-]2.0.0-preview1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例如安装 ruby 1.9.3-head, 在不发生歧义的情况下方括号内的东西可以不必敲.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;rvm install 1.9.3-head
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之后等呀等呀自动安装了 1.8.7 和 1.9.3&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;rvm list

rvm rubies

   ruby-1.8.7-p371 [ i686 ]
   ruby-1.9.3-head [ i686 ]

# Default ruby not set. Try 'rvm alias create default &amp;lt;ruby&amp;gt;'.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;选择 1.9.3 作为当前的使用版本, 并且设置为缺省&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;rvm use ruby-1.9.3-head --default
Using /home/abbuggy/.rvm/gems/ruby-1.9.3-head
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置好之后察看ruby版本&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;ruby -v
ruby 1.9.3p327 (2012-11-10) [i686-linux]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;察看ruby的路径, 就是 RVM 帮我们安装的&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;which ruby
/home/abbuggy/.rvm/rubies/ruby-1.9.3-head/bin/ruby
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="_2"&gt;从源码安装&lt;/h1&gt;
&lt;p&gt;如果你不能安装 RVM, 那就尝试从源码安装吧.&lt;/p&gt;
&lt;p&gt;Reference: &lt;a href="http://blog.csdn.net/abbuggy/article/details/8170899"&gt;Setup Ruby On Rails on Ubuntu 14.04 Trusty Tahr&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为避免和当前 Ruby 冲突, 先卸载当前版本:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get remove ruby1.8

sudo apt-get autoremove
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后安装新版本的 Ruby:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;wget http://ftp.ruby-lang.org/pub/ruby/2.3/ruby-2.3.1.tar.gz

tar -xzvf ruby-2.3.1.tar.gz

cd ruby-2.3.1/

./configure

make

sudo make install
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装完查看下版本: &lt;code&gt;ruby -v&lt;/code&gt;.&lt;/p&gt;
&lt;h1 id="travis-client"&gt;使用 Travis Client 推荐的方法&lt;/h1&gt;
&lt;p&gt;由于我使用第二种方法成功安装了, 因为这种方法我没测试过, 先记录下再说…&lt;/p&gt;
&lt;p&gt;Reference: &lt;a href="https://github.com/travis-ci/travis.rb#other-unix-systems"&gt;Travis Client Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;先卸载当前版本:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get remove ruby1.8

sudo apt-get autoremove
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后安装新版本:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get install python-software-properties
sudo apt-add-repository ppa:brightbox/ruby-ng
sudo apt-get update
sudo apt-get install ruby2.1 ruby-switch ruby2.1-dev
sudo ruby-switch --set ruby2.1
&lt;/pre&gt;&lt;/div&gt;</content><category term="工具折腾"></category></entry><entry><title>折腾 Travis CI</title><link href="http://www.smallcpp.cn/zhe-teng-travis-ci.html" rel="alternate"></link><published>2016-05-28T21:04:00+08:00</published><updated>2016-05-28T21:04:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-05-28:/zhe-teng-travis-ci.html</id><summary type="html">
&lt;h1 id="_1"&gt;介绍&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://travis-ci.org/"&gt;Travis CI&lt;/a&gt; 是在软件开发领域中的一个&lt;strong&gt;在线的&lt;/strong&gt;、&lt;strong&gt;分布式&lt;/strong&gt;的持续集成服务, 用来构建及测试在 &lt;strong&gt;Github&lt;/strong&gt; 托管的代码, 简单的说, 就是它可以监控你 Github 仓库的某个分支, 当你提交修改到这个分支的时候, 它就会把你提交的分支 clone 到它的服务上进行构建, 你可以通过配置来决定构建完成后是否推送回 Github ~&lt;/p&gt;
&lt;p&gt;这里记录一些我在将 Simiki 项目和 Travis CI 结合过程中折腾过的坑, 以抛砖引玉…&lt;/p&gt;
&lt;h1 id="github"&gt;关联 Github 仓库 …&lt;/h1&gt;</summary><content type="html">
&lt;h1 id="_1"&gt;介绍&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://travis-ci.org/"&gt;Travis CI&lt;/a&gt; 是在软件开发领域中的一个&lt;strong&gt;在线的&lt;/strong&gt;、&lt;strong&gt;分布式&lt;/strong&gt;的持续集成服务, 用来构建及测试在 &lt;strong&gt;Github&lt;/strong&gt; 托管的代码, 简单的说, 就是它可以监控你 Github 仓库的某个分支, 当你提交修改到这个分支的时候, 它就会把你提交的分支 clone 到它的服务上进行构建, 你可以通过配置来决定构建完成后是否推送回 Github ~&lt;/p&gt;
&lt;p&gt;这里记录一些我在将 Simiki 项目和 Travis CI 结合过程中折腾过的坑, 以抛砖引玉…&lt;/p&gt;
&lt;h1 id="github"&gt;关联 Github 仓库&lt;/h1&gt;
&lt;p&gt;访问 &lt;a href="https://travis-ci.org/"&gt;Travis CI&lt;/a&gt; 官网, 点击页面右上角 &lt;strong&gt;signing-in button-signingin&lt;/strong&gt; 用 Github 账号登录 Travis CI.&lt;/p&gt;
&lt;p&gt;登录成功后, 点击页面左侧 &lt;strong&gt;My Repositories&lt;/strong&gt; 旁边的 &lt;strong&gt;+&lt;/strong&gt; 号.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i63.tinypic.com/dndmvt.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;然后选择你要监控的仓库.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i65.tinypic.com/izcghc.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;最后, 在本地的 Simiki 项目目录中添加一个 &lt;code&gt;.travis.yml&lt;/code&gt; 文件并创建一个 &lt;code&gt;.travis&lt;/code&gt; 子目录备用.&lt;/p&gt;
&lt;h1 id="ssh"&gt;设置 SSH&lt;/h1&gt;
&lt;h2 id="_2"&gt;生成密钥&lt;/h2&gt;
&lt;p&gt;在前面说过 Travis CI 可以通过配置来决定构建完成后是否推送回 Github, 由于我们需要把 Travis CI 的构建结果, 也就是 wiki 生成文件推送回 Github Project 的 &lt;strong&gt;gh-page&lt;/strong&gt; 分支 (参考: &lt;a href="http://www.smallcpp.cn/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/%E6%8A%98%E8%85%BE%20Simiki.html"&gt;折腾 Simiki&lt;/a&gt;), 所以需要把 Travis CI 的公钥添加到 Simiki 项目的 &lt;strong&gt;Deploy Key&lt;/strong&gt; 中 (&lt;strong&gt;注意&lt;/strong&gt;, 你添加的是应该是项目的单独 &lt;strong&gt;Deploy Key&lt;/strong&gt;, 而不是你 Github 账户的全局 Key).&lt;/p&gt;
&lt;p&gt;在本地的 Simiki 项目中生成一对单独密钥: &lt;code&gt;ssh-keygen -t rsa -C "youremail@example.com"&lt;/code&gt; (因为这是 simiki 项目的单独密钥, 所以不要生成到系统的 .ssh 目录中去了).&lt;/p&gt;
&lt;p&gt;把生成的 &lt;code&gt;id_rsa.pub&lt;/code&gt; 添加到你 Github 仓库上 Simiki 项目的 &lt;strong&gt;Deploy Key&lt;/strong&gt; 中, 注意要开启 &lt;code&gt;Allow write access&lt;/code&gt;, 然后这个公钥就可以删掉了…&lt;/p&gt;
&lt;h2 id="_3"&gt;加密密钥&lt;/h2&gt;
&lt;p&gt;因为上一步生成的 &lt;code&gt;id_rsa&lt;/code&gt; 私钥是要发布到 Github 仓库供 Travis CI 拉回服务器的 (Travis CI 需要这个私钥来和 Github 通信), 为了安全, Travis CI 提供了一种加密手段, 也就是说这个私钥只有你的 Travis CI 账户才能解密使用, 就算被别人拿到了也没用, 除非他也拿到了你的 Travis CI 账户.&lt;/p&gt;
&lt;p&gt;此时需要使用到 &lt;a href="https://github.com/travis-ci/travis.rb"&gt;Travis Client&lt;/a&gt; 了, Travis Client 基于 &lt;strong&gt;Ruby&lt;/strong&gt;(&amp;gt;=1.9.3), 所以先检查下你的 Ruby 版本…Windows 用户直接用 &lt;a href="http://rubyinstaller.org/"&gt;rubyinstaller&lt;/a&gt; 就好了, ubuntu 用户参考另一 wiki &lt;a href="http://www.smallcpp.cn/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/ubuntu%20%E5%8D%87%E7%BA%A7%20ruby%20%E7%89%88%E6%9C%AC.html"&gt;ubuntu 升级 ruby 版本&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;确认好 Ruby 版本后, 首先要打磨下 &lt;strong&gt;gem&lt;/strong&gt; 工具 &lt;a href="http://www.smallcpp.cn/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/%E6%89%93%E7%A3%A8%20gem.html"&gt;打磨 gem&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;然后, 安裝 Travis Client:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;gem install travis
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在安裝完毕, 设置你的登录认证:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;travis login --auto
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;会要求输入账号密码, 如此一來, 就能通过 Travis Client 加密 &lt;code&gt;id_rsa&lt;/code&gt; 了, Travis Client首先会产生一个新的 &lt;code&gt;id_rsa.enc&lt;/code&gt; 文件, 然后在 &lt;code&gt;.travis.yml&lt;/code&gt; 的 &lt;code&gt;before_install&lt;/code&gt; 中插入解密指令.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;travis encrypt-file id_rsa --add
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意要在你的 Simiki 项目路径执行上面的命令, 正常來說 Travis Client 會自動解析目前的 repo (並把 Private key 上傳到相對應的 repo), 但有時可能會秀逗, 這時你必須在指令後加上 -r 選項來指定 repo 名稱, 例如:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;travis encrypt-file id_rsa --add -r xxx/xxx
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="travisyml"&gt;配置 .travis.yml&lt;/h1&gt;
&lt;p&gt;把剛剛製作的 &lt;code&gt;id_rsa.enc&lt;/code&gt; 移至 &lt;code&gt;.travis/id_rsa.enc&lt;/code&gt; (&lt;code&gt;.travis&lt;/code&gt; 是在第一步中新建的子目录), 並在 &lt;code&gt;.travis&lt;/code&gt; 目录中建立 &lt;code&gt;ssh_config&lt;/code&gt; 文件, 用来指定 Travis 上的 SSH 設定.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ssh_config&lt;/code&gt;:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;Host github.com
  User git
  StrictHostKeyChecking no
  IdentityFile ~/.ssh/id_rsa
  IdentitiesOnly yes
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因為剛剛修改了 id_rsa.enc 的位址, 所以我們要順帶修改剛剛 Travis 在 &lt;code&gt;.travis.yml&lt;/code&gt; 幫我們插入的那條解密指令:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;- openssl aes-256-cbc -K $encrypted_06b8e90ac19b_key -iv $encrypted_06b8e90ac19b_iv
  -in .travis/id_rsa.enc -out ~/.ssh/id_rsa -d
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;這條指令會利用 openssl 解密你仓库 &lt;code&gt;.travis/id_rsa.enc&lt;/code&gt; 文件, 並把解密後的文件放到 Travis 服务器的 &lt;code&gt;~/.ssh/id_rsa&lt;/code&gt;, 这样 Travis 就能利用这个私钥和你的 Github 通信了.&lt;/p&gt;
&lt;p&gt;然后 &lt;code&gt;.travis.yml&lt;/code&gt; 中还需要配置一些其他选项, 我的 simiki 完整 &lt;code&gt;.travis.yml&lt;/code&gt; 如下:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;python:
- '2.7'

before_install:
- openssl aes-256-cbc -K $encrypted_67deb6670456_key -iv $encrypted_67deb6670456_iv
  -in .travis/id_rsa.enc -out ~/.ssh/id_rsa -d
- chmod 600 ~/.ssh/id_rsa
- eval $(ssh-agent)
- ssh-add ~/.ssh/id_rsa
- cp .travis/ssh_config ~/.ssh/config
- git config --global user.name "uldaman"
- git config --global user.email "zhuec@hotmail.com"
- git remote set-url --push origin git@github.com:uldaman/wiki.git  # hack 1
- git fetch origin gh-pages:refs/remotes/origin/gh-pages  # hack 2

install:
- sudo pip install fabric
- sudo pip install ghp-import
- sudo pip install simiki

script:
- simiki g
- fab deploy

branches:
  only:
  - master  # 只监视 master 的提交
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大部分都好理解, 重点解释下 &lt;strong&gt;hack 1&lt;/strong&gt; 和 &lt;strong&gt;hack 2&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;hack 1&lt;/strong&gt;, 因为 Travis CI 克隆是用的 &lt;strong&gt;http/https&lt;/strong&gt; 协议, 所以在推送时就没法使用 SSH 模式了, 于是克隆下来后要改协议为 &lt;strong&gt;ssh/git&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;hack 2&lt;/strong&gt;, Travis CI 克隆项目指定了 --depth, 这样会只拉出当前 master 分支, 如果没有这条配置, 推送时就会报错, 因为这样相当于新建了 gh-pages 分支, 所以必然会提示冲突…加上 hack 2 从 origin 拉回 gh-pages 分支, 解决下面的错误.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;To git@github.com:tankywoo/wiki.tankywoo.com.git
 ! [rejected]        gh-pages -&amp;gt; gh-pages (fetch first)
error: failed to push some refs to 'git@github.com:tankywoo/wiki.tankywoo.com.git'
hint: Updates were rejected because the remote contains work that you do
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: (e.g., 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="reference"&gt;Reference&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://github.com/travis-ci/travis.rb"&gt;Travis CI Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://blog.tankywoo.com/2016/02/19/simiki-with-travis-ci.html"&gt;Simiki基于Github Pages配合Travis CI做持续集成&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://xuanwo.org/2015/02/07/Travis-CI-Hexo-Autodeploy/"&gt;使用Travis CI自动部署Hexo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://gorails.com/setup/ubuntu/14.04"&gt;Setup Ruby On Rails on Ubuntu 14.04 Trusty Tahr&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.cnblogs.com/ToDoToTry/p/4422454.html"&gt;gem install 出现Errno::ECONNRESET: Connection reset by peer - SSL_connect (https://api.rubygems.org)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://ruby-china.org/topics/15260"&gt;修改 gem sources 后遇到的问题&lt;/a&gt;&lt;/p&gt;</content><category term="工具折腾"></category></entry><entry><title>折腾 Simiki</title><link href="http://www.smallcpp.cn/zhe-teng-simiki.html" rel="alternate"></link><published>2016-05-28T19:18:00+08:00</published><updated>2016-05-28T19:18:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-05-28:/zhe-teng-simiki.html</id><summary type="html">
&lt;h1 id="diy"&gt;DIY 主题&lt;/h1&gt;
&lt;p&gt;Simiki 自带的主题稍微有点 low, 可以使用官网推荐的另一款主题: &lt;a href="https://github.com/tankywoo/yasimple/tree/ce4af036ab95ef1d5235266d8231f97dc14dd871"&gt;yasimple&lt;/a&gt;, Clone 到本地后替换掉 &lt;code&gt;~/themes/simple&lt;/code&gt; 下的文件;&lt;/p&gt;
&lt;p&gt;这些主题都没有网站图标, 所以要再 DIY 一下, 先准备好网站图标, 如 &lt;code&gt;favicon.ico&lt;/code&gt;, 放到 &lt;code&gt;~/themes/simple/static/images&lt;/code&gt; 目录下 (没有 &lt;code&gt;images&lt;/code&gt; 目录就新建一个), 然后打开 …&lt;/p&gt;</summary><content type="html">
&lt;h1 id="diy"&gt;DIY 主题&lt;/h1&gt;
&lt;p&gt;Simiki 自带的主题稍微有点 low, 可以使用官网推荐的另一款主题: &lt;a href="https://github.com/tankywoo/yasimple/tree/ce4af036ab95ef1d5235266d8231f97dc14dd871"&gt;yasimple&lt;/a&gt;, Clone 到本地后替换掉 &lt;code&gt;~/themes/simple&lt;/code&gt; 下的文件;&lt;/p&gt;
&lt;p&gt;这些主题都没有网站图标, 所以要再 DIY 一下, 先准备好网站图标, 如 &lt;code&gt;favicon.ico&lt;/code&gt;, 放到 &lt;code&gt;~/themes/simple/static/images&lt;/code&gt; 目录下 (没有 &lt;code&gt;images&lt;/code&gt; 目录就新建一个), 然后打开 &lt;code&gt;~/themes/simple/base.html&lt;/code&gt;, 在 &lt;strong&gt;head&lt;/strong&gt; 标签中添加如下内容:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;link&lt;/span&gt; &lt;span style="color: #658b00"&gt;rel&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"shortcut icon"&lt;/span&gt; &lt;span style="color: #658b00"&gt;href&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"{{ site.root }}/static/images/favicon.ico"&lt;/span&gt; &lt;span style="color: #658b00"&gt;type&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"image/x-icon"&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;link&lt;/span&gt; &lt;span style="color: #658b00"&gt;rel&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"icon"&lt;/span&gt; &lt;span style="color: #658b00"&gt;href&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"{{ site.root }}/static/images/favicon.ico"&lt;/span&gt; &lt;span style="color: #658b00"&gt;type&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"image/x-icon"&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="diy_1"&gt;DIY 评论&lt;/h1&gt;
&lt;p&gt;我用的是&lt;a href="http://duoshuo.com/"&gt;多说评论系统&lt;/a&gt; (来必力也是一个不错的评论系统, 可以去试试), 首先去&lt;a href="http://duoshuo.com/"&gt;多说官网&lt;/a&gt;注册一个账号, 然后为我们的 wiki 添加一个站点.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i63.tinypic.com/fdd182.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;添加好后, 在管理页面会看到如下信息:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i67.tinypic.com/2cg2dxy.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;打开 Simiki 主题目录下的 &lt;code&gt;page.html&lt;/code&gt; 文件, 在 &lt;code&gt;{% endblock %}&lt;/code&gt; 上面添加上图中的代码, 我这里改成了:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;{% extends "base.html" %}

{% block title %}{{ page.title }} - {{ site.title }}{% endblock %}

{% block container %}
    &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt; &lt;span style="color: #658b00"&gt;id&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"header"&lt;/span&gt;&amp;gt;
        &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt; &lt;span style="color: #658b00"&gt;id&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"post-nav"&lt;/span&gt;&amp;gt;
            {% if not default_home_page %}
            &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;a&lt;/span&gt; &lt;span style="color: #658b00"&gt;href&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"{{ site.root }}/"&lt;/span&gt;&amp;gt;Home&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;a&lt;/span&gt;&amp;gt;{%- if page.category %} » &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;a&lt;/span&gt; &lt;span style="color: #658b00"&gt;href&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"{{ site.root }}/#{{ page.category }}"&lt;/span&gt;&amp;gt;{{ page.category }}&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;a&lt;/span&gt;&amp;gt;
{%- endif %} » {{ page.title }}
            {% endif %}
        &amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
    &amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt; &lt;span style="color: #658b00"&gt;class&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"clearfix"&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt; &lt;span style="color: #658b00"&gt;id&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"content"&lt;/span&gt;&amp;gt;
        {{ page.content }}
    &amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;

    &lt;span style="color: #228B22"&gt;&amp;lt;!-- 多说评论框 start --&amp;gt;&lt;/span&gt;
    &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt; &lt;span style="color: #658b00"&gt;class&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"ds-thread"&lt;/span&gt; &lt;span style="color: #658b00"&gt;data-thread-key&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"{{ page.title }}"&lt;/span&gt; &lt;span style="color: #658b00"&gt;data-title&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"{{ page.title }}"&lt;/span&gt; &lt;span style="color: #658b00"&gt;data-url&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"{{ site.url }}/{{ page.category }}/{{ page.title }}.html"&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
    &lt;span style="color: #228B22"&gt;&amp;lt;!-- 多说评论框 end --&amp;gt;&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;&amp;lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&amp;gt;&lt;/span&gt;
    &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;script&lt;/span&gt; &lt;span style="color: #658b00"&gt;type&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"text/javascript"&lt;/span&gt;&amp;gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;var&lt;/span&gt; duoshuoQuery = {short_name:&lt;span style="color: #CD5555"&gt;"smallwiki"&lt;/span&gt;};
        (&lt;span style="color: #8B008B; font-weight: bold"&gt;function&lt;/span&gt;() {
            &lt;span style="color: #8B008B; font-weight: bold"&gt;var&lt;/span&gt; ds = &lt;span style="color: #658b00"&gt;document&lt;/span&gt;.createElement(&lt;span style="color: #CD5555"&gt;'script'&lt;/span&gt;);
            ds.type = &lt;span style="color: #CD5555"&gt;'text/javascript'&lt;/span&gt;;ds.&lt;span style="color: #8B008B; font-weight: bold"&gt;async&lt;/span&gt; = &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;;
            ds.src = (&lt;span style="color: #658b00"&gt;document&lt;/span&gt;.location.protocol == &lt;span style="color: #CD5555"&gt;'https:'&lt;/span&gt; ? &lt;span style="color: #CD5555"&gt;'https:'&lt;/span&gt; : &lt;span style="color: #CD5555"&gt;'http:'&lt;/span&gt;) + &lt;span style="color: #CD5555"&gt;'//static.duoshuo.com/embed.js'&lt;/span&gt;;
            ds.charset = &lt;span style="color: #CD5555"&gt;'UTF-8'&lt;/span&gt;;
            (&lt;span style="color: #658b00"&gt;document&lt;/span&gt;.getElementsByTagName(&lt;span style="color: #CD5555"&gt;'head'&lt;/span&gt;)[&lt;span style="color: #B452CD"&gt;0&lt;/span&gt;] || &lt;span style="color: #658b00"&gt;document&lt;/span&gt;.getElementsByTagName(&lt;span style="color: #CD5555"&gt;'body'&lt;/span&gt;)[&lt;span style="color: #B452CD"&gt;0&lt;/span&gt;]).appendChild(ds);
        })();
    &amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;script&lt;/span&gt;&amp;gt;
    &lt;span style="color: #228B22"&gt;&amp;lt;!-- 多说公共JS代码 end --&amp;gt;&lt;/span&gt;

{% endblock %}
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="diy_2"&gt;DIY 部署&lt;/h1&gt;
&lt;p&gt;我使用的是 Github Project Page, 所以可以把 &lt;strong&gt;output&lt;/strong&gt; 目录加入 &lt;strong&gt;.gitignore&lt;/strong&gt; 来忽略每次生成时的变化.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;master&lt;/strong&gt; 分支托管源文件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gh-pages&lt;/strong&gt; 分支放 &lt;strong&gt;output&lt;/strong&gt; 的发布文件&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注意, 第一次使用时要先 &lt;strong&gt;push&lt;/strong&gt; 一次 &lt;strong&gt;master&lt;/strong&gt; 分支&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;推送 &lt;strong&gt;gh-pages&lt;/strong&gt; 分支这一步可以使用 &lt;a href="https://github.com/davisp/ghp-import"&gt;ghp-import&lt;/a&gt; 来简化操作, &lt;strong&gt;ghp-import&lt;/strong&gt; 是一个 python 工具包, 能把一个文件夹里的内容推送到一个 branch 里, 不过 ghp-import 在 windows 下各种坑, 所以 windows 下就别想了…&lt;/p&gt;
&lt;p&gt;官方给出了自动化部署的 &lt;code&gt;fabfile.py&lt;/code&gt; 文件 (依赖于 &lt;strong&gt;gh-pages&lt;/strong&gt;, windows 下勿使用), 只需在 &lt;code&gt;_config.yml&lt;/code&gt; 中添加如下内容:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;deploy:
  - type: git
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后使用 &lt;code&gt;fab deploy&lt;/code&gt; 就能自动把 &lt;strong&gt;output&lt;/strong&gt; 目录推送到远程 &lt;strong&gt;gh-pages&lt;/strong&gt; 分支.&lt;/p&gt;
&lt;p&gt;最后, 由于 Github Project Page 需要用到一个 &lt;code&gt;CNAME&lt;/code&gt; 文件, 所以我修改了官方 &lt;code&gt;fabfile.py&lt;/code&gt; 文件的 &lt;code&gt;deploy_git&lt;/code&gt; 函数, 让部署时自动生成 &lt;code&gt;CNAME&lt;/code&gt; 文件:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #008b45"&gt;deploy_git&lt;/span&gt;(deploy_configs):
    &lt;span style="color: #CD5555"&gt;'''for pages service of such as github/gitcafe ...'''&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;with&lt;/span&gt; settings(warn_only=&lt;span style="color: #8B008B; font-weight: bold"&gt;True&lt;/span&gt;):
        res = local(&lt;span style="color: #CD5555"&gt;'which ghp-import &amp;gt; /dev/null 2&amp;gt;&amp;amp;1; echo $?'&lt;/span&gt;, capture=&lt;span style="color: #8B008B; font-weight: bold"&gt;True&lt;/span&gt;)
        &lt;span style="color: #8B008B; font-weight: bold"&gt;if&lt;/span&gt; &lt;span style="color: #658b00"&gt;int&lt;/span&gt;(res.strip()):
            do_exit(&lt;span style="color: #CD5555"&gt;'Warning: ghp-import not installed! '&lt;/span&gt;
                    &lt;span style="color: #CD5555"&gt;'run: `pip install ghp-import`'&lt;/span&gt;)
    output_dir = configs[&lt;span style="color: #CD5555"&gt;'destination'&lt;/span&gt;]
    &lt;span style="color: #8B008B; font-weight: bold"&gt;with&lt;/span&gt; lcd(output_dir):  &lt;span style="color: #228B22"&gt;# 添加 CNAME 文件&lt;/span&gt;
        local(&lt;span style="color: #CD5555"&gt;'echo wiki.smallcpp.cn &amp;gt; CNAME'&lt;/span&gt;)
    remote = deploy_configs.get(&lt;span style="color: #CD5555"&gt;'remote'&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;'origin'&lt;/span&gt;)
    branch = deploy_configs.get(&lt;span style="color: #CD5555"&gt;'branch'&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;'gh-pages'&lt;/span&gt;)
    &lt;span style="color: #228B22"&gt;# commit gh-pages branch and push to remote&lt;/span&gt;
    _mesg = &lt;span style="color: #CD5555"&gt;'Update output documentation'&lt;/span&gt;
    local(&lt;span style="color: #CD5555"&gt;'ghp-import -p -m "{0}" -r {1} -b {2} {3}'&lt;/span&gt;
          .format(_mesg, remote, branch, output_dir))
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="_1"&gt;注意事项&lt;/h1&gt;
&lt;p&gt;后期使用时发现一些问题要注意下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件要以 &lt;code&gt;md&lt;/code&gt; 后缀, 不能以 &lt;code&gt;markdown&lt;/code&gt; 后缀&lt;/li&gt;
&lt;li&gt;文件头信息字段冒号后要空一格: &lt;code&gt;title: 标题&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;文件头信息特殊字符不能放在起始位置:
    + &lt;code&gt;title: [折腾] Simiki&lt;/code&gt; =&amp;gt; 错误
    + &lt;code&gt;title: Simiki [折腾]&lt;/code&gt; =&amp;gt; 正确&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="_2"&gt;补充&lt;/h1&gt;
&lt;p&gt;推荐使用 &lt;a href="http://www.smallcpp.cn/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/%E6%8A%98%E8%85%BE%20Travis%20CI.html"&gt;Travis-ci&lt;/a&gt; 自动化部署 Simiki 项目.&lt;/p&gt;</content><category term="工具折腾"></category></entry><entry><title>使用 Simiki 进行碎片整理</title><link href="http://www.smallcpp.cn/shi-yong-simiki-jin-xing-sui-pian-zheng-li.html" rel="alternate"></link><published>2016-05-27T19:46:00+08:00</published><updated>2016-05-27T19:46:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-05-27:/shi-yong-simiki-jin-xing-sui-pian-zheng-li.html</id><summary type="html">
&lt;h1 id="_1"&gt;开始&lt;/h1&gt;
&lt;p&gt;从 Hansong Xiao 的&lt;a href="http://blog.xiaohansong.com/2016/01/16/kownledge-Management/"&gt;程序员的知识管理&lt;/a&gt;中学到用 wiki 来进行知识碎片整理, 确实, 一些零散的知识, 如某个常用命令的语法、特定的软件配置等等, 记到博客上太零碎, 本地记录的也不够系统, 放到个人 Wiki 是最不过了, 使用的就是 Hansong Xiao 推荐的 &lt;a href="http://simiki.org/"&gt;Simiki&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Simiki 提供了&lt;a href="http://simiki.org/zh-docs/"&gt;中文文档&lt;/a&gt;, 十分简单, 参考&lt;a href="http://simiki.org/zh-docs/"&gt;中文文档&lt;/a&gt;分分钟就上手了 …&lt;/p&gt;</summary><content type="html">
&lt;h1 id="_1"&gt;开始&lt;/h1&gt;
&lt;p&gt;从 Hansong Xiao 的&lt;a href="http://blog.xiaohansong.com/2016/01/16/kownledge-Management/"&gt;程序员的知识管理&lt;/a&gt;中学到用 wiki 来进行知识碎片整理, 确实, 一些零散的知识, 如某个常用命令的语法、特定的软件配置等等, 记到博客上太零碎, 本地记录的也不够系统, 放到个人 Wiki 是最不过了, 使用的就是 Hansong Xiao 推荐的 &lt;a href="http://simiki.org/"&gt;Simiki&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Simiki 提供了&lt;a href="http://simiki.org/zh-docs/"&gt;中文文档&lt;/a&gt;, 十分简单, 参考&lt;a href="http://simiki.org/zh-docs/"&gt;中文文档&lt;/a&gt;分分钟就上手了, 当然还是有些配置要折腾的, Reference &lt;a href="http://wiki.smallcpp.cn/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/%E6%8A%98%E8%85%BE%20Simiki.html"&gt;折腾 Simiki&lt;/a&gt;&lt;/p&gt;
&lt;h1 id="_2"&gt;补充&lt;/h1&gt;
&lt;p&gt;目前我使用 &lt;a href="http://wiki.smallcpp.cn/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/%E6%8A%98%E8%85%BE%20Travis%20CI.html"&gt;Github Project Pages + Travis-ci&lt;/a&gt; 来自动化部署 Simiki 项目.&lt;/p&gt;</content><category term="杂项"></category></entry><entry><title>迁移 Github Project Page</title><link href="http://www.smallcpp.cn/qian-yi-github-project-page.html" rel="alternate"></link><published>2016-05-25T18:45:00+08:00</published><updated>2016-05-25T18:45:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-05-25:/qian-yi-github-project-page.html</id><summary type="html">&lt;p&gt;将我的博客从 User Pages site 迁移到 Project Pages site.&lt;/p&gt;</summary><content type="html">&lt;p&gt;在很早之前我从 wordpress 迁移到 github, 参考日记: &lt;a href="http://www.smallcpp.cn/cong-wp-qian-yi-dao-pelican-github.html"&gt;从 wp 迁移到 pelican (github)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;近期读到一个博主的文章: &lt;a href="http://blog.xiaohansong.com/2016/01/16/kownledge-Management/"&gt;程序员的知识管理&lt;/a&gt;, 参考了下他的 &lt;a href="http://xiaohansong.com/"&gt;Github Page 首页&lt;/a&gt;, 发现挺有意思的.&lt;/p&gt;
&lt;p&gt;他的 &lt;a href="https://github.com/x-hansong/x-hansong.github.io"&gt;Github Page 本身&lt;/a&gt; 很少内容, 但是 &lt;a href="http://blog.xiaohansong.com/"&gt;http://blog.xiaohansong.com/&lt;/a&gt; 却能访问到他的 &lt;a href="https://github.com/x-hansong/blog"&gt;blog 仓储&lt;/a&gt;, 而 &lt;a href="http://blog.xiaohansong.com/"&gt;http://wiki.xiaohansong.com/&lt;/a&gt; 也能访问 &lt;a href="https://github.com/x-hansong/wiki"&gt;wiki 仓储&lt;/a&gt;…&lt;/p&gt;
&lt;p&gt;查找到 &lt;a href="https://help.github.com/categories/github-pages-basics/"&gt;Gihub 官方 Github Page 资料&lt;/a&gt; 才发现还有 &lt;strong&gt;User Pages site&lt;/strong&gt; 和 &lt;strong&gt;Project Pages site&lt;/strong&gt; 之分, 而上面那位就是利用了 &lt;strong&gt;Project Pages site&lt;/strong&gt;…于是, 本着学习的态度, 我迁移了自己的 Github Page.&lt;/p&gt;

&lt;h1 id="project-pages-site"&gt;创建 Project Pages site&lt;/h1&gt;
&lt;p&gt;Project Pages site 和普通的 Github Repository 没两样, 但它利用一个 &lt;code&gt;gh-pages&lt;/code&gt; 分支来用于构建和发布项目页面的网站, 然后通过 &lt;code&gt;username.github.io/projectname&lt;/code&gt; (你也可以自定义域名) 来访问这个项目的 &lt;code&gt;gh-pages&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;我们直接在 Github 上再新建个仓库命名为 &lt;code&gt;blog&lt;/code&gt;, 然后将它 clone 到本地:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;git clone github.com/user/repository.git
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再创建 &lt;code&gt;gh-pages&lt;/code&gt; 分支:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #658b00"&gt;cd&lt;/span&gt; repository

git checkout --orphan gh-pages
Switched to a new branch &lt;span style="color: #CD5555"&gt;'gh-pages'&lt;/span&gt;

git rm -rf .
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在, 这个 &lt;code&gt;gh-pages&lt;/code&gt; 分支就是我们新的 &lt;code&gt;blog&lt;/code&gt; 仓库, 类似于以前 Github Page 仓库 (username.github.io) 的主分支, 我们将以前 Github Page 仓库下的文件拷贝到这个 &lt;code&gt;gh-pages&lt;/code&gt; 分支下, 最后提交到远程:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;git push origin gh-pages
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在, 我们通过 &lt;code&gt;username.github.io/blog&lt;/code&gt; 就能访问 &lt;code&gt;blog&lt;/code&gt; 仓库 &lt;code&gt;gh-pages&lt;/code&gt; 分支下的 &lt;code&gt;index.html&lt;/code&gt; 文件.&lt;/p&gt;
&lt;h1 id="_1"&gt;添加自定义域名&lt;/h1&gt;
&lt;p&gt;首先修改 &lt;code&gt;gh-pages&lt;/code&gt; 下的 &lt;code&gt;CNAME&lt;/code&gt; 文件内容, 从顶级域名 &lt;code&gt;smallcpp.cn&lt;/code&gt; 改为子级域名 &lt;code&gt;blog.smallcpp.cn&lt;/code&gt;  (&lt;code&gt;smallcpp.cn&lt;/code&gt; 是我的顶级域名, 你需要自己购买), 改完后可以通过下面的方法验证下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Repository settings buttonUnder your repository name, click  Settings.&lt;/li&gt;
&lt;li&gt;Under “GitHub Pages”, you should see the custom domain from your CNAME file.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="http://i64.tinypic.com/5dmhqc.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;然后去 &lt;code&gt;dnspod&lt;/code&gt; 为 &lt;code&gt;smallcpp.cn&lt;/code&gt; 添加一个记录:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;blog    CNAME        username.github.io
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改过后要等一段时间才能生效, 具体时间视域名运营商决定…&lt;/p&gt;
&lt;h1 id="_2"&gt;迁移博客源文件&lt;/h1&gt;
&lt;p&gt;我是用 &lt;code&gt;Pelican&lt;/code&gt; 创建的博客, 在以前, 放在 &lt;code&gt;username.github.io&lt;/code&gt; 下的是发布文件 (即通过 &lt;code&gt;make html&lt;/code&gt; 生成的网站文件), &lt;code&gt;Pelican&lt;/code&gt; 源码文件通过另一个仓库 &lt;code&gt;MyBlog&lt;/code&gt; 来保存.&lt;/p&gt;
&lt;p&gt;现在, 我有了 Project Repository, 它的 &lt;code&gt;gh-pages&lt;/code&gt; 分支被用来放发布文件, 它的 &lt;code&gt;master&lt;/code&gt; 分支就可以用来放博客的源码文件啦~&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i63.tinypic.com/xddzia.jpg"/&gt;&lt;/p&gt;
&lt;h1 id="pelican"&gt;修改 Pelican 配置&lt;/h1&gt;
&lt;p&gt;在 Pelican 项目中, &lt;code&gt;pelicanconf.py&lt;/code&gt; 配置文件中有一项 &lt;strong&gt;SITEURL&lt;/strong&gt; 指向的是 &lt;code&gt;http://username.github.io&lt;/code&gt;, 因此所有的静态文件都是访问 &lt;code&gt;username.github.io&lt;/code&gt; 下的, 现在要改成 &lt;code&gt;http://username.github.io/blog&lt;/code&gt;.&lt;/p&gt;
&lt;h1 id="_3"&gt;补充&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Pelican&lt;/strong&gt; 提供了 &lt;strong&gt;fabric&lt;/strong&gt; 的方式部署代码, 直接执行 &lt;code&gt;fab gh_pages&lt;/code&gt; 就能把项目的 output 目录下的文件推送到 &lt;code&gt;gh-pages&lt;/code&gt; 分支, 不过要修改下 Pelican 默认的 &lt;code&gt;fabfile.py&lt;/code&gt; (让其自动生成 CNAME):&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #008b45"&gt;gh_pages&lt;/span&gt;():
    &lt;span style="color: #CD5555"&gt;"""Publish to GitHub Pages"""&lt;/span&gt;
    rebuild()
    &lt;span style="color: #8B008B; font-weight: bold"&gt;with&lt;/span&gt; lcd(&lt;span style="color: #CD5555"&gt;'{deploy_path}'&lt;/span&gt;.format(**env)):
        local(&lt;span style="color: #CD5555"&gt;'echo blog.smallcpp.cn &amp;gt; CNAME'&lt;/span&gt;)

    local(&lt;span style="color: #CD5555"&gt;"ghp-import -b {github_pages_branch} {deploy_path}"&lt;/span&gt;.format(**env))
    local(&lt;span style="color: #CD5555"&gt;"git push origin {github_pages_branch}"&lt;/span&gt;.format(**env))
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="references"&gt;References&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://help.github.com/categories/github-pages-basics/"&gt;GitHub Pages Basics&lt;/a&gt;&lt;br/&gt;
&lt;a href="https://help.github.com/articles/setting-up-your-pages-site-repository/"&gt;Setting up your pages site repository&lt;/a&gt;&lt;br/&gt;
&lt;a href="https://help.github.com/articles/setting-up-a-custom-subdomain/"&gt;Setting up a custom subdomain&lt;/a&gt;&lt;br/&gt;
&lt;a href="http://wiki.jikexueyuan.com/project/github-pages-basics/"&gt;GitHub Pages 指南&lt;/a&gt;&lt;br/&gt;
&lt;a href="https://segmentfault.com/a/1190000003946969"&gt;单个 GitHub 帐号下添加多个 GitHub Pages 的相关问题&lt;/a&gt;&lt;/p&gt;</content><category term="杂项"></category></entry><entry><title>在 OpenShift 上部署 Django Todolist 应用</title><link href="http://www.smallcpp.cn/zai-openshift-shang-bu-shu-django-todolist-ying-yong.html" rel="alternate"></link><published>2016-05-11T10:23:00+08:00</published><updated>2016-05-11T10:23:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-05-11:/zai-openshift-shang-bu-shu-django-todolist-ying-yong.html</id><summary type="html">
&lt;h1 id="openshift-django"&gt;一、初始化 Openshift Django 应用&lt;/h1&gt;
&lt;p&gt;首先去 Openshift 上创建一个 Django 应用, 关于怎么创建 Openshift 应用参考我&lt;a href="http://www.smallcpp.cn/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/%E5%8D%90%20%E8%A7%A3%E5%90%A7!%20%E5%8F%B9%E6%81%AF%E5%A2%99!%20%E2%80%94%20%E4%BC%98%E9%9B%85%E7%9A%84%E7%BF%BB%E5%A2%99.html"&gt;另一篇笔记&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我这里创建了一个 &lt;code&gt;todolist-smallcpp.rhcloud.com&lt;/code&gt;, 然后, 利用&lt;a href="http://www.smallcpp.cn/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/%E5%8D%90%20%E8%A7%A3%E5%90%A7!%20%E5%8F%B9%E6%81%AF%E5%A2%99!%20%E2%80%94%20%E4%BC%98%E9%9B%85%E7%9A%84%E7%BF%BB%E5%A2%99.html"&gt;另一篇笔记&lt;/a&gt;的知识用 SecureCRT 连上我们的服务器.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;补充一下用 putty.exe 连接的方法.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先, 和 …&lt;/p&gt;</summary><content type="html">
&lt;h1 id="openshift-django"&gt;一、初始化 Openshift Django 应用&lt;/h1&gt;
&lt;p&gt;首先去 Openshift 上创建一个 Django 应用, 关于怎么创建 Openshift 应用参考我&lt;a href="http://www.smallcpp.cn/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/%E5%8D%90%20%E8%A7%A3%E5%90%A7!%20%E5%8F%B9%E6%81%AF%E5%A2%99!%20%E2%80%94%20%E4%BC%98%E9%9B%85%E7%9A%84%E7%BF%BB%E5%A2%99.html"&gt;另一篇笔记&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我这里创建了一个 &lt;code&gt;todolist-smallcpp.rhcloud.com&lt;/code&gt;, 然后, 利用&lt;a href="http://www.smallcpp.cn/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/%E5%8D%90%20%E8%A7%A3%E5%90%A7!%20%E5%8F%B9%E6%81%AF%E5%A2%99!%20%E2%80%94%20%E4%BC%98%E9%9B%85%E7%9A%84%E7%BF%BB%E5%A2%99.html"&gt;另一篇笔记&lt;/a&gt;的知识用 SecureCRT 连上我们的服务器.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;补充一下用 putty.exe 连接的方法.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先, 和&lt;a href="http://www.smallcpp.cn/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/%E5%8D%90%20%E8%A7%A3%E5%90%A7!%20%E5%8F%B9%E6%81%AF%E5%A2%99!%20%E2%80%94%20%E4%BC%98%E9%9B%85%E7%9A%84%E7%BF%BB%E5%A2%99.html"&gt;另一篇笔记&lt;/a&gt;中一样, 通过 &lt;a href="http://www.smallcpp.cn/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git%20%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C.html#101-ssh-key"&gt;Git 简明手册&lt;/a&gt; 拿到了两个密钥文件: id_rsa(私钥) 和 id_rsa.pub(公钥), 将 id_rsa.pub(公钥) 部署到刚创建的 Django 应用上.&lt;/p&gt;
&lt;p&gt;putty.exe 不能识别直接从服务器拷贝来的私钥, 需要使用 &lt;code&gt;puttygen.exe&lt;/code&gt; 进行格式转换.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开 puttygen.exe --&amp;gt; Conversions --&amp;gt; Import Key&lt;/li&gt;
&lt;li&gt;选择私钥文件 id_rsa&lt;/li&gt;
&lt;li&gt;Save private key -&amp;gt; id_rsa.ppk (保存私钥)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后, 打开 putty.exe&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Session --&amp;gt; Host Name (填写服务器地址或者域名)&lt;/li&gt;
&lt;li&gt;Connection --&amp;gt; SSH --&amp;gt; Auth (点 Browse 选择刚生成的 id_rsa.ppk)&lt;/li&gt;
&lt;li&gt;Connection --&amp;gt; Data (填写 Auto-login username)&lt;/li&gt;
&lt;li&gt;open&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;成功连接后出现下面这样的提示:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;login as: your login user name
Authenticating with public key &lt;span style="color: #CD5555"&gt;"imported-openssh-key"&lt;/span&gt;
...
[todolist-smallcpp.rhcloud.com your login user name]&lt;span style="color: #CD5555"&gt;\&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="django"&gt;二、配置默认的 Django&lt;/h1&gt;
&lt;p&gt;用 Openshift 创建的 Django 应用默认有一个 &lt;code&gt;Hello World&lt;/code&gt; (你懂的…), 但此时我们直接访问 &lt;a href="https://todolist-smallcpp.rhcloud.com"&gt;https://todolist-smallcpp.rhcloud.com&lt;/a&gt; 是会报错的…需要配置下.&lt;/p&gt;
&lt;p&gt;我们先用 git 把 Openshift 上的 Django 项目 pull 回本地 (git 地址在创建应用时网站上会提示), 该项目目录如下:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i66.tinypic.com/zvu6o3.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;里面有个 &lt;code&gt;Readme.md&lt;/code&gt;, 阅读后发现下面这些信息:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Django project name 是 myproject (在 wsgi 目录下)&lt;/li&gt;
&lt;li&gt;数据库保存在 $OPENSHIFT_DATA_DIR/db.sqlite3 ($OPENSHIFT_DATA_DIR 是一个 Link, 指向 app-root/data)&lt;/li&gt;
&lt;li&gt;初次使用, 必须创建/修改 admin 的密码
    + &lt;code&gt;python $OPENSHIFT_REPO_DIR/wsgi/myproject/manage.py createsuperuser&lt;/code&gt; ($OPENSHIFT_REPO_DIR 是一个 Link, 指向 app-root/runtime/repo)
    + 登录地址: &lt;a href="https://todolist-smallcpp.rhcloud.com/admin"&gt;https://todolist-smallcpp.rhcloud.com/admin&lt;/a&gt; (已被修改为 &lt;a href="https://todolist-smallcpp.rhcloud.com/todos"&gt;https://todolist-smallcpp.rhcloud.com/todos&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;要注意使用 &lt;code&gt;python $OPENSHIFT_REPO_DIR/wsgi/myproject/manage.py syncdb&lt;/code&gt; 同步数据库
    + 由于 &lt;code&gt;syncdb&lt;/code&gt; 的尿性, 如果修改了数据库结构, 需要先执行 &lt;code&gt;rm -f $OPENSHIFT_DATA_DIR/db.sqlite3&lt;/code&gt;
    + 关于 &lt;code&gt;syncdb&lt;/code&gt; 的说明参考我另一篇笔记 &lt;code&gt;44. Django migration vs syncdb&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="todolist"&gt;三、安装 todolist 项目&lt;/h1&gt;
&lt;p&gt;todolist 我弄了个&lt;a href="https://github.com/zongxiao/Django-Simple-Todo"&gt;开源的源码&lt;/a&gt;, clone 到本地, 将目录更名为 &lt;code&gt;todolist&lt;/code&gt; 并放到步骤二 pull 回本地的 Django 项目根目录的 &lt;code&gt;wsgi&lt;/code&gt; 目录下, 并删除自带的 &lt;code&gt;myproject&lt;/code&gt; 目录 (注意, 备份下 &lt;code&gt;myproject&lt;/code&gt; 里的 &lt;code&gt;settings.py&lt;/code&gt;, 后面有用).&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i67.tinypic.com/2ijixar.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i63.tinypic.com/24yza51.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i67.tinypic.com/j0fyc9.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;然后有几个关键地方要配置:&lt;/p&gt;
&lt;p&gt;首先是 &lt;code&gt;setup.py&lt;/code&gt; 文件, 其中有一项 &lt;code&gt;install_requires&lt;/code&gt; 很重要, 它表示项目中用到的第三方 python 库, 填在里面的项 push 到 openshift 后, openshift 会自动调用 easy_install 进行安装, 例如:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;install_requires = [&lt;span style="color: #CD5555"&gt;'Django&amp;lt;=1.8'&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;'django-markdown'&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;'django-markdown-deux==1.0.5'&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;'markdown2==2.3.0'&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;'markdown'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后打开 &lt;code&gt;\todolist\.openshift\action_hooks&lt;/code&gt; 目录下的 &lt;code&gt;deploy&lt;/code&gt; 文件, 这里面保存的是当 push 到 openshift 后执行的动作, 我们把里面的 &lt;code&gt;myproject&lt;/code&gt; 改为 &lt;code&gt;todolist&lt;/code&gt;.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;#!/bin/bash&lt;/span&gt;
&lt;span style="color: #228B22"&gt;# This deploy hook gets executed after dependencies are resolved and the&lt;/span&gt;
&lt;span style="color: #228B22"&gt;# build hook has been run but before the application has been started back&lt;/span&gt;
&lt;span style="color: #228B22"&gt;# up again.  This script gets executed directly, so it could be python, php,&lt;/span&gt;
&lt;span style="color: #228B22"&gt;# ruby, etc.&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;if&lt;/span&gt; [ &lt;span style="color: #a61717; background-color: #e3d2d2"&gt;!&lt;/span&gt; -f &lt;span style="color: #CD5555"&gt;"$OPENSHIFT_DATA_DIR"&lt;/span&gt;secrets.json ]; then
    echo &lt;span style="color: #CD5555"&gt;"Generating $OPENSHIFT_DATA_DIR/secrets.json"&lt;/span&gt;
    python &lt;span style="color: #CD5555"&gt;"$OPENSHIFT_REPO_DIR"&lt;/span&gt;libs/secrets.py &amp;gt; &lt;span style="color: #CD5555"&gt;"$OPENSHIFT_DATA_DIR"&lt;/span&gt;secrets.json
fi

&lt;span style="color: #228B22"&gt;# GETTING-STARTED: change 'todolist' to your project name:&lt;/span&gt;
echo &lt;span style="color: #CD5555"&gt;"Executing 'python $OPENSHIFT_REPO_DIR/wsgi/todolist/manage.py migrate --noinput'"&lt;/span&gt;
&lt;span style="color: #228B22"&gt;# GETTING-STARTED: change 'todolist' to your project name:&lt;/span&gt;
python &lt;span style="color: #CD5555"&gt;"$OPENSHIFT_REPO_DIR"&lt;/span&gt;wsgi/todolist/manage.py migrate --noinput

&lt;span style="color: #228B22"&gt;# GETTING-STARTED: change 'todolist' to your project name:&lt;/span&gt;
echo &lt;span style="color: #CD5555"&gt;"Executing 'python $OPENSHIFT_REPO_DIR/wsgi/todolist/manage.py collectstatic --noinput'"&lt;/span&gt;
&lt;span style="color: #228B22"&gt;# GETTING-STARTED: change 'todolist' to your project name:&lt;/span&gt;
python &lt;span style="color: #CD5555"&gt;"$OPENSHIFT_REPO_DIR"&lt;/span&gt;wsgi/todolist/manage.py collectstatic --noinput
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再进入 &lt;code&gt;wsgi&lt;/code&gt; 文件夹, 里面有个 &lt;code&gt;application&lt;/code&gt; 的文件&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;#!/usr/bin/env python&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;os&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;sys&lt;/span&gt;
&lt;span style="color: #228B22"&gt;## GETTING-STARTED: make sure the next line points to your settings.py:&lt;/span&gt;
os.environ[&lt;span style="color: #CD5555"&gt;'DJANGO_SETTINGS_MODULE'&lt;/span&gt;] = &lt;span style="color: #CD5555"&gt;'openshift.settings'&lt;/span&gt;
&lt;span style="color: #228B22"&gt;## GETTING-STARTED: make sure the next line points to your django project dir:&lt;/span&gt;
sys.path.append(os.path.join(os.environ[&lt;span style="color: #CD5555"&gt;'OPENSHIFT_REPO_DIR'&lt;/span&gt;], &lt;span style="color: #CD5555"&gt;'wsgi'&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;'openshift'&lt;/span&gt;))
virtenv = os.environ[&lt;span style="color: #CD5555"&gt;'APPDIR'&lt;/span&gt;] + &lt;span style="color: #CD5555"&gt;'/virtenv/'&lt;/span&gt;
&lt;span style="color: #228B22"&gt;## GETTING-STARTED: make sure the next line has the right python version:&lt;/span&gt;
os.environ[&lt;span style="color: #CD5555"&gt;'PYTHON_EGG_CACHE'&lt;/span&gt;] = os.path.join(virtenv, &lt;span style="color: #CD5555"&gt;'lib/python2.7/site-packages'&lt;/span&gt;)
virtualenv = os.path.join(virtenv, &lt;span style="color: #CD5555"&gt;'bin/activate_this.py'&lt;/span&gt;)
&lt;span style="color: #8B008B; font-weight: bold"&gt;try&lt;/span&gt;:
    execfile(virtualenv, &lt;span style="color: #658b00"&gt;dict&lt;/span&gt;(&lt;span style="color: #00688B"&gt;__file__&lt;/span&gt;=virtualenv))
&lt;span style="color: #8B008B; font-weight: bold"&gt;except&lt;/span&gt;:
    &lt;span style="color: #8B008B; font-weight: bold"&gt;pass&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;django.core.wsgi&lt;/span&gt;
application = django.core.wsgi.get_wsgi_application()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意这两行:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;os.environ[&lt;span style="color: #CD5555"&gt;'DJANGO_SETTINGS_MODULE'&lt;/span&gt;] = &lt;span style="color: #CD5555"&gt;'myproject.settings'&lt;/span&gt;
sys.path.append(os.path.join(os.environ[&lt;span style="color: #CD5555"&gt;'OPENSHIFT_REPO_DIR'&lt;/span&gt;], &lt;span style="color: #CD5555"&gt;'wsgi'&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;'myproject'&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;改为:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;os.environ[&lt;span style="color: #CD5555"&gt;'DJANGO_SETTINGS_MODULE'&lt;/span&gt;] = &lt;span style="color: #CD5555"&gt;'simple_todo.settings'&lt;/span&gt;
sys.path.append(os.path.join(os.environ[&lt;span style="color: #CD5555"&gt;'OPENSHIFT_REPO_DIR'&lt;/span&gt;], &lt;span style="color: #CD5555"&gt;'wsgi'&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;'todolist'&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;, 别改错了,  第一个是 &lt;code&gt;simple_todo.settings&lt;/code&gt;, 别改成 &lt;code&gt;todolist.settings&lt;/code&gt; 了.&lt;/p&gt;
&lt;p&gt;最后, 进入 &lt;code&gt;\todolist\wsgi\todolist\simple_todo&lt;/code&gt; 目录, 用之前从 &lt;code&gt;myproject&lt;/code&gt; 里备份的 &lt;code&gt;settings.py&lt;/code&gt; 替换掉 &lt;code&gt;simple_todo&lt;/code&gt; 里的 &lt;code&gt;settings.py&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;但要做下修改, 把 &lt;code&gt;settings.py&lt;/code&gt; 里的 &lt;code&gt;myproject&lt;/code&gt; 替换成 &lt;code&gt;simple_todo&lt;/code&gt;, 然后在 &lt;code&gt;INSTALLED_APPS&lt;/code&gt; 里添加一项 &lt;code&gt;todo&lt;/code&gt;, 再把 &lt;code&gt;Debug&lt;/code&gt; 属性改为 &lt;code&gt;False&lt;/code&gt; (如果部署到 openshift 后发现有问题, 可以改为 &lt;code&gt;True&lt;/code&gt; 后进行调试, 调试完毕再改为 &lt;code&gt;False&lt;/code&gt;), 改完后的 &lt;code&gt;settings.py&lt;/code&gt; 如下:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #CD5555"&gt;"""&lt;/span&gt;
&lt;span style="color: #CD5555"&gt;Django settings for simple_todo project.&lt;/span&gt;

&lt;span style="color: #CD5555"&gt;For more information on this file, see&lt;/span&gt;
&lt;span style="color: #CD5555"&gt;https://docs.djangoproject.com/en/1.8/topics/settings/&lt;/span&gt;

&lt;span style="color: #CD5555"&gt;For the full list of settings and their values, see&lt;/span&gt;
&lt;span style="color: #CD5555"&gt;https://docs.djangoproject.com/en/1.8/ref/settings/&lt;/span&gt;
&lt;span style="color: #CD5555"&gt;"""&lt;/span&gt;

&lt;span style="color: #228B22"&gt;# Build paths inside the project like this: os.path.join(BASE_DIR, ...)&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;os&lt;/span&gt;
DJ_PROJECT_DIR = os.path.dirname(&lt;span style="color: #00688B"&gt;__file__&lt;/span&gt;)
BASE_DIR = os.path.dirname(DJ_PROJECT_DIR)
WSGI_DIR = os.path.dirname(BASE_DIR)
REPO_DIR = os.path.dirname(WSGI_DIR)
DATA_DIR = os.environ.get(&lt;span style="color: #CD5555"&gt;'OPENSHIFT_DATA_DIR'&lt;/span&gt;, BASE_DIR)

&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;sys&lt;/span&gt;
sys.path.append(os.path.join(REPO_DIR, &lt;span style="color: #CD5555"&gt;'libs'&lt;/span&gt;))
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;secrets&lt;/span&gt;
SECRETS = secrets.getter(os.path.join(DATA_DIR, &lt;span style="color: #CD5555"&gt;'secrets.json'&lt;/span&gt;))

&lt;span style="color: #228B22"&gt;# Quick-start development settings - unsuitable for production&lt;/span&gt;
&lt;span style="color: #228B22"&gt;# See https://docs.djangoproject.com/en/1.8/howto/deployment/checklist/&lt;/span&gt;

&lt;span style="color: #228B22"&gt;# SECURITY WARNING: keep the secret key used in production secret!&lt;/span&gt;
SECRET_KEY = SECRETS[&lt;span style="color: #CD5555"&gt;'secret_key'&lt;/span&gt;]

&lt;span style="color: #228B22"&gt;# SECURITY WARNING: don't run with debug turned on in production!&lt;/span&gt;
DEBUG = &lt;span style="color: #8B008B; font-weight: bold"&gt;False&lt;/span&gt;
TEMPLATE_DEBUG = DEBUG

&lt;span style="color: #8B008B; font-weight: bold"&gt;from&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;socket&lt;/span&gt; &lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; gethostname
ALLOWED_HOSTS = [
    gethostname(), &lt;span style="color: #228B22"&gt;# For internal OpenShift load balancer security purposes.&lt;/span&gt;
    os.environ.get(&lt;span style="color: #CD5555"&gt;'OPENSHIFT_APP_DNS'&lt;/span&gt;), &lt;span style="color: #228B22"&gt;# Dynamically map to the OpenShift gear name.&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;#'example.com', # First DNS alias (set up in the app)&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;#'www.example.com', # Second DNS alias (set up in the app)&lt;/span&gt;
]

&lt;span style="color: #228B22"&gt;# Application definition&lt;/span&gt;

INSTALLED_APPS = (
    &lt;span style="color: #CD5555"&gt;'django.contrib.auth'&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;'django.contrib.contenttypes'&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;'django.contrib.sessions'&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;'django.contrib.messages'&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;'django.contrib.staticfiles'&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;'todo'&lt;/span&gt;,
)

MIDDLEWARE_CLASSES = (
    &lt;span style="color: #CD5555"&gt;'django.contrib.sessions.middleware.SessionMiddleware'&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;'django.middleware.common.CommonMiddleware'&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;'django.middleware.csrf.CsrfViewMiddleware'&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;'django.contrib.auth.middleware.AuthenticationMiddleware'&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;'django.contrib.auth.middleware.SessionAuthenticationMiddleware'&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;'django.contrib.messages.middleware.MessageMiddleware'&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;'django.middleware.clickjacking.XFrameOptionsMiddleware'&lt;/span&gt;,
)

&lt;span style="color: #228B22"&gt;# GETTING-STARTED: change 'simple_todo' to your project name:&lt;/span&gt;
ROOT_URLCONF = &lt;span style="color: #CD5555"&gt;'simple_todo.urls'&lt;/span&gt;

TEMPLATES = [
    {
        &lt;span style="color: #CD5555"&gt;'BACKEND'&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;'django.template.backends.django.DjangoTemplates'&lt;/span&gt;,
        &lt;span style="color: #CD5555"&gt;'DIRS'&lt;/span&gt;: [],
        &lt;span style="color: #CD5555"&gt;'APP_DIRS'&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;True&lt;/span&gt;,
        &lt;span style="color: #CD5555"&gt;'OPTIONS'&lt;/span&gt;: {
            &lt;span style="color: #CD5555"&gt;'context_processors'&lt;/span&gt;: [
                &lt;span style="color: #CD5555"&gt;'django.template.context_processors.debug'&lt;/span&gt;,
                &lt;span style="color: #CD5555"&gt;'django.template.context_processors.request'&lt;/span&gt;,
                &lt;span style="color: #CD5555"&gt;'django.contrib.auth.context_processors.auth'&lt;/span&gt;,
                &lt;span style="color: #CD5555"&gt;'django.contrib.messages.context_processors.messages'&lt;/span&gt;,
            ],
        },
    },
]

WSGI_APPLICATION = &lt;span style="color: #CD5555"&gt;'simple_todo.wsgi.application'&lt;/span&gt;

&lt;span style="color: #228B22"&gt;# Database&lt;/span&gt;
&lt;span style="color: #228B22"&gt;# https://docs.djangoproject.com/en/1.8/ref/settings/#databases&lt;/span&gt;

DATABASES = {
    &lt;span style="color: #CD5555"&gt;'default'&lt;/span&gt;: {
        &lt;span style="color: #CD5555"&gt;'ENGINE'&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;'django.db.backends.sqlite3'&lt;/span&gt;,
        &lt;span style="color: #228B22"&gt;# GETTING-STARTED: change 'db.sqlite3' to your sqlite3 database:&lt;/span&gt;
        &lt;span style="color: #CD5555"&gt;'NAME'&lt;/span&gt;: os.path.join(DATA_DIR, &lt;span style="color: #CD5555"&gt;'db.sqlite3'&lt;/span&gt;),
    }
}

&lt;span style="color: #228B22"&gt;# Internationalization&lt;/span&gt;
&lt;span style="color: #228B22"&gt;# https://docs.djangoproject.com/en/1.8/topics/i18n/&lt;/span&gt;

LANGUAGE_CODE = &lt;span style="color: #CD5555"&gt;'en-us'&lt;/span&gt;

TIME_ZONE = &lt;span style="color: #CD5555"&gt;'UTC'&lt;/span&gt;

USE_I18N = &lt;span style="color: #8B008B; font-weight: bold"&gt;True&lt;/span&gt;

USE_L10N = &lt;span style="color: #8B008B; font-weight: bold"&gt;True&lt;/span&gt;

USE_TZ = &lt;span style="color: #8B008B; font-weight: bold"&gt;True&lt;/span&gt;

&lt;span style="color: #228B22"&gt;# Static files (CSS, JavaScript, Images)&lt;/span&gt;
&lt;span style="color: #228B22"&gt;# https://docs.djangoproject.com/en/1.8/howto/static-files/&lt;/span&gt;

STATIC_URL = &lt;span style="color: #CD5555"&gt;'/static/'&lt;/span&gt;
STATIC_ROOT = os.path.join(WSGI_DIR, &lt;span style="color: #CD5555"&gt;'static'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;静态文件的处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如 CSS、图片等等, 一般 Django 应用的静态文件的目录是在 settings.py 中配置的, 但是 OpenShift 使用了不一样的方式, 所有的静态文件都将被放置在 &lt;code&gt;wsgi/static&lt;/code&gt; 目录下.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;貌似在 openshift 中, css 文件中的 url 属性不生效, 我现在把 css 中的 url 属性都移到 html 标签中嵌套了…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id="diy-todolist"&gt;四、DIY todolist&lt;/h1&gt;
&lt;p&gt;上面的开源项目基于实现了 todolist 的功能, 不好的是暂时缺少用户管理系统 (所有人访问都是同一个 todolist), 所以准备 DIY 一下, 加一个用户系统.&lt;/p&gt;
&lt;h1 id="_1"&gt;五、最后&lt;/h1&gt;
&lt;p&gt;重要的事再说一次:&lt;/p&gt;
&lt;p&gt;由于 &lt;code&gt;syncdb&lt;/code&gt; 的尿性, 如果修改了数据库结构, 需要先执行 &lt;code&gt;rm -f $OPENSHIFT\_DATA\_DIR/db.sqlite3&lt;/code&gt;, 再执行次 &lt;code&gt;python $OPENSHIFT_REPO_DIR/wsgi/myproject/manage.py syncdb&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;修改后的项目, 我放在 git@oschina 上了, 可以参考参考…&lt;/p&gt;</content><category term="工具折腾"></category></entry><entry><title>让 Putty 自动登陆 [转]</title><link href="http://www.smallcpp.cn/rang-putty-zi-dong-deng-lu-zhuan.html" rel="alternate"></link><published>2016-05-05T14:04:00+08:00</published><updated>2016-05-05T14:04:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-05-05:/rang-putty-zi-dong-deng-lu-zhuan.html</id><summary type="html">
&lt;h3 id="_1"&gt;序言&lt;/h3&gt;
&lt;p&gt;Putty 基本是用来登陆 Linux/Unix 终端的不二之先, 因其小, 开源, 界面也非常实用. 可是当你要在私有的机器上, 经常性的要登陆很多机器的时候就觉得烦琐了, 不光打开一堆的窗口, 还要一遍一遍的输入用户名和密码. 当然登陆用户名是可以保存的, 我也是最近才注意到这一点的. Putty 不愿去保存密码是出于安全考虑, 相信在多数时候确实是非常必要的.&lt;/p&gt;
&lt;p&gt;于是我选择了 SecureCRT, 它能保存密码, 而且是多 Tab 的, 把 Session 改成 VT100 Linux 模式 …&lt;/p&gt;</summary><content type="html">
&lt;h3 id="_1"&gt;序言&lt;/h3&gt;
&lt;p&gt;Putty 基本是用来登陆 Linux/Unix 终端的不二之先, 因其小, 开源, 界面也非常实用. 可是当你要在私有的机器上, 经常性的要登陆很多机器的时候就觉得烦琐了, 不光打开一堆的窗口, 还要一遍一遍的输入用户名和密码. 当然登陆用户名是可以保存的, 我也是最近才注意到这一点的. Putty 不愿去保存密码是出于安全考虑, 相信在多数时候确实是非常必要的.&lt;/p&gt;
&lt;p&gt;于是我选择了 SecureCRT, 它能保存密码, 而且是多 Tab 的, 把 Session 改成 VT100 Linux 模式, 用着一直很顺溜. 然而今天却发现在 SecureCRT 终端中使用 vim 不能高亮显示语法, 试过多种设置, 在 Putty 中却行的, 就这样又重新回到了 Putty 的怀抱. 要相处得好, 必须更深层次的挖掘它的潜力, 其实它也可让你实现自动登陆、甚至是多 Tab 的方式.&lt;/p&gt;
&lt;p&gt;方法有四~&lt;/p&gt;
&lt;h3 id="puttygenexe-ssh"&gt;一. 用 PuTTYgen.exe 生成 ssh 证书, 可在特定的机器上自动登陆&lt;/h3&gt;
&lt;p&gt;PuTTYgen.exe 也是从 &lt;a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html"&gt;putty.exe 站点&lt;/a&gt;下载, 对于 Linux to Linux 的 ssh 证书生成及自动登陆的方法也有一个&lt;a href="http://unmi.cc/ssh-no-need-input-password"&gt;介绍&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;而怎么使用 PuTTYgen.exe 请直接参考: &lt;a href="http://www.shocr.com/sshcertificate-putty-linux/"&gt;SSH证书让Putty免密码登陆Linux&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;这种方法需要在服务器端做相应的操作, 本文主要想介绍第二种方法.&lt;/p&gt;
&lt;h3 id="putty-v60"&gt;二. 用 Putty v6.0 修改版, 可保存登陆名和密码, 实现自动登陆&lt;/h3&gt;
&lt;p&gt;Putty 默认版只能保存登陆名, 每次需输入登陆密码, 主机和登陆名是保存在注册表中的. 不过因为它是开源, 所以有相关需求者做了个能同时保存用户和密码的版本, 这些信息是保存在文件中的. 该保存登陆名和密码版可在些下载: &lt;a href="http://unmi.cc/wp-content/uploads/2010/06/putty_v6.0.rar"&gt;putty_v6.0.rar&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;就是设置起来有点是特别好理解, 默认版本也是这样子的. 操作步骤全写在下面这幅图片里了:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i65.tinypic.com/svj5m1.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;可以看看人家是怎么改的 PuTTY 源代码的:  &lt;a href="http://blog.csdn.net/free2o/article/details/2507023"&gt;修改Putty 0.6 代码支持SSH 密码保存功能&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="putty-connection-manager-putty-tab"&gt;三. 有了个 PuTTY Connection Manager 管理你的 PuTTY 登陆, 还支持 Tab&lt;/h3&gt;
&lt;p&gt;PuTTY Connection Manager 的&lt;a href="http://puttycm.free.fr"&gt;官网&lt;/a&gt;被 Blocked 了, 想窥个究竟的就勇敢的翻墙吧. 这是用 C# 写的对 PuTTY 的包装程序, 需要机器上安装 .NET Framework 2.0 或以上的版本, 另外, 可让你使用更新 PuTTY 版本. 从官方截个图让大家看看:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i65.tinypic.com/30jh1e9.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i65.tinypic.com/wrgknc.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;也能兼容原来的 PuTTY 保存登陆名的方式, 还可用自己的连接管理独立的保存登陆名和密码, 可多 Tab 使用. 如果你觉得界面复杂, 可以把菜单、工具栏、状态栏什么的全隐藏了起来, 看起来就和 PuTTY 一样清爽了.&lt;/p&gt;
&lt;p&gt;为给大家省事, 还是把 PuTTY Connection Manager 的程序从网站上捞下来放到这里来了: &lt;a href="http://unmi.cc/wp-content/uploads/2010/06/puttycm.rar"&gt;puttycm.rar&lt;/a&gt;. 其中 puttycm.exe 是个独立执行版, 要求你事前安装了 .NET Framework, puttycm0.7.1.136beta.exe 是安装版, 会自动检测有没有 .NET Freamework, 无则帮你下载安上.&lt;/p&gt;
&lt;h3 id="_2"&gt;四. 用快捷方式实现自动登陆&lt;/h3&gt;
&lt;p&gt;首先创建 putty.exe 的快捷方式到桌面; 然后运行 putty, 输入host name、port、saved session’s name, 点击保存, 假设 session 名为”qa server”, 随后关闭窗口; 最后右击 putty 快捷方式, 属性, 目标, 加上如下参数 &lt;code&gt;-load "qa server" -ssh -l {username} -pw {password}&lt;/code&gt;, 保存, 关闭;&lt;/p&gt;
&lt;p&gt;以后运行putty的快捷方式, 就能自动输入用户名和密码, 进入远程电脑.&lt;/p&gt;</content><category term="工具折腾"></category></entry><entry><title>Sublime 配置 Python 开发环境</title><link href="http://www.smallcpp.cn/sublime-pei-zhi-python-kai-fa-huan-jing.html" rel="alternate"></link><published>2016-04-24T15:08:00+08:00</published><updated>2016-04-24T15:08:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-04-24:/sublime-pei-zhi-python-kai-fa-huan-jing.html</id><summary type="html">
&lt;h1 id="1"&gt;1. 中文文件名方框&lt;/h1&gt;
&lt;p&gt;这个是 sublime text 3 的 bug, 当 Windows 个性化显示中的设置自定义文本大小 (DPI) 大于默认的 100% 的时候, 就会出现这个bug.&lt;/p&gt;
&lt;p&gt;解决方法:&lt;/p&gt;
&lt;p&gt;在 sublime text 3 中, Preference, Settings - User, 最后加上一行 &lt;code&gt;"dpi_scale": 1.0&lt;/code&gt; 覆盖操作系统设置的 …&lt;/p&gt;</summary><content type="html">
&lt;h1 id="1"&gt;1. 中文文件名方框&lt;/h1&gt;
&lt;p&gt;这个是 sublime text 3 的 bug, 当 Windows 个性化显示中的设置自定义文本大小 (DPI) 大于默认的 100% 的时候, 就会出现这个bug.&lt;/p&gt;
&lt;p&gt;解决方法:&lt;/p&gt;
&lt;p&gt;在 sublime text 3 中, Preference, Settings - User, 最后加上一行 &lt;code&gt;"dpi_scale": 1.0&lt;/code&gt; 覆盖操作系统设置的 DPI:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;{
    &lt;span style="color: #CD5555"&gt;"color_scheme"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"Packages/Nil-Theme/Sanakan.tmTheme"&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"font_size"&lt;/span&gt;: &lt;span style="color: #B452CD"&gt;11.0&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"ignored_packages"&lt;/span&gt;:
    [
        &lt;span style="color: #CD5555"&gt;"Vintage"&lt;/span&gt;
    ],
    &lt;span style="color: #CD5555"&gt;"update_check"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;false&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"word_wrap"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"auto"&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"dpi_scale"&lt;/span&gt;:&lt;span style="color: #B452CD"&gt;1.0&lt;/span&gt; &lt;span style="color: #228B22"&gt;// &amp;lt;= 这里&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="2"&gt;2. 主题、字体&lt;/h1&gt;
&lt;p&gt;先安装字体, 我习惯的是 &lt;a href="https://pan.baidu.com/s/1mppyQNea7qHjuAvvp6B3Nw"&gt;Microsoft YaHei Mono&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;再安装主题, &lt;strong&gt;Monokai Extended&lt;/strong&gt; 和 &lt;strong&gt;Soda Dark&lt;/strong&gt;, 使用 package control 就可以安装了.&lt;/p&gt;
&lt;p&gt;然后是 sublime 的设置了, 首选项 -&amp;gt; 设置 - 用户&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;{
    &lt;span style="color: #CD5555"&gt;"auto_complete_commit_on_tab"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;false&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"auto_find_in_selection"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"open_files_in_new_window"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;false&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"hot_exit"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;false&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"remember_open_files"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"bold_folder_labels"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"color_scheme"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"Packages/Monokai Extended/Monokai Extended.tmTheme"&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"theme"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"Soda Dark.sublime-theme"&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"default_line_ending"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"unix"&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"detect_indentation"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;false&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"detect_slow_plugins"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;false&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"dpi_scale"&lt;/span&gt;: &lt;span style="color: #B452CD"&gt;1.0&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"drag_text"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;false&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"draw_white_space"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"selection"&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"ensure_newline_at_eof_on_save"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"fallback_encoding"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"UTF-8"&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"font_face"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"Microsoft YaHei Mono"&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"font_size"&lt;/span&gt;: &lt;span style="color: #B452CD"&gt;12&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"highlight_line"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"highlight_modified_tabs"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"ignored_packages"&lt;/span&gt;:
    [
        &lt;span style="color: #CD5555"&gt;"Vintageous"&lt;/span&gt;,
        &lt;span style="color: #CD5555"&gt;"Vintage"&lt;/span&gt;
    ],
    &lt;span style="color: #CD5555"&gt;"indent_guide_options"&lt;/span&gt;:
    [
        &lt;span style="color: #CD5555"&gt;"draw_active"&lt;/span&gt;,
        &lt;span style="color: #CD5555"&gt;"draw_normal"&lt;/span&gt;
    ],
    &lt;span style="color: #CD5555"&gt;"indent_to_bracket"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"line_padding_bottom"&lt;/span&gt;: &lt;span style="color: #B452CD"&gt;1&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"line_padding_top"&lt;/span&gt;: &lt;span style="color: #B452CD"&gt;1&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"preview_on_click"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;false&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"rulers"&lt;/span&gt;:
    [
        &lt;span style="color: #B452CD"&gt;120&lt;/span&gt;
    ],
    &lt;span style="color: #CD5555"&gt;"scroll_past_end"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"shift_tab_unindent"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"show_encoding"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"tab_size"&lt;/span&gt;: &lt;span style="color: #B452CD"&gt;4&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"translate_tabs_to_spaces"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"trim_automatic_white_space"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"trim_trailing_white_space_on_save"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"update_check"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;false&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"word_wrap"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"wrap_width"&lt;/span&gt;: &lt;span style="color: #B452CD"&gt;120&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;保存重启就能看到效果了.&lt;/p&gt;
&lt;h1 id="3"&gt;3. 代码提示&lt;/h1&gt;
&lt;p&gt;代码提示插件, 有 &lt;strong&gt;SublimeCodeIntel&lt;/strong&gt;、&lt;strong&gt;Anaconda&lt;/strong&gt;、&lt;strong&gt;sublimePythonIDE&lt;/strong&gt; 以及 &lt;strong&gt;Jedi&lt;/strong&gt; 等.&lt;/p&gt;
&lt;p&gt;不过 winodows 下 &lt;strong&gt;SublimeCodeIntel&lt;/strong&gt;、&lt;strong&gt;Anaconda&lt;/strong&gt;、&lt;strong&gt;sublimePythonIDE&lt;/strong&gt; 配置有点问题, 总不能达到预期目标, 最终选取了 &lt;strong&gt;Jedi&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;(不过始终觉得 &lt;strong&gt;Anaconda&lt;/strong&gt; 比较好…太可惜了, 装不上.. )&lt;/p&gt;
&lt;h2 id="31-jedi"&gt;3.1 Jedi&lt;/h2&gt;
&lt;p&gt;Jedi 貌似现在不能通过 Package Control 来安装, 可以直接去 GitHub 上下载 &lt;a href="https://github.com/srusskih/SublimeJEDI"&gt;https://github.com/srusskih/SublimeJEDI&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载好后, 解压文件, 重命名为 Jedi - Python autocompletion, 然后复制到 Sublime Text 3\Data\Packages 目录下.&lt;/p&gt;
&lt;p&gt;然后再打开 sublime 插件里就有 Jedi 了.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i66.tinypic.com/2z4zbjb.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;接下来就是要配置插件的默认设置…&lt;/p&gt;
&lt;p&gt;添加按点(dot)[.]后出现代码提示.&lt;/p&gt;
&lt;p&gt;到 Sublime Text 3\Data\Packages\User 下添加一个文件 Python.sublime-settings (如果没有的话), 添加如下内容:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;{
   &lt;span style="color: #CD5555"&gt;"auto_complete_triggers"&lt;/span&gt;: [
        {
            &lt;span style="color: #CD5555"&gt;"selector"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"source.python"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"characters"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"."&lt;/span&gt;
        }
    ],

    &lt;span style="color: #CD5555"&gt;"auto_complete_selector"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"-"&lt;/span&gt;,
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后, 打开 Jedi 的默认设置文件, 更改下面两条:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i64.tinypic.com/211v22p.jpg"/&gt;&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #CD5555"&gt;"python_interpreter"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"D:/Python/python.exe"&lt;/span&gt;,

&lt;span style="color: #CD5555"&gt;"python_package_paths"&lt;/span&gt;: [
    &lt;span style="color: #CD5555"&gt;"D:/Python"&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"D:/Python/DLLs"&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"D:/Python/Lib"&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"D:/Python/Lib/lib-tk"&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"D:/Python/Lib/site-packages"&lt;/span&gt;
],
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="32-anaconda"&gt;3.2 Anaconda&lt;/h2&gt;
&lt;p&gt;Anaconda 是一个终极 Python 插件, 它为 ST3 增添了多项 IDE 类似的功能，例如:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Autocompletion: 自动完成，该选项默认开启，同时提供多种配置选项&lt;/li&gt;
&lt;li&gt;Code linting: 使用支持 pep8 标准的 PyLint 或者 PyFlakes&lt;/li&gt;
&lt;li&gt;McCabe code complexity checker: 让你可以在特定的文件中使用 &lt;a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"&gt;McCabe complexity checker&lt;/a&gt;. 如果你对软件复杂度检查工具不太熟悉的话，请务必先浏览上边的链接&lt;/li&gt;
&lt;li&gt;Goto Definitions: 能够在你的整个工程中查找并且显示任意一个变量，函数，或者类的定义&lt;/li&gt;
&lt;li&gt;Find Usage: 能够快速的查找某个变量，函数或者类在某个特定文件中的什么地方被使用了&lt;/li&gt;
&lt;li&gt;Show Documentation:  能够显示一个函数或者类的说明性字符串(当然，是在定义了字符串的情况下, 目前只支持英文)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Anaconda 可以通过 Package Control 直接安装.&lt;/p&gt;
&lt;p&gt;通常, 我的 Anaconda 配置如下:&lt;/p&gt;
&lt;p&gt;[Preferences -&amp;gt; 插件设置 -&amp;gt; Anaconda -&amp;gt; Settings-User]&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;{
    &lt;span style="color: #CD5555"&gt;"python_interpreter"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"C:/Python27/python"&lt;/span&gt;,  &lt;span style="color: #228B22"&gt;// 应在项目配置&lt;/span&gt;

    &lt;span style="color: #CD5555"&gt;"pep8_ignore"&lt;/span&gt;:
        [
            &lt;span style="color: #CD5555"&gt;"E309"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"E501"&lt;/span&gt; &lt;span style="color: #228B22"&gt;// 忽略长度限制&lt;/span&gt;
        ],

    &lt;span style="color: #CD5555"&gt;"auto_formatting"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;,

    &lt;span style="color: #CD5555"&gt;"autoformat_ignore"&lt;/span&gt;:
        [
            &lt;span style="color: #CD5555"&gt;"E309"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"E501"&lt;/span&gt; &lt;span style="color: #228B22"&gt;// 忽略长度限制&lt;/span&gt;
        ],

    &lt;span style="color: #CD5555"&gt;"anaconda_linter_mark_style"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"none"&lt;/span&gt;,

    &lt;span style="color: #CD5555"&gt;"anaconda_linter_underlines"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;false&lt;/span&gt;,

    &lt;span style="color: #CD5555"&gt;"complete_parameters"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;, &lt;span style="color: #228B22"&gt;// 输 ( 时补充函数的非默认参数&lt;/span&gt;

    &lt;span style="color: #CD5555"&gt;"complete_all_parameters"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;false&lt;/span&gt;, &lt;span style="color: #228B22"&gt;// 输 ( 时补充函数的所有参数&lt;/span&gt;

    &lt;span style="color: #CD5555"&gt;"auto_python_builder_enabled"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;false&lt;/span&gt;,  &lt;span style="color: #228B22"&gt;// 自动为当前项目生成编译系统, 通常不需要, 我们自己配置, 参照 6. 项目设置&lt;/span&gt;

    &lt;span style="color: #CD5555"&gt;"auto_complete_triggers"&lt;/span&gt;:  &lt;span style="color: #228B22"&gt;// 点(dot)\[.\]后出现代码提示&lt;/span&gt;
        [
            {
                &lt;span style="color: #CD5555"&gt;"selector"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"source.python - string - comment - constant.numeric"&lt;/span&gt;,
                &lt;span style="color: #CD5555"&gt;"characters"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"."&lt;/span&gt;
            }
        ],
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="4"&gt;4. 代码规范检查&lt;/h1&gt;
&lt;p&gt;如果上一步你能安装 &lt;strong&gt;3.2 Anaconda&lt;/strong&gt; 就不需要这一步了, &lt;strong&gt;Anaconda&lt;/strong&gt; 已经帮你集成好了.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pylinter&lt;/strong&gt; 插件&lt;/p&gt;
&lt;p&gt;这个插件依赖于 python 的 &lt;strong&gt;pylint&lt;/strong&gt; 库, 所以首先, 我们得 &lt;code&gt;pip install pylint&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;安装好后还要对 pylinter 插件做下设置&lt;/p&gt;
&lt;p&gt;首选项 -&amp;gt; 插件设置 -&amp;gt; Pylinter -&amp;gt; Settings-Default&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #CD5555"&gt;"python_bin"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"D:/Python/python.exe"&lt;/span&gt;,

&lt;span style="color: #228B22"&gt;// The following paths will be added Pylint's Python path&lt;/span&gt;
&lt;span style="color: #CD5555"&gt;"python_path"&lt;/span&gt;: [
    &lt;span style="color: #CD5555"&gt;"D:/Python"&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"D:/Python/DLLs"&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"D:/Python/Lib"&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"D:/Python/Lib/lib-tk"&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"D:/Python/Lib/site-packages"&lt;/span&gt;
],
&lt;span style="color: #228B22"&gt;// Full path to the lint.py module in the pylint package&lt;/span&gt;
&lt;span style="color: #CD5555"&gt;"pylint_path"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"D:/Python/Lib/site-packages/pylint"&lt;/span&gt;,

&lt;span style="color: #228B22"&gt;// Set to true to automtically run Pylint on save&lt;/span&gt;
&lt;span style="color: #CD5555"&gt;"run_on_save"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;,

&lt;span style="color: #228B22"&gt;// Set to true to use graphical error icons&lt;/span&gt;
&lt;span style="color: #CD5555"&gt;"use_icons"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;,
&lt;span style="color: #CD5555"&gt;"disable_outline"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;,

&lt;span style="color: #228B22"&gt;// Status messages stay as long as cursor is on an error line&lt;/span&gt;
&lt;span style="color: #CD5555"&gt;"message_stay"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;,
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="5"&gt;5. 自动生成注释&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;DocBlockr&lt;/strong&gt; 插件&lt;/p&gt;
&lt;p&gt;在 Python 文件中, 文件头、类头以及函数头输入 “”” 再按回车即可, 例如:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;class TestClass():
    """ &amp;lt;-- Press [enter]

def test_function():
    """ &amp;lt;-- Press [enter]
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="6"&gt;6. 项目设置&lt;/h1&gt;
&lt;p&gt;由於 Python 可以透過 virtualenv 來設定不同的虛擬環境, 透過這些環境來對不同開發專案, 達到環境獨立的優點, 因此我們也會期望在使用 sublime 開發時, 也可以偵測到不同的環境.
首先先用 sublime 创建一个项目, 很简单, 直接 &lt;strong&gt;项目 -&amp;gt; 项目另存为&lt;/strong&gt; 就可以了.&lt;/p&gt;
&lt;p&gt;保存好后选择 &lt;strong&gt;项目 -&amp;gt; 编辑项目&lt;/strong&gt;, 设置使用 virtualenv 环境:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2018.06.26 update for mac, python3.6&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;// mac, python3.6&lt;/span&gt;
{
    &lt;span style="color: #CD5555"&gt;"build_systems"&lt;/span&gt;:
    [
        {
            &lt;span style="color: #CD5555"&gt;"cmd"&lt;/span&gt;:
            [
                &lt;span style="color: #CD5555"&gt;"${project_path}/venv/bin/python"&lt;/span&gt;,
                &lt;span style="color: #CD5555"&gt;"-i"&lt;/span&gt;,
                &lt;span style="color: #CD5555"&gt;"-u"&lt;/span&gt;,
                &lt;span style="color: #CD5555"&gt;"-m"&lt;/span&gt;,
                &lt;span style="color: #CD5555"&gt;"${project_base_name}.${file_base_name}"&lt;/span&gt;
            ],
            &lt;span style="color: #CD5555"&gt;"encoding"&lt;/span&gt;:&lt;span style="color: #CD5555"&gt;"cp936"&lt;/span&gt;,  &lt;span style="color: #228B22"&gt;// 仅 windows 下需要，否则会输出 Decode error - output not utf-8&lt;/span&gt;
            &lt;span style="color: #CD5555"&gt;"env"&lt;/span&gt;:
            {
                &lt;span style="color: #CD5555"&gt;"LANG"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"de_DE.utf-8"&lt;/span&gt;,
                &lt;span style="color: #CD5555"&gt;"LC_ALL"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"de_DE.utf-8"&lt;/span&gt;
            },
            &lt;span style="color: #CD5555"&gt;"name"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"project_venv builder"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"selector"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"source.python"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"working_dir"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"${project_path:${folder}}"&lt;/span&gt;  &lt;span style="color: #228B22"&gt;// project_path == nil 时取 folder&lt;/span&gt;
        }
    ],
    &lt;span style="color: #CD5555"&gt;"folders"&lt;/span&gt;:
    [
        {
            &lt;span style="color: #CD5555"&gt;"path"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"."&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"follow_symlinks"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;
        }
    ],
    &lt;span style="color: #CD5555"&gt;"settings"&lt;/span&gt;:
    {
        &lt;span style="color: #CD5555"&gt;"python_interpreter"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"${project_path}/venv/bin/python"&lt;/span&gt;
    }
}

&lt;span style="color: #228B22"&gt;// window, python2.7&lt;/span&gt;
{
    &lt;span style="color: #CD5555"&gt;"build_systems"&lt;/span&gt;: [  &lt;span style="color: #228B22"&gt;// 添加 [Tools / Build System]&lt;/span&gt;
        {
            &lt;span style="color: #CD5555"&gt;"name"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"project_venv builder"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"selector"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"source.python"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"shell_cmd"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"D:/pydj/project_venv/Scripts/python -u \"$file\""&lt;/span&gt;
        }
    ],

    &lt;span style="color: #CD5555"&gt;"folders"&lt;/span&gt;: [
        {
          &lt;span style="color: #CD5555"&gt;"follow_symlinks"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;,
          &lt;span style="color: #CD5555"&gt;"path"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"."&lt;/span&gt;
        }
     ]
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后是覆盖 &lt;strong&gt;Jedi&lt;/strong&gt; 默认设置中的 python_interpreter 和 python_package_paths (如果你安装了 &lt;strong&gt;Jedi&lt;/strong&gt; 的话):&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;// window, python2.7&lt;/span&gt;
{
    &lt;span style="color: #CD5555"&gt;"build_systems"&lt;/span&gt;: [
        {
            &lt;span style="color: #CD5555"&gt;"name"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"project_venv builder"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"selector"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"source.python"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"shell_cmd"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"D:/pydj/project_venv/Scripts/python -u \"$file\""&lt;/span&gt;
        }
    ],

    &lt;span style="color: #CD5555"&gt;"folders"&lt;/span&gt;: [
        {
          &lt;span style="color: #CD5555"&gt;"follow_symlinks"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;,
          &lt;span style="color: #CD5555"&gt;"path"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"."&lt;/span&gt;
        }
     ],

    &lt;span style="color: #CD5555"&gt;"settings"&lt;/span&gt;: {
        &lt;span style="color: #CD5555"&gt;"python_interpreter"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"D:/pydj/project_venv/Scripts/python.exe"&lt;/span&gt;,

        &lt;span style="color: #CD5555"&gt;"python_package_paths"&lt;/span&gt;: [
            &lt;span style="color: #CD5555"&gt;"D:/pydj/project_venv/Scripts"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"D:/pydj/project_venv/Lib"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"D:/pydj/project_venv/Lib/site-packages"&lt;/span&gt;
        ],
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外是覆盖 &lt;strong&gt;pylinter&lt;/strong&gt; 的设置 (如果使用的是 &lt;strong&gt;pylinter&lt;/strong&gt; 的话, 另外, virtualenv 里也需要 &lt;code&gt;pip install pylint&lt;/code&gt;):&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;// window, python2.7&lt;/span&gt;
{
    &lt;span style="color: #CD5555"&gt;"build_systems"&lt;/span&gt;: [
        {
            &lt;span style="color: #CD5555"&gt;"name"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"project_venv builder"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"selector"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"source.python"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"shell_cmd"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"D:/pydj/project_venv/Scripts/python -u \"$file\""&lt;/span&gt;
        }
    ],

    &lt;span style="color: #CD5555"&gt;"folders"&lt;/span&gt;: [
        {
          &lt;span style="color: #CD5555"&gt;"follow_symlinks"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;,
          &lt;span style="color: #CD5555"&gt;"path"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"."&lt;/span&gt;
        }
     ],

    &lt;span style="color: #CD5555"&gt;"settings"&lt;/span&gt;: {
        &lt;span style="color: #CD5555"&gt;"python_interpreter"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"D:/pydj/project_venv/Scripts/python.exe"&lt;/span&gt;,

        &lt;span style="color: #CD5555"&gt;"python_package_paths"&lt;/span&gt;: [
            &lt;span style="color: #CD5555"&gt;"D:/pydj/project_venv/Scripts"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"D:/pydj/project_venv/Lib"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"D:/pydj/project_venv/Lib/site-packages"&lt;/span&gt;
        ],

        &lt;span style="color: #CD5555"&gt;"pylinter"&lt;/span&gt;: {
            &lt;span style="color: #CD5555"&gt;"python_bin"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"D:/pydj/project_venv/Scripts/python.exe"&lt;/span&gt;,

            &lt;span style="color: #CD5555"&gt;"python_path"&lt;/span&gt;: [
                &lt;span style="color: #CD5555"&gt;"D:/pydj/project_venv/Scripts"&lt;/span&gt;,
                &lt;span style="color: #CD5555"&gt;"D:/pydj/project_venv/Lib"&lt;/span&gt;,
                &lt;span style="color: #CD5555"&gt;"D:/pydj/project_venv/Lib/site-packages"&lt;/span&gt;
            ],
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="7"&gt;7. 侧边栏扩展&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;SideBarEnhancements&lt;/strong&gt; 插件&lt;/p&gt;
&lt;p&gt;安装好, &lt;code&gt;view -&amp;gt; Side Bar -&amp;gt; Hide Open Files&lt;/code&gt;, 其它的几乎不需要设置, 当打开__项目__时, 在项目文件上右键就能显示扩展.&lt;/p&gt;
&lt;p&gt;如果安装好 SideBarEnhancements 后没有显示侧边栏, 可以用快捷键 &lt;strong&gt;ctrl + k&lt;/strong&gt;, &lt;strong&gt;ctrl + b&lt;/strong&gt; 来打开侧边栏 (不是 ctrl + k + b, 是先按 ctrl + k, 松开再按 ctrl + b), 或者点击菜单: 查看 -&amp;gt; 侧边栏 -&amp;gt; 显示\隐藏侧边栏&lt;/p&gt;
&lt;h1 id="8"&gt;8. 代码调试&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;SublimeREPL&lt;/strong&gt; 插件&lt;/p&gt;
&lt;p&gt;这个插件允许在编辑界面直接运行 Python 解释器&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i63.tinypic.com/2pzz760.jpg"/&gt;&lt;/p&gt;
&lt;h2 id="81-sublimerepl"&gt;8.1 SublimeREPL 基础&lt;/h2&gt;
&lt;p&gt;这部分内容仅做了解, 可直接用 &lt;strong&gt;[8.2 更好的 SulimeREPL 设置]&lt;/strong&gt; 替代.&lt;/p&gt;
&lt;h3 id="811-virtualenv"&gt;8.1.1 添加 virtualenv 支持&lt;/h3&gt;
&lt;p&gt;打开 SublimeREPL 的用户设置: 首选项 -&amp;gt; 插件设置 -&amp;gt; SulimeREPL -&amp;gt; Setting-User.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;{
    &lt;span style="color: #CD5555"&gt;"python_virtualenv_paths"&lt;/span&gt;: [
        &lt;span style="color: #CD5555"&gt;"D:/pydj"&lt;/span&gt;
    ]
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里写入 virtualenv 项目的根目录路径, 如我的 virtualenv 项目路径是 &lt;code&gt;D:/pydj/project_venv&lt;/code&gt;, 所以这里填入 &lt;code&gt;D:/pdj&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当需要运行 virtualenv 时, 选择 Python - virtualenv 后, 界面上会出现 virtualenv 选择框:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i65.tinypic.com/2q2lhg2.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i66.tinypic.com/2n7ianq.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;选择后就能打开该 virtualenv 的 python 交互解释器了.&lt;/p&gt;
&lt;h3 id="812"&gt;8.1.2 以交互式运行当前文件&lt;/h3&gt;
&lt;p&gt;SublimeREPL 里最常用的应该就是 Python 和 Python - RUN current file, 前者是打开交互式环境, 后者是直接运行当前文件, 但是一些常见的 python ide 都是把这两者结合起来, SublimeREPL 通过设置也能实现这个功能.&lt;/p&gt;
&lt;p&gt;打开 Sublime Text 3\Packages\SublimeREPL\config\Python\Main.sublime-menu 文件 (先备份一份).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;删除&lt;/strong&gt; “id” 为 “repl_python” 的项(如果想保留也可以不删除), &lt;strong&gt;修改&lt;/strong&gt; “id” 为 “repl_python_run” 的项:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;[
    {
        &lt;span style="color: #CD5555"&gt;"id"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"tools"&lt;/span&gt;,
        &lt;span style="color: #CD5555"&gt;"children"&lt;/span&gt;:[
            {
                &lt;span style="color: #CD5555"&gt;"caption"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"SublimeREPL"&lt;/span&gt;,
                &lt;span style="color: #CD5555"&gt;"mnemonic"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"r"&lt;/span&gt;,
                &lt;span style="color: #CD5555"&gt;"id"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"SublimeREPL"&lt;/span&gt;,
                &lt;span style="color: #CD5555"&gt;"children"&lt;/span&gt;: [
                    {
                        &lt;span style="color: #CD5555"&gt;"caption"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"Python"&lt;/span&gt;,
                        &lt;span style="color: #CD5555"&gt;"id"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"Python"&lt;/span&gt;,
                        &lt;span style="color: #CD5555"&gt;"children"&lt;/span&gt;: [
                            {
                                &lt;span style="color: #CD5555"&gt;"command"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"repl_open"&lt;/span&gt;,
                                &lt;span style="color: #CD5555"&gt;"caption"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"Python"&lt;/span&gt;,
                                &lt;span style="color: #CD5555"&gt;"id"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"repl_python"&lt;/span&gt;,  &lt;span style="color: #228B22"&gt;// &amp;lt;= 这里&lt;/span&gt;
                                &lt;span style="color: #CD5555"&gt;"mnemonic"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"p"&lt;/span&gt;,
                                &lt;span style="color: #CD5555"&gt;"args"&lt;/span&gt;: {
                                    &lt;span style="color: #CD5555"&gt;"type"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"subprocess"&lt;/span&gt;,
                                    &lt;span style="color: #CD5555"&gt;"encoding"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"utf8"&lt;/span&gt;,
                                    &lt;span style="color: #CD5555"&gt;"cmd"&lt;/span&gt;: [&lt;span style="color: #CD5555"&gt;"python"&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;"-i"&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;"-u"&lt;/span&gt;],
                                    &lt;span style="color: #CD5555"&gt;"cwd"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"$file_path"&lt;/span&gt;,
                                    &lt;span style="color: #CD5555"&gt;"syntax"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"Packages/Python/Python.tmLanguage"&lt;/span&gt;,
                                    &lt;span style="color: #CD5555"&gt;"external_id"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"python"&lt;/span&gt;,
                                    &lt;span style="color: #CD5555"&gt;"extend_env"&lt;/span&gt;: {&lt;span style="color: #CD5555"&gt;"PYTHONIOENCODING"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"utf-8"&lt;/span&gt;}
                                }
                            },
                            {
                                &lt;span style="color: #CD5555"&gt;"command"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"repl_open"&lt;/span&gt;,
                                &lt;span style="color: #CD5555"&gt;"caption"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"Python - RUN current file"&lt;/span&gt;,
                                &lt;span style="color: #CD5555"&gt;"id"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"repl_python_run"&lt;/span&gt;, &lt;span style="color: #228B22"&gt;// &amp;lt;= 这里&lt;/span&gt;
                                &lt;span style="color: #CD5555"&gt;"mnemonic"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"d"&lt;/span&gt;,
                                &lt;span style="color: #CD5555"&gt;"args"&lt;/span&gt;: {
                                    &lt;span style="color: #CD5555"&gt;"type"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"subprocess"&lt;/span&gt;,
                                    &lt;span style="color: #CD5555"&gt;"encoding"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"utf8"&lt;/span&gt;,
                                    &lt;span style="color: #CD5555"&gt;"cmd"&lt;/span&gt;: [&lt;span style="color: #CD5555"&gt;"python"&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;"-i"&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;"-u"&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;"$file_basename"&lt;/span&gt;],
                                    &lt;span style="color: #CD5555"&gt;"cwd"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"$file_path"&lt;/span&gt;,
                                    &lt;span style="color: #CD5555"&gt;"syntax"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"Packages/Python/Python.tmLanguage"&lt;/span&gt;,
                                    &lt;span style="color: #CD5555"&gt;"external_id"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"python"&lt;/span&gt;,
                                    &lt;span style="color: #CD5555"&gt;"extend_env"&lt;/span&gt;: {&lt;span style="color: #CD5555"&gt;"PYTHONIOENCODING"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"utf-8"&lt;/span&gt;}
                                }
                            },
                            {
                                &lt;span style="color: #CD5555"&gt;"command"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"repl_open"&lt;/span&gt;,
                                &lt;span style="color: #CD5555"&gt;"caption"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"Python - PDB current file"&lt;/span&gt;,
                                &lt;span style="color: #CD5555"&gt;"id"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"repl_python_pdb"&lt;/span&gt;,
                                &lt;span style="color: #CD5555"&gt;"mnemonic"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"d"&lt;/span&gt;,
                                &lt;span style="color: #CD5555"&gt;"args"&lt;/span&gt;: {
                                    &lt;span style="color: #CD5555"&gt;"type"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"subprocess"&lt;/span&gt;,
                                    &lt;span style="color: #CD5555"&gt;"encoding"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"utf8"&lt;/span&gt;,
                                    &lt;span style="color: #CD5555"&gt;"cmd"&lt;/span&gt;: [&lt;span style="color: #CD5555"&gt;"python"&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;"-i"&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;"-u"&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;"-m"&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;"pdb"&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;"$file_basename"&lt;/span&gt;],
                                    &lt;span style="color: #CD5555"&gt;"cwd"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"$file_path"&lt;/span&gt;,
                                    &lt;span style="color: #CD5555"&gt;"syntax"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"Packages/Python/Python.tmLanguage"&lt;/span&gt;,
                                    &lt;span style="color: #CD5555"&gt;"external_id"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"python"&lt;/span&gt;,
                                    &lt;span style="color: #CD5555"&gt;"extend_env"&lt;/span&gt;: {&lt;span style="color: #CD5555"&gt;"PYTHONIOENCODING"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"utf-8"&lt;/span&gt;}
                                }
                            },
                            {
                                &lt;span style="color: #CD5555"&gt;"command"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"python_virtualenv_repl"&lt;/span&gt;,
                                &lt;span style="color: #CD5555"&gt;"id"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"python_virtualenv_repl"&lt;/span&gt;,
                                &lt;span style="color: #CD5555"&gt;"caption"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"Python - virtualenv"&lt;/span&gt;
                            },
                            {
                                &lt;span style="color: #CD5555"&gt;"command"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"repl_open"&lt;/span&gt;,
                                &lt;span style="color: #CD5555"&gt;"caption"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"Python - IPython"&lt;/span&gt;,
                                &lt;span style="color: #CD5555"&gt;"id"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"repl_python_ipython"&lt;/span&gt;,
                                &lt;span style="color: #CD5555"&gt;"mnemonic"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"p"&lt;/span&gt;,
                                &lt;span style="color: #CD5555"&gt;"args"&lt;/span&gt;: {
                                    &lt;span style="color: #CD5555"&gt;"type"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"subprocess"&lt;/span&gt;,
                                    &lt;span style="color: #CD5555"&gt;"encoding"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"utf8"&lt;/span&gt;,
                                    &lt;span style="color: #CD5555"&gt;"autocomplete_server"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;,
                                    &lt;span style="color: #CD5555"&gt;"cmd"&lt;/span&gt;: {
                                        &lt;span style="color: #CD5555"&gt;"osx"&lt;/span&gt;: [&lt;span style="color: #CD5555"&gt;"python"&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;"-u"&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;"${packages}/SublimeREPL/config/Python/ipy_repl.py"&lt;/span&gt;],
                                        &lt;span style="color: #CD5555"&gt;"linux"&lt;/span&gt;: [&lt;span style="color: #CD5555"&gt;"python"&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;"-u"&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;"${packages}/SublimeREPL/config/Python/ipy_repl.py"&lt;/span&gt;],
                                        &lt;span style="color: #CD5555"&gt;"windows"&lt;/span&gt;: [&lt;span style="color: #CD5555"&gt;"python"&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;"-u"&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;"${packages}/SublimeREPL/config/Python/ipy_repl.py"&lt;/span&gt;]
                                    },
                                    &lt;span style="color: #CD5555"&gt;"cwd"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"$file_path"&lt;/span&gt;,
                                    &lt;span style="color: #CD5555"&gt;"syntax"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"Packages/Python/Python.tmLanguage"&lt;/span&gt;,
                                    &lt;span style="color: #CD5555"&gt;"external_id"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"python"&lt;/span&gt;,
                                    &lt;span style="color: #CD5555"&gt;"extend_env"&lt;/span&gt;: {
                                        &lt;span style="color: #CD5555"&gt;"PYTHONIOENCODING"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"utf-8"&lt;/span&gt;,
                                        &lt;span style="color: #CD5555"&gt;"SUBLIMEREPL_EDITOR"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"$editor"&lt;/span&gt;
                                    }
                                }
                            }
                        ]
                    }
                ]
            }
        ]
    }
]
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;补充下: ipython 是一个 python 的交互式 shell, 比默认的 python shell 好用得多, 支持变量自动补全, 自动缩进, 支持 bash shell 命令, 内置了许多很有用的功能和函数.
不过 SublimeREPL 的 ipython 不怎么好用, 所以一般也不用…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="813"&gt;8.1.3 关联快捷键&lt;/h3&gt;
&lt;p&gt;首选项 -&amp;gt; 按键绑定 - 用户&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;[
    {
        &lt;span style="color: #CD5555"&gt;"keys"&lt;/span&gt;: [&lt;span style="color: #CD5555"&gt;"f5"&lt;/span&gt;],
        &lt;span style="color: #CD5555"&gt;"command"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"run_existing_window_command"&lt;/span&gt;,
        &lt;span style="color: #CD5555"&gt;"args"&lt;/span&gt;: {
            &lt;span style="color: #CD5555"&gt;"id"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"repl_python_run"&lt;/span&gt;,
            &lt;span style="color: #CD5555"&gt;"file"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"config/Python/Main.sublime-menu"&lt;/span&gt;
        }
    },
]
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="82-sulimerepl"&gt;8.2 更好的 SulimeREPL 设置&lt;/h2&gt;
&lt;p&gt;在 stackoverflow 上找到一个解决方案 &lt;a href="http://stackoverflow.com/questions/24963030/sublime-text3-and-virtualenvs"&gt;http://stackoverflow.com/questions/24963030/sublime-text3-and-virtualenvs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;该方案有很好兼容性, 完全可以替代上面的所有设置, 设置好后, 通过快捷键来触发 SublimeREPL, 并且以后切换 virtualenv 时, 只需要设置项目设置中的 &lt;strong&gt;python_interpreter&lt;/strong&gt; 就可以了.&lt;/p&gt;
&lt;p&gt;首选项 -&amp;gt; 浏览插件, 创建一个 py 文件: &lt;code&gt;project_venv_repl.py&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2018.06.26 update for mac, python3.6&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;# mac, python3.6&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;os&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;sublime&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;sublime_plugin&lt;/span&gt;


&lt;span style="color: #8B008B; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #008b45"&gt;expand&lt;/span&gt;(view, path):
    &lt;span style="color: #CD5555"&gt;"""Expand the given path&lt;/span&gt;
&lt;span style="color: #CD5555"&gt;    """&lt;/span&gt;
    window = view.window()
    &lt;span style="color: #8B008B; font-weight: bold"&gt;if&lt;/span&gt; window &lt;span style="color: #8B008B"&gt;is&lt;/span&gt; &lt;span style="color: #8B008B"&gt;not&lt;/span&gt; &lt;span style="color: #8B008B; font-weight: bold"&gt;None&lt;/span&gt;:
        tmp = sublime.expand_variables(path, window.extract_variables())
        tmp = os.path.expanduser(os.path.expandvars(tmp))
    &lt;span style="color: #8B008B; font-weight: bold"&gt;else&lt;/span&gt;:
        &lt;span style="color: #8B008B; font-weight: bold"&gt;return&lt;/span&gt; path
    &lt;span style="color: #8B008B; font-weight: bold"&gt;return&lt;/span&gt; tmp


&lt;span style="color: #8B008B; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;ProjectVenvReplCommand&lt;/span&gt;(sublime_plugin.TextCommand):
    &lt;span style="color: #CD5555"&gt;"""&lt;/span&gt;
&lt;span style="color: #CD5555"&gt;    Starts a SublimeREPL, attempting to use project"s specified&lt;/span&gt;
&lt;span style="color: #CD5555"&gt;    python interpreter.&lt;/span&gt;
&lt;span style="color: #CD5555"&gt;    """&lt;/span&gt;

    &lt;span style="color: #8B008B; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #008b45"&gt;run&lt;/span&gt;(&lt;span style="color: #658b00"&gt;self&lt;/span&gt;, edit, no_file=&lt;span style="color: #8B008B; font-weight: bold"&gt;False&lt;/span&gt;):
        &lt;span style="color: #CD5555"&gt;"""Called on project_venv_repl command"""&lt;/span&gt;
        cmd_list = [&lt;span style="color: #658b00"&gt;self&lt;/span&gt;.get_project_interpreter(), &lt;span style="color: #CD5555"&gt;"-i"&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;"-u"&lt;/span&gt;]
        &lt;span style="color: #8B008B; font-weight: bold"&gt;if&lt;/span&gt; &lt;span style="color: #8B008B"&gt;not&lt;/span&gt; no_file:
            file = &lt;span style="color: #CD5555"&gt;"{}.{}"&lt;/span&gt;.format(&lt;span style="color: #658b00"&gt;self&lt;/span&gt;.get_variable(&lt;span style="color: #CD5555"&gt;"project_base_name"&lt;/span&gt;), &lt;span style="color: #658b00"&gt;self&lt;/span&gt;.get_variable(&lt;span style="color: #CD5555"&gt;"file_base_name"&lt;/span&gt;))
            cmd_list.append(&lt;span style="color: #CD5555"&gt;"-m"&lt;/span&gt;)
            cmd_list.append(file)
        &lt;span style="color: #658b00"&gt;self&lt;/span&gt;.repl_open(cmd_list=cmd_list)

    &lt;span style="color: #8B008B; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #008b45"&gt;get_variable&lt;/span&gt;(&lt;span style="color: #658b00"&gt;self&lt;/span&gt;, key):
        &lt;span style="color: #8B008B; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #658b00"&gt;self&lt;/span&gt;.view.window().extract_variables()[key]

    &lt;span style="color: #8B008B; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #008b45"&gt;get_project_interpreter&lt;/span&gt;(&lt;span style="color: #658b00"&gt;self&lt;/span&gt;):
        &lt;span style="color: #CD5555"&gt;"""Return the project"s specified python interpreter, if any"""&lt;/span&gt;
        settings = &lt;span style="color: #658b00"&gt;self&lt;/span&gt;.view.settings()
        &lt;span style="color: #8B008B; font-weight: bold"&gt;return&lt;/span&gt; expand(&lt;span style="color: #658b00"&gt;self&lt;/span&gt;.view, settings.get(&lt;span style="color: #CD5555"&gt;"python_interpreter"&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;"python"&lt;/span&gt;))

    &lt;span style="color: #8B008B; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #008b45"&gt;repl_open&lt;/span&gt;(&lt;span style="color: #658b00"&gt;self&lt;/span&gt;, cmd_list):
        &lt;span style="color: #CD5555"&gt;"""Open a SublimeREPL using provided commands"""&lt;/span&gt;
        &lt;span style="color: #658b00"&gt;self&lt;/span&gt;.view.window().run_command(
            &lt;span style="color: #CD5555"&gt;"repl_open"&lt;/span&gt;, {
                &lt;span style="color: #CD5555"&gt;"encoding"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"utf8"&lt;/span&gt;,
                &lt;span style="color: #CD5555"&gt;"type"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"subprocess"&lt;/span&gt;,
                &lt;span style="color: #CD5555"&gt;"cmd"&lt;/span&gt;: cmd_list,
                &lt;span style="color: #CD5555"&gt;"cwd"&lt;/span&gt;: &lt;span style="color: #658b00"&gt;self&lt;/span&gt;.get_variable(&lt;span style="color: #CD5555"&gt;"project_path"&lt;/span&gt;),
                &lt;span style="color: #CD5555"&gt;"syntax"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"Packages/Python/Python.tmLanguage"&lt;/span&gt;,
                &lt;span style="color: #CD5555"&gt;"extend_env"&lt;/span&gt;: {
                    &lt;span style="color: #CD5555"&gt;"LANG"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"de_DE.utf-8"&lt;/span&gt;,
                    &lt;span style="color: #CD5555"&gt;"LC_ALL"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"de_DE.utf-8"&lt;/span&gt;
                },
            }
        )

&lt;span style="color: #228B22"&gt;# windows, python2.7&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;sublime_plugin&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;ProjectVenvReplCommand&lt;/span&gt;(sublime_plugin.TextCommand):
    &lt;span style="color: #CD5555"&gt;"""&lt;/span&gt;
&lt;span style="color: #CD5555"&gt;    Starts a SublimeREPL, attempting to use project's specified&lt;/span&gt;
&lt;span style="color: #CD5555"&gt;    python interpreter.&lt;/span&gt;
&lt;span style="color: #CD5555"&gt;    """&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #008b45"&gt;run&lt;/span&gt;(&lt;span style="color: #658b00"&gt;self&lt;/span&gt;, edit, open_file=&lt;span style="color: #CD5555"&gt;'$file'&lt;/span&gt;):
        &lt;span style="color: #CD5555"&gt;"""Called on project_venv_repl command"""&lt;/span&gt;
        cmd_list = [&lt;span style="color: #658b00"&gt;self&lt;/span&gt;.get_project_interpreter(), &lt;span style="color: #CD5555"&gt;'-i'&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;'-u'&lt;/span&gt;]
        &lt;span style="color: #8B008B; font-weight: bold"&gt;if&lt;/span&gt; open_file:
            cmd_list.append(open_file)
        &lt;span style="color: #658b00"&gt;self&lt;/span&gt;.repl_open(cmd_list=cmd_list)

    &lt;span style="color: #8B008B; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #008b45"&gt;get_project_interpreter&lt;/span&gt;(&lt;span style="color: #658b00"&gt;self&lt;/span&gt;):
        &lt;span style="color: #CD5555"&gt;"""Return the project's specified python interpreter, if any"""&lt;/span&gt;
        settings = &lt;span style="color: #658b00"&gt;self&lt;/span&gt;.view.settings()
        &lt;span style="color: #8B008B; font-weight: bold"&gt;return&lt;/span&gt; settings.get(&lt;span style="color: #CD5555"&gt;'python_interpreter'&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;'python'&lt;/span&gt;)

    &lt;span style="color: #8B008B; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #008b45"&gt;repl_open&lt;/span&gt;(&lt;span style="color: #658b00"&gt;self&lt;/span&gt;, cmd_list):
        &lt;span style="color: #CD5555"&gt;"""Open a SublimeREPL using provided commands"""&lt;/span&gt;
        &lt;span style="color: #658b00"&gt;self&lt;/span&gt;.view.window().run_command(
            &lt;span style="color: #CD5555"&gt;'repl_open'&lt;/span&gt;, {
                &lt;span style="color: #CD5555"&gt;'encoding'&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;'utf8'&lt;/span&gt;,
                &lt;span style="color: #CD5555"&gt;'type'&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;'subprocess'&lt;/span&gt;,
                &lt;span style="color: #CD5555"&gt;'cmd'&lt;/span&gt;: cmd_list,
                &lt;span style="color: #CD5555"&gt;'cwd'&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;'$file_path'&lt;/span&gt;,
                &lt;span style="color: #CD5555"&gt;'syntax'&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;'Packages/Python/Python.tmLanguage'&lt;/span&gt;
            }
        )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首选项 -&amp;gt; 按键绑定 - 用户&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2018.06.26 update for mac, python3.6&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;// mac, python3.6&lt;/span&gt;
[
    &lt;span style="color: #228B22"&gt;// Runs currently open file in repl&lt;/span&gt;
    {
        &lt;span style="color: #CD5555"&gt;"keys"&lt;/span&gt;:[
            &lt;span style="color: #CD5555"&gt;"super+b"&lt;/span&gt;
        ],
        &lt;span style="color: #CD5555"&gt;"command"&lt;/span&gt;:&lt;span style="color: #CD5555"&gt;"project_venv_repl"&lt;/span&gt;
    },

    &lt;span style="color: #228B22"&gt;// Runs repl without any file&lt;/span&gt;
    {
        &lt;span style="color: #CD5555"&gt;"keys"&lt;/span&gt;:[
            &lt;span style="color: #CD5555"&gt;"super+shift+b"&lt;/span&gt;
        ],
        &lt;span style="color: #CD5555"&gt;"command"&lt;/span&gt;:&lt;span style="color: #CD5555"&gt;"project_venv_repl"&lt;/span&gt;,
        &lt;span style="color: #CD5555"&gt;"args"&lt;/span&gt;:{
            &lt;span style="color: #CD5555"&gt;"no_file"&lt;/span&gt;:&lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;
        }
    }
]

&lt;span style="color: #228B22"&gt;// windows, python2.7&lt;/span&gt;
[
    &lt;span style="color: #228B22"&gt;// Runs currently open file in repl&lt;/span&gt;
    {
        &lt;span style="color: #CD5555"&gt;"keys"&lt;/span&gt;: [&lt;span style="color: #CD5555"&gt;"f5"&lt;/span&gt;],
        &lt;span style="color: #CD5555"&gt;"command"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"project_venv_repl"&lt;/span&gt;
    },
    &lt;span style="color: #228B22"&gt;// Runs repl without any file&lt;/span&gt;
    {
        &lt;span style="color: #CD5555"&gt;"keys"&lt;/span&gt;: [&lt;span style="color: #CD5555"&gt;"f6"&lt;/span&gt;],
        &lt;span style="color: #CD5555"&gt;"command"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"project_venv_repl"&lt;/span&gt;,
        &lt;span style="color: #CD5555"&gt;"args"&lt;/span&gt;: {
            &lt;span style="color: #CD5555"&gt;"open_file"&lt;/span&gt;: &lt;span style="color: #8B008B; font-weight: bold"&gt;null&lt;/span&gt;
        }
    },
    &lt;span style="color: #228B22"&gt;// Runs a specific file in repl, change main.py to desired file&lt;/span&gt;
    {
        &lt;span style="color: #CD5555"&gt;"keys"&lt;/span&gt;: [&lt;span style="color: #CD5555"&gt;"f7"&lt;/span&gt;],
        &lt;span style="color: #CD5555"&gt;"command"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"project_venv_repl"&lt;/span&gt;,
        &lt;span style="color: #CD5555"&gt;"args"&lt;/span&gt;: {
            &lt;span style="color: #CD5555"&gt;"open_file"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"/home/user/example/main.py"&lt;/span&gt;
        }
    }
]
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;f5: 以项目设置中的 &lt;strong&gt;python_interpreter&lt;/strong&gt;  来运行当前文件&lt;/li&gt;
&lt;li&gt;f6: 直接运行项目设置中的 &lt;strong&gt;python_interpreter&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;f7: 以项目设置中的 &lt;strong&gt;python_interpreter&lt;/strong&gt;  来运行指定 py 文件, 更新 open_file 就可以了.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="9-outline"&gt;9. outline&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Outline&lt;/strong&gt; 插件&lt;/p&gt;
&lt;p&gt;安装好后, 打开它的配置文件:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;{
    "color_scheme": "Packages/Outline/outline-Dark.hidden-tmTheme"
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="10-pyc"&gt;10. 编译 Pyc 文件&lt;/h1&gt;
&lt;h2 id="101-pyc"&gt;10.1 生成单个的 pyc 文件&lt;/h2&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;py_compile&lt;/span&gt;
py_compile.compile(&lt;span style="color: #CD5555"&gt;r'H:/game/test.py'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行上面的代码, 就能将 test.py 生成 test.pyc 了.&lt;/p&gt;
&lt;h2 id="102-py-pyc"&gt;10.2 将整个目录下的 py 文件都生成 pyc&lt;/h2&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;compileall&lt;/span&gt;
compileall.compile_dir(&lt;span style="color: #CD5555"&gt;r'H:/game'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行上面的代码, 就将 game 目录下的所有 py 文件(包含子目录)都生成 pyc 文件了.&lt;/p&gt;
&lt;p&gt;当编写项目时, 可以把这个功能做到 &lt;strong&gt;[工具 -&amp;gt; 编译系统]&lt;/strong&gt; 里或者 &lt;strong&gt;[SublimeREPL]&lt;/strong&gt; 里:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;{
    &lt;span style="color: #CD5555"&gt;"selector"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"source.python"&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"shell_cmd"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"python -m py_compile \"test.py\""&lt;/span&gt;
}

{
    &lt;span style="color: #CD5555"&gt;"selector"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"source.python"&lt;/span&gt;,
    &lt;span style="color: #CD5555"&gt;"shell_cmd"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"python -m compileall \"C:/Users/Administrator/Desktop/Scripts\""&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;</content><category term="工具折腾"></category></entry><entry><title>win7 与 VMware ubuntu 虚拟机实现文件共享</title><link href="http://www.smallcpp.cn/win7-yu-vmware-ubuntu-xu-ni-ji-shi-xian-wen-jian-gong-xiang.html" rel="alternate"></link><published>2016-04-23T14:55:00+08:00</published><updated>2016-04-23T14:55:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-04-23:/win7-yu-vmware-ubuntu-xu-ni-ji-shi-xian-wen-jian-gong-xiang.html</id><summary type="html">
&lt;p&gt;貌似安装 VM Tools 后也无法直接拖拽, 只能让 win7 与 VMware ubuntu 虚拟机实现文件共享了~~&lt;/p&gt;
&lt;h2 id="_1"&gt;第一步&lt;/h2&gt;
&lt;p&gt;当然是安装 VM Tools 啦.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 VMware 虚拟机界面, 点 VM -&amp;gt; Install VMware Tools, 之后, 点击 Ubuntu 窗口中主文件按钮, 然后再左边会看见设备里有 VMware tools …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">
&lt;p&gt;貌似安装 VM Tools 后也无法直接拖拽, 只能让 win7 与 VMware ubuntu 虚拟机实现文件共享了~~&lt;/p&gt;
&lt;h2 id="_1"&gt;第一步&lt;/h2&gt;
&lt;p&gt;当然是安装 VM Tools 啦.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 VMware 虚拟机界面, 点 VM -&amp;gt; Install VMware Tools, 之后, 点击 Ubuntu 窗口中主文件按钮, 然后再左边会看见设备里有 VMware tools 文件夹, 右键 -&amp;gt; 解压到这里&lt;/li&gt;
&lt;li&gt;打开 Terminal 终端(ctrl + alt + t), 进入解压的文件夹中, 输入以下命令:&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;sudo tar zxf VMwareTools-xxx.tar.gz
cd /vmware-tools-distrib
sudo ./vmware-install.pl
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装过程中一直按 enter 即可, 或者输入 [] 提示 yes 和 no, 直到安装完毕&lt;/p&gt;
&lt;p&gt;最后查看下结果:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;lsmod | grep vmblock
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="_2"&gt;第二步&lt;/h2&gt;
&lt;p&gt;设置共享文件夹的目录&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将 Ubuntu 关机, 否则不能添加共享文件夹&lt;/li&gt;
&lt;li&gt;在 VMware 虚拟机窗口, 选择 VM -&amp;gt; Settings -&amp;gt; Options -&amp;gt; Shared Folders&lt;/li&gt;
&lt;li&gt;点右边的 Add, 点 Next -&amp;gt; 选择 Win7 共享目录的路径, 然后点 Next -&amp;gt; 选中 Enable this share -&amp;gt; Finish&lt;/li&gt;
&lt;li&gt;在 VM -&amp;gt; Settings -&amp;gt; Options -&amp;gt; Shared Folders 窗口的右边, Folder sharing 栏里选择 Always enabled&lt;/li&gt;
&lt;li&gt;点 OK, 重启 Ubuntu&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="_3"&gt;第三步&lt;/h2&gt;
&lt;p&gt;在 Ubuntu 虚拟机下挂载共享文件夹&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;执行 &lt;code&gt;sudo apt-get install open-vm-dkms&lt;/code&gt; (注: 如果安装过, 以后就不用执行这一行)&lt;/li&gt;
&lt;li&gt;执行 &lt;code&gt;sudo mount -t vmhgfs .host:/ /mnt/hgfs&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;然后去看看效果吧 &lt;code&gt;cd /mnt/hgfs&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="_4"&gt;第四步&lt;/h2&gt;
&lt;p&gt;把挂载共享文件夹加入开机动作&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo gedit /etc/init.d/rc.local&lt;/code&gt;, 打开的文件中加入挂载代码: &lt;code&gt;sudo mount -t vmhgfs .host:/ /mnt/hgfs&lt;/code&gt;, 如下图, 保存退出, 重启 Ubuntu, 发现共享文件夹已经成功自动挂载了.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i68.tinypic.com/2uos3mu.jpg"/&gt;&lt;/p&gt;</content><category term="工具折腾"></category></entry><entry><title>RedMine 简明手册</title><link href="http://www.smallcpp.cn/redmine-jian-ming-shou-ce.html" rel="alternate"></link><published>2016-04-21T22:41:00+08:00</published><updated>2016-04-21T22:41:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-04-21:/redmine-jian-ming-shou-ce.html</id><content type="html">&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;Redmine 是一个开源的项目管理平台, 用于项目的需求管理和缺陷跟踪, Redmine 可以和多种版本库 (如 Git) 整合, 可以直接通过 Web 界面浏览 Git 提交, 还实现了提交和问题的关联.&lt;/p&gt;</content><category term="工具折腾"></category></entry><entry><title>卐 解吧! 叹息墙! — 优雅的翻墙</title><link href="http://www.smallcpp.cn/wan-jie-ba-tan-xi-qiang-you-ya-de-fan-qiang.html" rel="alternate"></link><published>2016-04-09T17:49:00+08:00</published><updated>2016-04-09T17:49:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-04-09:/wan-jie-ba-tan-xi-qiang-you-ya-de-fan-qiang.html</id><summary type="html">
&lt;h2 id="_1"&gt;一. 介绍&lt;/h2&gt;
&lt;h3 id="openshift"&gt;Openshift&lt;/h3&gt;
&lt;p&gt;OpenShift 是&lt;strong&gt;红帽&lt;/strong&gt;的云开发平台即服务(&lt;strong&gt;PaaS&lt;/strong&gt;).&lt;/p&gt;
&lt;p&gt;在 OpenShift 上, 开发人员能够创建、测试和运行他们的应用程序, 并且可以把它们部署到云中.&lt;/p&gt;
&lt;p&gt;Openshift 广泛支持多种编程语言和框架, 如 Java、Ruby 和 PHP 等, 另外它还提供了多种集成开发工具, 如 Eclipse integration、JBoss Developer Studio 和 …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="_1"&gt;一. 介绍&lt;/h2&gt;
&lt;h3 id="openshift"&gt;Openshift&lt;/h3&gt;
&lt;p&gt;OpenShift 是&lt;strong&gt;红帽&lt;/strong&gt;的云开发平台即服务(&lt;strong&gt;PaaS&lt;/strong&gt;).&lt;/p&gt;
&lt;p&gt;在 OpenShift 上, 开发人员能够创建、测试和运行他们的应用程序, 并且可以把它们部署到云中.&lt;/p&gt;
&lt;p&gt;Openshift 广泛支持多种编程语言和框架, 如 Java、Ruby 和 PHP 等, 另外它还提供了多种集成开发工具, 如 Eclipse integration、JBoss Developer Studio 和 Jenkins 等.&lt;/p&gt;
&lt;p&gt;OpenShift Online 服务构建在 Red Hat Enterprise Linux 上.&lt;/p&gt;
&lt;p&gt;Red Hat Enterprise Linux 提供 集成应用程序、运行库和一个配置可伸缩的多用户单实例的 操作系统, 以满足企业级应用的各种需求.&lt;/p&gt;
&lt;h3 id="_2"&gt;翻墙原理&lt;/h3&gt;
&lt;p&gt;由于在 OpenShift 上创建的应用可以通过 &lt;strong&gt;SSH&lt;/strong&gt; 来访问, 而 &lt;strong&gt;SSH&lt;/strong&gt; 的数据传输又是通过加密传输, 因此可以通过 socket5 把请求代理到本地然后再使用 &lt;strong&gt;SSH&lt;/strong&gt; 隧道访问目标网页, 以此达到翻墙目的.&lt;/p&gt;
&lt;h2 id="_3"&gt;二. 开始翻墙&lt;/h2&gt;
&lt;h3 id="openshift_1"&gt;注册/登录 Openshift&lt;/h3&gt;
&lt;p&gt;Openshift 在国内是可以直接访问的(要不然怎么利用它代理翻墙..), 但是注册的时候可能会看不到&lt;strong&gt;验证码&lt;/strong&gt;, 多刷新几次, 要是还不行的话你懂的…&lt;/p&gt;
&lt;h3 id="_4"&gt;创建应用&lt;/h3&gt;
&lt;p&gt;由于目的不是建站, 因此随便创建一个运行环境就行, 比如说这里创建了一个 PHP 运行环境:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i67.tinypic.com/1075mhz.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;然后填写下图中红框中的信息后, 一路下一步到创建成功.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i66.tinypic.com/116nhbq.jpg"/&gt;&lt;/p&gt;
&lt;h3 id="ssh"&gt;配置 SSH&lt;/h3&gt;
&lt;p&gt;利用 &lt;strong&gt;SecureCRT&lt;/strong&gt; 远程 OpenShift 需要使用到两个密钥(公钥和私钥), 这样使用的是现在的, 可以参考我的另一篇笔记: &lt;a href="http://www.smallcpp.cn/git-jian-ming-shou-ce.html#101-ssh-key"&gt;Git 简明手册&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过 &lt;a href="http://www.smallcpp.cn/git-jian-ming-shou-ce.html#101-ssh-key"&gt;Git 简明手册&lt;/a&gt; 拿到了两个密钥文件: &lt;strong&gt;id_rsa&lt;/strong&gt;(私钥) 和 &lt;strong&gt;id_rsa.pub&lt;/strong&gt;(公钥).&lt;/p&gt;
&lt;p&gt;现在需要到 &lt;strong&gt;OpenShift&lt;/strong&gt; 上添加刚拿到的 SSH 公钥了:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i66.tinypic.com/2qk01ls.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;把 &lt;strong&gt;id_rsa.pub&lt;/strong&gt; 里的内容拷贝进去就可以了, Key name 随便写…&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i64.tinypic.com/bfm5n6.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;然后把 OpenShift PHP 应用的 &lt;strong&gt;主机名&lt;/strong&gt; 和 &lt;strong&gt;用户名&lt;/strong&gt; 拷贝下来.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i63.tinypic.com/15guky0.jpg"/&gt;&lt;/p&gt;
&lt;h3 id="securecrt"&gt;使用 SecureCRT&lt;/h3&gt;
&lt;p&gt;首先按 &lt;a href="http://www.smallcpp.cn/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/SecureCRT%20%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8.html"&gt;参考: SecureCRT 的安装和使用&lt;/a&gt; 配好 SecureCRT.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i68.tinypic.com/5fiss1.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;然后保存退回到主界面, 选择 &lt;strong&gt;连接&lt;/strong&gt;, 打开 连接配置窗口, 再选择 &lt;strong&gt;新建会话&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i66.tinypic.com/2mebei0.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i66.tinypic.com/1gpsup.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i66.tinypic.com/2yott20.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i67.tinypic.com/t9yyrk.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i67.tinypic.com/sctmvl.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i64.tinypic.com/2m51k5y.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i67.tinypic.com/2cnb8lt.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i63.tinypic.com/1531x0p.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i63.tinypic.com/2lliueq.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i63.tinypic.com/2sbodaf.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;至此, SecureCRT 到 Openshift 的会话就配好了, 保存退回到 &lt;strong&gt;连接&lt;/strong&gt; 窗口, 点击 &lt;strong&gt;连接&lt;/strong&gt;, 出现下面的提示就说明配对了…&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i68.tinypic.com/e16bk9.jpg"/&gt;&lt;/p&gt;
&lt;h3 id="socket5"&gt;配置浏览器 socket5 代理&lt;/h3&gt;
&lt;p&gt;本地代理环境已经搭好了, 现在开始配置 Chrome, 让 Chrome 通过代理来翻墙…&lt;/p&gt;
&lt;p&gt;这里选择的扩展程序是 &lt;strong&gt;SwitchyOmega&lt;/strong&gt; 插件, 你也可以选择其它的.&lt;/p&gt;
&lt;p&gt;安装好扩展程序后, 进入插件设置面板, 添加一条 &lt;strong&gt;socket5&lt;/strong&gt; 代理, 端口填刚才在 SecureCRT 里设置的&lt;strong&gt;转发端口&lt;/strong&gt;, 我的是 1913, 然后给这个代理起个名字, 例如 &lt;strong&gt;openshift&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i68.tinypic.com/1zqy8me.jpg"/&gt;&lt;/p&gt;
&lt;h2 id="_5"&gt;三. 测试效果&lt;/h2&gt;
&lt;p&gt;&lt;img alt="" src="http://i65.tinypic.com/23mxvl.jpg"/&gt;&lt;/p&gt;</content><category term="工具折腾"></category></entry><entry><title>Git 简明手册</title><link href="http://www.smallcpp.cn/git-jian-ming-shou-ce.html" rel="alternate"></link><published>2016-03-13T13:00:00+08:00</published><updated>2016-03-13T13:00:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-03-13:/git-jian-ming-shou-ce.html</id><summary type="html">
&lt;h2 id="1-git"&gt;1. git 配置&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;git config --list&lt;/li&gt;
&lt;li&gt;git config --global user.name “your name”&lt;/li&gt;
&lt;li&gt;git config --global user.email “email@example.com”&lt;/li&gt;
&lt;li&gt;git config --global push.followTags true  // 这会在 push 时推送有注释的 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">
&lt;h2 id="1-git"&gt;1. git 配置&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;git config --list&lt;/li&gt;
&lt;li&gt;git config --global user.name “your name”&lt;/li&gt;
&lt;li&gt;git config --global user.email “email@example.com”&lt;/li&gt;
&lt;li&gt;git config --global push.followTags true  // 这会在 push 时推送有注释的 tag (git tag -am “xx” yy)&lt;/li&gt;
&lt;li&gt;git config --global core.autocrlf  false  // 关闭换行符检测, windows 的换行有点问题&lt;/li&gt;
&lt;li&gt;git config --global merge.ff false  // 关闭 merge 的 fast forwarding 选项, 能保证每次 merge 都有原始分支信息&lt;/li&gt;
&lt;li&gt;git config --global pull.ff only  // pull 也走的 merge 过程, 需要覆盖上一条的设置, 否则 pull 也会产生一条 Merge message&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.smallcpp.cn/git-jian-ming-shou-ce.html#12"&gt;中文显示&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.smallcpp.cn/git-jian-ming-shou-ce.html#13"&gt;区分大小写&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.smallcpp.cn/git-jian-ming-shou-ce.html#14"&gt;命令别名&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.smallcpp.cn/git-jian-ming-shou-ce.html#15-log"&gt;自定义 Log&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="2"&gt;2. 初始化版本库&lt;/h2&gt;
&lt;p&gt;打开 git bash, 进入目标目录, 执行 &lt;strong&gt;git init&lt;/strong&gt;, 在目标目录下就会生成 &lt;strong&gt;.git&lt;/strong&gt; 目录, 它存放的就是 git 版本库信息.&lt;/p&gt;
&lt;h2 id="3"&gt;3. 正常工作流程&lt;/h2&gt;
&lt;p&gt;edit file (工作区) -&amp;gt; git add (暂存区/index/stage) -&amp;gt; git commit (commit)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;git add file1 file2
    + 如果想将当前目录所有文件都加入 index, 可以用 git add . (点表示当前目录)&lt;/li&gt;
&lt;li&gt;git diff --cached 可以查看哪些文件将被 commit, 即 index 里的文件
    + 或者可以用 git status 查看当前版本库的状况&lt;/li&gt;
&lt;li&gt;git commit -m “注释”&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如果不用 git add 命令, 可以用 git commit -a 参数来合并 add 和 commit 操作(不包括未加入版本控制的文件, 即新建立的文件).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="4"&gt;4. 分支&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;创建一个新分支
    + &lt;code&gt;git branch&lt;/code&gt; 分支名&lt;/li&gt;
&lt;li&gt;查看本地分支表
    + &lt;code&gt;git branch&lt;/code&gt;, * 号表示当前所在分支&lt;/li&gt;
&lt;li&gt;查看所有分支表(包括远程)
    + &lt;code&gt;git branch -a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;切换分支
    + &lt;code&gt;git checkout&lt;/code&gt; 分支名&lt;/li&gt;
&lt;li&gt;合并分支
    + &lt;code&gt;git checkout master&lt;/code&gt;, &lt;code&gt;git merge&lt;/code&gt; 分支名, 这样就把分支的内容合并的 master 分支了 (&lt;a href="http://www.smallcpp.cn/git-jian-ming-shou-ce.html#15-log"&gt;注意&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;解决冲突
    + 如果产生了冲突, 先 &lt;code&gt;git diff&lt;/code&gt; 查看冲突, 解决冲突后, &lt;code&gt;git add&lt;/code&gt;, &lt;code&gt;git commit&lt;/code&gt; 重新提交&lt;/li&gt;
&lt;li&gt;查看图形化时间线
    + &lt;code&gt;gitk&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;比较分支
    + &lt;code&gt;git diff&lt;/code&gt; 分支名..分支名&lt;/li&gt;
&lt;li&gt;重命名本地分支
    + &lt;code&gt;git branch -m&lt;/code&gt; 原名 新名&lt;/li&gt;
&lt;li&gt;删除本地分支
    + &lt;code&gt;git branch -d&lt;/code&gt; 分支名, 删除已经合并的分支
    + &lt;code&gt;git branch -D&lt;/code&gt; 分支名, 强制删除分支, 不管有没有合并过&lt;/li&gt;
&lt;li&gt;删除远程分支
    + 方法一: &lt;code&gt;git push --delete origin branch-name&lt;/code&gt;
    + 方法二: &lt;code&gt;git push origin :branch-name&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;清理本地的远程分支追踪 (使用场景: 某一个远程分支被另一个开发删除)
    + 方法一: &lt;code&gt;git fetch -p&lt;/code&gt;
    + 方法二: &lt;code&gt;git remote prune origin&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="5"&gt;5. 撤销&lt;/h2&gt;
&lt;p&gt;撤销的情况比较复杂&lt;/p&gt;
&lt;p&gt;首先是 &lt;strong&gt;reset --参数 commit id&lt;/strong&gt; 命令, 这个命令有三个参数:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;--mixed：此为默认方式, 回退到某个版本, 只保留工作区, 回退 commit 和 index&lt;/li&gt;
&lt;li&gt;--soft：回退到某个版本, 只回退了 commit, 保留工作区和 index&lt;/li&gt;
&lt;li&gt;--hard：彻底回退到某个版本, 工作区、commit 和 index 都会改变&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再就是 &lt;strong&gt;HEAD&lt;/strong&gt; ‘指针’, HEAD 表示当前版本, 上一个版本就是 HEAD^, 上上一个版本就是 HEAD^^, 当然往上100个版本写 100 个 ^ 比较容易数不过来, 所以写成 HEAD~100;&lt;/p&gt;
&lt;p&gt;另外还有个 &lt;strong&gt;ORIG_HEAD&lt;/strong&gt; 指针, 它指向的是 HEAD 上一次所在的位置.&lt;/p&gt;
&lt;p&gt;使用 &lt;strong&gt;reset&lt;/strong&gt; 命令, 就可以在各个版本之间穿梭了.
穿梭前, 用 &lt;strong&gt;git log&lt;/strong&gt; 可以查看提交历史, 以便确定要回退到哪个版本, 使用 &lt;strong&gt;--pretty=oneline&lt;/strong&gt; 参数可以比较清晰的看到 log, 不过要注意, 一但回到某个版本, 那该版本之后的那些版本通过 git log 就看不到了, 如果还想要重返未来, 可以用 &lt;strong&gt;git reflog&lt;/strong&gt; 查看命令历史, 就可以得到’未来’的 commit id 了.&lt;/p&gt;
&lt;h3 id="commit"&gt;未 commit&lt;/h3&gt;
&lt;h4 id="-"&gt;–版本层面上&lt;/h4&gt;
&lt;p&gt;如果你修改了工作区, 甚至已经提交到 index, 只要你还没 commit, 就可以通过 &lt;strong&gt;git reset --hard HEAD&lt;/strong&gt; 可以回退到当前版本的初始状态.&lt;/p&gt;
&lt;h4 id="-_1"&gt;–文件层面上&lt;/h4&gt;
&lt;p&gt;还有一种情况, 就是修改了工作区, 提交到了 index, 然后又修改了工作区, 然后, 只需要撤掉第二次工作区的修改, 如果使用 git reset --hard HEAD 命令, 那就会把工作区和 index 都给撤掉了, 我们可以使用 &lt;strong&gt;checkout&lt;/strong&gt; 命令.&lt;/p&gt;
&lt;p&gt;命令 &lt;strong&gt;git checkout -- readme.txt&lt;/strong&gt; 意思就是, 把 readme.txt 文件在工作区的修改全部撤销, 它可以让这个文件回到最近一次 git commit 或 git add 时的状态.&lt;/p&gt;
&lt;h3 id="commit_1"&gt;已 commit&lt;/h3&gt;
&lt;h4 id="-_2"&gt;–版本层面上&lt;/h4&gt;
&lt;p&gt;如果已经 commit, 有&lt;strong&gt;两种&lt;/strong&gt;方式来撤销.&lt;/p&gt;
&lt;h5 id="a-push"&gt;a. 修改或删除一个提交 (未 push)&lt;/h5&gt;
&lt;p&gt;使用 &lt;code&gt;git commit --amend&lt;/code&gt; 可以将本次修改追加到上一次的提交, 还可以通过 &lt;code&gt;-c&lt;/code&gt; 指定要追加的 &lt;code&gt;commit id&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;如果确实要删除, 可以通过 &lt;strong&gt;git reset --hard ORIG_HEAD&lt;/strong&gt; 或者 &lt;strong&gt;git reset --hard HEAD^&lt;/strong&gt; 来恢复到上一个版本.&lt;/p&gt;
&lt;h5 id="b-push"&gt;b. 创建一个撤销了上次提交的新提交 (已 push)&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;git revert commit id&lt;/strong&gt;, 这个命令将 commit id 的提交撤销(即回退到上一个版本), 然后创建一个新的提交, 这是一种比较安全的作法, 推荐使用.&lt;/p&gt;
&lt;p&gt;所以这里要注意下, 假设现在有两个版本, A 版本 和 B 版本, A 是刚提交的版本, B 是上一个版本, 如果想撤销 A 的提交.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用 &lt;strong&gt;reset&lt;/strong&gt; 的话, 直接指定 B 版本的 commit id, 它会直接回退到 B 版本&lt;/li&gt;
&lt;li&gt;用 &lt;strong&gt;revert&lt;/strong&gt; 的话, 指定的是 A 版本的 commit id, 它会将 A 版本的上一个版本做为一个新提交&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意, revert 后其实并不会直接 commit, 而是保存在 index 中, 需要执行 git commit 才是真正的提交.&lt;/p&gt;
&lt;p&gt;在 revert 下, 如果已经修改了当前工作区, 那就有可能和撤销后的版本有冲突, 需要解决冲突后, 再提交.&lt;/p&gt;
&lt;h4 id="-_3"&gt;– 文件层面上&lt;/h4&gt;
&lt;p&gt;首先查看该文件的历史版本信息: git log default.txt&lt;/p&gt;
&lt;p&gt;记录下需要恢复的 commit 版本号, 如: 9aa51d89799716aa68cff3f30c26f8815408e926&lt;/p&gt;
&lt;p&gt;恢复该文件: &lt;strong&gt;git reset --hard 9aa51d89799716aa68cff3f30c26f8815408e926 default.txt&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;提交git: git commit -m “恢复单个文件”&lt;/p&gt;
&lt;h2 id="6"&gt;6. 比较差异&lt;/h2&gt;
&lt;p&gt;之前也提到一些, 现在单独列出来:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;git diff 查看工作区与 index 的差异 (产生冲突时可以用该命令查看)&lt;/li&gt;
&lt;li&gt;git diff --cached, 查看 index 和 commit 的差异&lt;/li&gt;
&lt;li&gt;git diff 分支名..分支名, 比较分支&lt;/li&gt;
&lt;li&gt;git diff HEAD 查看 工作区 和 commit 的差异&lt;/li&gt;
&lt;li&gt;git diff 分支名, 查看工作区与另一个分支的差异&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="beyond-compare-diff"&gt;整合 beyond compare 与 diff&lt;/h3&gt;
&lt;p&gt;安装好 BCompare 后, 打开用户目录~下的 &lt;code&gt;.gitconfig&lt;/code&gt; 文件, 进行如下修改:&lt;/p&gt;
&lt;p&gt;windows:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;[diff]
    tool = bc3
[difftool]
    prompt = false
[difftool "bc3"]
    cmd = "\"D:/hanxiao/i/l/u/Beyond Compare/BCompare.exe\" \"$LOCAL\" \"$REMOTE\""

[merge]
    tool = bc3
[mergetool]
    prompt = false
    keepBackup = false
[mergetool "bc3"]
    cmd = "\"D:/hanxiao/i/l/u/Beyond Compare/BCompare.exe\" \"$LOCAL\" \"$REMOTE\" \"$BASE\" \"$MERGED\""
    trustExitCode = true
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;OX:&lt;/p&gt;
&lt;p&gt;安装 beyong compare 后需要在菜单栏点击 “Install Command Line Tools” 把它加入到命令行.&lt;/p&gt;
&lt;p&gt;再参考: &lt;a href="http://www.scootersoftware.com/support.php?zz=kb_vcs_osx"&gt;Beyond Compare&lt;/a&gt;官网介绍.&lt;/p&gt;
&lt;p&gt;最后需要执行下面两行命令:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;git config --global difftool.prompt &lt;span style="color: #658b00"&gt;false&lt;/span&gt;
git config --global mergetool.keepBackup &lt;span style="color: #658b00"&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数说明:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;prompt&lt;/strong&gt;: 打开 tool 前是否出现提示 “是否打开 xx ?”, 一般不需要&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;keepBackup&lt;/strong&gt;: 解决冲突时会生成一个原来冲突文件的备份, 一般也不需要&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;trustExitCode&lt;/strong&gt;: 是否接受 tool 的成功解决冲突通知, 如果设为 false, 解决冲突后 git 还会再问一次 “是否解决冲突了?”, 简直多余, 所以也不需要&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三路合并:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;LOCAL&lt;/strong&gt;: your file with the changes you’ve made to it&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;REMOTE&lt;/strong&gt;: the file you’re merging in, possibly authored by someone else&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BASE&lt;/strong&gt;: the common ancestor file that LOCAL and REMOTE came from&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MERGE_RESULT&lt;/strong&gt;: the file resulting from the merge where you resolve conflicts&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You often need to see all four of these pieces of information to make intelligent choices. Where you came from (LOCAL), where the other person’s changes came from (REMOTE), where you both started (BASE) and where you are now (MERGE_RESULT).&lt;/p&gt;
&lt;p&gt;暴露一个无限试用的方式.&lt;/p&gt;
&lt;p&gt;打开终端&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进入 &lt;code&gt;Beyond Compare&lt;/code&gt; 目录，命令是 &lt;code&gt;cd /Applications/Beyond\ Compare.app/Contents/MacOS&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重命名文件 &lt;code&gt;BCompare&lt;/code&gt; 为 &lt;code&gt;BCompare.real&lt;/code&gt;, 命令是 &lt;code&gt;sudo mv BCompare BCompare.real&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;创建新的 &lt;code&gt;BComapre&lt;/code&gt; 文件, 命令是 &lt;code&gt;sudo touch BCompare&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;打开文件 &lt;code&gt;sudo vim BCompare&lt;/code&gt; 写入以下内容后, 并修改权限 &lt;code&gt;sudo chmod a+x BCompare&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;table class="codehilitetable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;&lt;span style="color: #000000; background-color: #f0f0f0; padding-left: 5px; padding-right: 5px;"&gt;1&lt;/span&gt;
&lt;span style="color: #000000; background-color: #f0f0f0; padding-left: 5px; padding-right: 5px;"&gt;2&lt;/span&gt;
&lt;span style="color: #000000; background-color: #f0f0f0; padding-left: 5px; padding-right: 5px;"&gt;3&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;#!/bin/bash&lt;/span&gt;
rm &lt;span style="color: #CD5555"&gt;"/Users/&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;$(&lt;/span&gt;whoami&lt;span style="color: #8B008B; font-weight: bold"&gt;)&lt;/span&gt;&lt;span style="color: #CD5555"&gt;/Library/Application Support/BeyondCompare/registry.dat"&lt;/span&gt;
&lt;span style="color: #CD5555"&gt;"`dirname "&lt;/span&gt;&lt;span style="color: #00688B"&gt;$0&lt;/span&gt;&lt;span style="color: #CD5555"&gt;"`"&lt;/span&gt;/BCompare.real &lt;span style="color: #00688B"&gt;$@&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;下面是之前的方法, 现在已经不用了, 仅留个备份.&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;[diff]
    tool = bc3
[difftool]
    prompt = false
[difftool "bc3"]
    cmd = bcomp $REMOTE $LOCAL

[merge]
    tool = bc3
[mergetool]
    prompt = false
    keepBackup = false
[mergetool "bc3"]
    cmd = bcomp $LOCAL $REMOTE $BASE $MERGED
    trustExitCode = true
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;下面是更早之前的方法, 现在已经不用了, 仅留个备份.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先在 &lt;code&gt;~/bin/&lt;/code&gt; 目录下 (windows 是用户主目录, 如 &lt;code&gt;C:\Users\Administrator&lt;/code&gt;) 新建一个 git-diff-wrapper.sh 文件&lt;/p&gt;
&lt;p&gt;window 系统的 git bash 的 git-diff-wrapper.sh&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;#/bin/sh
# diff is called by git with 7 parameters:
# path old-file old-hex old-mode new-file new-hex new-mode
"D:/hanxiao/i/l/u/Beyond Compare/BCompare.exe" "$2" "$5" | cat
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;mac 系统的 git-diff-wrapper.sh&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;#/bin/sh
# diff is called by git with 7 parameters:
# path old-file old-hex old-mode new-file new-hex new-mode
bcompare "$2" "$5"|cat
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在用户目录~下修改 .gitconfig 文件, 添加一行:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;[diff]
external = ~/bin/git-diff-wrapper.sh
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意: Mac上运行 git diff 时, 由于系统要保存历史文件到临时目录再进行比较, 而在保存到临时目录又需要很高的权限, 所以在 git diff 前加了 sudo 才能执行成功.&lt;/p&gt;
&lt;h2 id="7"&gt;7. 忽略文件&lt;/h2&gt;
&lt;p&gt;即 .gitignore, 由于 windows 的特性, 可能无法直接新建这样文件名的文件, 可以在 git bash 中使用 linux 命令来新建.&lt;/p&gt;
&lt;p&gt;.gitignore 文件只对还没有加入版本管理的文件起作用, 如果之前已经在之前已经把这些文件加入了版本库, 忽略文件就不起作用了, 那么解决方法就是先把本地缓存删除(改变成未 track 状态), 然后再提交:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;  git rm -r --cached .
  git add .
  git commit -m 'update .gitignore'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这并不会改变已有的版本库历史信息, 可以放心使用.&lt;/p&gt;
&lt;p&gt;配置语法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以 “#” 开头的是注释&lt;/li&gt;
&lt;li&gt;以 “/” 开头表示目录&lt;/li&gt;
&lt;li&gt;以 “?” 通配单个字符&lt;/li&gt;
&lt;li&gt;以 “*” 通配多个字符&lt;/li&gt;
&lt;li&gt;以方括号 “[]” 包含单个字符的匹配列表, 如忽略所有的 *.txt 和 *.html 文件, *.[txthtml]&lt;/li&gt;
&lt;li&gt;以叹号 “!” 强制跟踪某个文件或目录&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如在 .gitignore 写入 test.lib 后, 那么将忽略 test.lib 文件, 写入 /test(或者 /test/*) 就能忽略根目录下的 test 目录(包括这个目录下的所有內容).&lt;/p&gt;
&lt;h2 id="8"&gt;8. 远程操作&lt;/h2&gt;
&lt;h3 id="81"&gt;8.1 新建/克隆版本库&lt;/h3&gt;
&lt;p&gt;根据情况不同, 有两种操作.&lt;/p&gt;
&lt;h4 id="811"&gt;8.1.1 新建版本库&lt;/h4&gt;
&lt;p&gt;现在的情景是, 你已经在本地创建了一个 Git 仓库后, 又想在 GitHub 创建一个 Git 仓库, 并且让这两个仓库进行远程同步, 这样, GitHub 上的仓库既可以作为备份, 又可以让其他人通过该仓库来协作, 真是一举多得.&lt;/p&gt;
&lt;p&gt;首先, 你要去 GitHub 上建立一个新的空版本库, 最好与本地的仓库同名, 好, 现在假设你已经建好了, 新库的地址为: git@github.com:xxx/yyy.git&lt;/p&gt;
&lt;p&gt;现在, 在本地打开 git bash(注意, 要进入本地待同步的仓库目录下), 执行下面的命令:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;git remote add origin git@github.com:xxx/yyy.git
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个命令可以理解成, 给远程仓库(git@github.com:xxx/yyy.git)指定一个简名 origin, 以后在本地仓库目录下, 操作 origin 即是操作远程仓库, origin 是默认的叫法, 也可以改成别的, 但是 origin 这个名字一看就知道是远程库, 通常情况下, 我们也是用这个名字.&lt;/p&gt;
&lt;p&gt;下一步, 就可以把本地库的所有内容推送到远程库上:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;git push -u origin master:master
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;推送到远程, 用 &lt;strong&gt;git push&lt;/strong&gt; 命令.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;git push &amp;lt;远程主机名&amp;gt; &amp;lt;本地分支名&amp;gt;:&amp;lt;远程分支名&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果省略远程分支名, 则表示将本地分支推送与之存在”追踪关系”的远程分支, 通常两者同名, 如果该远程分支不存在, 则会被新建;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-u&lt;/strong&gt; 参数相当于建立关联(追踪)关系, 将远程主机(这里是 origin)的 master 分支和本地仓库的 master 分支关联起来, 以后进行推送/拉取操作时就可以简化命令.
&lt;strong&gt;如果你使用 branch -a 来查看当前所有分支, 则会看到这个关联(追踪)关系&lt;/strong&gt;.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;$ git branch -a
* master
  remotes/origin/HEAD -&amp;gt; origin/master
  remotes/origin/master
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;remotes/origin/HEAD is the default branch for the remote named origin. This lets you simply say origin instead of origin/master.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="http://www.yiibai.com/git/git_push.html"&gt;关于 git push 命令的详细参考链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;推送成功后, 可以立刻在 GitHub 页面中看到远程库的内容已经和本地一模一样;&lt;/p&gt;
&lt;p&gt;从现在起, 只要本地作了提交, 就可以通过命令:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;git push
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把本地 master 分支的最新修改推送至 GitHub, 现在, 你就拥有了真正的分布式版本库.&lt;/p&gt;
&lt;h4 id="812"&gt;8.1.2 克隆版本库&lt;/h4&gt;
&lt;p&gt;8.1.1 讲了先有本地库, 后有远程库的时候, 如何关联远程库, 现在, 假设已经有了一个远程库, 从远程库克隆到本地, 该如何操作.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;$ git clone git@github.com:xxx/yyy.git
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果是 clone 的方式, 那么, 我们就不需要手动去设置远程仓库的简名以及关联(追踪)关系了, 它会自动给它设置好, 我们可以通过 git config –list 查看.&lt;/p&gt;
&lt;p&gt;当然, 推送修改时, 你依然可以用 &lt;strong&gt;-u&lt;/strong&gt; 参数来指定关联:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;git push -u origin master:master
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="82-pull"&gt;8.2 拉取更新(pull)&lt;/h3&gt;
&lt;p&gt;该操作取回远程主机某个分支的更新, 再&lt;strong&gt;与本地的指定分支合并&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.yiibai.com/git/git_pull.html"&gt;参考链接&lt;/a&gt;&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;git pull &amp;lt;远程主机名&amp;gt; &amp;lt;远程分支名&amp;gt;:&amp;lt;本地分支名&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果我们设置了关联(追踪)关系(参考 8.1.1), 则可以省略命令, 直接写: &lt;strong&gt;git pull&lt;/strong&gt; 就可以了.&lt;/p&gt;
&lt;h3 id="83-fetch"&gt;8.3 获取更新(fetch)&lt;/h3&gt;
&lt;p&gt;该操作取回远程主机某个分支的更新, 但并&lt;strong&gt;不与本地分支进行合并&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.yiibai.com/git/git_fetch.html"&gt;参考链接&lt;/a&gt;&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;git fetch &amp;lt;远程主机名&amp;gt; &amp;lt;分支名&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所取回的更新, 在本地主机上要用 “&lt;strong&gt;远程主机名/分支名&lt;/strong&gt;” 的形式读取, 比如 origin 主机的 master, 就要用 origin/master 读取.&lt;/p&gt;
&lt;p&gt;git branch -a 查看所有分支:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;$ git branch -a
* master
  remotes/origin/master
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面命令结果表示, 本地主机的当前分支是 master, 远程分支是 origin/master.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;git log -p master..origin/master
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;取回远程主机的更新以后, 通过上面的命令比较本地仓库和远程参考的区别, 如果你需要详细的比较信息, 可以用 diff 命令:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;git diff master..origin/master
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当检查修正完后, 使用 git merge 在本地分支上合并远程分支:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;$ git merge origin/master
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面命令表示在当前分支上, 合并 origin/master.&lt;/p&gt;
&lt;h2 id="9-git-in-windows"&gt;9. Git In Windows&lt;/h2&gt;
&lt;p&gt;首先, 先安装 Msysgit 和 SourceTree, 因为服务器在国外, 下载起来非常慢, 我下载好一份放在云盘上, 地址在下面:&lt;/p&gt;
&lt;p&gt;Git For Windows(Msysgit):
&lt;a href="https://yunpan.cn/cYR2UcrFIwrKM"&gt;https://yunpan.cn/cYR2UcrFIwrKM&lt;/a&gt; 访问密码 1d91&lt;/p&gt;
&lt;p&gt;SourceTree:
&lt;a href="https://yunpan.cn/cYR2i2zBPbzce"&gt;https://yunpan.cn/cYR2i2zBPbzce&lt;/a&gt; 访问密码 45cd&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;除了 SourceTree 外也还有其他的选择, 如 TortoiseGit, 然而试用过后, 还是 SourceTree 比较好.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Git For Windows(Msysgit) 自带一个 &lt;strong&gt;git bash&lt;/strong&gt; 和 &lt;strong&gt;git gui&lt;/strong&gt;, 哦, 对了, 还有一个 &lt;strong&gt;gitk&lt;/strong&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;git bash 就是一个模拟 linux 的终端&lt;/li&gt;
&lt;li&gt;git gui 是一个轻量级的图形操作界面&lt;/li&gt;
&lt;li&gt;gitk  是一个 git 浏览器, 主要用于用户查看仓库的各类信息(更改信息、提交信息、版本信息、图形显示等)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Msysgit 的图形化界面, 虽然能满足日常需求, 但确实比较粗糙, 而 SourceTree 就是一个很好的替代方案, 日常操作就用 SourceTree, 需要用到命令行时就用 git bash.&lt;/p&gt;
&lt;p&gt;其实 SourceTree 也可以自动下载 git, 只不过速度不敢恭维, 还是我们自己手动下载、安装好了, 安装好 SourceTree 后, 首次运行, 会让你进行一个&lt;strong&gt;初始化设置&lt;/strong&gt;, 请&lt;strong&gt;直接跳过&lt;/strong&gt;;
因为我们已经安装好 Git 客服端了, 如果让 SourceTree 进行初始化, 它会给你重新下载一个 Git 还有 Mercurial.&lt;/p&gt;
&lt;p&gt;SourceTree 参考资料:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.myexception.cn/other/1997033.html"&gt;用SourceTree轻巧Git项目图解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.takobear.tw/2014/02/15/bear-git-flow-sourcetreegit-flow"&gt;如何在SOURCETREE使用GIT FLOW管理開發!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="10-sourcetree-in-github"&gt;10. SourceTree In GitHub&lt;/h2&gt;
&lt;p&gt;假设已经有了 GitHub 上自己的远程仓库.&lt;/p&gt;
&lt;h3 id="101-ssh-key"&gt;10.1 创建 SSH Key&lt;/h3&gt;
&lt;p&gt;首先, 到用户目录下(C:/Users/Administrator), 看看有没有 .ssh 目录, 如果有, 则进入这个目录, 看看有没有 &lt;strong&gt;id_rsa&lt;/strong&gt;(私钥) 和 &lt;strong&gt;id_rsa.pub&lt;/strong&gt;(公钥) 这两个文件, 如果有, 就可以跳过 10.1 后面的操作了, 直接开始 10.2, 如果没有, 则打开 gui bash, 运行下面的命令, 创建一个密钥对:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;$ ssh-keygen -t rsa -C "youremail@example.com" // 后面的 -C 邮件 是注释, 也可以省略
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一路回车后, 就在刚才的目录下面生成了 &lt;strong&gt;id_rsa&lt;/strong&gt;(私钥) 和 &lt;strong&gt;id_rsa.pub&lt;/strong&gt;(公钥) 两个文件.&lt;/p&gt;
&lt;h3 id="102-github"&gt;10.2 设置 GitHub&lt;/h3&gt;
&lt;p&gt;登录 GitHub 后, 设置 GitHub 的 “SSH Keys”, 就是刚才生成的 &lt;strong&gt;id_rsa.pub&lt;/strong&gt;(公钥) 里面的内容, 直接复制进去就可以了.&lt;/p&gt;
&lt;p&gt;设置完后, 可以在 git bash 中执行下面的命令看看有没有设置成功:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;ssh git@github.com
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="103-sourcetree"&gt;10.3 设置 SourceTree&lt;/h3&gt;
&lt;p&gt;打开 “工具”-&amp;gt;”创建/导入SSH密钥”, 打开 PuTTY 后, 点击 “Load” 按钮, 选择 9.1 中生成的 &lt;strong&gt;id_rsa&lt;/strong&gt;(私钥) 文件, 然后点击 “Save private key” 按钮, 保存为 &lt;strong&gt;id_rsa.ppk&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id="104"&gt;10.4 克隆项目&lt;/h3&gt;
&lt;p&gt;到你的 GitHub 上拷贝一个项目的 SSH 下来, 打开 SourceTree, 点击 “克隆/新建”, 填写好相关信息后, 点击 “克隆”, 首次使用, 可能会克隆不下来, SourceTree 会报个错.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;...
The server's rsa2 key fingerprint is:
ssh-rsa 2048 9f:a7:a4:00:e4:f1:7a:bc:aa:c1:d3:ea:1e:d7:4d:79
If you trust this host, enter "y" to add the key to
PuTTY's cache and carry on connecting.
If you want to carry on connecting just once, without
adding the key to the cache, enter "n".
If you do not trust this host, press Return to abandon the
connection.
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;其实这里是让你输 yes / no, 可惜 sourcetree 中输入不了,  得我们手动在 cmd 中操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是因为首次连接一个使用 SSH 协议的 Git 服务器的时候, 因为远程 SSH 服务器的公钥没有经过确认而导致 git 命令执行失败, 解决方法是在&lt;strong&gt;命令行&lt;/strong&gt;下找到 SourceTree 安装目录里的 PuTTy 工具, 例如 “C:/Program Files (x86)/Atlassian/SourceTree/tools/putty/plink.exe”, 然后执行命令&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;plink.exe git@github.com
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它会继续报刚才的错误, 我们在 cmd 中输入 yes 就可以了.&lt;/p&gt;
&lt;p&gt;然后重新在 SourceTree 中克隆项目, 然后它就会提示你, 让你选择私钥 key 文件, 点击桌面右下角任务栏的 “Pageant”, 点击 “add key” 按钮, 选择 9.3 中生成的 &lt;strong&gt;id_rsa.ppk&lt;/strong&gt; 即可.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;每次重新启动电脑后, Pageant 都会清空, 又要重新选择 key 文件 . . . , 等找到解决方法后再来更新笔记.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;已经找到解决方法:
点击 “工具”-&amp;gt;”选项”-&amp;gt;”一般”, 在 SSH 密钥那一栏里选择我们的 &lt;strong&gt;id_rsa.ppk&lt;/strong&gt;, 就不需要每次都要 “add key” 了.&lt;/p&gt;
&lt;h2 id="11-git-stash"&gt;11. git stash 贮藏&lt;/h2&gt;
&lt;p&gt;git stash 的功能是保存当前工作目录和暂存区, 并 reset –hard HEAD, 即恢复成最新 commit 时的状态.&lt;/p&gt;
&lt;p&gt;需要恢复的时候, 使用 &lt;strong&gt;git stash apply&lt;/strong&gt; 就将过去贮藏(stashed)的工作区快照恢复了, 和 merge 一样，git stash apply 之前要保证当前目录是干净的(没有未提交的改变), 否则会保错:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;error: Your local changes to the following files would be overwritten by merge: Please, commit your changes or stash them before you can merge.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果工作区在贮藏之后发生了变化(即更改过 file 并 commit 了), 恢复时就有可能产生冲突(conflict), 这种情况下 git stash apply 会对工作目录进行 merge 操作.&lt;/p&gt;
&lt;p&gt;git stash apply 只能恢复工作目录, 如果想把暂存区也按照贮藏时的暂存区恢复的话, 可以加上 &lt;strong&gt;–index&lt;/strong&gt; 参数, 如果暂存区恢复时发生冲突了会怎么办呢? 它可不会让你进行 merge, 而是直接报错不允许你这么做:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;Conflicts in index. Try without --index.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以不要指望让 stash 去恢复暂存区, 如果暂存区有文件, 还是先 commit 的吧, 不然很可能就找不回来了…&lt;/p&gt;
&lt;p&gt;在使用 SourceTree 的 stash 功能过程中, 我误解了一点东西, 这里也记录下:&lt;/p&gt;
&lt;p&gt;SourceTree 的 stash 操作会让选择一个选项 – “保存暂存的更改”&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i67.tinypic.com/lees0.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;我一开始以为, 这个选项是控制 –index 参数, 后来发现不管勾不勾这个选项, 恢复时都不会恢复暂存区的内容(估计 SourceTree 也认为不能指望让 stash 去恢复暂存区吧), 那这个选项是干什么的呢?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不勾选, 就是正常的 git stash, 和我们使我 git bash 用命令一样的效果&lt;/li&gt;
&lt;li&gt;勾选, 贮藏后, 工作区的内容被回退到 HEAD, 但保留暂存区里的内容&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="12"&gt;12. 中文显示问题&lt;/h2&gt;
&lt;p&gt;参考: &lt;a href="http://xstarcd.github.io/wiki/shell/git_chinese.html"&gt;http://xstarcd.github.io/wiki/shell/git_chinese.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解决 git status 和 push、pull 时, 中文文件名乱码, 如:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;[/data/soft/xstarcd.github.io]$git status
位于分支 master
您的分支与上游分支 'origin/master' 一致。
未跟踪的文件:
  （使用 "git add &amp;lt;文件&amp;gt;..." 以包含要提交的内容）

        "\346\265\213\350\257\225.txt"

提交为空，但是存在尚未跟踪的文件（使用 "git add" 建立跟踪）
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解决方式：&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;git config --global core.quotepath &lt;span style="color: #658b00"&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外, 还会出现 commit/log 信息乱码:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;git config --global i18n.commitencoding utf-8
git config --global i18n.logoutputencoding utf-8
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后还要把 &lt;code&gt;LESSCHARSET=utf-8&lt;/code&gt; 添加到系统环境变量中：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.smallcpp.cn/images/Git简明手册/LESSCHARSET.jpg"/&gt;&lt;/p&gt;
&lt;h2 id="13"&gt;13. 区分文件大小写&lt;/h2&gt;
&lt;p&gt;默认的 Git 监控是&lt;strong&gt;不区分&lt;/strong&gt;文件大小写的 ~&lt;/p&gt;
&lt;p&gt;Git 控制是否忽略大小的选项是 &lt;code&gt;core.ignorecase&lt;/code&gt; (true: 不区分, false: 区分), 但是这个选项在每个 Git 项目的配置里都是默认 true 的, 所以就算配了全局的 &lt;code&gt;core.ignorecase&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt;, 也会被项目的配置给覆盖掉.&lt;/p&gt;
&lt;p&gt;所以一般这里有两种处理方法.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一种, 做全局设置 &lt;code&gt;git config --global core.ignorecase false&lt;/code&gt;, 并且删除 Git 项目的 &lt;code&gt;core.ignorecase&lt;/code&gt; 选项&lt;/li&gt;
&lt;li&gt;第二种, 就是只对当前项目做配置 &lt;code&gt;git config core.ignorecase false&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="14"&gt;14. 命令别名&lt;/h2&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;git config --global alias.co checkout
git config --global alias.cm commit -m
git config --global alias.br branch
git config --global alias.st status
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="15-log"&gt;15. 自定义 Log&lt;/h2&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;git config --global alias.lg &lt;span style="color: #CD5555"&gt;"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&amp;lt;%an&amp;gt;%Creset' --abbrev-commit"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</content><category term="工具折腾"></category></entry><entry><title>Sublime 配置 Markdown 写作环境</title><link href="http://www.smallcpp.cn/sublime-pei-zhi-markdown-xie-zuo-huan-jing.html" rel="alternate"></link><published>2016-03-05T13:00:00+08:00</published><updated>2016-03-05T13:00:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-03-05:/sublime-pei-zhi-markdown-xie-zuo-huan-jing.html</id><summary type="html">
&lt;h2 id="_1"&gt;语法高亮&lt;/h2&gt;
&lt;p&gt;Sublime Text 内置 Markdown 文档的语法高亮, 只是默认的太挫了…&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Monokai Extended&lt;/strong&gt; 和 &lt;strong&gt;Markdown Extended&lt;/strong&gt; 是一套解决方案.&lt;/p&gt;
&lt;p&gt;安装完两个插件后, 首先在 [首选项] -&amp;gt; [主题方案] 里设置 &lt;em&gt;Monokai Extended&lt;/em&gt;, 然后, 打开一个 *.md 文件, 在 Sublime 右下角显示文件语法那里点击选择 [打开具有当前扩展名的] -&amp;gt; [Markdown Extended …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="_1"&gt;语法高亮&lt;/h2&gt;
&lt;p&gt;Sublime Text 内置 Markdown 文档的语法高亮, 只是默认的太挫了…&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Monokai Extended&lt;/strong&gt; 和 &lt;strong&gt;Markdown Extended&lt;/strong&gt; 是一套解决方案.&lt;/p&gt;
&lt;p&gt;安装完两个插件后, 首先在 [首选项] -&amp;gt; [主题方案] 里设置 &lt;em&gt;Monokai Extended&lt;/em&gt;, 然后, 打开一个 *.md 文件, 在 Sublime 右下角显示文件语法那里点击选择 [打开具有当前扩展名的] -&amp;gt; [Markdown Extended], 或者在 [查看] -&amp;gt; [语法] -&amp;gt; [打开具有当前扩展名的] -&amp;gt; [Markdown Extended], 这样就将 *.md 文件与 Markdown Extended 关联起来了.&lt;/p&gt;
&lt;h2 id="_2"&gt;智能补全&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Markdown Editing&lt;/strong&gt; 插件&lt;/p&gt;
&lt;p&gt;Markdown Editing 也自带三种配色方案, 不过嘛, 略丑, 还是用 Monokai Extended 和 Markdown Extended 的好.&lt;/p&gt;
&lt;p&gt;Markdown Editing 常用功能如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;星号 、 下划线 和 反引号(键盘 1 旁边的那个键) 自动匹配
    + 按 回退键 删除整个符号
    + 按 空格键 删除右边的符号&lt;/li&gt;
&lt;li&gt;在列表的末尾回车, 下一行自动生成列表符号
    + 在当前列表按 tab 键可生成子列表, 并循环使用 *, -, + 符号
    + shift tab 键可以反向上面的操作&lt;/li&gt;
&lt;li&gt;在引用的末尾回车, 下一行自动生成引用符号&lt;/li&gt;
&lt;li&gt;选取需要的内容后, 按 &lt;em&gt;&amp;gt;&lt;/em&gt; 能将选取的内容都加上引用&lt;/li&gt;
&lt;li&gt;Ctrl + Win + V 插入链接&lt;/li&gt;
&lt;li&gt;Ctrl + Win + R 插入参考式链接&lt;/li&gt;
&lt;li&gt;Shift + Win + K 插入图片(有冲突, 等下讲怎么处理)&lt;/li&gt;
&lt;li&gt;Ctrl + Shift + B / I 粗体 / 斜体&lt;/li&gt;
&lt;li&gt;Ctrl + 1~6 插入标题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不过我用反引号时, 都是用三个反引号来指定编程语言, 单反引号貌似不能指定语言, 所以改了下 Markdown Editeing 的快捷键, [首选项] -&amp;gt; [插件设置] -&amp;gt; [Markdown Editing] -&amp;gt; [Key Bindings -- User]&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;    {
        "keys": ["`"], "command": "insert_snippet", "args": {"contents": "```$0\n```\n
"}, "context":
        [
             { "key": "setting.auto_match_enabled", "operator": "equal", "operand": true },
             { "key": "selection_empty", "operator": "equal", "operand": true, "match_all": true },
             { "key": "following_text", "operator": "regex_contains", "operand": "^(?:\t| |\\)|]|\\}|$)", "match_all": true },
             { "key": "preceding_text", "operator": "not_regex_contains", "operand": "['a-zA-Z0-9_`]$", "match_all": true },
             { "key": "eol_selector", "operator": "not_equal", "operand": "string.quoted.single", "match_all": true },
             { "key": "selector", "operator": "equal", "operand": "text.html.markdown", "match_all": true }
        ]
    },

    {
        "keys": ["`"], "command": "insert_snippet", "args": {"contents": "```\n${0:$SELECTION}\n```"}, "context":
        [
            { "key": "setting.auto_match_enabled", "operator": "equal", "operand": true },
            { "key": "selection_empty", "operator": "equal", "operand": false, "match_all": true },
            { "key": "selector", "operator": "equal", "operand": "text.html.markdown", "match_all": true }
        ]
    },
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外, &lt;strong&gt;Shift + Win + K&lt;/strong&gt; 插入图片快捷键和输入法有点冲突, 我们改成 &lt;strong&gt;ctrl + super + k&lt;/strong&gt;, 一样的打开 [Key Bindings – User]&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;    {
        "keys": ["ctrl+super+k"], "command": "reference_new_inline_image", "context":
        [
            { "key": "selector", "operator": "equal", "operand": "text.html.markdown", "match_all": true }
        ]
    },
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后, Markdown Editing 默认的粗体和斜体是用下划线控制的, 在 pelican 中转化成貌似有点问题, 所以改成了 *, [首选项] -&amp;gt; [插件设置] -&amp;gt; [Markdown Editing] -&amp;gt; [Bold and Italic Settings -- User]:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #1e889b"&gt;&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;&lt;/span&gt;
&lt;span style="color: #1e889b"&gt;&amp;lt;!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&amp;gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;plist&lt;/span&gt; &lt;span style="color: #658b00"&gt;version=&lt;/span&gt;&lt;span style="color: #CD5555"&gt;"1.0"&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;name&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;Bold and Italic Markers&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;scope&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;text.html.markdown&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;settings&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;shellVariables&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;array&amp;gt;&lt;/span&gt;
            &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;name&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;MD_BOLD_MARKER&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;value&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;**&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
            &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
            &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;name&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;MD_ITALIC_MARKER&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;value&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;*&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
            &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/array&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;uuid&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;E3F0F1B0-53C8-11E3-8F96-0800200C9A66&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/plist&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="_3"&gt;表格辅助&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;TableEditor&lt;/strong&gt;: Markdown 中的表格书写体验真心不咋样, 所有有人为这个开发了一个插件, 具有较好的自适应性, 会自动对齐.&lt;/p&gt;
&lt;p&gt;首先需要用 &lt;strong&gt;ctrl + shift + p&lt;/strong&gt; 打开这个功能:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Table Editor: Enable for current syntax&lt;/li&gt;
&lt;li&gt;Table Editor: Enable for current view&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常用方法:&lt;/p&gt;
&lt;p&gt;输入下面的样式&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;  | Name | Phone |
  |-
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;按 tab 键&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;  | Name | Phone |
  |------|-------|
  | _    |       |
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用 &lt;strong&gt;tab&lt;/strong&gt; 切换字段, 按 &lt;strong&gt;enter&lt;/strong&gt; 新建新行&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;输入下面的样式&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;  |Name|Phone
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;按 ctrl + k, enter (注意是先按 ctrl + k, 按完后再按 enter)&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;  | Name | Phone |
  |------|-------|
  | _    |       |
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;
&lt;p&gt;行列操作&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;alt + shift + up&lt;/strong&gt; 删除当前行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;alt + shift + down&lt;/strong&gt; 在当前行上面新建一行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;alt + up/down&lt;/strong&gt; 上下移动行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;alt + shift + left&lt;/strong&gt; 删除当前列&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;alt + shift + right&lt;/strong&gt; 在当前列左边新建列&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;alt + right/left&lt;/strong&gt; 左右移动列&lt;/p&gt;
&lt;h2 id="_4"&gt;预览&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;OmniMarkupPreviewer&lt;/strong&gt; 可以实时在浏览器中预览&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ctrl + Alt + O: Preview Markup in Browser.&lt;/li&gt;
&lt;li&gt;Ctrl + Alt + X: Export Markup as HTML.&lt;/li&gt;
&lt;li&gt;Ctrl + Alt + C: Copy Markup as HTML.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有个 &lt;strong&gt;Markdown Preview&lt;/strong&gt; 插件也是可以预览 md 文件, 但是需要手动生成 + F5 的, 所以感觉用起来比较麻烦.&lt;/p&gt;
&lt;p&gt;OmniMarkupPreviewer 的默认配置已经满足日常需求了, 不过可以在配置文件中把 &lt;strong&gt;toc&lt;/strong&gt; 打开, 这样就可以生成目录了.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;"extensions": ["tables", "strikeout", "fenced_code", "codehilite", "toc"] // 这是 OmniMarkupPreviewer 配置文件的最后一行
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="_5"&gt;插入文件头&lt;/h2&gt;
&lt;p&gt;我们使用 Pelican 时, 要在每个 md 文件中添加文件头, 格式大概如下:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;Title: Git 简明手册
Author: HanXiao
Date: 2016-03-13 13:00
Summary: Git 学习笔记, 记录一些常用的操作, 以及 SourceTree、Github 的用法.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用 sublime 提供的 code snippet 可以方便的完成添加操作.&lt;/p&gt;
&lt;p&gt;“工具”-&amp;gt;”新代码片段”:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;snippet&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;content&amp;gt;&lt;/span&gt;&lt;span style="color: #1e889b"&gt;&amp;lt;![CDATA[Title: ${1}&lt;/span&gt;
&lt;span style="color: #1e889b"&gt;Author: HanXiao&lt;/span&gt;
&lt;span style="color: #1e889b"&gt;Date: ${2}&lt;/span&gt;
&lt;span style="color: #1e889b"&gt;Summary:&lt;/span&gt;

&lt;span style="color: #1e889b"&gt;${3}&lt;/span&gt;
&lt;span style="color: #1e889b"&gt;]]&amp;gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/content&amp;gt;&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;&amp;lt;!-- Optional: Set a tabTrigger to define how to trigger the snippet --&amp;gt;&lt;/span&gt;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;tabTrigger&amp;gt;&lt;/span&gt;md&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/tabTrigger&amp;gt;&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;&amp;lt;!-- Optional: Set a scope to limit where the snippet will trigger --&amp;gt;&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;&amp;lt;!-- &amp;lt;scope&amp;gt;source.python&amp;lt;/scope&amp;gt; --&amp;gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;&amp;lt;/snippet&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;保存文件, 取名为 &lt;strong&gt;title-code.sublime-snippet&lt;/strong&gt;, 此时, 在文本中, 输入 md, 然后按 tab 键, 就可以直接输入我们的文件头了.&lt;/p&gt;
&lt;h2 id="_6"&gt;插入时间&lt;/h2&gt;
&lt;p&gt;在我们上一步的操作中, 我们还要手写时间, 这也比较麻烦, sublime 也没有提供直接的方法来插入时间, 不过还好, sublime 可以用插件的方式来扩展功能.&lt;/p&gt;
&lt;p&gt;“工具”-&amp;gt;”新插件”:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;datetime&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;sublime&lt;/span&gt;, &lt;span style="color: #008b45; text-decoration: underline"&gt;sublime_plugin&lt;/span&gt;

&lt;span style="color: #8B008B; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;AddCurrentTimeCommand&lt;/span&gt;(sublime_plugin.TextCommand):
    &lt;span style="color: #8B008B; font-weight: bold"&gt;def&lt;/span&gt; &lt;span style="color: #008b45"&gt;run&lt;/span&gt;(&lt;span style="color: #658b00"&gt;self&lt;/span&gt;, edit):
        &lt;span style="color: #658b00"&gt;self&lt;/span&gt;.view.run_command(&lt;span style="color: #CD5555"&gt;"insert_snippet"&lt;/span&gt;,
            {
                &lt;span style="color: #CD5555"&gt;"contents"&lt;/span&gt;: &lt;span style="color: #CD5555"&gt;"%s"&lt;/span&gt; % datetime.datetime.now().strftime(&lt;span style="color: #CD5555"&gt;"%Y-%m-%d %H:%M"&lt;/span&gt;)
            }
        )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;保存为 &lt;strong&gt;add_current_time.py&lt;/strong&gt;, 然后打开用户的按键绑定设置, 在后添加一个新快捷键:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;// 插入时间
{
    "keys": ["ctrl+shift+."], "command":"add_current_time",
},
&lt;/pre&gt;&lt;/div&gt;</content><category term="工具折腾"></category></entry><entry><title>从 wp 迁移到 pelican (github)</title><link href="http://www.smallcpp.cn/cong-wp-qian-yi-dao-pelican-github.html" rel="alternate"></link><published>2016-01-03T23:00:00+08:00</published><updated>2016-01-03T23:00:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2016-01-03:/cong-wp-qian-yi-dao-pelican-github.html</id><summary type="html">&lt;p&gt;考虑了很久, 终于下定决心把博客从 wordpress 迁移到 github 上了, 这里作个记录, 方便以后查询.&lt;/p&gt;</summary><content type="html">&lt;p&gt;考虑了很久, 终于下定决心把博客从 wordpress 迁移到 github 上了, 这里作个记录, 方便以后查询.&lt;/p&gt;

&lt;h1 id="1-pelican"&gt;1. Pelican 博客搭建&lt;/h1&gt;
&lt;p&gt;首先, 要在 github 上建立自己的主页, 方法很简单, 在自己的 github 上 new 一个 repository，名字必须是 &lt;strong&gt;yourname.github.com&lt;/strong&gt;, 然后通过 yourname.github.com 就能访问了这个 repository 主干下的 index.html 文件了, 为方便测试, 可以手动添加一个 index.html, 然后随便写上几句话, 然后通过 yourname.github.com 查看效果.&lt;/p&gt;
&lt;p&gt;接下来, 就是搭建本地博客了, 这里使用的是 pelican 系统, why? 因为它是 Python 写的, 而我又刚好懂那么一丢丢 python…&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;pip install pelican
pip install Markdown
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后新建一个 myblog 文件夹, 运行 cmd, 进入这个文件夹, 然后执行 &lt;strong&gt;pelican-quickstart&lt;/strong&gt;, 运行命令后, 会让做一些选项设置:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;gt; Where do you want to create your new web site? [.]
&amp;gt; What will be the title of this web site? SmallCpp
&amp;gt; Who will be the author of this web site? HanXiao
&amp;gt; What will be the default language of this web site? [en] zh
&amp;gt; Do you want to specify a URL prefix? e.g., http://example.com   (Y/n)
&amp;gt; What is your URL prefix? (see above example; no trailing slash) http://uldaman.github.com
&amp;gt; Do you want to enable article pagination? (Y/n)
&amp;gt; How many articles per page do you want? [10]
&amp;gt; What is your time zone? [Europe/Paris] Asia/Shanghai
&amp;gt; Do you want to generate a Fabfile/Makefile to automate generation and publishing? (Y/n)
&amp;gt; Do you want an auto-reload &amp;amp; simpleHTTP script to assist with theme and site development? (Y/n)
&amp;gt; Do you want to upload your website using FTP? (y/N)
&amp;gt; Do you want to upload your website using SSH? (y/N)
&amp;gt; Do you want to upload your website using Dropbox? (y/N)
&amp;gt; Do you want to upload your website using S3? (y/N)
&amp;gt; Do you want to upload your website using Rackspace Cloud Files? (y/N)
&amp;gt; Do you want to upload your website using GitHub Pages? (y/N) Y
&amp;gt; Is this your personal page (username.github.io)? (y/N) Y
Done. Your new project is available at C:\Users\Administrator\Desktop\test
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后, 在当前的 myblog 目录下就有以下文件:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;myblog/
├── content
│   └── (pages)
├── output
├── develop_server.sh
├── fabfile.py
├── Makefile
├── pelicanconf.py       # Main settings file
└── publishconf.py       # Settings to use when ready to publish
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;content: 这里是放置博文的 md 文件, 例如 hello_python.markdown 文章;&lt;/p&gt;
&lt;p&gt;output: 这个目录下放置的就是一会利用 pelican 生成的静态博客内容, 当然是 html 的;&lt;/p&gt;
&lt;p&gt;pelicanconf.py: 是博客的配置文件;&lt;/p&gt;
&lt;p&gt;publishconf.py: 发布配置文件,可有可无;&lt;/p&gt;
&lt;p&gt;Makefile: make 命令的配置文件, 如果你懂 linux 这个就so easy! 不过不懂也没事, 基本用不上;&lt;/p&gt;
&lt;p&gt;develop_server.sh: 本地服务的脚本, 用来测试当前生成的博客的.&lt;/p&gt;
&lt;p&gt;接下来就是写个测试博客~&lt;/p&gt;
&lt;p&gt;到 content 目录下新建个 my_first.markdown 文件:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;Title: 标题
Author: 作者
Date: 2010-12-03 10:20
Category: 分类
Tags: 标签1, 标签2
Slug: url 别名
Summary: 摘要

正文
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;保存好后, 用 cmd 进入 myblog 目录, 执行 &lt;strong&gt;make html&lt;/strong&gt;, 过一会, output 目录下就生成了博客文件, 再执行 &lt;strong&gt;make serve&lt;/strong&gt;, 然后打开浏览器, 访问: &lt;strong&gt;http://localhost:8000/&lt;/strong&gt;, 如果不出问题, 应该能够看到我们博客了…&lt;/p&gt;
&lt;p&gt;pelican 支持很多插件, 这里暂时用不上, 因为我只是用来当一个静态页面而已, 不过换个自己喜欢的主题还是蛮不错的~&lt;/p&gt;
&lt;h1 id="2"&gt;2. 更换主题&lt;/h1&gt;
&lt;p&gt;从 &lt;strong&gt;https://github.com/getpelican/pelican-themes.git&lt;/strong&gt; 上把项目 clone 下来, 解压文件夹到 myblog 目录下(与 output 同级), 然后在 &lt;strong&gt;pelicanconf.py&lt;/strong&gt; 文件里设置要使用的主题: &lt;strong&gt;THEME = ‘pelican-themes/xxx’&lt;/strong&gt;, 我这里使用的是 THEME = ‘pelican-themes/zurb-F5-basic’.&lt;/p&gt;
&lt;p&gt;zurb-F5-basic 主题现在有个 Bug, 那就是第一篇博文竟然是全文显示, 这特么简直就是巨坑… 不过还好, 机智的我找到了解决方案, 依次打开文件 &lt;strong&gt;myblog/pelican-themes/zurb-F5-basic/templates/index.html&lt;/strong&gt;, 更改如下:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;{% extends "base.html" %}
{% block content_title %}{% endblock %}
{% block content %}
{% if articles %}
    {% for article in articles_page.object_list %}
        &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;article&lt;/span&gt;&amp;gt;
            &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;a&lt;/span&gt; &lt;span style="color: #658b00"&gt;href&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"{{ SITEURL }}/{{ article.url }}"&lt;/span&gt;&amp;gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;h3&lt;/span&gt; &lt;span style="color: #658b00"&gt;class&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"article-title"&lt;/span&gt;&amp;gt;{{ article.title }}&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;h3&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;a&lt;/span&gt;&amp;gt;
            {% include 'article_infos.html' %}{{ article.summary }}{% include 'article_infos_bottom.html' %}{% include 'comments.html' %}
            &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;a&lt;/span&gt; &lt;span style="color: #658b00"&gt;class&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"button radius secondary small right"&lt;/span&gt; &lt;span style="color: #658b00"&gt;href&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"{{ SITEURL }}/{{ article.url }}"&lt;/span&gt;&amp;gt;Read More&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;a&lt;/span&gt;&amp;gt;
            &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;hr&lt;/span&gt;  &lt;span style="color: #658b00"&gt;class&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"gradient"&lt;/span&gt;/&amp;gt;
        &amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;article&lt;/span&gt;&amp;gt;

        {% if loop.last %}
            &lt;span style="color: #228B22"&gt;&amp;lt;!-- /#posts-list --&amp;gt;&lt;/span&gt;
            {% if loop.last and (articles_page.has_previous() or not articles_page.has_previous() and loop.length &amp;gt; 1) %}
                {% include 'pagination.html' %}
            {% endif %}
        {% endif %}
    {% endfor %}

{% else %}

    &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;h3&lt;/span&gt;&amp;gt;Pages&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;h3&lt;/span&gt;&amp;gt;
    {% for page in PAGES %}
        &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;li&lt;/span&gt;&amp;gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;a&lt;/span&gt; &lt;span style="color: #658b00"&gt;href&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"{{ SITEURL }}/{{ page.url }}"&lt;/span&gt;&amp;gt;{{ page.title }}&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;a&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;li&lt;/span&gt;&amp;gt;
    {% endfor %}

{% endif %}
{% endblock content %}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于 &lt;code&gt;pelicanconf.py&lt;/code&gt;, 除了 THEME 外, 还有一些有用的设置:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;AUTHOR = &lt;span style="color: #CD5555"&gt;u'hanxiao'&lt;/span&gt;
SITENAME = &lt;span style="color: #CD5555"&gt;u'Small Cpp'&lt;/span&gt;
SITEURL = &lt;span style="color: #CD5555"&gt;'http://uldaman.github.com'&lt;/span&gt;

THEME = &lt;span style="color: #CD5555"&gt;'pelican-themes/zurb-F5-basic'&lt;/span&gt;
USE_FOLDER_AS_CATEGORY = &lt;span style="color: #8B008B; font-weight: bold"&gt;True&lt;/span&gt; &lt;span style="color: #228B22"&gt;# 这个可以让 pelican 根据 content 里的文件夹结构自动生成文章分类&lt;/span&gt;
DELETE_OUTPUT_DIRECTORY = &lt;span style="color: #8B008B; font-weight: bold"&gt;True&lt;/span&gt; &lt;span style="color: #228B22"&gt;# 编译之前删除 output 目录，这样保证 output 下生成的内容干净&lt;/span&gt;
SUMMARY_MAX_LENGTH = &lt;span style="color: #B452CD"&gt;30&lt;/span&gt; &lt;span style="color: #228B22"&gt;# 文章摘要最大字数&lt;/span&gt;

&lt;span style="color: #228B22"&gt;# 设置 MD 语法高亮&lt;/span&gt;
MD_EXTENSIONS = [
  &lt;span style="color: #CD5555"&gt;"extra"&lt;/span&gt;,
  &lt;span style="color: #CD5555"&gt;"toc"&lt;/span&gt;,
  &lt;span style="color: #CD5555"&gt;"headerid"&lt;/span&gt;,
  &lt;span style="color: #CD5555"&gt;"meta"&lt;/span&gt;,
  &lt;span style="color: #CD5555"&gt;"sane_lists"&lt;/span&gt;,
  &lt;span style="color: #CD5555"&gt;"smarty"&lt;/span&gt;,
  &lt;span style="color: #CD5555"&gt;"wikilinks"&lt;/span&gt;,
  &lt;span style="color: #CD5555"&gt;"admonition"&lt;/span&gt;,
  &lt;span style="color: #CD5555"&gt;"codehilite(guess_lang=False,pygments_style=monokai,noclasses=True)"&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;, MD 语法高亮的设置需要 python 包 &lt;code&gt;pygments&lt;/code&gt; 支持, 所以, 先安装 &lt;code&gt;pygments&lt;/code&gt; 吧.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;pygments_style 可以在 &lt;a href="http://pygments.org/demo/?lang=cpp&amp;amp;sort="&gt;http://pygments.org/demo/&lt;/a&gt; 进行调试&lt;br/&gt;
Reference:&lt;br/&gt;
&lt;a href="http://crunk.io/post/introduction-to-pelican/"&gt;Introduction to Pelican&lt;/a&gt;&lt;br/&gt;
&lt;a href="http://fatsoon.com/2014/07/26/2014-07-26-use-highlite-in-django/"&gt;Django 中使用 markdown 和代码高亮&lt;/a&gt;&lt;br/&gt;
&lt;a href="https://pythonhosted.org/Markdown/extensions/code_hilite.html"&gt;Python Markdown v2.6.6 documentation » CodeHilite Extension&lt;/a&gt;&lt;br/&gt;
&lt;a href="https://packagecontrol.io/packages/Markdown%20Preview"&gt;Markdown Preview&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后再重新用 cmd 进入 myblog 目录, 执行 &lt;strong&gt;make html&lt;/strong&gt; + &lt;strong&gt;make serve&lt;/strong&gt;, 访问: &lt;a href="http://localhost:8000/"&gt;http://localhost:8000/&lt;/a&gt;, 看看我们的博客主题是不是已经发生变化啦~~&lt;/p&gt;
&lt;h2 id="21"&gt;2.1 添加评论系统&lt;/h2&gt;
&lt;p&gt;pelican 原生支持 DISQUS 评论系统, 然而坑爹的 GFW . . .&lt;/p&gt;
&lt;p&gt;所以我改用了国内的&lt;a href="http://duoshuo.com/"&gt;多说评论系统&lt;/a&gt; (来必力也是一个不错的评论系统, 可以去试试), 首先去&lt;a href="http://duoshuo.com/"&gt;多说官网&lt;/a&gt;注册一个账号, 然后为我们的 blog 添加一个站点.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i66.tinypic.com/t0p00h.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;添加好后, 在管理页面会看到如下信息:&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i67.tinypic.com/2cg2dxy.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;打开 pelican 主题目录下的 &lt;code&gt;article.html&lt;/code&gt; 文件, 在 &lt;code&gt;&amp;lt;/article&amp;gt;&lt;/code&gt; 上面添加上图中的代码, 我这里改成了:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;{% extends "base.html" %}
{% block title %}{{ article.title|striptags }}{% endblock %}
{% block content %}
&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;article&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;header&lt;/span&gt;&amp;gt;
        &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;h3&lt;/span&gt; &lt;span style="color: #658b00"&gt;class&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"article-title"&lt;/span&gt;&amp;gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;a&lt;/span&gt; &lt;span style="color: #658b00"&gt;href&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"{{ SITEURL }}/{{ article.url }}"&lt;/span&gt; &lt;span style="color: #658b00"&gt;rel&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"bookmark"&lt;/span&gt;
        &lt;span style="color: #658b00"&gt;title&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"Permalink to {{ article.title|striptags }}"&lt;/span&gt;&amp;gt;{{ article.title }}&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;a&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;h3&lt;/span&gt;&amp;gt;
        {% include 'twitter.html' %}
    &amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;header&lt;/span&gt;&amp;gt;

    {% include 'article_infos.html' %}
    {{ article.content }}
    {% include 'article_infos_bottom.html' %}

&lt;span style="color: #228B22"&gt;&amp;lt;!--     {% if DISQUS_SITENAME and SITEURL and article.status != "draft" %}&lt;/span&gt;
&lt;span style="color: #228B22"&gt;    &amp;lt;h4&amp;gt;Comments&amp;lt;/h4&amp;gt;&lt;/span&gt;
&lt;span style="color: #228B22"&gt;    {% include 'disqus_script.html' %}&lt;/span&gt;
&lt;span style="color: #228B22"&gt;    {% endif %} --&amp;gt;&lt;/span&gt;

    &lt;span style="color: #228B22"&gt;&amp;lt;!-- 多说评论框 start --&amp;gt;&lt;/span&gt;
    &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;h4&lt;/span&gt;&amp;gt;Comments !&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;h4&lt;/span&gt;&amp;gt;
    &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt; &lt;span style="color: #658b00"&gt;class&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"ds-thread"&lt;/span&gt; &lt;span style="color: #658b00"&gt;data-thread-key&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"{{ article.slug }}"&lt;/span&gt; &lt;span style="color: #658b00"&gt;data-title&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"{{ article.title }}"&lt;/span&gt; &lt;span style="color: #658b00"&gt;data-url&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"{{ SITEURL }}/{{ article.url }}"&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;div&lt;/span&gt;&amp;gt;
    &lt;span style="color: #228B22"&gt;&amp;lt;!-- 多说评论框 end --&amp;gt;&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;&amp;lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&amp;gt;&lt;/span&gt;
    &amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;script&lt;/span&gt; &lt;span style="color: #658b00"&gt;type&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"text/javascript"&lt;/span&gt;&amp;gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;var&lt;/span&gt; duoshuoQuery = {short_name:&lt;span style="color: #CD5555"&gt;"smallcpp"&lt;/span&gt;};
            (&lt;span style="color: #8B008B; font-weight: bold"&gt;function&lt;/span&gt;() {
                &lt;span style="color: #8B008B; font-weight: bold"&gt;var&lt;/span&gt; ds = &lt;span style="color: #658b00"&gt;document&lt;/span&gt;.createElement(&lt;span style="color: #CD5555"&gt;'script'&lt;/span&gt;);
                ds.type = &lt;span style="color: #CD5555"&gt;'text/javascript'&lt;/span&gt;;ds.&lt;span style="color: #8B008B; font-weight: bold"&gt;async&lt;/span&gt; = &lt;span style="color: #8B008B; font-weight: bold"&gt;true&lt;/span&gt;;
                ds.src = (&lt;span style="color: #658b00"&gt;document&lt;/span&gt;.location.protocol == &lt;span style="color: #CD5555"&gt;'https:'&lt;/span&gt; ? &lt;span style="color: #CD5555"&gt;'https:'&lt;/span&gt; : &lt;span style="color: #CD5555"&gt;'http:'&lt;/span&gt;) + &lt;span style="color: #CD5555"&gt;'//static.duoshuo.com/embed.js'&lt;/span&gt;;
                ds.charset = &lt;span style="color: #CD5555"&gt;'UTF-8'&lt;/span&gt;;
                (&lt;span style="color: #658b00"&gt;document&lt;/span&gt;.getElementsByTagName(&lt;span style="color: #CD5555"&gt;'head'&lt;/span&gt;)[&lt;span style="color: #B452CD"&gt;0&lt;/span&gt;] || &lt;span style="color: #658b00"&gt;document&lt;/span&gt;.getElementsByTagName(&lt;span style="color: #CD5555"&gt;'body'&lt;/span&gt;)[&lt;span style="color: #B452CD"&gt;0&lt;/span&gt;]).appendChild(ds);
            })();
    &amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;script&lt;/span&gt;&amp;gt;
    &lt;span style="color: #228B22"&gt;&amp;lt;!-- 多说公共JS代码 end --&amp;gt;&lt;/span&gt;
&amp;lt;/&lt;span style="color: #8B008B; font-weight: bold"&gt;article&lt;/span&gt;&amp;gt;
{% endblock %}
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="3-gfm"&gt;3. 解析 GFM&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;使用 GFM 后, 有些 markdown 样式渲染不出来, 不再推荐使用~ 仅了解下就好.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;GFM 即 Github Flavored Mardown, 它是现在比较受欢迎的一种 Markdown 风格, 但 pygments 本身并不支持 (py-markdown 的语法高亮通过 pygments 来支持), 要通过第三方扩展来实现.&lt;/p&gt;
&lt;p&gt;首先, 要安装 pymdown  第三方扩展 &lt;code&gt;pip install pymdown-extensions&lt;/code&gt;, 然后把 &lt;code&gt;pelicanconf.py&lt;/code&gt; 文件中 &lt;code&gt;MD_EXTENSIONS&lt;/code&gt; 的 &lt;strong&gt;extra&lt;/strong&gt; 替换成 &lt;strong&gt;pymdownx.github&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Pymdown Extensions Documentation 对 &lt;strong&gt;pymdownx.github&lt;/strong&gt; 说明如下:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;For code highlighting, you will also need to load the markdown.extensions.codehilite extension yourself as well with guess_lang=False and your preferred Pygments style (if available or use some other JavaScript highlighter). Though there is no Github style included with this extension, you are most likely able to find a suitable theme online by searching. I do have older Github styles found at the pymdown-styles repo; it contains the original Pygments Github style (github) and the Github 2014 style (github2014) which Github used before they ditched Pygments for their own in-house highlighter.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;简单的说, 就是 &lt;strong&gt;pymdownx.github&lt;/strong&gt; 提供了一些功能用来模仿 Github, 但不是全部, 如果想要使用 Github 的代码高亮, 你需要设置 &lt;code&gt;markdown.extensions.codehilite&lt;/code&gt; 的 &lt;code&gt;guess_lang=False&lt;/code&gt;, 并且引用一个 &lt;code&gt;Pygments style&lt;/code&gt; 文件, 虽然该扩展本身并不包含 Github style, 但是你可以去找....然后作者也给了一个 &lt;a href="https://github.com/uldaman/pymdown-styles"&gt;pymdown-styles repo&lt;/a&gt; 供使用 (我将它 Fork 回自己的仓库, 做了点更改, 让它更像 Github 的高亮风格).&lt;/p&gt;
&lt;p&gt;使用方法比较简单, clone 项目到本地, 执行 &lt;code&gt;python setup.py install&lt;/code&gt;, 然后修改 &lt;code&gt;pelicanconf.py&lt;/code&gt; 文件中 &lt;code&gt;MD_EXTENSIONS&lt;/code&gt; 的 &lt;strong&gt;codehilite&lt;/strong&gt;, 最终的 &lt;strong&gt;MD_EXTENSIONS&lt;/strong&gt; 如下:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;MD_EXTENSIONS = [
  &lt;span style="color: #CD5555"&gt;"pymdownx.github(no_nl2br=True)"&lt;/span&gt;,
  &lt;span style="color: #CD5555"&gt;"toc"&lt;/span&gt;,
  &lt;span style="color: #CD5555"&gt;"headerid"&lt;/span&gt;,
  &lt;span style="color: #CD5555"&gt;"meta"&lt;/span&gt;,
  &lt;span style="color: #CD5555"&gt;"sane_lists"&lt;/span&gt;,
  &lt;span style="color: #CD5555"&gt;"smarty"&lt;/span&gt;,
  &lt;span style="color: #CD5555"&gt;"wikilinks"&lt;/span&gt;,
  &lt;span style="color: #CD5555"&gt;"admonition"&lt;/span&gt;,
  &lt;span style="color: #CD5555"&gt;"codehilite(guess_lang=False,pygments_style=github2014,noclasses=True)"&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;References:&lt;br/&gt;
&lt;a href="https://pythonhosted.org/Markdown/extensions/"&gt;Python Markdown Documentation&lt;/a&gt;&lt;br/&gt;
&lt;a href="http://facelessuser.github.io/pymdown-extensions/extensions/github/"&gt;Pymdown Extensions Documentation For Github&lt;/a&gt;&lt;br/&gt;
&lt;a href="https://packagecontrol.io/packages/Markdown%20Preview"&gt;Markdown Preview&lt;/a&gt;&lt;/p&gt;
&lt;h1 id="4"&gt;4. 添加网站图标&lt;/h1&gt;
&lt;p&gt;不同的 pelican 主题添加方法不一样, 我这里用的是 &lt;code&gt;zurb-F5-basic&lt;/code&gt; 主题, 就以它为例说明下.&lt;/p&gt;
&lt;p&gt;首先准备好 &lt;code&gt;ico&lt;/code&gt; 文件如 &lt;code&gt;favicon.ico&lt;/code&gt;, 放到主题的静态图标目录下 (&lt;code&gt;~\pelican-themes\zurb-F5-basic\static\images\icons&lt;/code&gt;), 然后打开文件 &lt;strong&gt;~/pelican-themes/zurb-F5-basic/templates/base.html&lt;/strong&gt;, 在 &lt;code&gt;head&lt;/code&gt; 标签中添加一行:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;&lt;span style="color: #8B008B; font-weight: bold"&gt;link&lt;/span&gt; &lt;span style="color: #658b00"&gt;rel&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"shortcut icon"&lt;/span&gt; &lt;span style="color: #658b00"&gt;type&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"image/x-icon"&lt;/span&gt; &lt;span style="color: #658b00"&gt;href&lt;/span&gt;=&lt;span style="color: #CD5555"&gt;"{{ SITEURL }}/theme/images/favicon.ico"&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="5-wordpress"&gt;5. 迁移 wordpress&lt;/h1&gt;
&lt;p&gt;环境搭建好后, 就是把我们 wordpress(后面简称 wp) 的内容迁移过来啦.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步&lt;/strong&gt;, 进入 wp 后台, 工具-&amp;gt;导出, 然后把 ‘全部’ 和 ‘文章’ 这两个都导出一份(其实我们导出文章就可以了, 把 ‘全部’ 也都导出是为了以后可能还有用处, 以防万一嘛), 然后进入我们的主机管理系统(这个我们购买的主机商那就有提供), 把 mysql 数据也导出一份, 然后进入主机空间, 把整个空间都 dump 一份.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步&lt;/strong&gt;, 到 https://github.com/thomasf/exitwp.git &lt;strong&gt;clone&lt;/strong&gt; 项目到本地, 把刚从 wp 导出的 ‘文章’ xml 放到 exitwp 目录下的 &lt;strong&gt;wordpress-xml&lt;/strong&gt; 子目录里, 然后 cmd 进入 exitwp 目录, 执行 &lt;strong&gt;python exitwp.py&lt;/strong&gt;, 稍等片刻, 我们的文章全部都转成 *.md 格式啦(路径: &lt;strong&gt;exitwp/build/jekyll/原 wp 路径/_posts&lt;/strong&gt;).&lt;/p&gt;
&lt;p&gt;不过, 这里有个坑, 这个工具导出的 md 文件, 是按文件内容里的 slug 项来命名的, 特么 py 对中文的处理不大好, 导致 md 的文件名都有问题, 于是写了个脚本用来转换用户名.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #CD5555"&gt;'''&lt;/span&gt;
&lt;span style="color: #CD5555"&gt;当使用 exitwp 生成 md 文件时, 文件名会乱码, 使用该脚本可以修复&lt;/span&gt;

&lt;span style="color: #CD5555"&gt;'''&lt;/span&gt;
&lt;span style="color: #228B22"&gt;# -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;re&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;urllib&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;os&lt;/span&gt;

files=os.listdir(&lt;span style="color: #CD5555"&gt;'C:/Users/Administrator/Desktop/exitwp-master/build/jekyll/www.smallcpp.cn/_posts'&lt;/span&gt;) &lt;span style="color: #228B22"&gt;# 路径自己改&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;for&lt;/span&gt; file &lt;span style="color: #8B008B"&gt;in&lt;/span&gt; files:
    &lt;span style="color: #8B008B; font-weight: bold"&gt;if&lt;/span&gt; file != &lt;span style="color: #CD5555"&gt;u'change_md_file_name.py'&lt;/span&gt;:
        file_object = &lt;span style="color: #658b00"&gt;open&lt;/span&gt;(file)
        all_the_text = file_object.read( )
        header = re.search(&lt;span style="color: #CD5555"&gt;'''---(.*?)---'''&lt;/span&gt;, all_the_text, re.S)
        slug = re.search(&lt;span style="color: #CD5555"&gt;'''slug: (.*?)title'''&lt;/span&gt;, header.group(&lt;span style="color: #B452CD"&gt;1&lt;/span&gt;), re.S)
        new = urllib.unquote(slug.group(&lt;span style="color: #B452CD"&gt;1&lt;/span&gt;)).replace(&lt;span style="color: #CD5555"&gt;'\n'&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;''&lt;/span&gt;).decode(&lt;span style="color: #CD5555"&gt;'utf-8'&lt;/span&gt;)
        file_object.close()

        os.renames(file, new + &lt;span style="color: #CD5555"&gt;'.markdown'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;第三步&lt;/strong&gt;, 有了 md 文件了, 剩下的还不好办吗, 全部拷贝到 myblog/content 目录下, 然而问题又来了, 一堆 md 文件堆在一个文件夹下显然是很乱的, 而且也无法利用 &lt;strong&gt;USE_FOLDER_AS_CATEGORY = True # 这个可以让 pelican 根据 content 里的文件夹结构自动生成文章分类&lt;/strong&gt; 这条设置了, 所以又写了个脚本把文章按类别分类(在运行脚本之前要手动建好文件夹).&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;# -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span style="color: #CD5555"&gt;'''&lt;/span&gt;
&lt;span style="color: #CD5555"&gt;读取文件中的 Category, 然后将文件放到 Category 指定的文件夹&lt;/span&gt;
&lt;span style="color: #CD5555"&gt;'''&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;re&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;urllib&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;os&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;shutil&lt;/span&gt;


files=os.listdir(&lt;span style="color: #CD5555"&gt;'C:/Users/Administrator/Desktop/content'&lt;/span&gt;)
&lt;span style="color: #8B008B; font-weight: bold"&gt;for&lt;/span&gt; file &lt;span style="color: #8B008B"&gt;in&lt;/span&gt; files:
    file = file.decode(&lt;span style="color: #CD5555"&gt;'gbk'&lt;/span&gt;).encode(&lt;span style="color: #CD5555"&gt;'utf-8'&lt;/span&gt;)
    &lt;span style="color: #8B008B; font-weight: bold"&gt;if&lt;/span&gt; file != &lt;span style="color: #CD5555"&gt;'sss.py'&lt;/span&gt;:
        file_object = &lt;span style="color: #658b00"&gt;open&lt;/span&gt;(file.decode(&lt;span style="color: #CD5555"&gt;'utf-8'&lt;/span&gt;).encode(&lt;span style="color: #CD5555"&gt;'gbk'&lt;/span&gt;))
        lnum = &lt;span style="color: #B452CD"&gt;0&lt;/span&gt;
        &lt;span style="color: #8B008B; font-weight: bold"&gt;for&lt;/span&gt; line &lt;span style="color: #8B008B"&gt;in&lt;/span&gt; file_object:
                lnum += &lt;span style="color: #B452CD"&gt;1&lt;/span&gt;
                &lt;span style="color: #8B008B; font-weight: bold"&gt;if&lt;/span&gt; lnum == &lt;span style="color: #B452CD"&gt;5&lt;/span&gt;:
                    result = re.search(&lt;span style="color: #CD5555"&gt;'''Category: (.*?)\n'''&lt;/span&gt;, line, re.S)
                    tar = &lt;span style="color: #CD5555"&gt;'C:/Users/Administrator/Desktop/field/'&lt;/span&gt; + result.group(&lt;span style="color: #B452CD"&gt;1&lt;/span&gt;)
                    shutil.copy(file.decode(&lt;span style="color: #CD5555"&gt;'utf-8'&lt;/span&gt;).encode(&lt;span style="color: #CD5555"&gt;'gbk'&lt;/span&gt;),  tar.decode(&lt;span style="color: #CD5555"&gt;'utf-8'&lt;/span&gt;).encode(&lt;span style="color: #CD5555"&gt;'gbk'&lt;/span&gt;))
                    &lt;span style="color: #8B008B; font-weight: bold"&gt;break&lt;/span&gt;
        file_object.close()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;第四步&lt;/strong&gt;, md 按类别整理好后, 就可以用 &lt;strong&gt;make html&lt;/strong&gt; 来生成 blog 啦, 不过遗憾的是特么生成的文件名依然是乱码, 于是又写了个脚本修复文件名…(应该可以改源码的, 暂时没空看源码, 先用这个脚本过度下).&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;# -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span style="color: #CD5555"&gt;'''&lt;/span&gt;
&lt;span style="color: #CD5555"&gt;当使用 make html 生成 html 文件, 文件名乱码, 使用该脚本可以修复&lt;/span&gt;
&lt;span style="color: #CD5555"&gt;'''&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;re&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;urllib&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;import&lt;/span&gt; &lt;span style="color: #008b45; text-decoration: underline"&gt;os&lt;/span&gt;


files=os.listdir(&lt;span style="color: #CD5555"&gt;'C:/Users/Administrator/Desktop/123'&lt;/span&gt;)
&lt;span style="color: #8B008B; font-weight: bold"&gt;for&lt;/span&gt; file &lt;span style="color: #8B008B"&gt;in&lt;/span&gt; files:
    &lt;span style="color: #8B008B; font-weight: bold"&gt;if&lt;/span&gt; file != &lt;span style="color: #CD5555"&gt;'change_hml_file_name.py'&lt;/span&gt;:
        new = urllib.unquote(file).replace(&lt;span style="color: #CD5555"&gt;'\r'&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;''&lt;/span&gt;).replace(&lt;span style="color: #CD5555"&gt;'\n'&lt;/span&gt;, &lt;span style="color: #CD5555"&gt;''&lt;/span&gt;)
        &lt;span style="color: #658b00"&gt;print&lt;/span&gt; new
        os.renames(file, new.decode(&lt;span style="color: #CD5555"&gt;'utf-8'&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好了, 现在我们的 wp 已经迁移到了本地博客系统, 运行 &lt;strong&gt;make serve&lt;/strong&gt; 看看是不是成功了…&lt;/p&gt;
&lt;h1 id="6-github"&gt;6. 发布到 Github&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;更新: 关于发布到 Github 还是有些东西要说的, 见我另一篇笔记: &lt;a href="http://www.smallcpp.cn/qian-yi-github-project-page.html"&gt;迁移 Github Project Page&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个其实没啥好讲的了, 我是用的 github for windows 工具来管理 github, 每次 &lt;strong&gt;make html&lt;/strong&gt; 后, 把 output 下的文件同步到 github 上 page 项目的主干下就行了…&lt;/p&gt;
&lt;p&gt;再来说说顶级域名吧, 首先, 在 github 的 page 项目的目录下, 新建一个 &lt;strong&gt;CNAME&lt;/strong&gt; 文件, 里面写上你的顶级域名地址, 例如我的: &lt;strong&gt;www.smallcpp.cn&lt;/strong&gt;, 然后到域名供应商那里 添加 or 修改 下解析设置, 我用的是 dnspod:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;@      CNAME        yourname.github.com
www    CNAME        yourname.github.com
&lt;/pre&gt;&lt;/div&gt;</content><category term="杂项"></category></entry><entry><title>正则表达式</title><link href="http://www.smallcpp.cn/zheng-ze-biao-da-shi.html" rel="alternate"></link><published>2015-08-21T17:19:00+08:00</published><updated>2015-08-21T17:19:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2015-08-21:/zheng-ze-biao-da-shi.html</id><summary type="html">
&lt;h1 id="_1"&gt;正则基础&lt;/h1&gt;
&lt;h2 id="_2"&gt;常用符号&lt;/h2&gt;
&lt;p&gt;比较常用的是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;?&lt;/code&gt;, 代表前面的字符能出现 0 次或 1 次, 比如 &lt;code&gt;colou?r&lt;/code&gt; 表示在目标串中找到 &lt;code&gt;color&lt;/code&gt; 或 &lt;code&gt;colour&lt;/code&gt; 并返回, 即 &lt;code&gt;u&lt;/code&gt; 可以出现 0 次或 1 次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt;, 代表前面的字符能出现 0 次或无限次, 比如 &lt;code&gt;colou*r&lt;/code&gt; 表示在目标串中找到 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">
&lt;h1 id="_1"&gt;正则基础&lt;/h1&gt;
&lt;h2 id="_2"&gt;常用符号&lt;/h2&gt;
&lt;p&gt;比较常用的是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;?&lt;/code&gt;, 代表前面的字符能出现 0 次或 1 次, 比如 &lt;code&gt;colou?r&lt;/code&gt; 表示在目标串中找到 &lt;code&gt;color&lt;/code&gt; 或 &lt;code&gt;colour&lt;/code&gt; 并返回, 即 &lt;code&gt;u&lt;/code&gt; 可以出现 0 次或 1 次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt;, 代表前面的字符能出现 0 次或无限次, 比如 &lt;code&gt;colou*r&lt;/code&gt; 表示在目标串中找到 &lt;code&gt;color&lt;/code&gt;、 &lt;code&gt;colour&lt;/code&gt;、 &lt;code&gt;colouur&lt;/code&gt;、 &lt;code&gt;colouuur&lt;/code&gt; 等并返回, 即 &lt;code&gt;u&lt;/code&gt; 可以出现 0 次或无限次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt;, 代表前面的字符能出现 1 次或无限次, 比如 &lt;code&gt;colou+r&lt;/code&gt; 表示在目标串中找到 &lt;code&gt;colour&lt;/code&gt;、 &lt;code&gt;colouur&lt;/code&gt;、 &lt;code&gt;colouuur&lt;/code&gt; 等并返回, 即 &lt;code&gt;u&lt;/code&gt; 可以出现 1 次或无限次&lt;/li&gt;
&lt;li&gt;&lt;code&gt;()&lt;/code&gt;, 代表以正则表达式匹配到目标后只返回括起来的内容, 比如 &lt;code&gt;(colou*)r&lt;/code&gt;, 其匹配规则与 &lt;code&gt;colou*r&lt;/code&gt; 一致, 但只返回 &lt;code&gt;colo&lt;/code&gt;、 &lt;code&gt;colou&lt;/code&gt;、 &lt;code&gt;colouu&lt;/code&gt; 等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里准备了一张表(来自小甲鱼), 列出了正则表达式中常用的符号, 有需要注意的地方将在表下方说明.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i61.tinypic.com/5jtavs.jpg"/&gt;&lt;/p&gt;
&lt;h2 id="_3"&gt;贪婪? 非贪婪?&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;?&lt;/code&gt; 还有个作用是让匹配模式变为&lt;strong&gt;非贪婪匹配&lt;/strong&gt;. 什么是贪婪? 非贪婪?&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;String str = "abcaxc";
Patter p = "ab*c";
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;贪婪匹配: 趋向于最大长度匹配. 如上面使用模式 p 匹配字符串 str, 结果就是匹配到: abcaxc (ab*c).&lt;/li&gt;
&lt;li&gt;非贪婪匹配: 趋向于最长度匹配. 如上面使用模式 p 匹配字符串 str, 结果就是匹配到: abc (ab*c).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;默认情况下, &lt;code&gt;*&lt;/code&gt;、 &lt;code&gt;+&lt;/code&gt;、 &lt;code&gt;?&lt;/code&gt; 都是贪婪匹配, 在后面加上 &lt;code&gt;?&lt;/code&gt; 后, 即: &lt;code&gt;*?&lt;/code&gt;、 &lt;code&gt;+?&lt;/code&gt;、 &lt;code&gt;??&lt;/code&gt; 为非贪婪匹配.&lt;/p&gt;
&lt;h2 id="x42-x42-x42-x42"&gt;(x*?)、 (x*)、 x*?、 x*&lt;/h2&gt;
&lt;p&gt;表达式中的 &lt;code&gt;x&lt;/code&gt; 表示可以用 &lt;code&gt;.&lt;/code&gt;、 &lt;code&gt;\d&lt;/code&gt;、 &lt;code&gt;\w&lt;/code&gt; 等符号代替, 表示要匹配的内容:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(x*)&lt;/code&gt;, 表示贪婪式匹配 &lt;code&gt;x&lt;/code&gt;, 例如以&lt;code&gt;'(.*)r'&lt;/code&gt;能从&lt;code&gt;'colorcolorcolor'&lt;/code&gt;匹配到 &lt;code&gt;'colorcolorcolo'&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x*&lt;/code&gt;, 表示贪婪式匹配 &lt;code&gt;x&lt;/code&gt;, 例如以&lt;code&gt;'.*r'&lt;/code&gt;能从&lt;code&gt;'colorcolorcolor'&lt;/code&gt;匹配到 &lt;code&gt;'colorcolorcolor'&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(x*?)&lt;/code&gt;, 表示非贪婪式匹配 &lt;code&gt;x&lt;/code&gt;, 例如以&lt;code&gt;'(.*?)r'&lt;/code&gt;能从&lt;code&gt;'colorcolorcolor'&lt;/code&gt;匹配到 &lt;code&gt;['colo', 'colo', 'colo']&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x*?&lt;/code&gt;, 表示非贪婪式匹配 &lt;code&gt;x&lt;/code&gt;, 例如以&lt;code&gt;'.*?r'&lt;/code&gt;能从&lt;code&gt;'colorcolorcolor'&lt;/code&gt;匹配到 &lt;code&gt;['color', 'color', 'color']&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="ptyhon"&gt;ptyhon&lt;/h1&gt;
&lt;p&gt;python 中支持正则表达式的模块是 &lt;code&gt;re&lt;/code&gt;, 使用时 &lt;code&gt;import re&lt;/code&gt; 即可.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;search&lt;/code&gt;: 匹配第一个符合规律的内容, 返回一个正则表达式对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;match&lt;/code&gt;: 只有当开头就能匹配到模式的时候, 才返回一个正则表达式对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;findall&lt;/code&gt;: 匹配所有符合规律的内容, 返回包含结果的列表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sub&lt;/code&gt;: 替换符合规律的内容, 返回替换后的值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;search&lt;/code&gt; 与 &lt;code&gt;match&lt;/code&gt; 返回的是一个正则表达式对象, 需要通过 &lt;code&gt;group(index)&lt;/code&gt; 去获取内容, &lt;code&gt;index&lt;/code&gt; 与正则表达式中使用的 &lt;code&gt;( )&lt;/code&gt; 有关:&lt;/p&gt;
&lt;p&gt;index 指出获取正则表达式中第几个括号的返回结果, 0 (或者省略 index) 表示获取无括号的结果, 即 &lt;code&gt;(x*?)&lt;/code&gt; 和  &lt;code&gt;x*?&lt;/code&gt; 通过 &lt;code&gt;group(0)&lt;/code&gt; 返回的结果是一样的, 如果 index 大于括号的数量则会报错;&lt;/p&gt;
&lt;p&gt;比如 &lt;code&gt;r = re.match(r'(.*?)r(.*?)r', 'xxxryyyr')&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;r.group()&lt;/code&gt; 返回 &lt;code&gt;xxxryyyr&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;r.group(1)&lt;/code&gt; 返回 &lt;code&gt;xxx&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;r.group(2)&lt;/code&gt; 返回 &lt;code&gt;yyy&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="工具折腾"></category></entry><entry><title>短期充电计划</title><link href="http://www.smallcpp.cn/duan-qi-chong-dian-ji-hua.html" rel="alternate"></link><published>2015-03-13T13:25:00+08:00</published><updated>2015-03-13T13:25:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2015-03-13:/duan-qi-chong-dian-ji-hua.html</id><content type="html">&lt;p&gt;&lt;img alt="" src="http://i61.tinypic.com/x6lde9.jpg"&gt;&lt;/p&gt;</content><category term="杂项"></category></entry><entry><title>VS 注释模板</title><link href="http://www.smallcpp.cn/vs-zhu-shi-mo-ban.html" rel="alternate"></link><published>2015-03-12T14:20:00+08:00</published><updated>2015-03-12T14:20:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2015-03-12:/vs-zhu-shi-mo-ban.html</id><summary type="html">
&lt;h1 id="_1"&gt;函数注释&lt;/h1&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;/************************************************************************&lt;/span&gt;
&lt;span style="color: #228B22"&gt;◇  名称:      $SymbolName$&lt;/span&gt;
&lt;span style="color: #228B22"&gt;◇  参数:      $MethodArg$&lt;/span&gt;
&lt;span style="color: #228B22"&gt;◇  返回值:    $SymbolType$&lt;/span&gt;
&lt;span style="color: #228B22"&gt;◇  功能:      $end$&lt;/span&gt;
&lt;span style="color: #228B22"&gt;◇  说明:      $selected$&lt;/span&gt;
&lt;span style="color: #228B22"&gt;************************************************************************/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;简单版:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;// 参数: $MethodArg$&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// 说明: $end$&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置方法:&lt;/p&gt;
&lt;p&gt;“VAssistX” –&amp;gt; “Visual VAssistX Options” 然后选择 “Suggestions”, 再点击 “Edit VA Snippets”,&lt;/p&gt;
&lt;p&gt;在打开的窗口中选择  “Refactoring”  –&amp;gt; “Document …&lt;/p&gt;</summary><content type="html">
&lt;h1 id="_1"&gt;函数注释&lt;/h1&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;/************************************************************************&lt;/span&gt;
&lt;span style="color: #228B22"&gt;◇  名称:      $SymbolName$&lt;/span&gt;
&lt;span style="color: #228B22"&gt;◇  参数:      $MethodArg$&lt;/span&gt;
&lt;span style="color: #228B22"&gt;◇  返回值:    $SymbolType$&lt;/span&gt;
&lt;span style="color: #228B22"&gt;◇  功能:      $end$&lt;/span&gt;
&lt;span style="color: #228B22"&gt;◇  说明:      $selected$&lt;/span&gt;
&lt;span style="color: #228B22"&gt;************************************************************************/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;简单版:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;// 参数: $MethodArg$&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// 说明: $end$&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置方法:&lt;/p&gt;
&lt;p&gt;“VAssistX” –&amp;gt; “Visual VAssistX Options” 然后选择 “Suggestions”, 再点击 “Edit VA Snippets”,&lt;/p&gt;
&lt;p&gt;在打开的窗口中选择  “Refactoring”  –&amp;gt; “Document Method”&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i58.tinypic.com/nn18p5.jpg"/&gt;&lt;/p&gt;
&lt;h1 id="_2"&gt;类注释&lt;/h1&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;/*-----------------------------------------------------------------------&lt;/span&gt;
&lt;span style="color: #228B22"&gt;* 类名: $classname$&lt;/span&gt;
&lt;span style="color: #228B22"&gt;* 说明: $end$&lt;/span&gt;
&lt;span style="color: #228B22"&gt;-----------------------------------------------------------------------*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="_3"&gt;头文件注释&lt;/h1&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;/////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// 文件名:   $FILE_BASE$.$FILE_EXT$&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// 说明:     $end$&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// 创建时间: $DATE$ $HOUR_02$:$MINUTE$&lt;/span&gt;
&lt;span style="color: #228B22"&gt;//&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// 更新日志:&lt;/span&gt;
&lt;span style="color: #228B22"&gt;/////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置方法:&lt;/p&gt;
&lt;p&gt;“VAssistX” –&amp;gt; “Visual VAssistX Options” 然后选择 “Suggestions”, 再点击 “Edit VA Snippets”,&lt;/p&gt;
&lt;p&gt;在打开的窗口中选择  “With Title Only” , 然后选择 “Class Comment” 和 “Header Comment”, 并修改.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i57.tinypic.com/zn0d1h.jpg"/&gt;&lt;/p&gt;
&lt;h1 id="_4"&gt;头文件 类内部注释&lt;/h1&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;//-----------------------------------------------------------&lt;/span&gt;
&lt;span style="color: #228B22"&gt;//    $end$&lt;/span&gt;
&lt;span style="color: #228B22"&gt;//-----------------------------------------------------------&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id="_5"&gt;实现文件 外部注释&lt;/h1&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;/////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span style="color: #228B22"&gt;//    $end$&lt;/span&gt;
&lt;span style="color: #228B22"&gt;/////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置方法:&lt;/p&gt;
&lt;p&gt;“VAssistX” –&amp;gt; “Visual VAssistX Options” 然后选择 “Suggestions”, 再点击 “Edit VA Snippets”, 在打开的窗口中选择  “All by Title” , 然后添加.&lt;/p&gt;
&lt;h1 id="_6"&gt;样例&lt;/h1&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #228B22"&gt;/////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// 文件名:   FindWay.h&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// 说明:     实现寻路功能的策略模式&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// 创建时间: 2015/03/12 21:27&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// 更新日志:&lt;/span&gt;
&lt;span style="color: #228B22"&gt;//&lt;/span&gt;
&lt;span style="color: #228B22"&gt;// 2015/03/12 21:31 -- 添加 Straight 策略, 实现直线走路, 目标和角色之间不&lt;/span&gt;
&lt;span style="color: #228B22"&gt;//                     能有障碍.&lt;/span&gt;
&lt;span style="color: #228B22"&gt;/////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span style="color: #1e889b"&gt;#pragma once&lt;/span&gt;
&lt;span style="color: #1e889b"&gt;#include&lt;/span&gt; &lt;span style="color: #228B22"&gt;&amp;lt;Windows.h&amp;gt;&lt;/span&gt;&lt;span style="color: #1e889b"&gt;&lt;/span&gt;
&lt;span style="color: #1e889b"&gt;#include&lt;/span&gt; &lt;span style="color: #228B22"&gt;&amp;lt;memory&amp;gt;&lt;/span&gt;&lt;span style="color: #1e889b"&gt;&lt;/span&gt;

&lt;span style="color: #228B22"&gt;/*-----------------------------------------------------------------------&lt;/span&gt;
&lt;span style="color: #228B22"&gt; + 类名: CFindWay&lt;/span&gt;
&lt;span style="color: #228B22"&gt; + 说明: 寻路策略模式中的抽象类&lt;/span&gt;
&lt;span style="color: #228B22"&gt;-----------------------------------------------------------------------*/&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CFindWay&lt;/span&gt; {
&lt;span style="color: #8B008B; font-weight: bold"&gt;public&lt;/span&gt;:
    CFindWay();
    &lt;span style="color: #8B008B; font-weight: bold"&gt;virtual&lt;/span&gt; ~CFindWay();

    &lt;span style="color: #00688B; font-weight: bold"&gt;double&lt;/span&gt; m_dPointX;
    &lt;span style="color: #00688B; font-weight: bold"&gt;double&lt;/span&gt; m_dPointY;
    &lt;span style="color: #8B008B; font-weight: bold"&gt;virtual&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;void&lt;/span&gt; GotoPoint() = &lt;span style="color: #B452CD"&gt;0&lt;/span&gt;;
};

&lt;span style="color: #228B22"&gt;/*-----------------------------------------------------------------------&lt;/span&gt;
&lt;span style="color: #228B22"&gt; + 类名: CExplicit&lt;/span&gt;
&lt;span style="color: #228B22"&gt; + 说明: 具体寻路策略, 寻路模式&lt;/span&gt;
&lt;span style="color: #228B22"&gt; -----------------------------------------------------------------------*/&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CExplicit&lt;/span&gt; :
    &lt;span style="color: #8B008B; font-weight: bold"&gt;public&lt;/span&gt; CFindWay {
&lt;span style="color: #8B008B; font-weight: bold"&gt;public&lt;/span&gt;:
    CExplicit();
    ~CExplicit();

    &lt;span style="color: #00688B; font-weight: bold"&gt;void&lt;/span&gt; &lt;span style="color: #008b45"&gt;GotoPoint&lt;/span&gt;();
};

&lt;span style="color: #228B22"&gt;/*-----------------------------------------------------------------------&lt;/span&gt;
&lt;span style="color: #228B22"&gt; + 类名: Straight&lt;/span&gt;
&lt;span style="color: #228B22"&gt; + 说明: 具体寻路策略, 直线走路模式&lt;/span&gt;
&lt;span style="color: #228B22"&gt;-----------------------------------------------------------------------*/&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;Straight&lt;/span&gt; :
    &lt;span style="color: #8B008B; font-weight: bold"&gt;public&lt;/span&gt; CFindWay {
&lt;span style="color: #8B008B; font-weight: bold"&gt;public&lt;/span&gt;:
    Straight();
    ~Straight();

    &lt;span style="color: #00688B; font-weight: bold"&gt;void&lt;/span&gt; &lt;span style="color: #008b45"&gt;GotoPoint&lt;/span&gt;();
};

&lt;span style="color: #228B22"&gt;/*-----------------------------------------------------------------------&lt;/span&gt;
&lt;span style="color: #228B22"&gt; + 类名: CFwContext&lt;/span&gt;
&lt;span style="color: #228B22"&gt; + 说明: 策略模式的环境类, 维护一个 CFindWay 的引用.&lt;/span&gt;
&lt;span style="color: #228B22"&gt;-----------------------------------------------------------------------*/&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;CFwContext&lt;/span&gt; {
&lt;span style="color: #8B008B; font-weight: bold"&gt;public&lt;/span&gt;:
    CFwContext(std::shared_ptr&amp;lt;CFindWay&amp;gt; strategy);
    ~CFwContext();

    &lt;span style="color: #00688B; font-weight: bold"&gt;double&lt;/span&gt; m_dPointX;
    &lt;span style="color: #00688B; font-weight: bold"&gt;double&lt;/span&gt; m_dPointY;

    &lt;span style="color: #00688B; font-weight: bold"&gt;void&lt;/span&gt; &lt;span style="color: #008b45"&gt;GotoPoint&lt;/span&gt;();

&lt;span style="color: #8B008B; font-weight: bold"&gt;private&lt;/span&gt;:
    &lt;span style="color: #228B22"&gt;//-----------------------------------------------------------&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;//    通过 shared_ptr(智能指针) 维护一个 CFindWay 的引用.&lt;/span&gt;
    &lt;span style="color: #228B22"&gt;//-----------------------------------------------------------&lt;/span&gt;
    std::shared_ptr&amp;lt;CFindWay&amp;gt; m_strategy;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #1e889b"&gt;#include&lt;/span&gt; &lt;span style="color: #228B22"&gt;"FindWay.h"&lt;/span&gt;&lt;span style="color: #1e889b"&gt;&lt;/span&gt;

&lt;span style="color: #228B22"&gt;/////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span style="color: #228B22"&gt;//    CFindWay 基类&lt;/span&gt;
&lt;span style="color: #228B22"&gt;/////////////////////////////////////////////////////////////////////////&lt;/span&gt;
CFindWay::CFindWay() {
}

CFindWay::~CFindWay() {
}

&lt;span style="color: #228B22"&gt;/////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span style="color: #228B22"&gt;//    CExplicit 策略类&lt;/span&gt;
&lt;span style="color: #228B22"&gt;/////////////////////////////////////////////////////////////////////////&lt;/span&gt;
CExplicit::CExplicit() {
}

CExplicit::~CExplicit() {
}

&lt;span style="color: #228B22"&gt;// 说明: 寻路模式 寻路到指定的明文坐标点&lt;/span&gt;
&lt;span style="color: #00688B; font-weight: bold"&gt;void&lt;/span&gt; CExplicit::GotoPoint() {

}

&lt;span style="color: #228B22"&gt;/////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span style="color: #228B22"&gt;//    Straight 策略类&lt;/span&gt;
&lt;span style="color: #228B22"&gt;/////////////////////////////////////////////////////////////////////////&lt;/span&gt;
Straight::Straight() {
}

Straight::~Straight() {
}

&lt;span style="color: #228B22"&gt;// 说明: 直线模式 直线走到指定的明文坐标点, 不能有障碍.&lt;/span&gt;
&lt;span style="color: #00688B; font-weight: bold"&gt;void&lt;/span&gt; Straight::GotoPoint() {

}

&lt;span style="color: #228B22"&gt;/////////////////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span style="color: #228B22"&gt;//    CFwContext 环境类&lt;/span&gt;
&lt;span style="color: #228B22"&gt;/////////////////////////////////////////////////////////////////////////&lt;/span&gt;
CFwContext::CFwContext(std::shared_ptr&amp;lt;CFindWay&amp;gt; strategy) {
    m_strategy = strategy;
}

CFwContext::~CFwContext() {
}

&lt;span style="color: #00688B; font-weight: bold"&gt;void&lt;/span&gt; CFwContext::GotoPoint() {
    m_strategy-&amp;gt;m_dPointX = m_dPointX;
    m_strategy-&amp;gt;m_dPointY = m_dPointY;
    m_strategy-&amp;gt;GotoPoint();
}
&lt;/pre&gt;&lt;/div&gt;</content><category term="软件工程"></category></entry><entry><title>C++ 中的基类为什么要抽象析构函数</title><link href="http://www.smallcpp.cn/c-zhong-de-ji-lei-wei-shi-yao-yao-chou-xiang-xi-gou-han-shu.html" rel="alternate"></link><published>2015-03-12T11:40:00+08:00</published><updated>2015-03-12T11:40:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2015-03-12:/c-zhong-de-ji-lei-wei-shi-yao-yao-chou-xiang-xi-gou-han-shu.html</id><summary type="html">&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;在 Google 编程规范 中提到过: 用来做基类的类, 其析构函数应该为虚函数.&lt;/p&gt;
&lt;p&gt;那么为什么呢? 看下面这个例子:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #1e889b"&gt;#include&lt;/span&gt; &lt;span style="color: #228B22"&gt;&amp;quot;stdafx.h&amp;quot;&lt;/span&gt;&lt;span style="color: #1e889b"&gt;&lt;/span&gt;
&lt;span style="color: #1e889b"&gt;#include&lt;/span&gt; &lt;span style="color: #228B22"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style="color: #1e889b"&gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;using&lt;/span&gt; &lt;span style="color: #8B008B; font-weight: bold"&gt;namespace&lt;/span&gt; std;

&lt;span style="color: #8B008B; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;ClxBase&lt;/span&gt; {
&lt;span style="color: #8B008B; font-weight: bold"&gt;public&lt;/span&gt;:
    ClxBase() {};
    &lt;span style="color: #8B008B; font-weight: bold"&gt;virtual&lt;/span&gt; ~ClxBase() {};

    &lt;span style="color: #8B008B; font-weight: bold"&gt;virtual&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;void&lt;/span&gt; DoSomething() {
        cout &lt;span style="color: #CD5555"&gt;&amp;quot;Do something in class …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;在 Google 编程规范 中提到过: 用来做基类的类, 其析构函数应该为虚函数.&lt;/p&gt;
&lt;p&gt;那么为什么呢? 看下面这个例子:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #1e889b"&gt;#include&lt;/span&gt; &lt;span style="color: #228B22"&gt;&amp;quot;stdafx.h&amp;quot;&lt;/span&gt;&lt;span style="color: #1e889b"&gt;&lt;/span&gt;
&lt;span style="color: #1e889b"&gt;#include&lt;/span&gt; &lt;span style="color: #228B22"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style="color: #1e889b"&gt;&lt;/span&gt;
&lt;span style="color: #8B008B; font-weight: bold"&gt;using&lt;/span&gt; &lt;span style="color: #8B008B; font-weight: bold"&gt;namespace&lt;/span&gt; std;

&lt;span style="color: #8B008B; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;ClxBase&lt;/span&gt; {
&lt;span style="color: #8B008B; font-weight: bold"&gt;public&lt;/span&gt;:
    ClxBase() {};
    &lt;span style="color: #8B008B; font-weight: bold"&gt;virtual&lt;/span&gt; ~ClxBase() {};

    &lt;span style="color: #8B008B; font-weight: bold"&gt;virtual&lt;/span&gt; &lt;span style="color: #00688B; font-weight: bold"&gt;void&lt;/span&gt; DoSomething() {
        cout &lt;span style="color: #CD5555"&gt;&amp;quot;Do something in class ClxBase!&amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; endl;
    };
};

&lt;span style="color: #8B008B; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;ClxDerived&lt;/span&gt;
    : &lt;span style="color: #8B008B; font-weight: bold"&gt;public&lt;/span&gt; ClxBase {
&lt;span style="color: #8B008B; font-weight: bold"&gt;public&lt;/span&gt;:
    ClxDerived() {};
    ~ClxDerived() {
        cout &amp;lt;&amp;lt; &lt;span style="color: #CD5555"&gt;&amp;quot;Output from the destructor of class ClxDerived!&amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; endl;
    };

    &lt;span style="color: #00688B; font-weight: bold"&gt;void&lt;/span&gt; &lt;span style="color: #008b45"&gt;DoSomething&lt;/span&gt;() {
        cout &amp;lt;&amp;lt; &lt;span style="color: #CD5555"&gt;&amp;quot;Do something in class ClxDerived!&amp;quot;&lt;/span&gt; &amp;lt;&amp;lt; endl;
    };
};

&lt;span style="color: #00688B; font-weight: bold"&gt;int&lt;/span&gt; &lt;span style="color: #008b45"&gt;_tmain&lt;/span&gt;(&lt;span style="color: #00688B; font-weight: bold"&gt;int&lt;/span&gt; argc, _TCHAR* argv[]) {
    ClxBase *pTest = &lt;span style="color: #8B008B; font-weight: bold"&gt;new&lt;/span&gt; ClxDerived;
    pTest-&amp;gt;DoSomething();
    &lt;span style="color: #8B008B; font-weight: bold"&gt;delete&lt;/span&gt; pTest;

    system(&lt;span style="color: #CD5555"&gt;&amp;quot;PAUSE&amp;quot;&lt;/span&gt;);
    &lt;span style="color: #8B008B; font-weight: bold"&gt;return&lt;/span&gt; &lt;span style="color: #B452CD"&gt;0&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输出结果是:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;Do something in class ClxDerived!

Output from the destructor of class ClxDerived!
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个很简单, 非常好理解.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是,&lt;/strong&gt; 如果把类 ClxBase 析构函数前的 virtual 去掉, 那输出结果就是下面的样子了:&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;Do something in class ClxDerived!
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;也就是说类 ClxDerived 的析构函数根本没有被调用.&lt;/p&gt;
&lt;p&gt;为什么没有被调用, 这也很好理解, 因为 pTest 是 ClxBase 类型, 它的析构不是虚函数的话, 也就不能实现多态.&lt;/p&gt;
&lt;p&gt;一般情况下类的析构函数里面都是释放内存资源, 而析构函数不被调用的话就会造成内存泄漏.&lt;/p&gt;
&lt;p&gt;至于子类没有额外数据成员, 甚至父类也没有任何数据成员的特殊情况下, 析构函数的调用是否必要是语义争论, 从编程设计规范的角度看, 在含有虚函数的父类中, 定义虚析构函数绝对必要.&lt;/p&gt;
&lt;p&gt;当然, 并不是要把所有类的析构函数都写成虚函数. 因为当类里面有虚函数的时候, 编译器会给类添加一个虚函数表, 里面来存放虚函数指针, 这样就会增加类的存储空间.
所以, 只有当一个类被用来作为基类的时候, 才把析构函数写成虚函数.&lt;/p&gt;</content><category term="软件工程"></category></entry><entry><title>XMind (思维导图制作软件) 零基础教程</title><link href="http://www.smallcpp.cn/xmind-si-wei-dao-tu-zhi-zuo-ruan-jian-ling-ji-chu-jiao-cheng.html" rel="alternate"></link><published>2015-03-10T02:38:00+08:00</published><updated>2015-03-10T02:38:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2015-03-10:/xmind-si-wei-dao-tu-zhi-zuo-ruan-jian-ling-ji-chu-jiao-cheng.html</id><summary type="html">&lt;p&gt;工欲善其事, 必先利其器. 这里推荐一款很不错的思维导图编辑软件 – XMind, &lt;a href="http://www.dayanzai.me/xmind.html"&gt;下载传送门&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id="xmind"&gt;&lt;strong&gt;XMind界面简介&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;img alt="" src="http://i60.tinypic.com/e8anhz.jpg"&gt;&lt;/p&gt;
&lt;p&gt;XMind有五种不同类型的主题，如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i60.tinypic.com/2ms0m89.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中心主题：&lt;/strong&gt;每一张思维图有且仅有一个中心主题. 这个主题在新建图的时候会被自动创建并安排在图的中心的位置. 当保存这个新建图的时候, 中心主题的内容会默认设置为保存文件的名字.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分支主题：&lt;/strong&gt;中心主题周围发散的第一层主题即分支主题.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子主题：&lt;/strong&gt;分支主题和自由主题后面添加的主题都被称为子主题.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自由主题：&lt;/strong&gt;通常总还会有些关键的, 但是临时缺少合适位置的信息, 这些信息将以自由主题的形式存在. Xmind 中有种不同的自由主题, 用户可以按需选用.&lt;/p&gt;
&lt;h1 id="_1"&gt;&lt;strong&gt;添加主题&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;分支主题:&lt;/strong&gt; 点选 [中心主题] , 右键-插入-主题.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i58.tinypic.com/2agoh1x.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子主题 …&lt;/strong&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;工欲善其事, 必先利其器. 这里推荐一款很不错的思维导图编辑软件 – XMind, &lt;a href="http://www.dayanzai.me/xmind.html"&gt;下载传送门&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id="xmind"&gt;&lt;strong&gt;XMind界面简介&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;img alt="" src="http://i60.tinypic.com/e8anhz.jpg"&gt;&lt;/p&gt;
&lt;p&gt;XMind有五种不同类型的主题，如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i60.tinypic.com/2ms0m89.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中心主题：&lt;/strong&gt;每一张思维图有且仅有一个中心主题. 这个主题在新建图的时候会被自动创建并安排在图的中心的位置. 当保存这个新建图的时候, 中心主题的内容会默认设置为保存文件的名字.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分支主题：&lt;/strong&gt;中心主题周围发散的第一层主题即分支主题.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子主题：&lt;/strong&gt;分支主题和自由主题后面添加的主题都被称为子主题.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自由主题：&lt;/strong&gt;通常总还会有些关键的, 但是临时缺少合适位置的信息, 这些信息将以自由主题的形式存在. Xmind 中有种不同的自由主题, 用户可以按需选用.&lt;/p&gt;
&lt;h1 id="_1"&gt;&lt;strong&gt;添加主题&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;分支主题:&lt;/strong&gt; 点选 [中心主题] , 右键-插入-主题.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i58.tinypic.com/2agoh1x.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子主题:&lt;/strong&gt; 点选 [分支主题] 或 [自由主题] 或 [子主题], 右键-插入-子主题.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img alt="" src="http://i61.tinypic.com/bxxqp.jpg"&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自由主题:&lt;/strong&gt; 点选空白处, 右键-自由主题.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i58.tinypic.com/xbn1qc.jpg"&gt;&lt;/p&gt;
&lt;h1 id="_2"&gt;&lt;strong&gt;修改主题&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;修改主题文字:&lt;/strong&gt; 左键双击要更改的主题(或点选主题后按下空格).&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i58.tinypic.com/2lc1bom.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;修改主题风格:&lt;/strong&gt; 菜单栏-视图-风格, 打开风格选项卡.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i61.tinypic.com/107rhpu.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i58.tinypic.com/23vnyc4.jpg"&gt;&lt;/p&gt;
&lt;p&gt;双击风格选项卡就可以立即更换主题风格.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i59.tinypic.com/2zohzt2.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;修改主题属性:&lt;/strong&gt; 点选要修改的主题, 右键-属性, 打开属性选项卡.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i58.tinypic.com/287121d.jpg"&gt;&lt;/p&gt;
&lt;p&gt;在属性选项卡里可以修改主题如下属性:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结构:&lt;/strong&gt; 在下拉列表中选择合适的结构, 所选结构会应用于当前主题及其子主题.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i62.tinypic.com/2zeyn2c.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i58.tinypic.com/25jedk5.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;样式:&lt;/strong&gt; 改变当前主题的样式(颜色和形状), 和风格不同的是, 样式只对当前主题有效果.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文字:&lt;/strong&gt; 可以调整主题的字体, 大小, 类型, 颜色, 排列等.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;外形:&lt;/strong&gt; 和样式差不多的功能, 可以说, 样式就是我们设计好的外形.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;边框:&lt;/strong&gt; 改变当前主题边框的样式及颜色.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线条:&lt;/strong&gt; 为当前主题同其子主题之间的关联线选择默认样式, 宽度及颜色.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;插入备注:&lt;/strong&gt; 点选主题, 按F4, 或者 右键-备注.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i59.tinypic.com/152z7up.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;插入图标:&lt;/strong&gt; 点选主题, 右键-图标, 选择想要添加的图标, 或者 点选主题, 在图标选项卡里点击想要的图标(图标选项卡: 菜单-视图-图标).&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i57.tinypic.com/2v96ubo.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关联主题:&lt;/strong&gt; 就是将自由主题与其他主题插入关联线, 右键-插入关联.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i62.tinypic.com/28vvwz.jpg"&gt;&lt;/p&gt;
&lt;p&gt;这种关联是平等的关联, 即关联后两个主题是平级的关系, 如果按住自由主题拖动到其他主题附近, 就会形成父子关系.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i57.tinypic.com/ojfh5g.jpg"&gt;&lt;/p&gt;
&lt;p&gt;按住 Ctrl + 拖动: 复制主题;&lt;/p&gt;
&lt;p&gt;按住 Alt+ 拖动: 拖动主题 , 但不改变主题属性, 即如果被拖动的主题初始是自由主题, 被拖动后, 依然还是自由主题, 不会和其他主题产生关联, 如果初始是子主题, 被拖动后, 依然还是子主题.&lt;/p&gt;
&lt;p&gt;按住 Shift+ 拖动: 拖动任意主题, 拖动后, 主题变为自由主题.&lt;/p&gt;
&lt;p&gt;右键关联线-属性, 可以对关联线的形状, 颜色等做调整.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;插入外框:&lt;/strong&gt; 点选主题, 右键-插入-外框.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://i58.tinypic.com/2jntc.jpg"&gt;&lt;/p&gt;
&lt;p&gt;右键外框-属性, 可以对外框的形状, 颜色等做调整.&lt;/p&gt;</content><category term="杂项"></category></entry><entry><title>瀑布式开发 VS 迭代式开发 [转]</title><link href="http://www.smallcpp.cn/pu-bu-shi-kai-fa-vs-die-dai-shi-kai-fa-zhuan.html" rel="alternate"></link><published>2015-03-02T05:48:00+08:00</published><updated>2015-03-02T05:48:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2015-03-02:/pu-bu-shi-kai-fa-vs-die-dai-shi-kai-fa-zhuan.html</id><summary type="html">&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;两者都是一种开发模式, 就像设计模式一样, 考虑的角度不一样, 个人感觉谈不到取代一说.&lt;/p&gt;
&lt;p&gt;传统的瀑布式开发, 也就是从需求到设计, 从设计到编码, 从编码到测试, 从测试到提交大概这样的流程, 要求每一个开发阶段都要做到最好. 特别是前期阶段, 设计的越完美, 提交后的成本损失就越少. 我现在从事的外包项目就是这样的流程.&lt;/p&gt;
&lt;p&gt;迭代式开发, 不要求每一个阶段的任务做的都是最完美的, 而是明明知道还有很多不足的地方, 却偏偏不去完善它, 而是把主要功能先搭建起来为目的, 以最短的时间, 最少的损失先完成一个&amp;rdquo;不完美的成果物&amp;rdquo;直至提交. 然后再通过客户或用户的反馈信息, 在这个&amp;rdquo;不完美的成果物&amp;rdquo;上逐步进行完善.&lt;/p&gt;
&lt;p&gt;这两种开发模式都各自具有自己的特点, 迭代式开发适合在一些需求信息不明确的项目中, 这样在开发过程中遇到需求的变化时 …&lt;/p&gt;</summary><content type="html">&lt;div class="toc"&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;两者都是一种开发模式, 就像设计模式一样, 考虑的角度不一样, 个人感觉谈不到取代一说.&lt;/p&gt;
&lt;p&gt;传统的瀑布式开发, 也就是从需求到设计, 从设计到编码, 从编码到测试, 从测试到提交大概这样的流程, 要求每一个开发阶段都要做到最好. 特别是前期阶段, 设计的越完美, 提交后的成本损失就越少. 我现在从事的外包项目就是这样的流程.&lt;/p&gt;
&lt;p&gt;迭代式开发, 不要求每一个阶段的任务做的都是最完美的, 而是明明知道还有很多不足的地方, 却偏偏不去完善它, 而是把主要功能先搭建起来为目的, 以最短的时间, 最少的损失先完成一个&amp;rdquo;不完美的成果物&amp;rdquo;直至提交. 然后再通过客户或用户的反馈信息, 在这个&amp;rdquo;不完美的成果物&amp;rdquo;上逐步进行完善.&lt;/p&gt;
&lt;p&gt;这两种开发模式都各自具有自己的特点, 迭代式开发适合在一些需求信息不明确的项目中, 这样在开发过程中遇到需求的变化时, 所带来的影响要比瀑布式开发小. 而现在的很多项目中, 需求在项目进行中变化的事儿经常见, 所以显得迭代式开发的优势更明显一些.&lt;/p&gt;</content><category term="软件工程"></category></entry><entry><title>UML 类图</title><link href="http://www.smallcpp.cn/uml-lei-tu.html" rel="alternate"></link><published>2015-02-15T14:17:00+08:00</published><updated>2015-02-15T14:17:00+08:00</updated><author><name>HanXiao</name></author><id>tag:www.smallcpp.cn,2015-02-15:/uml-lei-tu.html</id><summary type="html">&lt;p&gt;&lt;img alt="UML类图样例" src="http://img.blog.csdn.net/20150211193154259"&gt;&lt;/p&gt;
&lt;h4 id="_1"&gt;类图和接口图&lt;/h4&gt;
&lt;p&gt;首先&lt;strong&gt;动物&lt;/strong&gt;矩形框, 它就代表一个&lt;strong&gt;类图&lt;/strong&gt;, 分三层:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一层显示类的名称, 如果是&lt;strong&gt;抽象类&lt;/strong&gt;, 则用斜体表示&lt;/li&gt;
&lt;li&gt;第二层是类的属性&lt;/li&gt;
&lt;li&gt;第三层是类的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意前面的符号:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;‘+’ –&amp;gt; public&lt;/li&gt;
&lt;li&gt;‘-’ –&amp;gt; private&lt;/li&gt;
&lt;li&gt;‘#’ –&amp;gt; protected&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;左下角的”飞翔”矩形框, 它是一个&lt;strong&gt;接口图&lt;/strong&gt;, 它与类图的区别是顶端有&lt;strong&gt;interface&lt;/strong&gt;显示, 然后它只有二层, 第二层是接口方法.&lt;/p&gt;
&lt;p&gt;另外接口还有另一种表示法, 叫棒棒糖表示法, 看正下方的 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="UML类图样例" src="http://img.blog.csdn.net/20150211193154259"&gt;&lt;/p&gt;
&lt;h4 id="_1"&gt;类图和接口图&lt;/h4&gt;
&lt;p&gt;首先&lt;strong&gt;动物&lt;/strong&gt;矩形框, 它就代表一个&lt;strong&gt;类图&lt;/strong&gt;, 分三层:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一层显示类的名称, 如果是&lt;strong&gt;抽象类&lt;/strong&gt;, 则用斜体表示&lt;/li&gt;
&lt;li&gt;第二层是类的属性&lt;/li&gt;
&lt;li&gt;第三层是类的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意前面的符号:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;‘+’ –&amp;gt; public&lt;/li&gt;
&lt;li&gt;‘-’ –&amp;gt; private&lt;/li&gt;
&lt;li&gt;‘#’ –&amp;gt; protected&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;左下角的”飞翔”矩形框, 它是一个&lt;strong&gt;接口图&lt;/strong&gt;, 它与类图的区别是顶端有&lt;strong&gt;interface&lt;/strong&gt;显示, 然后它只有二层, 第二层是接口方法.&lt;/p&gt;
&lt;p&gt;另外接口还有另一种表示法, 叫棒棒糖表示法, 看正下方的”唐老鸭”那个类, 它实现了一个”讲人话”的接口.&lt;/p&gt;
&lt;h4 id="_2"&gt;类与类, 类与接口之间的关系&lt;/h4&gt;
&lt;p&gt;首先看 动物 –&amp;gt; 鸟 –&amp;gt; 鸭 –&amp;gt; 唐老鸭 这条线, 它们都是继承关系, 用&lt;strong&gt;空心三角 +实线&lt;/strong&gt;来表示．&lt;/p&gt;
&lt;p&gt;然后看 大雁 –&amp;gt; 飞翔, 大雁实现了飞翔接口, 用&lt;strong&gt;空心三角 + 虚线&lt;/strong&gt;来表示.&lt;/p&gt;
&lt;p&gt;再看 企鹅 –&amp;gt; 气候, 企鹅不继承气候, 也不实现气候, 但它需要知道气候的变化, 也就是说在企鹅这个类中需要引用到气候这个类, 这就是&lt;strong&gt;“关联”&lt;/strong&gt;关系, 用&lt;strong&gt;实线箭头&lt;/strong&gt;来表示.&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;Penguin&lt;/span&gt; : &lt;span style="color: #8B008B; font-weight: bold"&gt;public&lt;/span&gt; Bird {
&lt;span style="color: #8B008B; font-weight: bold"&gt;public&lt;/span&gt;:
    Climate climage; &lt;span style="color: #228B22"&gt;// 企鹅类中引用到了气候对象&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;再看 雁群 –&amp;gt; 大雁, 大雁是群居动物, 每只大雁都属于一个雁群, 一个雁群可以有多只大雁, 就是&lt;strong&gt;“聚合”&lt;/strong&gt;关系, 用&lt;strong&gt;空心菱形 + 实线箭头&lt;/strong&gt;来表示.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“聚合”是一种弱拥有关系, 体现的是A对象可以包含B对象, 但B对象又不是A对象的一部分&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;WideGooseAggregate&lt;/span&gt; {
&lt;span style="color: #8B008B; font-weight: bold"&gt;public&lt;/span&gt;:
    WideGoose[] arrayWideGoose; &lt;span style="color: #228B22"&gt;// 在雁群中有大雁数组对象&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;聚合是关联的一种，是强的关联关系, 在代码层面上，聚合和关联表现是一致的，只能从语义级别来区分；&lt;br&gt;
聚合关系是整体和个体的关系;&lt;br&gt;
普通关联关系的两个类处于同一层次上, 而聚合关系的两个类处于不同的层次，一个是整体，一个是部分.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在看 鸟 –&amp;gt; 羽毛, 这是一种”合成”的强拥有关系, 体现了严格的部分和整体的关系, 部分和整体的生命同期一样, 它用&lt;strong&gt;实心菱形 + 实线箭头&lt;/strong&gt;表示, 另外注意到合成关的连线下方有&lt;strong&gt;数字&lt;/strong&gt;说明, 这被称为&lt;strong&gt;基数&lt;/strong&gt;, 表明菱形这一端的类可以有几个箭头端的实例, 如果一个类可能有无数个实例, 则用’n’来表示.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关联 和 聚合 关系也可以有基数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;Bird&lt;/span&gt; {
&lt;span style="color: #8B008B; font-weight: bold"&gt;public&lt;/span&gt;:
    Bird() {
        m_LeftWing = &lt;span style="color: #8B008B; font-weight: bold"&gt;new&lt;/span&gt; Wing();
        m_RightWing = &lt;span style="color: #8B008B; font-weight: bold"&gt;new&lt;/span&gt; Wing();
    }

&lt;span style="color: #8B008B; font-weight: bold"&gt;protected&lt;/span&gt;:
    Wing m_LeftWing;
    Wing m_RightWing;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到, 在 Bird 构造时同时构造翅膀.&lt;/p&gt;
&lt;p&gt;最后看 动物 –&amp;gt; 氧气, 动物 –&amp;gt; 水, 动物中有新陈代谢方法, 而新陈代谢又需要用到氧气和水, 因此它们是一种依赖关系, 新陈代谢依赖于氧气和水&lt;strong&gt;(换个角度说就是新陈代谢这个方法有两个参数 氧气和水).&lt;/strong&gt;&lt;/p&gt;
&lt;div class="codehilite" style="background: #eeeedd"&gt;&lt;pre style="line-height: 125%;"&gt;&lt;span&gt;&lt;/span&gt;&lt;span style="color: #8B008B; font-weight: bold"&gt;class&lt;/span&gt; &lt;span style="color: #008b45; font-weight: bold"&gt;Animal&lt;/span&gt; {
&lt;span style="color: #8B008B; font-weight: bold"&gt;public&lt;/span&gt;:
    &lt;span style="color: #00688B; font-weight: bold"&gt;void&lt;/span&gt; Metabolism(Oxygen oxygen, Water water)
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;搞明白这些, 就能看懂大部分UML类图了.&lt;/p&gt;</content><category term="软件工程"></category></entry></feed>